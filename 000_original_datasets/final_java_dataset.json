[
  {
    "id": 0,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/alibaba/fastjson/commit/f5903fa56497c00ed0703ac875b511f9bd5f1d8e",
    "cve_id": "CVE-2017-18349",
    "cwe_id": "CWE-20",
    "filename": "src/main/java/com/alibaba/fastjson/serializer/ObjectArrayCodec.java",
    "code": "\r\npackage com.alibaba.fastjson.serializer;\r\n\r\nimport java.io.IOException;\r\nimport java.lang.reflect.Array;\r\nimport java.lang.reflect.GenericArrayType;\r\nimport java.lang.reflect.ParameterizedType;\r\nimport java.lang.reflect.Type;\r\nimport java.lang.reflect.TypeVariable;\r\n\r\nimport com.alibaba.fastjson.JSONArray;\r\nimport com.alibaba.fastjson.parser.DefaultJSONParser;\r\nimport com.alibaba.fastjson.parser.JSONLexer;\r\nimport com.alibaba.fastjson.parser.JSONToken;\r\nimport com.alibaba.fastjson.parser.deserializer.ObjectDeserializer;\r\nimport com.alibaba.fastjson.util.TypeUtils;\r\n\r\n\r\npublic class ObjectArrayCodec implements ObjectSerializer, ObjectDeserializer {\r\n\r\n    public static final ObjectArrayCodec instance = new ObjectArrayCodec();\r\n\r\n    public ObjectArrayCodec(){\r\n    }\r\n\r\n    public final void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features)\r\n                                                                                                       throws IOException {\r\n        SerializeWriter out = serializer.out;\r\n\r\n        Object[] array = (Object[]) object;\r\n\r\n        if (object == null) {\r\n            out.writeNull(SerializerFeature.WriteNullListAsEmpty);\r\n            return;\r\n        }\r\n\r\n        int size = array.length;\r\n\r\n        int end = size - 1;\r\n\r\n        if (end == -1) {\r\n            out.append(\"[]\");\r\n            return;\r\n        }\r\n\r\n        SerialContext context = serializer.context;\r\n        serializer.setContext(context, object, fieldName, 0);\r\n\r\n        try {\r\n            Class<?> preClazz = null;\r\n            ObjectSerializer preWriter = null;\r\n            out.append('[');\r\n\r\n            if (out.isEnabled(SerializerFeature.PrettyFormat)) {\r\n                serializer.incrementIndent();\r\n                serializer.println();\r\n                for (int i = 0; i < size; ++i) {\r\n                    if (i != 0) {\r\n                        out.write(',');\r\n                        serializer.println();\r\n                    }\r\n                    serializer.write(array[i]);\r\n                }\r\n                serializer.decrementIdent();\r\n                serializer.println();\r\n                out.write(']');\r\n                return;\r\n            }\r\n\r\n            for (int i = 0; i < end; ++i) {\r\n                Object item = array[i];\r\n\r\n                if (item == null) {\r\n                    out.append(\"null,\");\r\n                } else {\r\n                    if (serializer.containsReference(item)) {\r\n                        serializer.writeReference(item);\r\n                    } else {\r\n                        Class<?> clazz = item.getClass();\r\n\r\n                        if (clazz == preClazz) {\r\n                            preWriter.write(serializer, item, null, null, 0);\r\n                        } else {\r\n                            preClazz = clazz;\r\n                            preWriter = serializer.getObjectWriter(clazz);\r\n\r\n                            preWriter.write(serializer, item, null, null, 0);\r\n                        }\r\n                    }\r\n                    out.append(',');\r\n                }\r\n            }\r\n\r\n            Object item = array[end];\r\n\r\n            if (item == null) {\r\n                out.append(\"null]\");\r\n            } else {\r\n                if (serializer.containsReference(item)) {\r\n                    serializer.writeReference(item);\r\n                } else {\r\n                    serializer.writeWithFieldName(item, end);\r\n                }\r\n                out.append(']');\r\n            }\r\n        } finally {\r\n            serializer.context = context;\r\n        }\r\n    }\r\n    \r\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\r\n    public <T> T deserialze(DefaultJSONParser parser, Type type, Object fieldName) {\r\n        final JSONLexer lexer = parser.lexer;\r\n        if (lexer.token() == JSONToken.NULL) {\r\n            lexer.nextToken(JSONToken.COMMA);\r\n            return null;\r\n        }\r\n\r\n        if (lexer.token() == JSONToken.LITERAL_STRING) {\r\n            byte[] bytes = lexer.bytesValue();\r\n            lexer.nextToken(JSONToken.COMMA);\r\n            return (T) bytes;\r\n        }\r\n\r\n        Class componentClass;\r\n        Type componentType;\r\n        if (type instanceof GenericArrayType) {\r\n            GenericArrayType clazz = (GenericArrayType) type;\r\n            componentType = clazz.getGenericComponentType();\r\n            if (componentType instanceof TypeVariable) {\r\n                TypeVariable typeVar = (TypeVariable) componentType;\r\n                Type objType = parser.getContext().type;\r\n                if (objType instanceof ParameterizedType) {\r\n                    ParameterizedType objParamType = (ParameterizedType) objType;\r\n                    Type objRawType = objParamType.getRawType();\r\n                    Type actualType = null;\r\n                    if (objRawType instanceof Class) {\r\n                        TypeVariable[] objTypeParams = ((Class) objRawType).getTypeParameters();\r\n                        for (int i = 0; i < objTypeParams.length; ++i) {\r\n                            if (objTypeParams[i].getName().equals(typeVar.getName())) {\r\n                                actualType = objParamType.getActualTypeArguments()[i];\r\n                            }\r\n                        }\r\n                    }\r\n                    if (actualType instanceof Class) {\r\n                        componentClass = (Class) actualType;\r\n                    } else {\r\n                        componentClass = Object.class;\r\n                    }\r\n                } else {\r\n                    componentClass = TypeUtils.getClass(typeVar.getBounds()[0]);\r\n                }\r\n            } else {\r\n                componentClass = TypeUtils.getClass(componentType);\r\n            }\r\n        } else {\r\n            Class clazz = (Class) type;\r\n            componentType = componentClass = clazz.getComponentType();\r\n        }\r\n        JSONArray array = new JSONArray();\r\n        parser.parseArray(componentClass, array, fieldName);\r\n\r\n        return (T) toObjectArray(parser, componentClass, array);\r\n    }\r\n\r\n    @SuppressWarnings(\"unchecked\")\r\n    private <T> T toObjectArray(DefaultJSONParser parser, Class<?> componentType, JSONArray array) {\r\n        if (array == null) {\r\n            return null;\r\n        }\r\n\r\n        int size = array.size();\r\n\r\n        Object objArray = Array.newInstance(componentType, size);\r\n        for (int i = 0; i < size; ++i) {\r\n            Object value = array.get(i);\r\n\r\n            if (value == array) {\r\n                Array.set(objArray, i, objArray);\r\n                continue;\r\n            }\r\n\r\n            if (componentType.isArray()) {\r\n                Object element;\r\n                if (componentType.isInstance(value)) {\r\n                    element = value;\r\n                } else {\r\n                    element = toObjectArray(parser, componentType, (JSONArray) value);\r\n                }\r\n\r\n                Array.set(objArray, i, element);\r\n            } else {\r\n                Object element = null;\r\n                if (value instanceof JSONArray) {\r\n                    boolean contains = false;\r\n                    JSONArray valueArray = (JSONArray) value;\r\n                    int valueArraySize = valueArray.size();\r\n                    for (int y = 0; y < valueArraySize; ++y) {\r\n                        Object valueItem = valueArray.get(y);\r\n                        if (valueItem == array) {\r\n                            valueArray.set(i, objArray);\r\n                            contains = true;\r\n                        }\r\n                    }\r\n                    if (contains) {\r\n                        element = valueArray.toArray();\r\n                    }\r\n                }\r\n\r\n                if (element == null) {\r\n                    element = TypeUtils.cast(value, componentType, parser.getConfig());\r\n                }\r\n                Array.set(objArray, i, element);\r\n\r\n            }\r\n        }\r\n\r\n        array.setRelatedArray(objArray);\r\n        array.setComponentType(componentType);\r\n        return (T) objArray; \n    }\r\n\r\n    public int getFastMatchToken() {\r\n        return JSONToken.LBRACKET;\r\n    }\r\n}\r\n",
    "is_vulnerable": 1
  },
  {
    "id": 0,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/alibaba/fastjson/commit/f5903fa56497c00ed0703ac875b511f9bd5f1d8e",
    "cve_id": "CVE-2017-18349",
    "cwe_id": "CWE-20",
    "filename": "src/test/java/com/alibaba/json/bvt/bug/Issue1005.java",
    "code": "package com.alibaba.json.bvt.bug;\n\nimport com.alibaba.fastjson.JSON;\nimport junit.framework.TestCase;\n\nimport java.util.List;\n\n\npublic class Issue1005 extends TestCase {\n    public void test_for_issue() throws Exception {\n        Model model = JSON.parseObject(\"{\\\"values\\\":[1,2,3]}\", Model.class);\n        assertNotNull(model.values);\n        assertEquals(3, model.values.size());\n        assertEquals(Byte.class, model.values.get(0).getClass());\n        assertEquals(Byte.class, model.values.get(1).getClass());\n        assertEquals(Byte.class, model.values.get(2).getClass());\n    }\n\n    public static class Model {\n        public List<Byte> values;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 1,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/xmlgraphics-batik/commit/660ef628d637af636ea113243fe73f170ac43958",
    "cve_id": "CVE-2017-5662",
    "cwe_id": "CWE-611",
    "filename": "batik-dom/src/main/java/org/apache/batik/dom/util/SAXDocumentFactory.java",
    "code": "\npackage org.apache.batik.dom.util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InterruptedIOException;\nimport java.io.Reader;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.DocumentType;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.Locator;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.ext.LexicalHandler;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport org.apache.batik.util.HaltingThread;\nimport org.apache.batik.util.XMLConstants;\n\n\npublic class SAXDocumentFactory\n    extends    DefaultHandler\n    implements LexicalHandler,\n               DocumentFactory {\n\n    \n    protected DOMImplementation implementation;\n\n    \n    protected String parserClassName;\n\n    \n    protected XMLReader parser;\n\n    \n    protected Document document;\n\n    \n    protected DocumentDescriptor documentDescriptor;\n\n    \n    protected boolean createDocumentDescriptor;\n\n    \n    protected Node currentNode;\n\n    \n    protected Locator locator;\n\n    \n    protected StringBuffer stringBuffer = new StringBuffer();\n\n    \n    protected DocumentType doctype;\n\n    \n    protected boolean stringContent;\n\n    \n    protected boolean inDTD;\n\n    \n    protected boolean inCDATA;\n\n    \n    protected boolean inProlog;\n\n    \n    protected boolean isValidating;\n\n    \n    protected boolean isStandalone;\n\n    \n    protected String xmlVersion;\n\n    \n    protected HashTableStack namespaces;\n\n    \n    protected ErrorHandler errorHandler;\n\n    protected interface PreInfo {\n        Node createNode(Document doc);\n    }\n\n    static class ProcessingInstructionInfo implements PreInfo {\n        public String target, data;\n        public ProcessingInstructionInfo(String target, String data) {\n            this.target = target;\n            this.data = data;\n        }\n        public Node createNode(Document doc) {\n            return doc.createProcessingInstruction(target, data);\n        }\n    }\n\n    static class CommentInfo implements PreInfo {\n        public String comment;\n        public CommentInfo(String comment) {\n            this.comment = comment;\n        }\n        public Node createNode(Document doc) {\n            return doc.createComment(comment);\n        }\n    }\n\n    static class CDataInfo implements PreInfo {\n        public String cdata;\n        public CDataInfo(String cdata) {\n            this.cdata = cdata;\n        }\n        public Node createNode(Document doc) {\n            return doc.createCDATASection(cdata);\n        }\n    }\n\n    static class TextInfo implements PreInfo {\n        public String text;\n        public TextInfo(String text) {\n            this.text = text;\n        }\n        public Node createNode(Document doc) {\n            return doc.createTextNode(text);\n        }\n    }\n\n    \n    protected List preInfo;\n\n    \n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser) {\n        implementation           = impl;\n        parserClassName          = parser;\n    }\n\n    \n    public SAXDocumentFactory(DOMImplementation impl,\n                              String parser,\n                              boolean dd) {\n        implementation           = impl;\n        parserClassName          = parser;\n        createDocumentDescriptor = dd;\n    }\n\n    \n    public Document createDocument(String ns, String root, String uri)\n        throws IOException {\n        return createDocument(ns, root, uri, new InputSource(uri));\n    }\n\n    \n    public Document createDocument(String uri)\n        throws IOException {\n        return createDocument(new InputSource(uri));\n    }\n\n    \n    public Document createDocument(String ns, String root, String uri,\n                                   InputStream is) throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    \n    public Document createDocument(String uri, InputStream is)\n        throws IOException {\n        InputSource inp = new InputSource(is);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    \n    public Document createDocument(String ns, String root, String uri,\n                                   Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(ns, root, uri, inp);\n    }\n\n    \n    public Document createDocument(String ns, String root, String uri,\n                                   XMLReader r) throws IOException {\n        r.setContentHandler(this);\n        r.setDTDHandler(this);\n        r.setEntityResolver(this);\n        try {\n            r.parse(uri);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException) ex;\n            }\n            throw new SAXIOException(e);\n        }\n        currentNode = null;\n        Document ret = document;\n        document = null;\n        doctype = null;\n        return ret;\n    }\n\n    \n    public Document createDocument(String uri, Reader r) throws IOException {\n        InputSource inp = new InputSource(r);\n        inp.setSystemId(uri);\n        return createDocument(inp);\n    }\n\n    \n    protected Document createDocument(String ns, String root, String uri,\n                                      InputSource is)\n        throws IOException {\n        Document ret = createDocument(is);\n        Element docElem = ret.getDocumentElement();\n\n        String lname = root;\n        String nsURI = ns;\n        if (ns == null) {\n            int idx = lname.indexOf(':');\n            String nsp = (idx == -1 || idx == lname.length()-1)\n                ? \"\"\n                : lname.substring(0, idx);\n            nsURI = namespaces.get(nsp);\n            if (idx != -1 && idx != lname.length()-1) {\n                lname = lname.substring(idx+1);\n            }\n        }\n\n\n        String docElemNS = docElem.getNamespaceURI();\n        if ((docElemNS != nsURI) &&\n            ((docElemNS == null) || (!docElemNS.equals(nsURI))))\n            throw new IOException\n                (\"Root element namespace does not match that requested:\\n\" +\n                 \"Requested: \" + nsURI + \"\\n\" +\n                 \"Found: \" + docElemNS);\n\n        if (docElemNS != null) {\n            if (!docElem.getLocalName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getLocalName());\n        } else {\n            if (!docElem.getNodeName().equals(lname))\n                throw new IOException\n                    (\"Root element does not match that requested:\\n\" +\n                     \"Requested: \" + lname + \"\\n\" +\n                     \"Found: \" + docElem.getNodeName());\n        }\n\n        return ret;\n    }\n\n    static SAXParserFactory saxFactory;\n    static {\n        saxFactory = SAXParserFactory.newInstance();\n        try {\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            saxFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (SAXNotRecognizedException e) {\n            e.printStackTrace();\n        } catch (SAXNotSupportedException e) {\n            e.printStackTrace();\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n    }\n\n    \n    protected Document createDocument(InputSource is)\n        throws IOException {\n        try {\n            if (parserClassName != null) {\n                parser = XMLReaderFactory.createXMLReader(parserClassName);\n            } else {\n                SAXParser saxParser;\n                try {\n                    saxParser = saxFactory.newSAXParser();\n                } catch (ParserConfigurationException pce) {\n                    throw new IOException(\"Could not create SAXParser: \"\n                            + pce.getMessage());\n                }\n                parser = saxParser.getXMLReader();\n            }\n\n            parser.setContentHandler(this);\n            parser.setDTDHandler(this);\n            parser.setEntityResolver(this);\n            parser.setErrorHandler((errorHandler == null) ?\n                                   this : errorHandler);\n\n            parser.setFeature(\"http://xml.org/sax/features/namespaces\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/namespace-prefixes\",\n                              true);\n            parser.setFeature(\"http://xml.org/sax/features/validation\",\n                              isValidating);\n            parser.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            parser.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            parser.setProperty(\"http://xml.org/sax/properties/lexical-handler\",\n                               this);\n            parser.parse(is);\n        } catch (SAXException e) {\n            Exception ex = e.getException();\n            if (ex != null && ex instanceof InterruptedIOException) {\n                throw (InterruptedIOException)ex;\n            }\n            throw new SAXIOException(e);\n        }\n\n        currentNode  = null;\n        Document ret = document;\n        document     = null;\n        doctype      = null;\n        locator      = null;\n        parser       = null;\n        return ret;\n    }\n\n    \n    public DocumentDescriptor getDocumentDescriptor() {\n        return documentDescriptor;\n    }\n\n    \n    public void setDocumentLocator(Locator l) {\n        locator = l;\n    }\n\n    \n    public void setValidating(boolean isValidating) {\n        this.isValidating = isValidating;\n    }\n\n    \n    public boolean isValidating() {\n        return isValidating;\n    }\n\n    \n    public void setErrorHandler(ErrorHandler eh) {\n        errorHandler = eh;\n    }\n\n    public DOMImplementation getDOMImplementation(String ver) {\n        return implementation;\n    }\n\n    \n    public void fatalError(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    \n    public void error(SAXParseException ex) throws SAXException {\n        throw ex;\n    }\n\n    \n    public void warning(SAXParseException ex) throws SAXException {\n    }\n\n    \n    public void startDocument() throws SAXException {\n        preInfo    = new LinkedList();\n        namespaces = new HashTableStack();\n        namespaces.put(\"xml\", XMLSupport.XML_NAMESPACE_URI);\n        namespaces.put(\"xmlns\", XMLSupport.XMLNS_NAMESPACE_URI);\n        namespaces.put(\"\", null);\n\n        inDTD        = false;\n        inCDATA      = false;\n        inProlog     = true;\n        currentNode  = null;\n        document     = null;\n        doctype      = null;\n        isStandalone = false;\n        xmlVersion   = XMLConstants.XML_VERSION_10;\n\n        stringBuffer.setLength(0);\n        stringContent = false;\n\n        if (createDocumentDescriptor) {\n            documentDescriptor = new DocumentDescriptor();\n        } else {\n            documentDescriptor = null;\n        }\n    }\n\n    \n    public void startElement(String     uri,\n                             String     localName,\n                             String     rawName,\n                             Attributes attributes) throws SAXException {\n        \n        if (HaltingThread.hasBeenHalted()) {\n            throw new SAXException(new InterruptedIOException());\n        }\n\n        if (inProlog) {\n            inProlog = false;\n            if (parser != null) {\n                try {\n                    isStandalone = parser.getFeature\n                        (\"http://xml.org/sax/features/is-standalone\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n                try {\n                    xmlVersion = (String) parser.getProperty\n                        (\"http://xml.org/sax/properties/document-xml-version\");\n                } catch (SAXNotRecognizedException ex) {\n                }\n            }\n        }\n\n        \n        int len = attributes.getLength();\n        namespaces.push();\n        String version = null;\n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            int slen = aname.length();\n            if (slen < 5)\n                continue;\n            if (aname.equals(\"version\")) {\n                version = attributes.getValue(i);\n                continue;\n            }\n            if (!aname.startsWith(\"xmlns\"))\n                continue;\n            if (slen == 5) {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0)\n                    ns = null;\n                namespaces.put(\"\", ns);\n            } else if (aname.charAt(5) == ':') {\n                String ns = attributes.getValue(i);\n                if (ns.length() == 0) {\n                    ns = null;\n                }\n                namespaces.put(aname.substring(6), ns);\n            }\n        }\n\n        \n        appendStringData();\n\n        \n        Element e;\n        int idx = rawName.indexOf(':');\n        String nsp = (idx == -1 || idx == rawName.length()-1)\n            ? \"\"\n            : rawName.substring(0, idx);\n        String nsURI = namespaces.get(nsp);\n        if (currentNode == null) {\n            implementation = getDOMImplementation(version);\n            document = implementation.createDocument(nsURI, rawName, doctype);\n            Iterator i = preInfo.iterator();\n            currentNode = e = document.getDocumentElement();\n            while (i.hasNext()) {\n                PreInfo pi = (PreInfo)i.next();\n                Node n = pi.createNode(document);\n                document.insertBefore(n, e);\n            }\n            preInfo = null;\n        } else {\n            e = document.createElementNS(nsURI, rawName);\n            currentNode.appendChild(e);\n            currentNode = e;\n        }\n\n        \n        if (createDocumentDescriptor && locator != null) {\n            documentDescriptor.setLocation(e,\n                                           locator.getLineNumber(),\n                                           locator.getColumnNumber());\n        }\n\n        \n        for (int i = 0; i < len; i++) {\n            String aname = attributes.getQName(i);\n            if (aname.equals(\"xmlns\")) {\n                e.setAttributeNS(XMLSupport.XMLNS_NAMESPACE_URI,\n                                 aname,\n                                 attributes.getValue(i));\n            } else {\n                idx = aname.indexOf(':');\n                nsURI = (idx == -1)\n                    ? null\n                    : namespaces.get(aname.substring(0, idx));\n                e.setAttributeNS(nsURI, aname, attributes.getValue(i));\n            }\n        }\n    }\n\n    \n    public void endElement(String uri, String localName, String rawName)\n        throws SAXException {\n        appendStringData(); \n\n        if (currentNode != null)\n            currentNode = currentNode.getParentNode();\n        namespaces.pop();\n    }\n\n    public void appendStringData() {\n        if (!stringContent) return;\n\n        String str = stringBuffer.toString();\n        stringBuffer.setLength(0); \n        stringContent = false;\n        if (currentNode == null) {\n            if (inCDATA) preInfo.add(new CDataInfo(str));\n            else         preInfo.add(new TextInfo(str));\n        } else {\n            Node n;\n            if (inCDATA) n = document.createCDATASection(str);\n            else         n = document.createTextNode(str);\n            currentNode.appendChild(n);\n        }\n    }\n\n    \n    public void characters(char[] ch, int start, int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n\n    \n    public void ignorableWhitespace(char[] ch,\n                                    int start,\n                                    int length)\n        throws SAXException {\n        stringBuffer.append(ch, start, length);\n        stringContent = true;\n    }\n\n    \n    public void processingInstruction(String target, String data)\n        throws SAXException {\n        if (inDTD)\n            return;\n\n        appendStringData(); \n\n        if (currentNode == null)\n            preInfo.add(new ProcessingInstructionInfo(target, data));\n        else\n            currentNode.appendChild\n                (document.createProcessingInstruction(target, data));\n    }\n\n    \n\n    \n    public void startDTD(String name, String publicId, String systemId)\n        throws SAXException {\n        appendStringData(); \n        doctype = implementation.createDocumentType(name, publicId, systemId);\n        inDTD = true;\n    }\n\n    \n    public void endDTD() throws SAXException {\n        inDTD = false;\n    }\n\n    \n    public void startEntity(String name) throws SAXException {\n    }\n\n    \n    public void endEntity(String name) throws SAXException {\n    }\n\n    \n    public void startCDATA() throws SAXException {\n        appendStringData(); \n        inCDATA       = true;\n        stringContent = true; \n    }\n\n    \n    public void endCDATA() throws SAXException {\n        appendStringData(); \n        inCDATA = false;\n    }\n\n    \n    public void comment(char[] ch, int start, int length) throws SAXException {\n        if (inDTD) return;\n        appendStringData();\n\n        String str = new String(ch, start, length);\n        if (currentNode == null) {\n            preInfo.add(new CommentInfo(str));\n        } else {\n            currentNode.appendChild(document.createComment(str));\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 2,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/camel/commit/7d19340bcdb42f7aae584d9c5003ac4f7ddaee36",
    "cve_id": "CVE-2015-0263",
    "cwe_id": "Not Mapping",
    "filename": "camel-core/src/main/java/org/apache/camel/converter/jaxp/XmlConverter.java",
    "code": "\npackage org.apache.camel.converter.jaxp;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.sax.SAXSource;\nimport javax.xml.transform.stax.StAXSource;\nimport javax.xml.transform.stream.StreamResult;\nimport javax.xml.transform.stream.StreamSource;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\nimport org.apache.camel.BytesSource;\nimport org.apache.camel.Converter;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.StringSource;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\n@Converter\npublic class XmlConverter {\n    @Deprecated\n    \n    public static final String DEFAULT_CHARSET_PROPERTY = \"org.apache.camel.default.charset\";\n\n    public static final String OUTPUT_PROPERTIES_PREFIX = \"org.apache.camel.xmlconverter.output.\";\n    public static final String DOCUMENT_BUILDER_FACTORY_FEATURE = \"org.apache.camel.xmlconverter.documentBuilderFactory.feature\";\n    public static String defaultCharset = ObjectHelper.getSystemProperty(Exchange.DEFAULT_CHARSET_PROPERTY, \"UTF-8\");\n\n    private static final Logger LOG = LoggerFactory.getLogger(XmlConverter.class);\n\n    private DocumentBuilderFactory documentBuilderFactory;\n    private TransformerFactory transformerFactory;\n\n    public XmlConverter() {\n    }\n\n    public XmlConverter(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    \n    public Properties defaultOutputProperties() {\n        Properties properties = new Properties();\n        properties.put(OutputKeys.ENCODING, defaultCharset);\n        properties.put(OutputKeys.OMIT_XML_DECLARATION, \"yes\");\n        return properties;\n    }\n\n    \n    public void toResult(Source source, Result result) throws TransformerException {\n        toResult(source, result, defaultOutputProperties());\n    }\n\n    \n    public void toResult(Source source, Result result, Properties outputProperties) throws TransformerException {\n        if (source == null) {\n            return;\n        }\n\n        Transformer transformer = createTransformer();\n        if (transformer == null) {\n            throw new TransformerException(\"Could not create a transformer - JAXP is misconfigured!\");\n        }\n        transformer.setOutputProperties(outputProperties);\n        transformer.transform(source, result);\n    }\n\n    \n    @Converter\n    public Boolean toBoolean(NodeList list) {\n        return list.getLength() > 0;\n    }\n\n    \n    @Converter\n    public BytesSource toBytesSource(byte[] data) {\n        return new BytesSource(data);\n    }\n\n    \n    @Converter\n    public StringSource toStringSource(String data) {\n        return new StringSource(data);\n    }\n\n    \n    @Deprecated\n    public DOMSource toSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    \n    @Deprecated\n    public Source toSource(Node node) throws ParserConfigurationException, TransformerException {\n        return toDOMSource(node);\n    }\n\n    \n    @Converter\n    public DOMSource toDOMSource(Node node) throws ParserConfigurationException, TransformerException {\n        Document document = toDOMDocument(node);\n        return new DOMSource(document);\n    }\n\n    \n    @Converter\n    public DOMSource toDOMSource(Document document) {\n        return new DOMSource(document);\n    }\n\n    \n    @Converter\n    public Source toSource(String data) {\n        return new StringSource(data);\n    }\n\n    \n    @Deprecated\n    public String toString(Source source) throws TransformerException {\n        return toString(source, null);\n    }\n\n    \n    @Converter\n    public String toString(Source source, Exchange exchange) throws TransformerException {\n        if (source == null) {\n            return null;\n        } else if (source instanceof StringSource) {\n            return ((StringSource) source).getText();\n        } else if (source instanceof BytesSource) {\n            return new String(((BytesSource) source).getData());\n        } else {\n            StringWriter buffer = new StringWriter();\n            if (exchange != null) {\n                \n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX, exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toString();\n                }\n            }\n            \n            toResult(source, new StreamResult(buffer));\n            return buffer.toString();\n        }\n    }\n\n    \n    @Converter\n    public byte[] toByteArray(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof BytesSource) {\n            return ((BytesSource)source).getData();\n        } else {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            if (exchange != null) {\n                \n                Properties properties = ObjectHelper.getCamelPropertiesWithPrefix(OUTPUT_PROPERTIES_PREFIX,\n                                                                                  exchange.getContext());\n                if (properties.size() > 0) {\n                    toResult(source, new StreamResult(buffer), properties);\n                    return buffer.toByteArray();\n                }\n            }\n            \n            toResult(source, new StreamResult(buffer));\n            return buffer.toByteArray();\n        }\n    }\n\n    \n    @Deprecated\n    public String toString(Node node) throws TransformerException {\n        return toString(node, null);\n    }\n\n    \n    @Converter\n    public String toString(Node node, Exchange exchange) throws TransformerException {\n        return toString(new DOMSource(node), exchange);\n    }\n\n    \n    @Deprecated\n    public DOMSource toDOMSource(Source source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        return toDOMSource(source, (Exchange)null);\n    }\n    \n    \n    @Converter\n    public DOMSource toDOMSource(Source source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        if (source instanceof DOMSource) {\n            return (DOMSource) source;\n        } else if (source instanceof SAXSource) {\n            return toDOMSourceFromSAX((SAXSource) source);\n        } else if (source instanceof StreamSource) {\n            return toDOMSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toDOMSourceFromStAX((StAXSource)source);\n        } else {\n            return null;\n        }\n    }\n\n    \n    @Converter\n    public DOMSource toDOMSource(String text) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        Source source = toSource(text);\n        return toDOMSourceFromStream((StreamSource) source);\n    }\n\n    \n    @Converter\n    public DOMSource toDOMSource(byte[] bytes) throws IOException, SAXException, ParserConfigurationException {\n        InputStream is = new ByteArrayInputStream(bytes);\n        try {\n            return toDOMSource(is);\n        } finally {\n            IOHelper.close(is);\n        }\n    }\n\n\n    \n    @Deprecated\n    public SAXSource toSAXSource(String source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    \n    @Converter\n    public SAXSource toSAXSource(String source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toSource(source), exchange);\n    }\n\n    \n    @Converter\n    public StAXSource toStAXSource(String source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new StringReader(source));\n        return new StAXSource(r);\n    }\n\n    \n    @Converter\n    public StAXSource toStAXSource(byte[] in, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(new ByteArrayInputStream(in), exchange);\n        return new StAXSource(r);\n    }\n\n    \n    @Deprecated\n    public SAXSource toSAXSource(InputStream source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    \n    @Converter\n    public SAXSource toSAXSource(InputStream source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(source), exchange);\n    }\n\n    \n    @Converter\n    public SAXSource toSAXSource(byte[] in, Exchange exchange) throws IOException, SAXException, TransformerException {\n        return toSAXSource(toStreamSource(in, exchange), exchange);\n    }\n\n    \n    @Converter\n    public StAXSource toStAXSource(InputStream source, Exchange exchange) throws XMLStreamException {\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(source, exchange);\n        return new StAXSource(r);\n    }\n\n    \n    @Converter\n    public SAXSource toSAXSource(File file, Exchange exchange) throws IOException, SAXException, TransformerException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toSAXSource(is, exchange);\n    }\n\n    \n    @Converter\n    public StAXSource toStAXSource(File file, Exchange exchange) throws FileNotFoundException, XMLStreamException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        XMLStreamReader r = new StaxConverter().createXMLStreamReader(is, exchange);\n        return new StAXSource(r);\n    }\n\n    \n    @Deprecated\n    public SAXSource toSAXSource(Source source) throws IOException, SAXException, TransformerException {\n        return toSAXSource(source, null);\n    }\n\n    \n    @Converter\n    public SAXSource toSAXSource(Source source, Exchange exchange) throws IOException, SAXException, TransformerException {\n        if (source instanceof SAXSource) {\n            return (SAXSource) source;\n        } else if (source instanceof DOMSource) {\n            return toSAXSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof StreamSource) {\n            return toSAXSourceFromStream((StreamSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toSAXSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    \n    @Deprecated\n    public StreamSource toStreamSource(Source source) throws TransformerException {\n        return toStreamSource(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Source source, Exchange exchange) throws TransformerException {\n        if (source instanceof StreamSource) {\n            return (StreamSource) source;\n        } else if (source instanceof DOMSource) {\n            return toStreamSourceFromDOM((DOMSource) source, exchange);\n        } else if (source instanceof SAXSource) {\n            return toStreamSourceFromSAX((SAXSource) source, exchange);\n        } else if (source instanceof StAXSource) {\n            return toStreamSourceFromStAX((StAXSource) source, exchange);\n        } else {\n            return null;\n        }\n    }\n\n    @Converter\n    public StreamSource toStreamSource(InputStream in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(Reader in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(File in) throws TransformerException {\n        return new StreamSource(in);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(byte[] in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    @Converter\n    public StreamSource toStreamSource(ByteBuffer in, Exchange exchange) throws TransformerException {\n        InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, in);\n        return new StreamSource(is);\n    }\n\n    \n    @Deprecated\n    public StreamSource toStreamSourceFromSAX(SAXSource source) throws TransformerException {\n        return toStreamSourceFromSAX(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromSAX(SAXSource source, Exchange exchange) throws TransformerException {\n        InputSource inputSource = source.getInputSource();\n        if (inputSource != null) {\n            if (inputSource.getCharacterStream() != null) {\n                return new StreamSource(inputSource.getCharacterStream());\n            }\n            if (inputSource.getByteStream() != null) {\n                return new StreamSource(inputSource.getByteStream());\n            }\n        }\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    \n    @Deprecated\n    public StreamSource toStreamSourceFromDOM(DOMSource source) throws TransformerException {\n        return toStreamSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public StreamSource toStreamSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n    @Converter\n    public StreamSource toStreamSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String result = toString(source, exchange);\n        return new StringSource(result);\n    }\n\n    \n    @Deprecated\n    public SAXSource toSAXSourceFromStream(StreamSource source) throws SAXException {\n        return toSAXSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public SAXSource toSAXSourceFromStream(StreamSource source, Exchange exchange) throws SAXException {\n        InputSource inputSource;\n        if (source.getReader() != null) {\n            inputSource = new InputSource(source.getReader());\n        } else {\n            inputSource = new InputSource(source.getInputStream());\n        }\n        inputSource.setSystemId(source.getSystemId());\n        inputSource.setPublicId(source.getPublicId());\n        XMLReader xmlReader = null;\n        SAXParserFactory sfactory = null;\n        \n        try {\n            \n            if (exchange != null) {\n                sfactory = exchange.getProperty(Exchange.SAXPARSER_FACTORY, SAXParserFactory.class);\n            }\n            if (sfactory == null) {\n                sfactory = SAXParserFactory.newInstance();\n                try {\n                    sfactory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n                } catch (Exception e) {\n                    LOG.warn(\"SAXParser doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n                }\n            }\n            sfactory.setNamespaceAware(true);\n            SAXParser parser = sfactory.newSAXParser();\n            xmlReader = parser.getXMLReader();\n        } catch (Exception ex) {\n            LOG.warn(\"Cannot create the SAXParser XMLReader, due to {}\", ex);\n        }\n        return new SAXSource(xmlReader, inputSource);\n    }\n\n    \n    @Deprecated\n    public Reader toReaderFromSource(Source src) throws TransformerException {\n        return toReaderFromSource(src, null);\n    }\n\n    @Converter\n    public Reader toReaderFromSource(Source src, Exchange exchange) throws TransformerException {\n        StreamSource stSrc = toStreamSource(src, exchange);\n        Reader r = stSrc.getReader();\n        if (r == null) {\n            r = new InputStreamReader(stSrc.getInputStream());\n        }\n        return r;\n    }\n\n    \n    @Deprecated\n    public DOMSource toDOMSource(InputStream is) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(is, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(InputStream is, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputSource source = new InputSource(is);\n        String systemId = source.getSystemId();\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Document document = builder.parse(source);\n        return new DOMSource(document, systemId);\n    }\n\n    \n    @Deprecated\n    public DOMSource toDOMSource(File file) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSource(file, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSource(File file, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return toDOMSource(is, exchange);\n    }\n\n    \n    @Deprecated\n    public DOMSource toDOMSourceFromStream(StreamSource source) throws ParserConfigurationException, IOException, SAXException {\n        return toDOMSourceFromStream(source, null);\n    }\n    \n    @Converter\n    public DOMSource toDOMSourceFromStream(StreamSource source, Exchange exchange) throws ParserConfigurationException, IOException, SAXException {\n        Document document;\n        String systemId = source.getSystemId();\n\n        DocumentBuilder builder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        Reader reader = source.getReader();\n        if (reader != null) {\n            document = builder.parse(new InputSource(reader));\n        } else {\n            InputStream inputStream = source.getInputStream();\n            if (inputStream != null) {\n                InputSource inputsource = new InputSource(inputStream);\n                inputsource.setSystemId(systemId);\n                document = builder.parse(inputsource);\n            } else {\n                throw new IOException(\"No input stream or reader available on StreamSource: \" + source);\n            }\n        }\n        return new DOMSource(document, systemId);\n    }\n\n    \n    @Deprecated\n    public SAXSource toSAXSourceFromDOM(DOMSource source) throws TransformerException {\n        return toSAXSourceFromDOM(source, null);\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromDOM(DOMSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public SAXSource toSAXSourceFromStAX(StAXSource source, Exchange exchange) throws TransformerException {\n        String str = toString(source, exchange);\n        StringReader reader = new StringReader(str);\n        return new SAXSource(new InputSource(reader));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromSAX(SAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromSAX(source));\n    }\n\n    @Converter\n    public DOMSource toDOMSourceFromStAX(StAXSource source) throws IOException, SAXException, ParserConfigurationException, TransformerException {\n        return new DOMSource(toDOMNodeFromStAX(source));\n    }\n\n    @Converter\n    public Node toDOMNodeFromSAX(SAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    @Converter\n    public Node toDOMNodeFromStAX(StAXSource source) throws ParserConfigurationException, IOException, SAXException, TransformerException {\n        DOMResult result = new DOMResult();\n        toResult(source, result);\n        return result.getNode();\n    }\n\n    \n    @Converter(allowNull = true)\n    public Node toDOMNodeFromSingleNodeList(NodeList nl) {\n        return nl.getLength() == 1 ? nl.item(0) : null;\n    }\n\n    \n    @Converter(allowNull = true)\n    public Document toDOMDocumentFromSingleNodeList(NodeList nl) throws ParserConfigurationException, TransformerException {\n        if (nl.getLength() == 1) {\n            return toDOMDocument(nl.item(0));\n        } else if (nl instanceof Node) {\n            \n            \n            return toDOMDocument((Node) nl);\n        } else {\n            return null;\n        }\n    }\n\n    \n    @Converter(allowNull = true)\n    public Node toDOMNode(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        DOMSource domSrc = toDOMSource(source);\n        return domSrc != null ? domSrc.getNode() : null;\n    }\n\n    \n    @Converter\n    public Element toDOMElement(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMElement(node);\n    }\n\n    \n    @Converter\n    public Element toDOMElement(Node node) throws TransformerException {\n        \n        if (node instanceof Document) {\n            return ((Document) node).getDocumentElement();\n            \n        } else if (node instanceof Element) {\n            return (Element) node;\n            \n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to an Element\");\n        }\n    }\n\n    \n    \n    @Deprecated\n    public Document toDOMDocument(byte[] data) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(data, null);\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(byte[] data, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(new ByteArrayInputStream(data));\n    }\n\n    \n    @Deprecated\n    public Document toDOMDocument(InputStream in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, null);\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(InputStream in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    \n    @Deprecated\n    public Document toDOMDocument(Reader in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in));\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(Reader in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new InputSource(in), exchange);\n    }\n\n    \n    @Deprecated\n    public Document toDOMDocument(InputSource in) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(in, (Exchange)null);\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(InputSource in, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(in);\n    }\n\n    \n    @Deprecated\n    public Document toDOMDocument(String text) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text));\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(String text, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(new StringReader(text), exchange);\n    }\n\n    \n    @Deprecated\n    public Document toDOMDocument(File file) throws IOException, SAXException, ParserConfigurationException {\n        return toDOMDocument(file, null);\n    }\n    \n    \n    @Converter\n    public Document toDOMDocument(File file, Exchange exchange) throws IOException, SAXException, ParserConfigurationException {\n        DocumentBuilder documentBuilder = getDocumentBuilderFactory(exchange).newDocumentBuilder();\n        return documentBuilder.parse(file);\n    }\n\n    \n    @Converter\n    public Document toDOMDocument(Source source) throws TransformerException, ParserConfigurationException, IOException, SAXException {\n        Node node = toDOMNode(source);\n        return toDOMDocument(node);\n    }\n\n    \n    @Converter\n    public Document toDOMDocument(final Node node) throws ParserConfigurationException, TransformerException {\n        ObjectHelper.notNull(node, \"node\");\n\n        \n        if (node instanceof Document) {\n            return (Document) node;\n            \n        } else if (node instanceof Element) {\n            Element elem = (Element) node;\n            \n            if (elem.getOwnerDocument().getDocumentElement() == elem) {\n                return elem.getOwnerDocument();\n                \n            } else {\n                Document doc = createDocument();\n                \n                \n                synchronized (node.getOwnerDocument()) {\n                    doc.appendChild(doc.importNode(node, true));\n                }\n                return doc;\n            }\n            \n        } else {\n            throw new TransformerException(\"Unable to convert DOM node to a Document: \" + node);\n        }\n    }\n\n    \n    @Deprecated\n    public InputStream toInputStream(DOMSource source) throws TransformerException, IOException {\n        return toInputStream(source, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(DOMSource source, Exchange exchange) throws TransformerException, IOException {\n        return new ByteArrayInputStream(toByteArray(source, exchange));\n    }\n\n    \n    @Deprecated\n    public InputStream toInputStream(Document dom) throws TransformerException, IOException {\n        return toInputStream(dom, null);\n    }\n\n    @Converter\n    public InputStream toInputStream(Document dom, Exchange exchange) throws TransformerException, IOException {\n        return toInputStream(new DOMSource(dom), exchange);\n    }\n\n    @Converter\n    public InputSource toInputSource(InputStream is, Exchange exchange) {\n        return new InputSource(is);\n    }\n\n    @Converter\n    public InputSource toInputSource(File file, Exchange exchange) throws FileNotFoundException {\n        InputStream is = IOHelper.buffered(new FileInputStream(file));\n        return new InputSource(is);\n    }\n\n    \n    \n\n    public DocumentBuilderFactory getDocumentBuilderFactory() {\n        if (documentBuilderFactory == null) {\n            documentBuilderFactory = createDocumentBuilderFactory();\n        }\n        return documentBuilderFactory;\n    }\n\n    public void setDocumentBuilderFactory(DocumentBuilderFactory documentBuilderFactory) {\n        this.documentBuilderFactory = documentBuilderFactory;\n    }\n\n    public TransformerFactory getTransformerFactory() {\n        if (transformerFactory == null) {\n            transformerFactory = createTransformerFactory();\n        }\n        return transformerFactory;\n    }\n\n    public void setTransformerFactory(TransformerFactory transformerFactory) {\n        this.transformerFactory = transformerFactory;\n    }\n\n    \n    \n\n    protected void setupFeatures(DocumentBuilderFactory factory) {\n        Properties properties = System.getProperties();\n        List<String> features = new ArrayList<String>();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE)) {\n                String uri = ObjectHelper.after(key, \":\");\n                Boolean value = Boolean.valueOf((String)prop.getValue());\n                try {\n                    factory.setFeature(uri, value);\n                    features.add(\"feature \" + uri + \" value \" + value);\n                } catch (ParserConfigurationException e) {\n                    LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{uri, value, e});\n                }\n            }\n        }\n        if (features.size() > 0) {\n            StringBuilder featureString = new StringBuilder();\n            \n            for (String feature : features) {\n                if (featureString.length() != 0) {\n                    featureString.append(\", \");\n                }\n                featureString.append(feature);\n            }\n            LOG.info(\"DocumentBuilderFactory has been set with features {{}}.\", featureString.toString());\n        }\n\n    }\n    \n    public DocumentBuilderFactory getDocumentBuilderFactory(Exchange exchange) {\n        DocumentBuilderFactory answer = getDocumentBuilderFactory();\n        \n        if (exchange != null) {\n            DocumentBuilderFactory factory = exchange.getProperty(Exchange.DOCUMENT_BUILDER_FACTORY, DocumentBuilderFactory.class);\n            if (factory != null) {\n                answer = factory;\n            }\n        }\n        return answer;\n    }\n \n    public DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        factory.setIgnoringElementContentWhitespace(true);\n        factory.setIgnoringComments(true);\n        try {\n            \n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (ParserConfigurationException e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the feature {} with value {}, due to {}.\"\n                     , new Object[]{\"http://xml.org/sax/features/external-general-entities\", false, e});\n        }\n        \n        try {\n            Class<?> smClass = ObjectHelper.loadClass(\"org.apache.xerces.util.SecurityManager\");\n            if (smClass != null) {\n                Object sm = smClass.newInstance();\n                \n                factory.setAttribute(\"http://apache.org/xml/properties/security-manager\", sm);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"DocumentBuilderFactory doesn't support the attribute {}, due to {}.\"\n                     , new Object[]{\"http://apache.org/xml/properties/security-manager\", e});\n        }\n        \n        setupFeatures(factory);\n        return factory;\n    }\n\n    public DocumentBuilder createDocumentBuilder() throws ParserConfigurationException {\n        DocumentBuilderFactory factory = getDocumentBuilderFactory();\n        return factory.newDocumentBuilder();\n    }\n\n    public Document createDocument() throws ParserConfigurationException {\n        DocumentBuilder builder = createDocumentBuilder();\n        return builder.newDocument();\n    }\n\n    \n    @Deprecated\n    public Transformer createTransfomer() throws TransformerConfigurationException {\n        return createTransformer();\n    }\n\n    public Transformer createTransformer() throws TransformerConfigurationException {\n        TransformerFactory factory = getTransformerFactory();\n        return factory.newTransformer();\n    }\n\n    public TransformerFactory createTransformerFactory() {\n        TransformerFactory factory = TransformerFactory.newInstance();\n        \n        try {\n            factory.setFeature(javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, true);\n        } catch (TransformerConfigurationException e) {\n            LOG.warn(\"TransformerFactory doesn't support the feature {} with value {}, due to {}.\", new Object[]{javax.xml.XMLConstants.FEATURE_SECURE_PROCESSING, \"true\", e});\n        }\n        factory.setErrorListener(new XmlErrorListener());\n        return factory;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 2,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/camel/commit/7d19340bcdb42f7aae584d9c5003ac4f7ddaee36",
    "cve_id": "CVE-2015-0263",
    "cwe_id": "Not Mapping",
    "filename": "camel-core/src/test/java/org/apache/camel/component/xslt/XsltDTDTest.java",
    "code": "\npackage org.apache.camel.component.xslt;\n\nimport java.io.InputStream;\nimport java.util.List;\n\nimport javax.xml.transform.TransformerException;\n\nimport org.apache.camel.CamelExecutionException;\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.apache.camel.converter.IOConverter;\nimport org.apache.camel.impl.DefaultExchange;\n\n\npublic class XsltDTDTest extends ContextTestSupport {\n    private static final String MESSAGE = \n        \"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc//user//test\\\">]><task><name>&xxe;</name></task>\";\n    \n    public void testSendingStringMessage() throws Exception {\n        sendEntityMessage(MESSAGE);\n    }\n    \n    public void testSendingInputStreamMessage() throws Exception {\n        InputStream is = IOConverter.toInputStream(MESSAGE, new DefaultExchange(context));\n        sendEntityMessage(is);   \n    }\n    \n    private void sendEntityMessage(Object message) throws Exception {\n        \n        MockEndpoint endpoint = getMockEndpoint(\"mock:result\");\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n        \n        template.sendBody(\"direct:start1\", message);\n\n        assertMockEndpointsSatisfied();\n        \n        List<Exchange> list = endpoint.getReceivedExchanges();\n        Exchange exchange = list.get(0);\n        String xml = exchange.getIn().getBody(String.class);\n        assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n        \n        \n        \n        try {\n            template.sendBody(\"direct:start2\", message);\n            fail(\"Expect an exception here\");\n        } catch (Exception ex) {\n            \n            assertTrue(\"Get a wrong exception\", ex instanceof CamelExecutionException);\n            \n            assertTrue(\"Get a wrong exception cause\", ex.getCause() instanceof TransformerException);\n        }\n        \n    }\n    \n\n    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                \n                from(\"direct:start1\")\n                    .to(\"xslt:org/apache/camel/component/xslt/transform_dtd.xsl\")\n                    .to(\"mock:result\");\n                \n                from(\"direct:start2\")\n                    .to(\"xslt:org/apache/camel/component/xslt/transform_dtd.xsl?allowStAX=false\")\n                    .to(\"mock:result\");\n            }\n        };\n    }\n\n    \n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 3,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/camel/commit/1df559649a96a1ca0368373387e542f46e4820da",
    "cve_id": "CVE-2015-0264",
    "cwe_id": "Not Mapping",
    "filename": "camel-core/src/main/java/org/apache/camel/builder/xml/XPathBuilder.java",
    "code": "\npackage org.apache.camel.builder.xml;\n\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Queue;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentLinkedQueue;\nimport javax.xml.namespace.QName;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport javax.xml.xpath.XPathFactoryConfigurationException;\nimport javax.xml.xpath.XPathFunction;\nimport javax.xml.xpath.XPathFunctionException;\nimport javax.xml.xpath.XPathFunctionResolver;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Expression;\nimport org.apache.camel.NoTypeConversionAvailableException;\nimport org.apache.camel.Predicate;\nimport org.apache.camel.RuntimeExpressionException;\nimport org.apache.camel.WrappedFile;\nimport org.apache.camel.component.bean.BeanInvocation;\nimport org.apache.camel.impl.DefaultExchange;\nimport org.apache.camel.spi.Language;\nimport org.apache.camel.spi.NamespaceAware;\nimport org.apache.camel.support.ServiceSupport;\nimport org.apache.camel.util.ExchangeHelper;\nimport org.apache.camel.util.IOHelper;\nimport org.apache.camel.util.MessageHelper;\nimport org.apache.camel.util.ObjectHelper;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.apache.camel.builder.xml.Namespaces.DEFAULT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.FUNCTION_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.IN_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.OUT_NAMESPACE;\nimport static org.apache.camel.builder.xml.Namespaces.isMatchingNamespaceOrEmptyNamespace;\n\n\npublic class XPathBuilder extends ServiceSupport implements Expression, Predicate, NamespaceAware {\n    private static final Logger LOG = LoggerFactory.getLogger(XPathBuilder.class);\n    private static final String SAXON_OBJECT_MODEL_URI = \"http://saxon.sf.net/jaxp/xpath/om\";\n    private static final String OBTAIN_ALL_NS_XPATH = \"//*/namespace::*\";\n\n    private static volatile XPathFactory defaultXPathFactory;\n\n    private final Queue<XPathExpression> pool = new ConcurrentLinkedQueue<XPathExpression>();\n    private final Queue<XPathExpression> poolLogNamespaces = new ConcurrentLinkedQueue<XPathExpression>();\n    private final String text;\n    private final ThreadLocal<Exchange> exchange = new ThreadLocal<Exchange>();\n    private final MessageVariableResolver variableResolver = new MessageVariableResolver(exchange);\n    private final Map<String, String> namespaces = new ConcurrentHashMap<String, String>();\n    private volatile XPathFactory xpathFactory;\n    private volatile Class<?> documentType = Document.class;\n    \n    \n    \n    \n    private volatile Class<?> resultType;\n    private volatile QName resultQName = XPathConstants.NODESET;\n    private volatile String objectModelUri;\n    private volatile DefaultNamespaceContext namespaceContext;\n    private volatile boolean logNamespaces;\n    private volatile XPathFunctionResolver functionResolver;\n    private volatile XPathFunction bodyFunction;\n    private volatile XPathFunction headerFunction;\n    private volatile XPathFunction outBodyFunction;\n    private volatile XPathFunction outHeaderFunction;\n    private volatile XPathFunction propertiesFunction;\n    private volatile XPathFunction simpleFunction;\n    \n    private volatile String headerName;\n\n    \n    public XPathBuilder(String text) {\n        this.text = text;\n    }\n\n    \n    public static XPathBuilder xpath(String text) {\n        return new XPathBuilder(text);\n    }\n\n    \n    public static XPathBuilder xpath(String text, Class<?> resultType) {\n        XPathBuilder builder = new XPathBuilder(text);\n        builder.setResultType(resultType);\n        return builder;\n    }\n\n    @Override\n    public String toString() {\n        return \"XPath: \" + text;\n    }\n\n    public boolean matches(Exchange exchange) {\n        try {\n            Object booleanResult = evaluateAs(exchange, XPathConstants.BOOLEAN);\n            return exchange.getContext().getTypeConverter().convertTo(Boolean.class, booleanResult);\n        } finally {\n            \n            this.exchange.remove();\n        }\n    }\n\n    public <T> T evaluate(Exchange exchange, Class<T> type) {\n        try {\n            Object result = evaluate(exchange);\n            return exchange.getContext().getTypeConverter().convertTo(type, exchange, result);\n        } finally {\n            \n            this.exchange.remove();\n        }\n    }\n\n    \n    public boolean matches(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        \n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return matches(dummy);\n        } finally {\n            \n            exchange.remove();\n        }\n    }\n\n    \n    public <T> T evaluate(CamelContext context, Object body, Class<T> type) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        \n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        try {\n            return evaluate(dummy, type);\n        } finally {\n            \n            exchange.remove();\n        }\n    }\n\n    \n    public String evaluate(CamelContext context, Object body) {\n        ObjectHelper.notNull(context, \"CamelContext\");\n\n        \n        Exchange dummy = new DefaultExchange(context);\n        dummy.getIn().setBody(body);\n\n        setResultQName(XPathConstants.STRING);\n        try {\n            return evaluate(dummy, String.class);\n        } finally {\n            \n            this.exchange.remove();\n        }\n    }\n\n    \n    \n\n    \n    public XPathBuilder booleanResult() {\n        resultQName = XPathConstants.BOOLEAN;\n        return this;\n    }\n\n    \n    public XPathBuilder nodeResult() {\n        resultQName = XPathConstants.NODE;\n        return this;\n    }\n\n    \n    public XPathBuilder nodeSetResult() {\n        resultQName = XPathConstants.NODESET;\n        return this;\n    }\n\n    \n    public XPathBuilder numberResult() {\n        resultQName = XPathConstants.NUMBER;\n        return this;\n    }\n\n    \n    public XPathBuilder stringResult() {\n        resultQName = XPathConstants.STRING;\n        return this;\n    }\n\n    \n    public XPathBuilder resultType(Class<?> resultType) {\n        setResultType(resultType);\n        return this;\n    }\n\n    \n    public XPathBuilder objectModel(String uri) {\n        \n        \n        \n        this.objectModelUri = uri;\n        return this;\n    }\n\n    \n    public XPathBuilder saxon() {\n        this.objectModelUri = SAXON_OBJECT_MODEL_URI;\n        return this;\n    }\n\n    \n    public XPathBuilder functionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n        return this;\n    }\n\n    \n    public XPathBuilder namespace(String prefix, String uri) {\n        namespaces.put(prefix, uri);\n        return this;\n    }\n\n    \n    public XPathBuilder namespaces(Namespaces namespaces) {\n        namespaces.configure(this);\n        return this;\n    }\n\n    \n    public XPathBuilder variable(String name, Object value) {\n        getVariableResolver().addVariable(name, value);\n        return this;\n    }\n\n    \n    public XPathBuilder documentType(Class<?> documentType) {\n        setDocumentType(documentType);\n        return this;\n    }\n\n    \n    public XPathBuilder factory(XPathFactory xpathFactory) {\n        setXPathFactory(xpathFactory);\n        return this;\n    }\n\n    \n    public XPathBuilder logNamespaces() {\n        setLogNamespaces(true);\n        return this;\n    }\n\n    \n    \n\n    \n    public XPathFactory getXPathFactory() {\n        return xpathFactory;\n    }\n\n    public void setXPathFactory(XPathFactory xpathFactory) {\n        this.xpathFactory = xpathFactory;\n    }\n\n    public Class<?> getDocumentType() {\n        return documentType;\n    }\n\n    public void setDocumentType(Class<?> documentType) {\n        this.documentType = documentType;\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public QName getResultQName() {\n        return resultQName;\n    }\n\n    public void setResultQName(QName resultQName) {\n        this.resultQName = resultQName;\n    }\n\n    public String getHeaderName() {\n        return headerName;\n    }\n\n    public void setHeaderName(String headerName) {\n        this.headerName = headerName;\n    }\n\n    \n    public DefaultNamespaceContext getNamespaceContext() {\n        return namespaceContext;\n    }\n\n    public void setNamespaceContext(DefaultNamespaceContext namespaceContext) {\n        this.namespaceContext = namespaceContext;\n    }\n\n    public XPathFunctionResolver getFunctionResolver() {\n        return functionResolver;\n    }\n\n    public void setFunctionResolver(XPathFunctionResolver functionResolver) {\n        this.functionResolver = functionResolver;\n    }\n\n    public void setNamespaces(Map<String, String> namespaces) {\n        this.namespaces.clear();\n        this.namespaces.putAll(namespaces);\n    }\n\n    \n    public XPathFunction getBodyFunction() {\n        return bodyFunction;\n    }\n\n    private XPathFunction createBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                return exchange.get().getIn().getBody();\n            }\n        };\n    }\n\n    public void setBodyFunction(XPathFunction bodyFunction) {\n        this.bodyFunction = bodyFunction;\n    }\n\n    \n    public XPathFunction getHeaderFunction() {\n        return headerFunction;\n    }\n\n    private XPathFunction createHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getIn().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setHeaderFunction(XPathFunction headerFunction) {\n        this.headerFunction = headerFunction;\n    }\n\n    \n    public XPathFunction getOutBodyFunction() {\n        return outBodyFunction;\n    }\n\n    private XPathFunction createOutBodyFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && exchange.get().hasOut()) {\n                    return exchange.get().getOut().getBody();\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutBodyFunction(XPathFunction outBodyFunction) {\n        this.outBodyFunction = outBodyFunction;\n    }\n\n    \n    public XPathFunction getOutHeaderFunction() {\n        return outHeaderFunction;\n    }\n\n    private XPathFunction createOutHeaderFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (exchange.get() != null && !list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        return exchange.get().getOut().getHeader(text);\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setOutHeaderFunction(XPathFunction outHeaderFunction) {\n        this.outHeaderFunction = outHeaderFunction;\n    }\n\n    \n    public XPathFunction getPropertiesFunction() {\n        return propertiesFunction;\n    }\n\n    private XPathFunction createPropertiesFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        try {\n                            \n                            Object answer = exchange.get().getContext().resolvePropertyPlaceholders(\"{{\" + text + \"}}\");\n                            return answer;\n                        } catch (Exception e) {\n                            throw new XPathFunctionException(e);\n                        }\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setPropertiesFunction(XPathFunction propertiesFunction) {\n        this.propertiesFunction = propertiesFunction;\n    }\n\n    \n    public XPathFunction getSimpleFunction() {\n        return simpleFunction;\n    }\n\n    private XPathFunction createSimpleFunction() {\n        return new XPathFunction() {\n            @SuppressWarnings(\"rawtypes\")\n            public Object evaluate(List list) throws XPathFunctionException {\n                if (!list.isEmpty()) {\n                    Object value = list.get(0);\n                    if (value != null) {\n                        String text = exchange.get().getContext().getTypeConverter().convertTo(String.class, value);\n                        Language simple = exchange.get().getContext().resolveLanguage(\"simple\");\n                        Expression exp = simple.createExpression(text);\n                        Object answer = exp.evaluate(exchange.get(), Object.class);\n                        return answer;\n                    }\n                }\n                return null;\n            }\n        };\n    }\n\n    public void setSimpleFunction(XPathFunction simpleFunction) {\n        this.simpleFunction = simpleFunction;\n    }\n\n    public Class<?> getResultType() {\n        return resultType;\n    }\n\n    public void setResultType(Class<?> resultType) {\n        this.resultType = resultType;\n        if (Number.class.isAssignableFrom(resultType)) {\n            numberResult();\n        } else if (String.class.isAssignableFrom(resultType)) {\n            stringResult();\n        } else if (Boolean.class.isAssignableFrom(resultType)) {\n            booleanResult();\n        } else if (Node.class.isAssignableFrom(resultType)) {\n            nodeResult();\n        } else if (NodeList.class.isAssignableFrom(resultType)) {\n            nodeSetResult();\n        }\n    }\n\n    public void setLogNamespaces(boolean logNamespaces) {\n        this.logNamespaces = logNamespaces;\n    }\n\n    public boolean isLogNamespaces() {\n        return logNamespaces;\n    }\n\n    public String getObjectModelUri() {\n        return objectModelUri;\n    }\n\n    \n    public void enableSaxon() {\n        this.setObjectModelUri(SAXON_OBJECT_MODEL_URI);\n    }\n\n    public void setObjectModelUri(String objectModelUri) {\n        this.objectModelUri = objectModelUri;\n    }\n\n    \n    \n\n    protected Object evaluate(Exchange exchange) {\n        Object answer = evaluateAs(exchange, resultQName);\n        if (resultType != null) {\n            return ExchangeHelper.convertToType(exchange, resultType, answer);\n        }\n        return answer;\n    }\n\n    \n    protected Object evaluateAs(Exchange exchange, QName resultQName) {\n        \n        XPathExpression xpathExpression = pool.poll();\n        if (xpathExpression == null) {\n            LOG.trace(\"Creating new XPathExpression as none was available from pool\");\n            \n            try {\n                xpathExpression = createXPathExpression();\n            } catch (XPathExpressionException e) {\n                throw new InvalidXPathExpression(getText(), e);\n            } catch (Exception e) {\n                throw new RuntimeExpressionException(\"Cannot create xpath expression\", e);\n            }\n        } else {\n            LOG.trace(\"Acquired XPathExpression from pool\");\n        }\n        try {\n            if (logNamespaces && LOG.isInfoEnabled()) {\n                logNamespaces(exchange);\n            }\n            return doInEvaluateAs(xpathExpression, exchange, resultQName);\n        } finally {\n            \n            pool.add(xpathExpression);\n            LOG.trace(\"Released XPathExpression back to pool\");\n        }\n    }\n\n    private void logNamespaces(Exchange exchange) {\n        InputStream is = null;\n        NodeList answer = null;\n        XPathExpression xpathExpression = null;\n\n        try {\n            xpathExpression = poolLogNamespaces.poll();\n            if (xpathExpression == null) {\n                xpathExpression = createTraceNamespaceExpression();\n            }\n\n            \n            Object document;\n            if (isInputStreamNeeded(exchange)) {\n                is = exchange.getIn().getBody(InputStream.class);\n                document = getDocument(exchange, is);\n            } else {\n                Object body = exchange.getIn().getBody();\n                document = getDocument(exchange, body);\n            }\n            \n            if (document instanceof InputSource) {\n                InputSource inputSource = (InputSource) document;\n                answer = (NodeList) xpathExpression.evaluate(inputSource, XPathConstants.NODESET);\n            } else if (document instanceof DOMSource) {\n                DOMSource source = (DOMSource) document;\n                answer = (NodeList) xpathExpression.evaluate(source.getNode(), XPathConstants.NODESET);\n            } else {\n                answer = (NodeList) xpathExpression.evaluate(document, XPathConstants.NODESET);\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Unable to trace discovered namespaces in XPath expression\", e);\n        } finally {\n            \n            IOHelper.close(is);\n            poolLogNamespaces.add(xpathExpression);\n        }\n\n        if (answer != null) {\n            logDiscoveredNamespaces(answer);\n        }\n    }\n\n    private void logDiscoveredNamespaces(NodeList namespaces) {\n        Map<String, HashSet<String>> map = new LinkedHashMap<String, HashSet<String>>();\n        for (int i = 0; i < namespaces.getLength(); i++) {\n            Node n = namespaces.item(i);\n            if (n.getNodeName().equals(\"xmlns:xml\")) {\n                \n                continue;\n            }\n\n            String prefix = namespaces.item(i).getNodeName();\n            if (prefix.equals(\"xmlns\")) {\n                prefix = \"DEFAULT\";\n            }\n\n            \n            if (!map.containsKey(prefix)) {\n                map.put(prefix, new HashSet<String>());\n            }\n            map.get(prefix).add(namespaces.item(i).getNodeValue());\n        }\n\n        LOG.info(\"Namespaces discovered in message: {}.\", map);\n    }\n\n    protected Object doInEvaluateAs(XPathExpression xpathExpression, Exchange exchange, QName resultQName) {\n        LOG.trace(\"Evaluating exchange: {} as: {}\", exchange, resultQName);\n\n        Object answer;\n\n        \n        this.exchange.set(exchange);\n\n        \n        InputStream is = null;\n        try {\n            Object document;\n\n            \n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                String headerName = getHeaderName();\n                \n                if (isInputStreamNeeded(exchange, headerName)) {\n                    is = exchange.getIn().getHeader(headerName, InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object headerObject = exchange.getIn().getHeader(getHeaderName());\n                    document = getDocument(exchange, headerObject);\n                }\n            } else {\n                \n                if (isInputStreamNeeded(exchange)) {\n                    is = exchange.getIn().getBody(InputStream.class);\n                    document = getDocument(exchange, is);\n                } else {\n                    Object body = exchange.getIn().getBody();\n                    document = getDocument(exchange, body);\n                }\n            }\n\n            if (resultQName != null) {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource, resultQName);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode(), resultQName);\n                } else {\n                    answer = xpathExpression.evaluate(document, resultQName);\n                }\n            } else {\n                if (document instanceof InputSource) {\n                    InputSource inputSource = (InputSource) document;\n                    answer = xpathExpression.evaluate(inputSource);\n                } else if (document instanceof DOMSource) {\n                    DOMSource source = (DOMSource) document;\n                    answer = xpathExpression.evaluate(source.getNode());\n                } else {\n                    answer = xpathExpression.evaluate(document);\n                }\n            }\n        } catch (XPathExpressionException e) {\n            String message = getText();\n            if (ObjectHelper.isNotEmpty(getHeaderName())) {\n                message = message + \" with headerName \" + getHeaderName();\n            }\n            throw new InvalidXPathExpression(message, e);\n        } finally {\n            \n            IOHelper.close(is);\n        }\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Done evaluating exchange: {} as: {} with result: {}\", new Object[]{exchange, resultQName, answer});\n        }\n        return answer;\n    }\n\n    \n    protected synchronized XPathExpression createXPathExpression() throws XPathExpressionException, XPathFactoryConfigurationException {\n        \n        try {\n            start();\n        } catch (Exception e) {\n            throw new RuntimeExpressionException(\"Error starting XPathBuilder\", e);\n        }\n\n        \n        XPath xPath = getXPathFactory().newXPath();\n\n        if (!logNamespaces && LOG.isTraceEnabled()) {\n            LOG.trace(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        } else if (logNamespaces && LOG.isInfoEnabled()) {\n            LOG.info(\"Creating new XPath expression in pool. Namespaces on XPath expression: {}\", getNamespaceContext().toString());\n        }\n        xPath.setNamespaceContext(getNamespaceContext());\n        xPath.setXPathVariableResolver(getVariableResolver());\n\n        XPathFunctionResolver parentResolver = getFunctionResolver();\n        if (parentResolver == null) {\n            parentResolver = xPath.getXPathFunctionResolver();\n        }\n        xPath.setXPathFunctionResolver(createDefaultFunctionResolver(parentResolver));\n        return xPath.compile(text);\n    }\n\n    protected synchronized XPathExpression createTraceNamespaceExpression() throws XPathFactoryConfigurationException, XPathExpressionException {\n        \n        XPath xPath = getXPathFactory().newXPath();\n        return xPath.compile(OBTAIN_ALL_NS_XPATH);\n    }\n\n    protected DefaultNamespaceContext createNamespaceContext(XPathFactory factory) {\n        DefaultNamespaceContext context = new DefaultNamespaceContext(factory);\n        populateDefaultNamespaces(context);\n        return context;\n    }\n\n    \n    protected void populateDefaultNamespaces(DefaultNamespaceContext context) {\n        setNamespaceIfNotPresent(context, \"in\", IN_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"out\", OUT_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"env\", Namespaces.ENVIRONMENT_VARIABLES);\n        setNamespaceIfNotPresent(context, \"system\", Namespaces.SYSTEM_PROPERTIES_NAMESPACE);\n        setNamespaceIfNotPresent(context, \"function\", Namespaces.FUNCTION_NAMESPACE);\n    }\n\n    protected void setNamespaceIfNotPresent(DefaultNamespaceContext context, String prefix, String uri) {\n        if (context != null) {\n            String current = context.getNamespaceURI(prefix);\n            if (current == null) {\n                context.add(prefix, uri);\n            }\n        }\n    }\n\n    protected XPathFunctionResolver createDefaultFunctionResolver(final XPathFunctionResolver parent) {\n        return new XPathFunctionResolver() {\n            public XPathFunction resolveFunction(QName qName, int argumentCount) {\n                XPathFunction answer = null;\n                if (parent != null) {\n                    answer = parent.resolveFunction(qName, argumentCount);\n                }\n                if (answer == null) {\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), IN_NAMESPACE)\n                            || isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), DEFAULT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), OUT_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"body\") && argumentCount == 0) {\n                            return getOutBodyFunction();\n                        }\n                        if (localPart.equals(\"header\") && argumentCount == 1) {\n                            return getOutHeaderFunction();\n                        }\n                    }\n                    if (isMatchingNamespaceOrEmptyNamespace(qName.getNamespaceURI(), FUNCTION_NAMESPACE)) {\n                        String localPart = qName.getLocalPart();\n                        if (localPart.equals(\"properties\") && argumentCount == 1) {\n                            return getPropertiesFunction();\n                        }\n                        if (localPart.equals(\"simple\") && argumentCount == 1) {\n                            return getSimpleFunction();\n                        }\n                    }\n                }\n                return answer;\n            }\n        };\n    }\n\n    \n    protected boolean isInputStreamNeeded(Exchange exchange) {\n        Object body = exchange.getIn().getBody();\n        return isInputStreamNeededForObject(exchange, body);\n    }\n\n    \n    protected boolean isInputStreamNeeded(Exchange exchange, String headerName) {\n        Object header = exchange.getIn().getHeader(headerName);\n        return isInputStreamNeededForObject(exchange, header);\n    }\n\n    \n    protected boolean isInputStreamNeededForObject(Exchange exchange, Object obj) {\n        if (obj == null) {\n            return false;\n        }\n\n        if (obj instanceof WrappedFile) {\n            obj = ((WrappedFile<?>) obj).getFile();\n        }\n        if (obj instanceof File) {\n            \n            return true;\n        }\n\n        \n        return false;\n    }\n\n    \n    protected Object getDocument(Exchange exchange, Object body) {\n        try {\n            return doGetDocument(exchange, body);\n        } catch (Exception e) {\n            throw ObjectHelper.wrapRuntimeCamelException(e);\n        } finally {\n            \n            MessageHelper.resetStreamCache(exchange.getIn());\n        }\n    }\n\n    protected Object doGetDocument(Exchange exchange, Object body) throws Exception {\n        if (body == null) {\n            return null;\n        }\n\n        Object answer = null;\n\n        Class<?> type = getDocumentType();\n        Exception cause = null;\n        if (type != null) {\n            \n            try {\n                answer = exchange.getContext().getTypeConverter().convertTo(type, exchange, body);\n            } catch (Exception e) {\n                \n                cause = e;\n            }\n        }\n\n        \n        if (answer == null) {\n            \n            if (body instanceof WrappedFile) {\n                \n                InputStream is = exchange.getContext().getTypeConverter().convertTo(InputStream.class, exchange, body);\n                answer = new InputSource(is);\n            } else if (body instanceof BeanInvocation) {\n                \n                BeanInvocation bi = exchange.getContext().getTypeConverter().convertTo(BeanInvocation.class, exchange, body);\n                if (bi.getArgs() != null && bi.getArgs().length == 1 && bi.getArgs()[0] == null) {\n                    \n                    answer = null;\n                }\n            } else if (body instanceof String) {\n                answer = new InputSource(new StringReader((String) body));\n            }\n        }\n\n        if (type == null && answer == null) {\n            \n            answer = body;\n        } else if (answer == null) {\n            \n            if (cause != null) {\n                throw cause;\n            } else {\n                throw new NoTypeConversionAvailableException(body, type);\n            }\n        }\n\n        return answer;\n    }\n\n    private MessageVariableResolver getVariableResolver() {\n        return variableResolver;\n    }\n\n    @Override\n    public void doStart() throws Exception {\n        if (xpathFactory == null) {\n            xpathFactory = createXPathFactory();\n        }\n        if (namespaceContext == null) {\n            namespaceContext = createNamespaceContext(xpathFactory);\n        }\n        for (Map.Entry<String, String> entry : namespaces.entrySet()) {\n            namespaceContext.add(entry.getKey(), entry.getValue());\n        }\n\n        \n        if (bodyFunction == null) {\n            bodyFunction = createBodyFunction();\n        }\n        if (headerFunction == null) {\n            headerFunction = createHeaderFunction();\n        }\n        if (outBodyFunction == null) {\n            outBodyFunction = createOutBodyFunction();\n        }\n        if (outHeaderFunction == null) {\n            outHeaderFunction = createOutHeaderFunction();\n        }\n        if (propertiesFunction == null) {\n            propertiesFunction = createPropertiesFunction();\n        }\n        if (simpleFunction == null) {\n            simpleFunction = createSimpleFunction();\n        }\n    }\n\n    @Override\n    public void doStop() throws Exception {\n        pool.clear();\n        poolLogNamespaces.clear();\n    }\n\n    protected synchronized XPathFactory createXPathFactory() throws XPathFactoryConfigurationException {\n        if (objectModelUri != null) {\n            xpathFactory = XPathFactory.newInstance(objectModelUri);\n            LOG.info(\"Using objectModelUri \" + objectModelUri + \" when created XPathFactory {}\", xpathFactory);\n            return xpathFactory;\n        }\n\n        if (defaultXPathFactory == null) {\n            defaultXPathFactory = createDefaultXPathFactory();\n        }\n        return defaultXPathFactory;\n    }\n\n    protected static XPathFactory createDefaultXPathFactory() throws XPathFactoryConfigurationException {\n        XPathFactory factory = null;\n\n        \n        Properties properties = System.getProperties();\n        for (Map.Entry<Object, Object> prop : properties.entrySet()) {\n            String key = (String) prop.getKey();\n            if (key.startsWith(XPathFactory.DEFAULT_PROPERTY_NAME)) {\n                String uri = ObjectHelper.after(key, \":\");\n                if (uri != null) {\n                    factory = XPathFactory.newInstance(uri);\n                    LOG.info(\"Using system property {} with value {} when created default XPathFactory {}\", new Object[]{key, uri, factory});\n                }\n            }\n        }\n\n        if (factory == null) {\n            factory = XPathFactory.newInstance();\n            LOG.info(\"Created default XPathFactory {}\", factory);\n        }\n\n        return factory;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 3,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/camel/commit/1df559649a96a1ca0368373387e542f46e4820da",
    "cve_id": "CVE-2015-0264",
    "cwe_id": "Not Mapping",
    "filename": "camel-core/src/test/java/org/apache/camel/builder/xml/XPathFeatureTest.java",
    "code": "\npackage org.apache.camel.builder.xml;\n\n\nimport java.io.FileNotFoundException;\n\nimport javax.xml.xpath.XPathExpressionException;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.converter.jaxp.XmlConverter;\n\nimport static org.apache.camel.builder.xml.XPathBuilder.xpath;\n\npublic class XPathFeatureTest extends ContextTestSupport {\n    public static final String DOM_BUILER_FACTORY_FEATRUE = XmlConverter.DOCUMENT_BUILDER_FACTORY_FEATURE;\n    \n    public static final String XML_DATA = \" <!DOCTYPE foo [ \" \n        + \" <!ELEMENT foo ANY > <!ENTITY xxe SYSTEM \\\"file:///bin/test.sh\\\" >]> <test> &xxe; </test>\";\n                                              \n    \n    @Override\n    public boolean isUseRouteBuilder() {\n        return false;\n    }\n  \n    public void testXPathResult() throws Exception {\n        String result = (String)xpath(\"/\").stringResult().evaluate(createExchange(XML_DATA));\n        assertEquals(\"Get a wrong result\", \"  \", result);\n    }\n    \n    public void testXPath() throws Exception {\n        \n        \n        System.setProperty(DOM_BUILER_FACTORY_FEATRUE + \":\" \n            + \"http://xml.org/sax/features/external-general-entities\", \"true\");\n        try {\n            xpath(\"/\").stringResult().evaluate(createExchange(XML_DATA));\n            fail(\"Expect an Exception here\");\n        } catch (Exception ex) {\n            assertTrue(\"Get a wrong exception cause.\", ex instanceof InvalidXPathExpression);\n            assertTrue(\"Get a wrong exception cause.\", ex.getCause() instanceof XPathExpressionException);\n            assertTrue(\"Get a wrong exception cause.\", ex.getCause().getCause() instanceof FileNotFoundException);\n        } finally {\n            System.clearProperty(DOM_BUILER_FACTORY_FEATRUE + \":\" \n                + \"http://xml.org/sax/features/external-general-entities\");\n        }\n    }\n    \n    protected Exchange createExchange(Object xml) {\n        Exchange exchange = createExchangeWithBody(context, xml);\n        return exchange;\n    }\n\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 3,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/camel/commit/1df559649a96a1ca0368373387e542f46e4820da",
    "cve_id": "CVE-2015-0264",
    "cwe_id": "Not Mapping",
    "filename": "components/camel-saxon/src/test/java/org/apache/camel/component/xslt/SaxonXsltDTDTest.java",
    "code": "\npackage org.apache.camel.component.xslt;\n\nimport java.io.InputStream;\nimport java.util.List;\n\nimport javax.xml.transform.TransformerException;\n\nimport org.apache.camel.CamelExecutionException;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.apache.camel.converter.IOConverter;\nimport org.apache.camel.impl.DefaultExchange;\nimport org.apache.camel.test.junit4.CamelTestSupport;\nimport org.junit.Test;\n\n\npublic class SaxonXsltDTDTest extends CamelTestSupport {\n    \n    private static final String MESSAGE = \n        \"<!DOCTYPE foo [<!ENTITY xxe SYSTEM \\\"file:///etc//user//test\\\">]><task><name>&xxe;</name></task>\";\n    \n    @Test\n    public void testSendingStringMessage() throws Exception {\n        sendEntityMessage(MESSAGE);\n    }\n    \n    @Test\n    public void testSendingInputStreamMessage() throws Exception {\n        InputStream is = IOConverter.toInputStream(MESSAGE, new DefaultExchange(context));\n        sendEntityMessage(is);   \n    }\n    \n    private void sendEntityMessage(Object message) throws Exception {\n        \n        MockEndpoint endpoint = getMockEndpoint(\"mock:result\");\n        endpoint.reset();\n        endpoint.expectedMessageCount(1);\n        \n        template.sendBody(\"direct:start1\", message);\n\n        assertMockEndpointsSatisfied();\n        \n        List<Exchange> list = endpoint.getReceivedExchanges();\n        Exchange exchange = list.get(0);\n        String xml = exchange.getIn().getBody(String.class);\n        assertTrue(\"Get a wrong transformed message\", xml.indexOf(\"<transformed subject=\\\"\\\">\") > 0);\n        \n        \n        \n        try {\n            template.sendBody(\"direct:start2\", message);\n            fail(\"Expect an exception here\");\n        } catch (Exception ex) {\n            \n            assertTrue(\"Get a wrong exception\", ex instanceof CamelExecutionException);\n            \n            assertTrue(\"Get a wrong exception cause\", ex.getCause() instanceof TransformerException);\n        }\n        \n    }\n    \n\n    @Override\n    protected RouteBuilder createRouteBuilder() throws Exception {\n        return new RouteBuilder() {\n            @Override\n            public void configure() throws Exception {\n                \n                from(\"direct:start1\")\n                    .to(\"xslt:org/apache/camel/component/xslt/transform_dtd.xsl\")\n                    .to(\"mock:result\");\n                \n                from(\"direct:start2\")\n                    .to(\"xslt:org/apache/camel/component/xslt/transform_dtd.xsl?allowStAX=false\")\n                    .to(\"mock:result\");\n            }\n        };\n    }\n\n    \n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 4,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/a080293da69f3fe3d11d5214432e1469ee195870",
    "cve_id": "APACHE-COMMONS-001",
    "cwe_id": "Not Mapping",
    "filename": "src/main/java/org/apache/commons/compress/archivers/examples/Expander.java",
    "code": "\npackage org.apache.commons.compress.archivers.examples;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Enumeration;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveStreamFactory;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.zip.ZipArchiveEntry;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.compress.utils.IOUtils;\n\n\npublic class Expander {\n\n    private interface ArchiveEntrySupplier {\n        ArchiveEntry getNextReadableEntry() throws IOException;\n    }\n\n    private interface EntryWriter {\n        void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException;\n    }\n\n    \n    public void expand(File archive, File targetDirectory) throws IOException, ArchiveException {\n        String format = null;\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            format = new ArchiveStreamFactory().detect(i);\n        }\n        expand(format, archive, targetDirectory);\n    }\n\n    \n    public void expand(String format, File archive, File targetDirectory) throws IOException, ArchiveException {\n        if (prefersSeekableByteChannel(format)) {\n            try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\n                expand(format, c, targetDirectory);\n            }\n            return;\n        }\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            expand(format, i, targetDirectory);\n        }\n    }\n\n    \n    public void expand(InputStream archive, File targetDirectory) throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(archive), targetDirectory);\n    }\n\n    \n    public void expand(String format, InputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveStreamFactory().createArchiveInputStream(format, archive), targetDirectory);\n    }\n\n    \n    public void expand(String format, SeekableByteChannel archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        if (!prefersSeekableByteChannel(format)) {\n            expand(format, Channels.newInputStream(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.ZIP.equalsIgnoreCase(format)) {\n            expand(new ZipFile(archive), targetDirectory);\n        } else if (ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format)) {\n            expand(new SevenZFile(archive), targetDirectory);\n        } else {\n            \n            throw new ArchiveException(\"don't know how to handle format \" + format);\n        }\n    }\n\n    \n    public void expand(final ArchiveInputStream archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ArchiveEntry next = archive.getNextEntry();\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = archive.getNextEntry();\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                IOUtils.copy(archive, out);\n            }\n        }, targetDirectory);\n    }\n\n    \n    public void expand(final ZipFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        final Enumeration<ZipArchiveEntry> entries = archive.getEntries();\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                ZipArchiveEntry next = entries.hasMoreElements() ? entries.nextElement() : null;\n                while (next != null && !archive.canReadEntryData(next)) {\n                    next = entries.hasMoreElements() ? entries.nextElement() : null;\n                }\n                return next;\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                try (InputStream in = archive.getInputStream((ZipArchiveEntry) entry)) {\n                    IOUtils.copy(in, out);\n                }\n            }\n        }, targetDirectory);\n    }\n\n    \n    public void expand(final SevenZFile archive, File targetDirectory)\n        throws IOException, ArchiveException {\n        expand(new ArchiveEntrySupplier() {\n            @Override\n            public ArchiveEntry getNextReadableEntry() throws IOException {\n                return archive.getNextEntry();\n            }\n        }, new EntryWriter() {\n            @Override\n            public void writeEntryDataTo(ArchiveEntry entry, OutputStream out) throws IOException {\n                final byte[] buffer = new byte[8024];\n                int n = 0;\n                long count = 0;\n                while (-1 != (n = archive.read(buffer))) {\n                    out.write(buffer, 0, n);\n                    count += n;\n                }\n            }\n        }, targetDirectory);\n    }\n\n    private boolean prefersSeekableByteChannel(String format) {\n        return ArchiveStreamFactory.ZIP.equalsIgnoreCase(format) || ArchiveStreamFactory.SEVEN_Z.equalsIgnoreCase(format);\n    }\n\n    private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath();\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 4,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/a080293da69f3fe3d11d5214432e1469ee195870",
    "cve_id": "APACHE-COMMONS-001",
    "cwe_id": "Not Mapping",
    "filename": "src/test/java/org/apache/commons/compress/archivers/examples/ExpanderTest.java",
    "code": "\npackage org.apache.commons.compress.archivers.examples;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.SeekableByteChannel;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.apache.commons.compress.AbstractTestCase;\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveException;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.archivers.ArchiveOutputStream;\nimport org.apache.commons.compress.archivers.ArchiveStreamFactory;\nimport org.apache.commons.compress.archivers.StreamingNotSupportedException;\nimport org.apache.commons.compress.archivers.sevenz.SevenZFile;\nimport org.apache.commons.compress.archivers.sevenz.SevenZOutputFile;\nimport org.apache.commons.compress.archivers.zip.ZipFile;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.junit.Assert;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\n\npublic class ExpanderTest extends AbstractTestCase {\n\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    private File archive;\n\n    @Test\n    public void sevenZTwoFileVersion() throws IOException, ArchiveException {\n        setup7z();\n        new Expander().expand(\"7z\", archive, resultDir);\n        verifyTargetDir();\n    }\n\n    @Test\n    public void sevenZTwoFileVersionWithAutoDetection() throws IOException, ArchiveException {\n        setup7z();\n        new Expander().expand(archive, resultDir);\n        verifyTargetDir();\n    }\n\n    @Test(expected = StreamingNotSupportedException.class)\n    public void sevenZInputStreamVersion() throws IOException, ArchiveException {\n        setup7z();\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            new Expander().expand(\"7z\", i, resultDir);\n        }\n    }\n\n    @Test(expected = StreamingNotSupportedException.class)\n    public void sevenZInputStreamVersionWithAutoDetection() throws IOException, ArchiveException {\n        setup7z();\n        try (InputStream i = new BufferedInputStream(Files.newInputStream(archive.toPath()))) {\n            new Expander().expand(i, resultDir);\n        }\n    }\n\n    @Test\n    public void sevenZChannelVersion() throws IOException, ArchiveException {\n        setup7z();\n        try (SeekableByteChannel c = FileChannel.open(archive.toPath(), StandardOpenOption.READ)) {\n            new Expander().expand(\"7z\", c, resultDir);\n        }\n        verifyTargetDir();\n    }\n\n    @Test\n    public void sevenZFileVersion() throws IOException, ArchiveException {\n        setup7z();\n        try (SevenZFile f = new SevenZFile(archive)) {\n            new Expander().expand(f, resultDir);\n        }\n        verifyTargetDir();\n    }\n\n    @Test\n    public void zipFileVersion() throws IOException, ArchiveException {\n        setupZip();\n        try (ZipFile f = new ZipFile(archive)) {\n            new Expander().expand(f, resultDir);\n        }\n        verifyTargetDir();\n    }\n\n    @Test\n    public void fileCantEscapeViaAbsolutePath() throws IOException, ArchiveException {\n        setupZip(\"/tmp/foo\");\n        try (ZipFile f = new ZipFile(archive)) {\n            new Expander().expand(f, resultDir);\n        }\n        assertHelloWorld(\"tmp/foo\", \"1\");\n    }\n\n    @Test\n    public void fileCantEscapeDoubleDotPath() throws IOException, ArchiveException {\n        thrown.expect(IOException.class);\n        thrown.expectMessage(\"expanding ../foo would create file outside of\");\n        setupZip(\"../foo\");\n        try (ZipFile f = new ZipFile(archive)) {\n            new Expander().expand(f, resultDir);\n        }\n    }\n\n    private void setup7z() throws IOException, ArchiveException {\n        archive = new File(dir, \"test.7z\");\n        File dummy = new File(dir, \"x\");\n        try (OutputStream o = Files.newOutputStream(dummy.toPath())) {\n            o.write(new byte[14]);\n        }\n        try (SevenZOutputFile aos = new SevenZOutputFile(archive)) {\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a/b\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a/b/c\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dummy, \"a/b/d.txt\"));\n            aos.write(\"Hello, world 1\".getBytes(StandardCharsets.UTF_8));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dummy, \"a/b/c/e.txt\"));\n            aos.write(\"Hello, world 2\".getBytes(StandardCharsets.UTF_8));\n            aos.closeArchiveEntry();\n            aos.finish();\n        }\n    }\n\n    private void setupZip() throws IOException, ArchiveException {\n        archive = new File(dir, \"test.zip\");\n        File dummy = new File(dir, \"x\");\n        try (OutputStream o = Files.newOutputStream(dummy.toPath())) {\n            o.write(new byte[14]);\n        }\n        try (ArchiveOutputStream aos = new ArchiveStreamFactory()\n             .createArchiveOutputStream(\"zip\", Files.newOutputStream(archive.toPath()))) {\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a/b\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dir, \"a/b/c\"));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dummy, \"a/b/d.txt\"));\n            aos.write(\"Hello, world 1\".getBytes(StandardCharsets.UTF_8));\n            aos.closeArchiveEntry();\n            aos.putArchiveEntry(aos.createArchiveEntry(dummy, \"a/b/c/e.txt\"));\n            aos.write(\"Hello, world 2\".getBytes(StandardCharsets.UTF_8));\n            aos.closeArchiveEntry();\n            aos.finish();\n        }\n    }\n\n    private void setupZip(String entry) throws IOException, ArchiveException {\n        archive = new File(dir, \"test.zip\");\n        File dummy = new File(dir, \"x\");\n        try (OutputStream o = Files.newOutputStream(dummy.toPath())) {\n            o.write(new byte[14]);\n        }\n        try (ArchiveOutputStream aos = new ArchiveStreamFactory()\n             .createArchiveOutputStream(\"zip\", Files.newOutputStream(archive.toPath()))) {\n            aos.putArchiveEntry(aos.createArchiveEntry(dummy, entry));\n            aos.write(\"Hello, world 1\".getBytes(StandardCharsets.UTF_8));\n            aos.closeArchiveEntry();\n            aos.finish();\n        }\n    }\n\n    private void verifyTargetDir() throws IOException {\n        Assert.assertTrue(\"a has not been created\", new File(resultDir, \"a\").isDirectory());\n        Assert.assertTrue(\"a/b has not been created\", new File(resultDir, \"a/b\").isDirectory());\n        Assert.assertTrue(\"a/b/c has not been created\", new File(resultDir, \"a/b/c\").isDirectory());\n        assertHelloWorld(\"a/b/d.txt\", \"1\");\n        assertHelloWorld(\"a/b/c/e.txt\", \"2\");\n    }\n\n    private void assertHelloWorld(String fileName, String suffix) throws IOException {\n        Assert.assertTrue(fileName + \" does not exist\", new File(resultDir, fileName).isFile());\n        byte[] expected = (\"Hello, world \" + suffix).getBytes(StandardCharsets.UTF_8);\n        try (InputStream is = Files.newInputStream(new File(resultDir, fileName).toPath())) {\n            byte[] actual = IOUtils.toByteArray(is);\n            Assert.assertArrayEquals(expected, actual);\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 5,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/2a2f1dc48e22a34ddb72321a4db211da91aa933b",
    "cve_id": "CVE-2018-1324",
    "cwe_id": "CWE-835",
    "filename": "src/main/java/org/apache/commons/compress/archivers/zip/X0017_StrongEncryptionHeader.java",
    "code": "\npackage org.apache.commons.compress.archivers.zip;\n\n\npublic class X0017_StrongEncryptionHeader extends PKWareExtraHeader {\n\n    public X0017_StrongEncryptionHeader() {\n        super(new ZipShort(0x0017));\n    }\n\n    private int format; \n    private EncryptionAlgorithm algId;\n    private int bitlen; \n    private int flags; \n    private long rcount;\n    private HashAlgorithm hashAlg;\n    private int hashSize;\n\n    \n    private byte ivData[];\n    private byte erdData[];\n\n    \n    private byte recipientKeyHash[];\n    private byte keyBlob[];\n\n    \n    private byte vData[];\n    private byte vCRC32[];\n\n    \n    public long getRecordCount() {\n        return rcount;\n    }\n\n    \n    public HashAlgorithm getHashAlgorithm() {\n        return hashAlg;\n    }\n\n    \n    public EncryptionAlgorithm getEncryptionAlgorithm() {\n        return algId;\n    }\n\n    \n    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            \n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    \n                }\n            }\n        }\n    }\n\n    \n    public void parseFileFormat(final byte[] data, final int offset, final int length) {\n        final int ivSize = ZipShort.getValue(data, offset);\n        this.ivData = new byte[ivSize];\n        System.arraycopy(data, offset + 4, this.ivData, 0, ivSize);\n\n        this.format = ZipShort.getValue(data, offset + ivSize + 6);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 8));\n        this.bitlen = ZipShort.getValue(data, offset + ivSize + 10);\n        this.flags = ZipShort.getValue(data, offset + ivSize + 12);\n\n        final int erdSize = ZipShort.getValue(data, offset + ivSize + 14);\n        this.erdData = new byte[erdSize];\n        System.arraycopy(data, offset + ivSize + 16, this.erdData, 0, erdSize);\n\n        this.rcount = ZipLong.getValue(data, offset + ivSize + 16 + erdSize);\n        System.out.println(\"rcount: \" + rcount);\n        if (rcount == 0) {\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 20 + erdSize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize , this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + vSize - 4, vCRC32, 0, 4);\n        } else {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + ivSize + 20 + erdSize));\n            this.hashSize = ZipShort.getValue(data, offset + ivSize + 22 + erdSize);\n            final int resize = ZipShort.getValue(data, offset + ivSize + 24 + erdSize);\n            this.recipientKeyHash = new byte[this.hashSize];\n            this.keyBlob = new byte[resize - this.hashSize];\n            System.arraycopy(data, offset + ivSize + 24 + erdSize, this.recipientKeyHash, 0, this.hashSize);\n            System.arraycopy(data, offset + ivSize + 24 + erdSize + this.hashSize, this.keyBlob, 0, resize - this.hashSize);\n\n            final int vSize = ZipShort.getValue(data, offset + ivSize + 26 + erdSize + resize);\n            this.vData = new byte[vSize - 4];\n            this.vCRC32 = new byte[4];\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize, this.vData, 0, vSize - 4);\n            System.arraycopy(data, offset + ivSize + 22 + erdSize + resize + vSize - 4, vCRC32, 0, 4);\n        }\n\n        \n    }\n\n    @Override\n    public void parseFromLocalFileData(final byte[] data, final int offset, final int length) {\n        super.parseFromLocalFileData(data, offset, length);\n        parseFileFormat(data, offset, length);\n    }\n\n    @Override\n    public void parseFromCentralDirectoryData(final byte[] data, final int offset, final int length) {\n        super.parseFromCentralDirectoryData(data, offset, length);\n        parseCentralDirectoryFormat(data, offset, length);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 6,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/a41ce6892cb0590b2e658704434ac0dbcb6834c8",
    "cve_id": "CVE-2018-11771",
    "cwe_id": "CWE-835",
    "filename": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
    "code": "\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.math.BigInteger;\nimport java.nio.ByteBuffer;\nimport java.util.Arrays;\nimport java.util.zip.CRC32;\nimport java.util.zip.DataFormatException;\nimport java.util.zip.Inflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.archivers.ArchiveInputStream;\nimport org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream;\nimport org.apache.commons.compress.compressors.deflate64.Deflate64CompressorInputStream;\nimport org.apache.commons.compress.utils.ArchiveUtils;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.apache.commons.compress.utils.InputStreamStatistics;\n\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.DWORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.SHORT;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.WORD;\nimport static org.apache.commons.compress.archivers.zip.ZipConstants.ZIP64_MAGIC;\n\n\npublic class ZipArchiveInputStream extends ArchiveInputStream implements InputStreamStatistics {\n\n    \n    private final ZipEncoding zipEncoding;\n\n    \n    final String encoding;\n\n    \n    private final boolean useUnicodeExtraFields;\n\n    \n    private final InputStream in;\n\n    \n    private final Inflater inf = new Inflater(true);\n\n    \n    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n\n    \n    private CurrentEntry current = null;\n\n    \n    private boolean closed = false;\n\n    \n    private boolean hitCentralDirectory = false;\n\n    \n    private ByteArrayInputStream lastStoredEntry = null;\n\n    \n    private boolean allowStoredEntriesWithDataDescriptor = false;\n\n    \n    private long uncompressedCount = 0;\n\n    private static final int LFH_LEN = 30;\n    \n\n    private static final int CFH_LEN = 46;\n    \n\n    private static final long TWO_EXP_32 = ZIP64_MAGIC + 1;\n\n    \n    private final byte[] lfhBuf = new byte[LFH_LEN];\n    private final byte[] skipBuf = new byte[1024];\n    private final byte[] shortBuf = new byte[SHORT];\n    private final byte[] wordBuf = new byte[WORD];\n    private final byte[] twoDwordBuf = new byte[2 * DWORD];\n\n    private int entriesRead = 0;\n\n    \n    public ZipArchiveInputStream(final InputStream inputStream) {\n        this(inputStream, ZipEncodingHelper.UTF8);\n    }\n\n    \n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding) {\n        this(inputStream, encoding, true);\n    }\n\n    \n    public ZipArchiveInputStream(final InputStream inputStream, final String encoding, final boolean useUnicodeExtraFields) {\n        this(inputStream, encoding, useUnicodeExtraFields, false);\n    }\n\n    \n    public ZipArchiveInputStream(final InputStream inputStream,\n                                 final String encoding,\n                                 final boolean useUnicodeExtraFields,\n                                 final boolean allowStoredEntriesWithDataDescriptor) {\n        this.encoding = encoding;\n        zipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\n        this.useUnicodeExtraFields = useUnicodeExtraFields;\n        in = new PushbackInputStream(inputStream, buf.capacity());\n        this.allowStoredEntriesWithDataDescriptor =\n            allowStoredEntriesWithDataDescriptor;\n        \n        buf.limit(0);\n    }\n\n    public ZipArchiveEntry getNextZipEntry() throws IOException {\n        uncompressedCount = 0;\n\n        boolean firstEntry = true;\n        if (closed || hitCentralDirectory) {\n            return null;\n        }\n        if (current != null) {\n            closeEntry();\n            firstEntry = false;\n        }\n\n        long currentHeaderOffset = getBytesRead();\n        try {\n            if (firstEntry) {\n                \n                \n                \n                \n                readFirstLocalFileHeader(lfhBuf);\n            } else {\n                readFully(lfhBuf);\n            }\n        } catch (final EOFException e) {\n            return null;\n        }\n\n        final ZipLong sig = new ZipLong(lfhBuf);\n        if (!sig.equals(ZipLong.LFH_SIG)) {\n            if (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG) || isApkSigningBlock(lfhBuf)) {\n                hitCentralDirectory = true;\n                skipRemainderOfArchive();\n                return null;\n            }\n            throw new ZipException(String.format(\"Unexpected record signature: 0X%X\", sig.getValue()));\n        }\n\n        int off = WORD;\n        current = new CurrentEntry();\n\n        final int versionMadeBy = ZipShort.getValue(lfhBuf, off);\n        off += SHORT;\n        current.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\n        final GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(lfhBuf, off);\n        final boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\n        final ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\n        current.hasDataDescriptor = gpFlag.usesDataDescriptor();\n        current.entry.setGeneralPurposeBit(gpFlag);\n\n        off += SHORT;\n\n        current.entry.setMethod(ZipShort.getValue(lfhBuf, off));\n        off += SHORT;\n\n        final long time = ZipUtil.dosToJavaTime(ZipLong.getValue(lfhBuf, off));\n        current.entry.setTime(time);\n        off += WORD;\n\n        ZipLong size = null, cSize = null;\n        if (!current.hasDataDescriptor) {\n            current.entry.setCrc(ZipLong.getValue(lfhBuf, off));\n            off += WORD;\n\n            cSize = new ZipLong(lfhBuf, off);\n            off += WORD;\n\n            size = new ZipLong(lfhBuf, off);\n            off += WORD;\n        } else {\n            off += 3 * WORD;\n        }\n\n        final int fileNameLen = ZipShort.getValue(lfhBuf, off);\n\n        off += SHORT;\n\n        final int extraLen = ZipShort.getValue(lfhBuf, off);\n        off += SHORT; \n\n        final byte[] fileName = new byte[fileNameLen];\n        readFully(fileName);\n        current.entry.setName(entryEncoding.decode(fileName), fileName);\n        if (hasUTF8Flag) {\n            current.entry.setNameSource(ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n        }\n\n        final byte[] extraData = new byte[extraLen];\n        readFully(extraData);\n        current.entry.setExtra(extraData);\n\n        if (!hasUTF8Flag && useUnicodeExtraFields) {\n            ZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n        }\n\n        processZip64Extra(size, cSize);\n\n        current.entry.setLocalHeaderOffset(currentHeaderOffset);\n        current.entry.setDataOffset(getBytesRead());\n        current.entry.setStreamContiguous(true);\n\n        ZipMethod m = ZipMethod.getMethodByCode(current.entry.getMethod());\n        if (current.entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN) {\n            if (ZipUtil.canHandleEntryData(current.entry) && m != ZipMethod.STORED && m != ZipMethod.DEFLATED) {\n                InputStream bis = new BoundedInputStream(in, current.entry.getCompressedSize());\n                switch (m) {\n                case UNSHRINKING:\n                    current.in = new UnshrinkingInputStream(bis);\n                    break;\n                case IMPLODING:\n                    current.in = new ExplodingInputStream(\n                        current.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\n                        current.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\n                        bis);\n                    break;\n                case BZIP2:\n                    current.in = new BZip2CompressorInputStream(bis);\n                    break;\n                case ENHANCED_DEFLATED:\n                    current.in = new Deflate64CompressorInputStream(bis);\n                    break;\n                default:\n                    \n                    \n                    \n                    break;\n                }\n            }\n        } else if (m == ZipMethod.ENHANCED_DEFLATED) {\n            current.in = new Deflate64CompressorInputStream(in);\n        }\n\n        entriesRead++;\n        return current.entry;\n    }\n\n    \n    private void readFirstLocalFileHeader(final byte[] lfh) throws IOException {\n        readFully(lfh);\n        final ZipLong sig = new ZipLong(lfh);\n        if (sig.equals(ZipLong.DD_SIG)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n        }\n\n        if (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n            \n            \n            final byte[] missedLfhBytes = new byte[4];\n            readFully(missedLfhBytes);\n            System.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\n            System.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n        }\n    }\n\n    \n    private void processZip64Extra(final ZipLong size, final ZipLong cSize) {\n        final Zip64ExtendedInformationExtraField z64 =\n            (Zip64ExtendedInformationExtraField)\n            current.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\n        current.usesZip64 = z64 != null;\n        if (!current.hasDataDescriptor) {\n            if (z64 != null \n                    && (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\n                current.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\n                current.entry.setSize(z64.getSize().getLongValue());\n            } else {\n                current.entry.setCompressedSize(cSize.getValue());\n                current.entry.setSize(size.getValue());\n            }\n        }\n    }\n\n    @Override\n    public ArchiveEntry getNextEntry() throws IOException {\n        return getNextZipEntry();\n    }\n\n    \n    @Override\n    public boolean canReadEntryData(final ArchiveEntry ae) {\n        if (ae instanceof ZipArchiveEntry) {\n            final ZipArchiveEntry ze = (ZipArchiveEntry) ae;\n            return ZipUtil.canHandleEntryData(ze)\n                && supportsDataDescriptorFor(ze)\n                && supportsCompressedSizeFor(ze);\n        }\n        return false;\n    }\n\n    @Override\n    public int read(final byte[] buffer, final int offset, final int length) throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n\n        if (current == null) {\n            return -1;\n        }\n\n        \n        if (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n\n        ZipUtil.checkRequestedFeatures(current.entry);\n        if (!supportsDataDescriptorFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\n                    current.entry);\n        }\n        if (!supportsCompressedSizeFor(current.entry)) {\n            throw new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.UNKNOWN_COMPRESSED_SIZE,\n                    current.entry);\n        }\n\n        int read;\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            read = readStored(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            read = readDeflated(buffer, offset, length);\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n                || current.entry.getMethod() == ZipMethod.IMPLODING.getCode()\n                || current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n                || current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            read = current.in.read(buffer, offset, length);\n        } else {\n            throw new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\n                    current.entry);\n        }\n\n        if (read >= 0) {\n            current.crc.update(buffer, offset, read);\n            uncompressedCount += read;\n        }\n\n        return read;\n    }\n\n    \n    @Override\n    public long getCompressedCount() {\n        if (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\n            return current.bytesRead;\n        } else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\n            return getBytesInflated();\n        } else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\n            return ((UnshrinkingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\n            return ((ExplodingInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()) {\n            return ((Deflate64CompressorInputStream) current.in).getCompressedCount();\n        } else if (current.entry.getMethod() == ZipMethod.BZIP2.getCode()) {\n            return ((BZip2CompressorInputStream) current.in).getCompressedCount();\n        } else {\n            return -1;\n        }\n    }\n\n    \n    @Override\n    public long getUncompressedCount() {\n        return uncompressedCount;\n    }\n\n    \n    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            \n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }\n\n    \n    private int readDeflated(final byte[] buffer, final int offset, final int length) throws IOException {\n        final int read = readFromInflater(buffer, offset, length);\n        if (read <= 0) {\n            if (inf.finished()) {\n                return -1;\n            } else if (inf.needsDictionary()) {\n                throw new ZipException(\"This archive needs a preset dictionary\"\n                                       + \" which is not supported by Commons\"\n                                       + \" Compress.\");\n            } else if (read == -1) {\n                throw new IOException(\"Truncated ZIP file\");\n            }\n        }\n        return read;\n    }\n\n    \n    private int readFromInflater(final byte[] buffer, final int offset, final int length) throws IOException {\n        int read = 0;\n        do {\n            if (inf.needsInput()) {\n                final int l = fill();\n                if (l > 0) {\n                    current.bytesReadFromStream += buf.limit();\n                } else if (l == -1) {\n                    return -1;\n                } else {\n                    break;\n                }\n            }\n            try {\n                read = inf.inflate(buffer, offset, length);\n            } catch (final DataFormatException e) {\n                throw (IOException) new ZipException(e.getMessage()).initCause(e);\n            }\n        } while (read == 0 && inf.needsInput());\n        return read;\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (!closed) {\n            closed = true;\n            try {\n                in.close();\n            } finally {\n                inf.end();\n            }\n        }\n    }\n\n    \n    @Override\n    public long skip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return skipped;\n                }\n                skipped += x;\n            }\n            return skipped;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    public static boolean matches(final byte[] signature, final int length) {\n        if (length < ZipArchiveOutputStream.LFH_SIG.length) {\n            return false;\n        }\n\n        return checksig(signature, ZipArchiveOutputStream.LFH_SIG) \n            || checksig(signature, ZipArchiveOutputStream.EOCD_SIG) \n            || checksig(signature, ZipArchiveOutputStream.DD_SIG) \n            || checksig(signature, ZipLong.SINGLE_SEGMENT_SPLIT_MARKER.getBytes());\n    }\n\n    private static boolean checksig(final byte[] signature, final byte[] expected) {\n        for (int i = 0; i < expected.length; i++) {\n            if (signature[i] != expected[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private void closeEntry() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        if (current == null) {\n            return;\n        }\n\n        \n        if (currentEntryHasOutstandingBytes()) {\n            drainCurrentEntryData();\n        } else {\n            \n            skip(Long.MAX_VALUE); \n\n            final long inB = current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED\n                       ? getBytesInflated() : current.bytesRead;\n\n            \n            \n            final int diff = (int) (current.bytesReadFromStream - inB);\n\n            \n            if (diff > 0) {\n                pushback(buf.array(), buf.limit() - diff, diff);\n                current.bytesReadFromStream -= diff;\n            }\n\n            \n            if (currentEntryHasOutstandingBytes()) {\n                drainCurrentEntryData();\n            }\n        }\n\n        if (lastStoredEntry == null && current.hasDataDescriptor) {\n            readDataDescriptor();\n        }\n\n        inf.reset();\n        buf.clear().flip();\n        current = null;\n        lastStoredEntry = null;\n    }\n\n    \n    private boolean currentEntryHasOutstandingBytes() {\n        return current.bytesReadFromStream <= current.entry.getCompressedSize()\n                && !current.hasDataDescriptor;\n    }\n\n    \n    private void drainCurrentEntryData() throws IOException {\n        long remaining = current.entry.getCompressedSize() - current.bytesReadFromStream;\n        while (remaining > 0) {\n            final long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n            if (n < 0) {\n                throw new EOFException(\"Truncated ZIP entry: \"\n                                       + ArchiveUtils.sanitize(current.entry.getName()));\n            }\n            count(n);\n            remaining -= n;\n        }\n    }\n\n    \n    private long getBytesInflated() {\n        long inB = inf.getBytesRead();\n        if (current.bytesReadFromStream >= TWO_EXP_32) {\n            while (inB + TWO_EXP_32 <= current.bytesReadFromStream) {\n                inB += TWO_EXP_32;\n            }\n        }\n        return inB;\n    }\n\n    private int fill() throws IOException {\n        if (closed) {\n            throw new IOException(\"The stream is closed\");\n        }\n        final int length = in.read(buf.array());\n        if (length > 0) {\n            buf.limit(length);\n            count(buf.limit());\n            inf.setInput(buf.array(), 0, buf.limit());\n        }\n        return length;\n    }\n\n    private void readFully(final byte[] b) throws IOException {\n        readFully(b, 0);\n    }\n\n    private void readFully(final byte[] b, final int off) throws IOException {\n        final int len = b.length - off;\n        final int count = IOUtils.readFully(in, b, off, len);\n        count(count);\n        if (count < len) {\n            throw new EOFException();\n        }\n    }\n\n    private void readDataDescriptor() throws IOException {\n        readFully(wordBuf);\n        ZipLong val = new ZipLong(wordBuf);\n        if (ZipLong.DD_SIG.equals(val)) {\n            \n            readFully(wordBuf);\n            val = new ZipLong(wordBuf);\n        }\n        current.entry.setCrc(val.getValue());\n\n        \n        \n        \n        \n        \n\n        \n        \n        \n        \n        \n        readFully(twoDwordBuf);\n        final ZipLong potentialSig = new ZipLong(twoDwordBuf, DWORD);\n        if (potentialSig.equals(ZipLong.CFH_SIG) || potentialSig.equals(ZipLong.LFH_SIG)) {\n            pushback(twoDwordBuf, DWORD, DWORD);\n            current.entry.setCompressedSize(ZipLong.getValue(twoDwordBuf));\n            current.entry.setSize(ZipLong.getValue(twoDwordBuf, WORD));\n        } else {\n            current.entry.setCompressedSize(ZipEightByteInteger.getLongValue(twoDwordBuf));\n            current.entry.setSize(ZipEightByteInteger.getLongValue(twoDwordBuf, DWORD));\n        }\n    }\n\n    \n    private boolean supportsDataDescriptorFor(final ZipArchiveEntry entry) {\n        return !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n                || (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n                || entry.getMethod() == ZipEntry.DEFLATED\n                || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode();\n    }\n\n    \n    private boolean supportsCompressedSizeFor(final ZipArchiveEntry entry) {\n        return entry.getCompressedSize() != ArchiveEntry.SIZE_UNKNOWN\n            || entry.getMethod() == ZipEntry.DEFLATED\n            || entry.getMethod() == ZipMethod.ENHANCED_DEFLATED.getCode()\n            || (entry.getGeneralPurposeBit().usesDataDescriptor()\n                && allowStoredEntriesWithDataDescriptor\n                && entry.getMethod() == ZipEntry.STORED);\n    }\n\n    \n    private void readStoredEntry() throws IOException {\n        final ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        int off = 0;\n        boolean done = false;\n\n        \n        final int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n\n        while (!done) {\n            final int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n            if (r <= 0) {\n                \n                \n                throw new IOException(\"Truncated ZIP file\");\n            }\n            if (r + off < 4) {\n                \n                off += r;\n                continue;\n            }\n\n            done = bufferContainsSignature(bos, off, r, ddLen);\n            if (!done) {\n                off = cacheBytesRead(bos, off, r, ddLen);\n            }\n        }\n\n        final byte[] b = bos.toByteArray();\n        lastStoredEntry = new ByteArrayInputStream(b);\n    }\n\n    private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\n    private static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\n    private static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n    \n    private boolean bufferContainsSignature(final ByteArrayOutputStream bos, final int offset, final int lastRead, final int expectedDDLen)\n            throws IOException {\n\n        boolean done = false;\n        int readTooMuch = 0;\n        for (int i = 0; !done && i < offset + lastRead - 4; i++) {\n            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                    \n                    readTooMuch = offset + lastRead - i - expectedDDLen;\n                    done = true;\n                }\n                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                    \n                    readTooMuch = offset + lastRead - i;\n                    done = true;\n                }\n                if (done) {\n                    \n                    \n                    \n                    \n                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n                    bos.write(buf.array(), 0, i);\n                    readDataDescriptor();\n                }\n            }\n        }\n        return done;\n    }\n\n    \n    private int cacheBytesRead(final ByteArrayOutputStream bos, int offset, final int lastRead, final int expecteDDLen) {\n        final int cacheable = offset + lastRead - expecteDDLen - 3;\n        if (cacheable > 0) {\n            bos.write(buf.array(), 0, cacheable);\n            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n            offset = expecteDDLen + 3;\n        } else {\n            offset += lastRead;\n        }\n        return offset;\n    }\n\n    private void pushback(final byte[] buf, final int offset, final int length) throws IOException {\n        ((PushbackInputStream) in).unread(buf, offset, length);\n        pushedBackBytes(length);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    \n    private void skipRemainderOfArchive() throws IOException {\n        \n        \n        \n        realSkip((long) entriesRead * CFH_LEN - LFH_LEN);\n        findEocdRecord();\n        realSkip((long) ZipFile.MIN_EOCD_SIZE - WORD  - SHORT );\n        readFully(shortBuf);\n        \n        realSkip(ZipShort.getValue(shortBuf));\n    }\n\n    \n    private void findEocdRecord() throws IOException {\n        int currentByte = -1;\n        boolean skipReadCall = false;\n        while (skipReadCall || (currentByte = readOneByte()) > -1) {\n            skipReadCall = false;\n            if (!isFirstByteOfEocdSig(currentByte)) {\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[1]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte != ZipArchiveOutputStream.EOCD_SIG[2]) {\n                if (currentByte == -1) {\n                    break;\n                }\n                skipReadCall = isFirstByteOfEocdSig(currentByte);\n                continue;\n            }\n            currentByte = readOneByte();\n            if (currentByte == -1\n                || currentByte == ZipArchiveOutputStream.EOCD_SIG[3]) {\n                break;\n            }\n            skipReadCall = isFirstByteOfEocdSig(currentByte);\n        }\n    }\n\n    \n    private void realSkip(final long value) throws IOException {\n        if (value >= 0) {\n            long skipped = 0;\n            while (skipped < value) {\n                final long rem = value - skipped;\n                final int x = in.read(skipBuf, 0, (int) (skipBuf.length > rem ? rem : skipBuf.length));\n                if (x == -1) {\n                    return;\n                }\n                count(x);\n                skipped += x;\n            }\n            return;\n        }\n        throw new IllegalArgumentException();\n    }\n\n    \n    private int readOneByte() throws IOException {\n        final int b = in.read();\n        if (b != -1) {\n            count(1);\n        }\n        return b;\n    }\n\n    private boolean isFirstByteOfEocdSig(final int b) {\n        return b == ZipArchiveOutputStream.EOCD_SIG[0];\n    }\n\n    private static final byte[] APK_SIGNING_BLOCK_MAGIC = new byte[] {\n        'A', 'P', 'K', ' ', 'S', 'i', 'g', ' ', 'B', 'l', 'o', 'c', 'k', ' ', '4', '2',\n    };\n    private static final BigInteger LONG_MAX = BigInteger.valueOf(Long.MAX_VALUE);\n\n    \n    private boolean isApkSigningBlock(byte[] suspectLocalFileHeader) throws IOException {\n        \n        BigInteger len = ZipEightByteInteger.getValue(suspectLocalFileHeader);\n        \n        \n        BigInteger toSkip = len.add(BigInteger.valueOf(DWORD - suspectLocalFileHeader.length\n            - APK_SIGNING_BLOCK_MAGIC.length));\n        byte[] magic = new byte[APK_SIGNING_BLOCK_MAGIC.length];\n\n        try {\n            if (toSkip.signum() < 0) {\n                \n                int off = suspectLocalFileHeader.length + toSkip.intValue();\n                \n                if (off < DWORD) {\n                    return false;\n                }\n                int bytesInBuffer = Math.abs(toSkip.intValue());\n                System.arraycopy(suspectLocalFileHeader, off, magic, 0, Math.min(bytesInBuffer, magic.length));\n                if (bytesInBuffer < magic.length) {\n                    readFully(magic, bytesInBuffer);\n                }\n            } else {\n                while (toSkip.compareTo(LONG_MAX) > 0) {\n                    realSkip(Long.MAX_VALUE);\n                    toSkip = toSkip.add(LONG_MAX.negate());\n                }\n                realSkip(toSkip.longValue());\n                readFully(magic);\n            }\n        } catch (EOFException ex) {\n            \n            return false;\n        }\n        return Arrays.equals(magic, APK_SIGNING_BLOCK_MAGIC);\n    }\n\n    \n    private static final class CurrentEntry {\n\n        \n        private final ZipArchiveEntry entry = new ZipArchiveEntry();\n\n        \n        private boolean hasDataDescriptor;\n\n        \n        private boolean usesZip64;\n\n        \n        private long bytesRead;\n\n        \n        private long bytesReadFromStream;\n\n        \n        private final CRC32 crc = new CRC32();\n\n        \n        private InputStream in;\n    }\n\n    \n    private class BoundedInputStream extends InputStream {\n\n        \n        private final InputStream in;\n\n        \n        private final long max;\n\n        \n        private long pos = 0;\n\n        \n        public BoundedInputStream(final InputStream in, final long size) {\n            this.max = size;\n            this.in = in;\n        }\n\n        @Override\n        public int read() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final int result = in.read();\n            pos++;\n            count(1);\n            current.bytesReadFromStream++;\n            return result;\n        }\n\n        @Override\n        public int read(final byte[] b) throws IOException {\n            return this.read(b, 0, b.length);\n        }\n\n        @Override\n        public int read(final byte[] b, final int off, final int len) throws IOException {\n            if (max >= 0 && pos >= max) {\n                return -1;\n            }\n            final long maxRead = max >= 0 ? Math.min(len, max - pos) : len;\n            final int bytesRead = in.read(b, off, (int) maxRead);\n\n            if (bytesRead == -1) {\n                return -1;\n            }\n\n            pos += bytesRead;\n            count(bytesRead);\n            current.bytesReadFromStream += bytesRead;\n            return bytesRead;\n        }\n\n        @Override\n        public long skip(final long n) throws IOException {\n            final long toSkip = max >= 0 ? Math.min(n, max - pos) : n;\n            final long skippedBytes = IOUtils.skip(in, toSkip);\n            pos += skippedBytes;\n            return skippedBytes;\n        }\n\n        @Override\n        public int available() throws IOException {\n            if (max >= 0 && pos >= max) {\n                return 0;\n            }\n            return in.available();\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 6,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/a41ce6892cb0590b2e658704434ac0dbcb6834c8",
    "cve_id": "CVE-2018-11771",
    "cwe_id": "CWE-835",
    "filename": "src/test/java/org/apache/commons/compress/archivers/zip/Maven221MultiVolumeTest.java",
    "code": "\n\npackage org.apache.commons.compress.archivers.zip;\n\nimport static org.apache.commons.compress.AbstractTestCase.getFile;\nimport static org.junit.Assert.*;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.junit.Test;\n\n\npublic class Maven221MultiVolumeTest {\n\n    private static final String [] ENTRIES = new String [] {\n        \"apache-maven-2.2.1/\",\n        \"apache-maven-2.2.1/LICENSE.txt\",\n        \"apache-maven-2.2.1/NOTICE.txt\",\n        \"apache-maven-2.2.1/README.txt\",\n        \"apache-maven-2.2.1/bin/\",\n        \"apache-maven-2.2.1/bin/m2.conf\",\n        \"apache-maven-2.2.1/bin/mvn\",\n        \"apache-maven-2.2.1/bin/mvn.bat\",\n        \"apache-maven-2.2.1/bin/mvnDebug\",\n        \"apache-maven-2.2.1/bin/mvnDebug.bat\",\n        \"apache-maven-2.2.1/boot/\",\n        \"apache-maven-2.2.1/boot/classworlds-1.1.jar\",\n        \"apache-maven-2.2.1/conf/\",\n        \"apache-maven-2.2.1/conf/settings.xml\",\n        \"apache-maven-2.2.1/lib/\"\n    };\n\n    private static final String LAST_ENTRY_NAME =\n        \"apache-maven-2.2.1/lib/maven-2.2.1-uber.jar\";\n\n    @Test\n    public void testRead7ZipMultiVolumeArchiveForStream() throws IOException {\n\n        final FileInputStream archive =\n            new FileInputStream(getFile(\"apache-maven-2.2.1.zip.001\"));\n        ZipArchiveInputStream zi = null;\n        try {\n            zi = new ZipArchiveInputStream(archive,null,false);\n\n            \n            \n            for (final String element : ENTRIES) {\n                assertEquals(element, zi.getNextEntry().getName());\n            }\n\n            \n            final ArchiveEntry lastEntry = zi.getNextEntry();\n            assertEquals(LAST_ENTRY_NAME, lastEntry.getName());\n            final byte [] buffer = new byte [4096];\n\n            \n            \n            \n            \n            try {\n                while (zi.read(buffer) > 0) { }\n                fail(\"shouldn't be able to read from truncated entry\");\n            } catch (final IOException e) {\n                assertEquals(\"Truncated ZIP file\", e.getMessage());\n            }\n\n            \n            \n            try {\n                zi.getNextEntry();\n                fail(\"shouldn't be able to read another entry from truncated\"\n                     + \" file\");\n            } catch (final IOException e) {\n                \n            }\n        } finally {\n            if (zi != null) {\n                zi.close();\n            }\n        }\n    }\n\n    @Test(expected=IOException.class)\n    public void testRead7ZipMultiVolumeArchiveForFile() throws IOException {\n        final File file = getFile(\"apache-maven-2.2.1.zip.001\");\n        ZipFile zf = new ZipFile(file);\n        zf.close();\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 6,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/a41ce6892cb0590b2e658704434ac0dbcb6834c8",
    "cve_id": "CVE-2018-11771",
    "cwe_id": "CWE-835",
    "filename": "src/test/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStreamTest.java",
    "code": "\n\npackage org.apache.commons.compress.archivers.zip;\n\nimport static org.apache.commons.compress.AbstractTestCase.getFile;\nimport static org.junit.Assert.assertArrayEquals;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.BufferedInputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.zip.ZipException;\n\nimport org.apache.commons.compress.archivers.ArchiveEntry;\nimport org.apache.commons.compress.utils.IOUtils;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class ZipArchiveInputStreamTest {\n\n    \n    @Test\n    public void winzipBackSlashWorkaround() throws Exception {\n        ZipArchiveInputStream in = null;\n        try {\n            in = new ZipArchiveInputStream(new FileInputStream(getFile(\"test-winzip.zip\")));\n            ZipArchiveEntry zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            zae = in.getNextZipEntry();\n            assertEquals(\"\\u00e4/\", zae.getName());\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    \n    @Test\n    public void properUseOfInflater() throws Exception {\n        ZipFile zf = null;\n        ZipArchiveInputStream in = null;\n        try {\n            zf = new ZipFile(getFile(\"COMPRESS-189.zip\"));\n            final ZipArchiveEntry zae = zf.getEntry(\"USD0558682-20080101.ZIP\");\n            in = new ZipArchiveInputStream(new BufferedInputStream(zf.getInputStream(zae)));\n            ZipArchiveEntry innerEntry;\n            while ((innerEntry = in.getNextZipEntry()) != null) {\n                if (innerEntry.getName().endsWith(\"XML\")) {\n                    assertTrue(0 < in.read());\n                }\n            }\n        } finally {\n            if (zf != null) {\n                zf.close();\n            }\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    @Test\n    public void shouldConsumeArchiveCompletely() throws Exception {\n        final InputStream is = ZipArchiveInputStreamTest.class\n            .getResourceAsStream(\"/archive_with_trailer.zip\");\n        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n        while (zip.getNextZipEntry() != null) {\n            \n        }\n        final byte[] expected = new byte[] {\n            'H', 'e', 'l', 'l', 'o', ',', ' ', 'w', 'o', 'r', 'l', 'd', '!', '\\n'\n        };\n        final byte[] actual = new byte[expected.length];\n        is.read(actual);\n        assertArrayEquals(expected, actual);\n        zip.close();\n    }\n\n    \n    @Test\n    public void shouldReadNestedZip() throws IOException {\n        ZipArchiveInputStream in = null;\n        try {\n            in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-219.zip\")));\n            extractZipInputStream(in);\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n\n    private void extractZipInputStream(final ZipArchiveInputStream in)\n        throws IOException {\n        ZipArchiveEntry zae = in.getNextZipEntry();\n        while (zae != null) {\n            if (zae.getName().endsWith(\".zip\")) {\n                extractZipInputStream(new ZipArchiveInputStream(in));\n            }\n            zae = in.getNextZipEntry();\n        }\n    }\n\n    @Test\n    public void testUnshrinkEntry() throws Exception {\n        final ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"SHRUNK.ZIP\")));\n\n        ZipArchiveEntry entry = in.getNextZipEntry();\n        assertEquals(\"method\", ZipMethod.UNSHRINKING.getCode(), entry.getMethod());\n        assertTrue(in.canReadEntryData(entry));\n\n        FileInputStream original = new FileInputStream(getFile(\"test1.xml\"));\n        try {\n            assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(in));\n        } finally {\n            original.close();\n        }\n\n        entry = in.getNextZipEntry();\n        assertEquals(\"method\", ZipMethod.UNSHRINKING.getCode(), entry.getMethod());\n        assertTrue(in.canReadEntryData(entry));\n\n        original = new FileInputStream(getFile(\"test2.xml\"));\n        try {\n            assertArrayEquals(IOUtils.toByteArray(original), IOUtils.toByteArray(in));\n        } finally {\n            original.close();\n        }\n    }\n\n\n    \n    @Test\n    public void testReadingOfFirstStoredEntry() throws Exception {\n\n        try (ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")))) {\n            final ZipArchiveEntry ze = in.getNextZipEntry();\n            assertEquals(5, ze.getSize());\n            assertArrayEquals(new byte[] { 'd', 'a', 't', 'a', '\\n' },\n                    IOUtils.toByteArray(in));\n        }\n    }\n\n    \n    @Test\n    public void testMessageWithCorruptFileName() throws Exception {\n        try (ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-351.zip\")))) {\n            ZipArchiveEntry ze = in.getNextZipEntry();\n            while (ze != null) {\n                ze = in.getNextZipEntry();\n            }\n            fail(\"expected EOFException\");\n        } catch (final EOFException ex) {\n            final String m = ex.getMessage();\n            assertTrue(m.startsWith(\"Truncated ZIP entry: ?2016\")); \n        }\n    }\n\n    @Test\n    public void testUnzipBZip2CompressedEntry() throws Exception {\n\n        try (ZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"bzip2-zip.zip\")))) {\n            final ZipArchiveEntry ze = in.getNextZipEntry();\n            assertEquals(42, ze.getSize());\n            final byte[] expected = new byte[42];\n            Arrays.fill(expected, (byte) 'a');\n            assertArrayEquals(expected, IOUtils.toByteArray(in));\n        }\n    }\n\n    \n    @Test\n    public void readDeflate64CompressedStream() throws Exception {\n        final File input = getFile(\"COMPRESS-380/COMPRESS-380-input\");\n        final File archive = getFile(\"COMPRESS-380/COMPRESS-380.zip\");\n        try (FileInputStream in = new FileInputStream(input);\n             ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(archive))) {\n            byte[] orig = IOUtils.toByteArray(in);\n            ZipArchiveEntry e = zin.getNextZipEntry();\n            byte[] fromZip = IOUtils.toByteArray(zin);\n            assertArrayEquals(orig, fromZip);\n        }\n    }\n\n    @Test\n    public void readDeflate64CompressedStreamWithDataDescriptor() throws Exception {\n        \n        final File archive = getFile(\"COMPRESS-380/COMPRESS-380-dd.zip\");\n        try (ZipArchiveInputStream zin = new ZipArchiveInputStream(new FileInputStream(archive))) {\n            ZipArchiveEntry e = zin.getNextZipEntry();\n            assertEquals(-1, e.getSize());\n            assertEquals(ZipMethod.ENHANCED_DEFLATED.getCode(), e.getMethod());\n            byte[] fromZip = IOUtils.toByteArray(zin);\n            byte[] expected = new byte[] {\n                'M', 'a', 'n', 'i', 'f', 'e', 's', 't', '-', 'V', 'e', 'r', 's', 'i', 'o', 'n', ':', ' ', '1', '.', '0',\n                '\\r', '\\n', '\\r', '\\n'\n            };\n            assertArrayEquals(expected, fromZip);\n            zin.getNextZipEntry();\n            assertEquals(25, e.getSize());\n        }\n    }\n\n    \n    @Test\n    public void testWithBytesAfterData() throws Exception {\n        final int expectedNumEntries = 2;\n        final InputStream is = ZipArchiveInputStreamTest.class\n                .getResourceAsStream(\"/archive_with_bytes_after_data.zip\");\n        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n\n        try {\n            int actualNumEntries = 0;\n            ZipArchiveEntry zae = zip.getNextZipEntry();\n            while (zae != null) {\n                actualNumEntries++;\n                readEntry(zip, zae);\n                zae = zip.getNextZipEntry();\n            }\n            assertEquals(expectedNumEntries, actualNumEntries);\n        } finally {\n            zip.close();\n        }\n    }\n\n    \n    @Test\n    public void testThrowOnInvalidEntry() throws Exception {\n        final InputStream is = ZipArchiveInputStreamTest.class\n                .getResourceAsStream(\"/invalid-zip.zip\");\n        final ZipArchiveInputStream zip = new ZipArchiveInputStream(is);\n\n        try {\n            zip.getNextZipEntry();\n            fail(\"IOException expected\");\n        } catch (ZipException expected) {\n            assertTrue(expected.getMessage().contains(\"Unexpected record signature\"));\n        } finally {\n            zip.close();\n        }\n    }\n\n    \n    @Test\n    public void testOffsets() throws Exception {\n        \n        try (InputStream archiveStream = ZipArchiveInputStream.class.getResourceAsStream(\"/mixed.zip\");\n             ZipArchiveInputStream zipStream =  new ZipArchiveInputStream((archiveStream))\n        ) {\n            ZipArchiveEntry inflatedEntry = zipStream.getNextZipEntry();\n            Assert.assertEquals(\"inflated.txt\", inflatedEntry.getName());\n            Assert.assertEquals(0x0000, inflatedEntry.getLocalHeaderOffset());\n            Assert.assertEquals(0x0046, inflatedEntry.getDataOffset());\n            ZipArchiveEntry storedEntry = zipStream.getNextZipEntry();\n            Assert.assertEquals(\"stored.txt\", storedEntry.getName());\n            Assert.assertEquals(0x5892, storedEntry.getLocalHeaderOffset());\n            Assert.assertEquals(0x58d6, storedEntry.getDataOffset());\n            Assert.assertNull(zipStream.getNextZipEntry());\n        }\n    }\n\n    @Test\n    public void nameSourceDefaultsToName() throws Exception {\n        nameSource(\"bla.zip\", \"test1.xml\", ZipArchiveEntry.NameSource.NAME);\n    }\n\n    @Test\n    public void nameSourceIsSetToUnicodeExtraField() throws Exception {\n        nameSource(\"utf8-winzip-test.zip\", \"\\u20AC_for_Dollar.txt\",\n                   ZipArchiveEntry.NameSource.UNICODE_EXTRA_FIELD);\n    }\n\n    @Test\n    public void nameSourceIsSetToEFS() throws Exception {\n        nameSource(\"utf8-7zip-test.zip\", \"\\u20AC_for_Dollar.txt\", 3,\n                   ZipArchiveEntry.NameSource.NAME_WITH_EFS_FLAG);\n    }\n\n    @Test\n    public void properlyMarksEntriesAsUnreadableIfUncompressedSizeIsUnknown() throws Exception {\n        \n        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new ByteArrayInputStream(new byte[0]))) {\n            ZipArchiveEntry e = new ZipArchiveEntry(\"test\");\n            e.setMethod(ZipMethod.DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.ENHANCED_DEFLATED.getCode());\n            assertTrue(zis.canReadEntryData(e));\n            e.setMethod(ZipMethod.BZIP2.getCode());\n            assertFalse(zis.canReadEntryData(e));\n        }\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\n    }\n\n    @Test\n    public void singleByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\n        singleByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\n    }\n\n    private void singleByteReadConsistentlyReturnsMinusOneAtEof(File file) throws Exception {\n        try (FileInputStream in = new FileInputStream(file);\n             ZipArchiveInputStream archive = new ZipArchiveInputStream(in)) {\n            ArchiveEntry e = archive.getNextEntry();\n            IOUtils.toByteArray(archive);\n            assertEquals(-1, archive.read());\n            assertEquals(-1, archive.read());\n        }\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bla.zip\"));\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingStore() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-264.zip\"));\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingUnshrink() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"SHRUNK.ZIP\"));\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingExplode() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"imploding-8Kdict-3trees.zip\"));\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingDeflate64() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"COMPRESS-380/COMPRESS-380.zip\"));\n    }\n\n    @Test\n    public void multiByteReadConsistentlyReturnsMinusOneAtEofUsingBzip2() throws Exception {\n        multiByteReadConsistentlyReturnsMinusOneAtEof(getFile(\"bzip2-zip.zip\"));\n    }\n\n    private void multiByteReadConsistentlyReturnsMinusOneAtEof(File file) throws Exception {\n        byte[] buf = new byte[2];\n        try (FileInputStream in = new FileInputStream(getFile(\"bla.zip\"));\n             ZipArchiveInputStream archive = new ZipArchiveInputStream(in)) {\n            ArchiveEntry e = archive.getNextEntry();\n            IOUtils.toByteArray(archive);\n            assertEquals(-1, archive.read(buf));\n            assertEquals(-1, archive.read(buf));\n        }\n    }\n\n    private static byte[] readEntry(ZipArchiveInputStream zip, ZipArchiveEntry zae) throws IOException {\n        final int len = (int)zae.getSize();\n        final byte[] buff = new byte[len];\n        zip.read(buff, 0, len);\n\n        return buff;\n    }\n\n    private static void nameSource(String archive, String entry, ZipArchiveEntry.NameSource expected) throws Exception {\n        nameSource(archive, entry, 1, expected);\n    }\n\n    private static void nameSource(String archive, String entry, int entryNo, ZipArchiveEntry.NameSource expected)\n        throws Exception {\n        try (ZipArchiveInputStream zis = new ZipArchiveInputStream(new FileInputStream(getFile(archive)))) {\n            ZipArchiveEntry ze;\n            do {\n                ze = zis.getNextZipEntry();\n            } while (--entryNo > 0);\n            assertEquals(entry, ze.getName());\n            assertEquals(expected, ze.getNameSource());\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 7,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-compress/commit/4ad5d80a6272e007f64a6ac66829ca189a8093b9",
    "cve_id": "CVE-2019-12402",
    "cwe_id": "CWE-835",
    "filename": "src/main/java/org/apache/commons/compress/archivers/zip/NioZipEncoding.java",
    "code": "\n\npackage org.apache.commons.compress.archivers.zip;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\n\n\nclass NioZipEncoding implements ZipEncoding, CharsetAccessor {\n\n    private final Charset charset;\n    private final boolean useReplacement;\n    private static final char REPLACEMENT = '?';\n    private static final byte[] REPLACEMENT_BYTES = { (byte) REPLACEMENT };\n    private static final String REPLACEMENT_STRING = String.valueOf(REPLACEMENT);\n    private static final char[] HEX_CHARS = new char[] {\n        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'\n    };\n\n\n    \n    NioZipEncoding(final Charset charset, boolean useReplacement) {\n        this.charset = charset;\n        this.useReplacement = useReplacement;\n    }\n\n    @Override\n    public Charset getCharset() {\n        return charset;\n    }\n\n    \n    @Override\n    public boolean canEncode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        return enc.canEncode(name);\n    }\n\n    \n    @Override\n    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                \n                \n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    \n                    \n                    \n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n            }\n        }\n        \n        enc.encode(cb, out, true);\n        \n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }\n\n    \n    @Override\n    public String decode(final byte[] data) throws IOException {\n        return newDecoder()\n            .decode(ByteBuffer.wrap(data)).toString();\n    }\n\n    private static ByteBuffer encodeFully(CharsetEncoder enc, CharBuffer cb, ByteBuffer out) {\n        ByteBuffer o = out;\n        while (cb.hasRemaining()) {\n            CoderResult result = enc.encode(cb, o, false);\n            if (result.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                o = ZipEncodingHelper.growBufferBy(o, increment);\n            }\n        }\n        return o;\n    }\n\n    private static CharBuffer encodeSurrogate(CharBuffer cb, char c) {\n        cb.position(0).limit(6);\n        cb.put('%');\n        cb.put('U');\n\n        cb.put(HEX_CHARS[(c >> 12) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 8) & 0x0f]);\n        cb.put(HEX_CHARS[(c >> 4) & 0x0f]);\n        cb.put(HEX_CHARS[c & 0x0f]);\n        cb.flip();\n        return cb;\n    }\n\n    private CharsetEncoder newEncoder() {\n        if (useReplacement) {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_BYTES);\n        } else {\n            return charset.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        }\n    }\n\n    private CharsetDecoder newDecoder() {\n        if (!useReplacement) {\n            return this.charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPORT)\n                .onUnmappableCharacter(CodingErrorAction.REPORT);\n        } else {\n            return  charset.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE)\n                .replaceWith(REPLACEMENT_STRING);\n        }\n    }\n\n    \n    private static int estimateInitialBufferSize(CharsetEncoder enc, int charChount) {\n        float first = enc.maxBytesPerChar();\n        float rest = (charChount - 1) * enc.averageBytesPerChar();\n        return (int) Math.ceil(first + rest);\n    }\n\n    \n    private static int estimateIncrementalEncodingSize(CharsetEncoder enc, int charCount) {\n        return (int) Math.ceil(charCount * enc.averageBytesPerChar());\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 8,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-configuration/commit/add7375cf37fd316d4838c6c56b054fc293b4641",
    "cve_id": "CVE-2020-1953",
    "cwe_id": "Not Mapping",
    "filename": "src/main/java/org/apache/commons/configuration2/YAMLConfiguration.java",
    "code": "\n\npackage org.apache.commons.configuration2;\n\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.apache.commons.configuration2.io.InputStreamSupport;\nimport org.apache.commons.configuration2.tree.ImmutableNode;\nimport org.yaml.snakeyaml.DumperOptions;\nimport org.yaml.snakeyaml.LoaderOptions;\nimport org.yaml.snakeyaml.Yaml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.util.Map;\n\n\npublic class YAMLConfiguration extends AbstractYAMLBasedConfiguration\n        implements FileBasedConfiguration, InputStreamSupport\n{\n    \n    public YAMLConfiguration()\n    {\n        super();\n    }\n\n    \n    public YAMLConfiguration(final HierarchicalConfiguration<ImmutableNode> c)\n    {\n        super(c);\n    }\n\n    @Override\n    public void read(final Reader in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml();\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final Reader in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    @Override\n    public void write(final Writer out) throws ConfigurationException, IOException\n    {\n        final DumperOptions options = new DumperOptions();\n        options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n        dump(out, options);\n    }\n\n    public void dump(final Writer out, final DumperOptions options)\n            throws ConfigurationException, IOException\n    {\n        final Yaml yaml = new Yaml(options);\n        yaml.dump(constructMap(getNodeModel().getNodeHandler().getRootNode()),\n                out);\n    }\n\n    \n    @Override\n    public void read(final InputStream in) throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml();\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n    public void read(final InputStream in, final LoaderOptions options)\n            throws ConfigurationException\n    {\n        try\n        {\n            final Yaml yaml = new Yaml(options);\n            final Map<String, Object> map = (Map) yaml.load(in);\n            load(map);\n        }\n        catch (final Exception e)\n        {\n            rethrowException(e);\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 8,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-configuration/commit/add7375cf37fd316d4838c6c56b054fc293b4641",
    "cve_id": "CVE-2020-1953",
    "cwe_id": "Not Mapping",
    "filename": "src/test/java/org/apache/commons/configuration2/TestYAMLConfiguration.java",
    "code": "\n\npackage org.apache.commons.configuration2;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringWriter;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.yaml.snakeyaml.Yaml;\n\n\npublic class TestYAMLConfiguration\n{\n    \n    private final String testYaml =\n            ConfigurationAssert.getTestFile(\"test.yaml\").getAbsolutePath();\n\n    private YAMLConfiguration yamlConfiguration;\n\n    @Before\n    public void setUp() throws Exception\n    {\n        yamlConfiguration = new YAMLConfiguration();\n        yamlConfiguration.read(new FileReader(testYaml));\n    }\n\n    @Test\n    public void testGetProperty_simple()\n    {\n        assertEquals(\"value1\", yamlConfiguration.getProperty(\"key1\"));\n    }\n\n    @Test\n    public void testGetProperty_nested()\n    {\n        assertEquals(\"value23\", yamlConfiguration.getProperty(\"key2.key3\"));\n    }\n\n    @Test\n    public void testGetProperty_nested_with_list()\n    {\n        assertEquals(Arrays.asList(\"col1\", \"col2\"),\n                yamlConfiguration.getProperty(\"key4.key5\"));\n    }\n\n    @Test\n    public void testGetProperty_subset()\n    {\n        final Configuration subset = yamlConfiguration.subset(\"key4\");\n        assertEquals(Arrays.asList(\"col1\", \"col2\"), subset.getProperty(\"key5\"));\n    }\n\n    @Test\n    public void testGetProperty_very_nested_properties()\n    {\n        final Object property =\n                yamlConfiguration.getProperty(\"very.nested.properties\");\n        assertEquals(Arrays.asList(\"nested1\", \"nested2\", \"nested3\"), property);\n    }\n\n    @Test\n    public void testGetProperty_integer()\n    {\n        final Object property = yamlConfiguration.getProperty(\"int1\");\n        assertTrue(\"property should be an Integer\",\n                property instanceof Integer);\n        assertEquals(37, property);\n    }\n\n    @Test\n    public void testSave() throws IOException, ConfigurationException\n    {\n        \n        final StringWriter sw = new StringWriter();\n        yamlConfiguration.write(sw);\n        final String output = sw.toString();\n\n        \n        final Map parsed = new Yaml().loadAs(output, Map.class);\n        assertEquals(6, parsed.entrySet().size());\n        assertEquals(\"value1\", parsed.get(\"key1\"));\n\n        final Map key2 = (Map) parsed.get(\"key2\");\n        assertEquals(\"value23\", key2.get(\"key3\"));\n\n        final List<String> key5 =\n                (List<String>) ((Map) parsed.get(\"key4\")).get(\"key5\");\n        assertEquals(2, key5.size());\n        assertEquals(\"col1\", key5.get(0));\n        assertEquals(\"col2\", key5.get(1));\n    }\n\n    @Test\n    public void testGetProperty_dictionary()\n    {\n        assertEquals(\"Martin D'vloper\",\n                yamlConfiguration.getProperty(\"martin.name\"));\n        assertEquals(\"Developer\", yamlConfiguration.getProperty(\"martin.job\"));\n        assertEquals(\"Elite\", yamlConfiguration.getProperty(\"martin.skill\"));\n    }\n\n    @Test\n    public void testCopyConstructor()\n    {\n        final BaseHierarchicalConfiguration c = new BaseHierarchicalConfiguration();\n        c.addProperty(\"foo\", \"bar\");\n\n        yamlConfiguration = new YAMLConfiguration(c);\n        assertEquals(\"bar\", yamlConfiguration.getString(\"foo\"));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 9,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-fileupload/commit/163a6061fbc077d4b6e4787d26857c2baba495d1",
    "cve_id": "CVE-2013-2186",
    "cwe_id": "CWE-20",
    "filename": "src/main/java/org/apache/commons/fileupload/disk/DiskFileItem.java",
    "code": "\npackage org.apache.commons.fileupload.disk;\n\nimport static java.lang.String.format;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Map;\nimport java.util.UUID;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileItemHeaders;\nimport org.apache.commons.fileupload.FileUploadException;\nimport org.apache.commons.fileupload.ParameterParser;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.io.output.DeferredFileOutputStream;\n\n\npublic class DiskFileItem\n    implements FileItem {\n\n    \n\n    \n    private static final long serialVersionUID = 2237570099615271025L;\n\n    \n    public static final String DEFAULT_CHARSET = \"ISO-8859-1\";\n\n    \n\n    \n    private static final String UID =\n            UUID.randomUUID().toString().replace('-', '_');\n\n    \n    private static final AtomicInteger COUNTER = new AtomicInteger(0);\n\n    \n    private String fieldName;\n\n    \n    private final String contentType;\n\n    \n    private boolean isFormField;\n\n    \n    private final String fileName;\n\n    \n    private long size = -1;\n\n\n    \n    private final int sizeThreshold;\n\n    \n    private final File repository;\n\n    \n    private byte[] cachedContent;\n\n    \n    private transient DeferredFileOutputStream dfos;\n\n    \n    private transient File tempFile;\n\n    \n    private File dfosFile;\n\n    \n    private FileItemHeaders headers;\n\n    \n\n    \n    public DiskFileItem(String fieldName,\n            String contentType, boolean isFormField, String fileName,\n            int sizeThreshold, File repository) {\n        this.fieldName = fieldName;\n        this.contentType = contentType;\n        this.isFormField = isFormField;\n        this.fileName = fileName;\n        this.sizeThreshold = sizeThreshold;\n        this.repository = repository;\n    }\n\n    \n\n    \n    public InputStream getInputStream()\n        throws IOException {\n        if (!isInMemory()) {\n            return new FileInputStream(dfos.getFile());\n        }\n\n        if (cachedContent == null) {\n            cachedContent = dfos.getData();\n        }\n        return new ByteArrayInputStream(cachedContent);\n    }\n\n    \n    public String getContentType() {\n        return contentType;\n    }\n\n    \n    public String getCharSet() {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        \n        Map<String, String> params = parser.parse(getContentType(), ';');\n        return params.get(\"charset\");\n    }\n\n    \n    public String getName() {\n        return Streams.checkFileName(fileName);\n    }\n\n    \n\n    \n    public boolean isInMemory() {\n        if (cachedContent != null) {\n            return true;\n        }\n        return dfos.isInMemory();\n    }\n\n    \n    public long getSize() {\n        if (size >= 0) {\n            return size;\n        } else if (cachedContent != null) {\n            return cachedContent.length;\n        } else if (dfos.isInMemory()) {\n            return dfos.getData().length;\n        } else {\n            return dfos.getFile().length();\n        }\n    }\n\n    \n    public byte[] get() {\n        if (isInMemory()) {\n            if (cachedContent == null) {\n                cachedContent = dfos.getData();\n            }\n            return cachedContent;\n        }\n\n        byte[] fileData = new byte[(int) getSize()];\n        InputStream fis = null;\n\n        try {\n            fis = new BufferedInputStream(new FileInputStream(dfos.getFile()));\n            fis.read(fileData);\n        } catch (IOException e) {\n            fileData = null;\n        } finally {\n            if (fis != null) {\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    \n                }\n            }\n        }\n\n        return fileData;\n    }\n\n    \n    public String getString(final String charset)\n        throws UnsupportedEncodingException {\n        return new String(get(), charset);\n    }\n\n    \n    public String getString() {\n        byte[] rawdata = get();\n        String charset = getCharSet();\n        if (charset == null) {\n            charset = DEFAULT_CHARSET;\n        }\n        try {\n            return new String(rawdata, charset);\n        } catch (UnsupportedEncodingException e) {\n            return new String(rawdata);\n        }\n    }\n\n    \n    public void write(File file) throws Exception {\n        if (isInMemory()) {\n            FileOutputStream fout = null;\n            try {\n                fout = new FileOutputStream(file);\n                fout.write(get());\n            } finally {\n                if (fout != null) {\n                    fout.close();\n                }\n            }\n        } else {\n            File outputFile = getStoreLocation();\n            if (outputFile != null) {\n                \n                size = outputFile.length();\n                \n                if (!outputFile.renameTo(file)) {\n                    BufferedInputStream in = null;\n                    BufferedOutputStream out = null;\n                    try {\n                        in = new BufferedInputStream(\n                            new FileInputStream(outputFile));\n                        out = new BufferedOutputStream(\n                                new FileOutputStream(file));\n                        IOUtils.copy(in, out);\n                    } finally {\n                        if (in != null) {\n                            try {\n                                in.close();\n                            } catch (IOException e) {\n                                \n                            }\n                        }\n                        if (out != null) {\n                            try {\n                                out.close();\n                            } catch (IOException e) {\n                                \n                            }\n                        }\n                    }\n                }\n            } else {\n                \n                throw new FileUploadException(\n                    \"Cannot write uploaded file to disk!\");\n            }\n        }\n    }\n\n    \n    public void delete() {\n        cachedContent = null;\n        File outputFile = getStoreLocation();\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    \n    public String getFieldName() {\n        return fieldName;\n    }\n\n    \n    public void setFieldName(String fieldName) {\n        this.fieldName = fieldName;\n    }\n\n    \n    public boolean isFormField() {\n        return isFormField;\n    }\n\n    \n    public void setFormField(boolean state) {\n        isFormField = state;\n    }\n\n    \n    public OutputStream getOutputStream()\n        throws IOException {\n        if (dfos == null) {\n            File outputFile = getTempFile();\n            dfos = new DeferredFileOutputStream(sizeThreshold, outputFile);\n        }\n        return dfos;\n    }\n\n    \n\n    \n    public File getStoreLocation() {\n        if (dfos == null) {\n            return null;\n        }\n        return dfos.getFile();\n    }\n\n    \n\n    \n    @Override\n    protected void finalize() {\n        File outputFile = dfos.getFile();\n\n        if (outputFile != null && outputFile.exists()) {\n            outputFile.delete();\n        }\n    }\n\n    \n    protected File getTempFile() {\n        if (tempFile == null) {\n            File tempDir = repository;\n            if (tempDir == null) {\n                tempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n            }\n\n            String tempFileName = format(\"upload_%s_%s.tmp\", UID, getUniqueId());\n\n            tempFile = new File(tempDir, tempFileName);\n        }\n        return tempFile;\n    }\n\n    \n\n    \n    private static String getUniqueId() {\n        final int limit = 100000000;\n        int current = COUNTER.getAndIncrement();\n        String id = Integer.toString(current);\n\n        \n        \n        if (current < limit) {\n            id = (\"00000000\" + id).substring(id.length());\n        }\n        return id;\n    }\n\n    \n    @Override\n    public String toString() {\n        return format(\"name=%s, StoreLocation=%s, size=%s bytes, isFormField=%s, FieldName=%s\",\n                      getName(), getStoreLocation(), getSize(), isFormField(), getFieldName());\n    }\n\n    \n\n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        \n        if (dfos.isInMemory()) {\n            cachedContent = get();\n        } else {\n            cachedContent = null;\n            dfosFile = dfos.getFile();\n        }\n\n        \n        out.defaultWriteObject();\n    }\n\n    \n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException {\n        \n        in.defaultReadObject();\n\n        OutputStream output = getOutputStream();\n        if (cachedContent != null) {\n            output.write(cachedContent);\n        } else {\n            FileInputStream input = new FileInputStream(dfosFile);\n            IOUtils.copy(input, output);\n            dfosFile.delete();\n            dfosFile = null;\n        }\n        output.close();\n\n        cachedContent = null;\n    }\n\n    \n    public FileItemHeaders getHeaders() {\n        return headers;\n    }\n\n    \n    public void setHeaders(FileItemHeaders pHeaders) {\n        headers = pHeaders;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 9,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-fileupload/commit/163a6061fbc077d4b6e4787d26857c2baba495d1",
    "cve_id": "CVE-2013-2186",
    "cwe_id": "CWE-20",
    "filename": "src/test/java/org/apache/commons/fileupload/DiskFileItemSerializeTest.java",
    "code": "\npackage org.apache.commons.fileupload;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\n\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.junit.Test;\n\n\npublic class DiskFileItemSerializeTest {\n\n    \n    private static final String textContentType = \"text/plain\";\n\n    \n    private static final int threshold = 16;\n\n    \n    @Test\n    public void testBelowThreshold() throws Exception {\n        \n        byte[] testFieldValueBytes = createContentBytes(threshold - 1);\n        FileItem item = createFileItem(testFieldValueBytes);\n\n        \n        assertTrue(\"Initial: in memory\", item.isInMemory());\n        assertEquals(\"Initial: size\", item.getSize(), testFieldValueBytes.length);\n        compareBytes(\"Initial\", item.get(), testFieldValueBytes);\n\n        \n        FileItem newItem = (FileItem)serializeDeserialize(item);\n\n        \n        assertTrue(\"Check in memory\", newItem.isInMemory());\n        compareBytes(\"Check\", testFieldValueBytes, newItem.get());\n\n        \n        compareFileItems(item, newItem);\n    }\n\n    \n    @Test\n    public void testThreshold() throws Exception {\n        \n        byte[] testFieldValueBytes = createContentBytes(threshold);\n        FileItem item = createFileItem(testFieldValueBytes);\n\n        \n        assertTrue(\"Initial: in memory\", item.isInMemory());\n        assertEquals(\"Initial: size\", item.getSize(), testFieldValueBytes.length);\n        compareBytes(\"Initial\", item.get(), testFieldValueBytes);\n\n\n        \n        FileItem newItem = (FileItem)serializeDeserialize(item);\n\n        \n        assertTrue(\"Check in memory\", newItem.isInMemory());\n        compareBytes(\"Check\", testFieldValueBytes, newItem.get());\n\n        \n        compareFileItems(item, newItem);\n    }\n\n    \n    @Test\n    public void testAboveThreshold() throws Exception {\n        \n        byte[] testFieldValueBytes = createContentBytes(threshold + 1);\n        FileItem item = createFileItem(testFieldValueBytes);\n\n        \n        assertFalse(\"Initial: in memory\", item.isInMemory());\n        assertEquals(\"Initial: size\", item.getSize(), testFieldValueBytes.length);\n        compareBytes(\"Initial\", item.get(), testFieldValueBytes);\n\n        \n        FileItem newItem = (FileItem)serializeDeserialize(item);\n\n        \n        assertFalse(\"Check in memory\", newItem.isInMemory());\n        compareBytes(\"Check\", testFieldValueBytes, newItem.get());\n\n        \n        compareFileItems(item, newItem);\n    }\n\n    \n    private void compareFileItems(FileItem origItem, FileItem newItem) {\n        assertTrue(\"Compare: is in Memory\",   origItem.isInMemory()   == newItem.isInMemory());\n        assertTrue(\"Compare: is Form Field\",  origItem.isFormField()  == newItem.isFormField());\n        assertEquals(\"Compare: Field Name\",   origItem.getFieldName(),   newItem.getFieldName());\n        assertEquals(\"Compare: Content Type\", origItem.getContentType(), newItem.getContentType());\n        assertEquals(\"Compare: File Name\",    origItem.getName(),        newItem.getName());\n    }\n\n    \n    private void compareBytes(String text, byte[] origBytes, byte[] newBytes) {\n        assertNotNull(\"origBytes must not be null\", origBytes);\n        assertNotNull(\"newBytes must not be null\", newBytes);\n        assertEquals(text + \" byte[] length\", origBytes.length, newBytes.length);\n        for (int i = 0; i < origBytes.length; i++) {\n            assertEquals(text + \" byte[\" + i + \"]\", origBytes[i], newBytes[i]);\n        }\n    }\n\n    \n    private byte[] createContentBytes(int size) {\n        StringBuilder buffer = new StringBuilder(size);\n        byte count = 0;\n        for (int i = 0; i < size; i++) {\n            buffer.append(count+\"\");\n            count++;\n            if (count > 9) {\n                count = 0;\n            }\n        }\n        return buffer.toString().getBytes();\n    }\n\n    \n    private FileItem createFileItem(byte[] contentBytes) {\n        FileItemFactory factory = new DiskFileItemFactory(threshold, null);\n        String textFieldName = \"textField\";\n\n        FileItem item = factory.createItem(\n                textFieldName,\n                textContentType,\n                true,\n                \"My File Name\"\n        );\n        try {\n            OutputStream os = item.getOutputStream();\n            os.write(contentBytes);\n            os.close();\n        } catch(IOException e) {\n            fail(\"Unexpected IOException\" + e);\n        }\n\n        return item;\n\n    }\n\n    \n    private Object serializeDeserialize(Object target) {\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        try {\n            ObjectOutputStream oos = new ObjectOutputStream(baos);\n            oos.writeObject(target);\n            oos.flush();\n            oos.close();\n        } catch (Exception e) {\n            fail(\"Exception during serialization: \" + e);\n        }\n\n        \n        Object result = null;\n        try {\n            ByteArrayInputStream bais =\n                new ByteArrayInputStream(baos.toByteArray());\n            ObjectInputStream ois = new ObjectInputStream(bais);\n            result = ois.readObject();\n            bais.close();\n        } catch (Exception e) {\n            fail(\"Exception during deserialization: \" + e);\n        }\n        return result;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 10,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-fileupload/commit/c61ff05b3241cb14d989b67209e57aa71540417a",
    "cve_id": "CVE-2014-0050",
    "cwe_id": "CWE-264",
    "filename": "src/main/java/org/apache/commons/fileupload/FileUploadBase.java",
    "code": "\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.fileupload.MultipartStream.ItemInputStream;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.servlet.ServletRequestContext;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.FileItemHeadersImpl;\nimport org.apache.commons.fileupload.util.LimitedInputStream;\nimport org.apache.commons.fileupload.util.Streams;\n\n\npublic abstract class FileUploadBase {\n\n    \n\n    \n    public static final boolean isMultipartContent(RequestContext ctx) {\n        String contentType = ctx.getContentType();\n        if (contentType == null) {\n            return false;\n        }\n        if (contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART)) {\n            return true;\n        }\n        return false;\n    }\n\n    \n    @Deprecated\n    public static boolean isMultipartContent(HttpServletRequest req) {\n        return ServletFileUpload.isMultipartContent(req);\n    }\n\n    \n\n    \n    public static final String CONTENT_TYPE = \"Content-type\";\n\n    \n    public static final String CONTENT_DISPOSITION = \"Content-disposition\";\n\n    \n    public static final String CONTENT_LENGTH = \"Content-length\";\n\n    \n    public static final String FORM_DATA = \"form-data\";\n\n    \n    public static final String ATTACHMENT = \"attachment\";\n\n    \n    public static final String MULTIPART = \"multipart/\";\n\n    \n    public static final String MULTIPART_FORM_DATA = \"multipart/form-data\";\n\n    \n    public static final String MULTIPART_MIXED = \"multipart/mixed\";\n\n    \n    @Deprecated\n    public static final int MAX_HEADER_SIZE = 1024;\n\n    \n\n    \n    private long sizeMax = -1;\n\n    \n    private long fileSizeMax = -1;\n\n    \n    private String headerEncoding;\n\n    \n    private ProgressListener listener;\n\n    \n\n    \n    public abstract FileItemFactory getFileItemFactory();\n\n    \n    public abstract void setFileItemFactory(FileItemFactory factory);\n\n    \n    public long getSizeMax() {\n        return sizeMax;\n    }\n\n    \n    public void setSizeMax(long sizeMax) {\n        this.sizeMax = sizeMax;\n    }\n\n    \n    public long getFileSizeMax() {\n        return fileSizeMax;\n    }\n\n    \n    public void setFileSizeMax(long fileSizeMax) {\n        this.fileSizeMax = fileSizeMax;\n    }\n\n    \n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    \n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    \n\n    \n    @Deprecated\n    public List<FileItem> parseRequest(HttpServletRequest req)\n    throws FileUploadException {\n        return parseRequest(new ServletRequestContext(req));\n    }\n\n    \n    public FileItemIterator getItemIterator(RequestContext ctx)\n    throws FileUploadException, IOException {\n        try {\n            return new FileItemIteratorImpl(ctx);\n        } catch (FileUploadIOException e) {\n            \n            throw (FileUploadException) e.getCause();\n        }\n    }\n\n    \n    public List<FileItem> parseRequest(RequestContext ctx)\n            throws FileUploadException {\n        List<FileItem> items = new ArrayList<FileItem>();\n        boolean successful = false;\n        try {\n            FileItemIterator iter = getItemIterator(ctx);\n            FileItemFactory fac = getFileItemFactory();\n            if (fac == null) {\n                throw new NullPointerException(\"No FileItemFactory has been set.\");\n            }\n            while (iter.hasNext()) {\n                final FileItemStream item = iter.next();\n                \n                final String fileName = ((FileItemIteratorImpl.FileItemStreamImpl) item).name;\n                FileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),\n                                                   item.isFormField(), fileName);\n                items.add(fileItem);\n                try {\n                    Streams.copy(item.openStream(), fileItem.getOutputStream(), true);\n                } catch (FileUploadIOException e) {\n                    throw (FileUploadException) e.getCause();\n                } catch (IOException e) {\n                    throw new IOFileUploadException(format(\"Processing of %s request failed. %s\",\n                                                           MULTIPART_FORM_DATA, e.getMessage()), e);\n                }\n                final FileItemHeaders fih = item.getHeaders();\n                fileItem.setHeaders(fih);\n            }\n            successful = true;\n            return items;\n        } catch (FileUploadIOException e) {\n            throw (FileUploadException) e.getCause();\n        } catch (IOException e) {\n            throw new FileUploadException(e.getMessage(), e);\n        } finally {\n            if (!successful) {\n                for (FileItem fileItem : items) {\n                    try {\n                        fileItem.delete();\n                    } catch (Throwable e) {\n                        \n                    }\n                }\n            }\n        }\n    }\n\n    \n    public Map<String, List<FileItem>> parseParameterMap(RequestContext ctx)\n            throws FileUploadException {\n        final List<FileItem> items = parseRequest(ctx);\n        final Map<String, List<FileItem>> itemsMap = new HashMap<String, List<FileItem>>(items.size());\n\n        for (FileItem fileItem : items) {\n            String fieldName = fileItem.getFieldName();\n            List<FileItem> mappedItems = itemsMap.get(fieldName);\n\n            if (mappedItems == null) {\n                mappedItems = new ArrayList<FileItem>();\n                itemsMap.put(fieldName, mappedItems);\n            }\n\n            mappedItems.add(fileItem);\n        }\n\n        return itemsMap;\n    }\n\n    \n\n    \n    protected byte[] getBoundary(String contentType) {\n        ParameterParser parser = new ParameterParser();\n        parser.setLowerCaseNames(true);\n        \n        Map<String, String> params = parser.parse(contentType, new char[] {';', ','});\n        String boundaryStr = params.get(\"boundary\");\n\n        if (boundaryStr == null) {\n            return null;\n        }\n        byte[] boundary;\n        try {\n            boundary = boundaryStr.getBytes(\"ISO-8859-1\");\n        } catch (UnsupportedEncodingException e) {\n            boundary = boundaryStr.getBytes(); \n        }\n        return boundary;\n    }\n\n    \n    @Deprecated\n    protected String getFileName(Map<String, String> headers) {\n        return getFileName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    \n    protected String getFileName(FileItemHeaders headers) {\n        return getFileName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    \n    private String getFileName(String pContentDisposition) {\n        String fileName = null;\n        if (pContentDisposition != null) {\n            String cdl = pContentDisposition.toLowerCase(Locale.ENGLISH);\n            if (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT)) {\n                ParameterParser parser = new ParameterParser();\n                parser.setLowerCaseNames(true);\n                \n                Map<String, String> params = parser.parse(pContentDisposition, ';');\n                if (params.containsKey(\"filename\")) {\n                    fileName = params.get(\"filename\");\n                    if (fileName != null) {\n                        fileName = fileName.trim();\n                    } else {\n                        \n                        \n                        \n                        fileName = \"\";\n                    }\n                }\n            }\n        }\n        return fileName;\n    }\n\n    \n    protected String getFieldName(FileItemHeaders headers) {\n        return getFieldName(headers.getHeader(CONTENT_DISPOSITION));\n    }\n\n    \n    private String getFieldName(String pContentDisposition) {\n        String fieldName = null;\n        if (pContentDisposition != null\n                && pContentDisposition.toLowerCase(Locale.ENGLISH).startsWith(FORM_DATA)) {\n            ParameterParser parser = new ParameterParser();\n            parser.setLowerCaseNames(true);\n            \n            Map<String, String> params = parser.parse(pContentDisposition, ';');\n            fieldName = params.get(\"name\");\n            if (fieldName != null) {\n                fieldName = fieldName.trim();\n            }\n        }\n        return fieldName;\n    }\n\n    \n    @Deprecated\n    protected String getFieldName(Map<String, String> headers) {\n        return getFieldName(getHeader(headers, CONTENT_DISPOSITION));\n    }\n\n    \n    @Deprecated\n    protected FileItem createItem(Map<String, String> headers,\n                                  boolean isFormField)\n        throws FileUploadException {\n        return getFileItemFactory().createItem(getFieldName(headers),\n                getHeader(headers, CONTENT_TYPE),\n                isFormField,\n                getFileName(headers));\n    }\n\n    \n    protected FileItemHeaders getParsedHeaders(String headerPart) {\n        final int len = headerPart.length();\n        FileItemHeadersImpl headers = newFileItemHeaders();\n        int start = 0;\n        for (;;) {\n            int end = parseEndOfLine(headerPart, start);\n            if (start == end) {\n                break;\n            }\n            StringBuilder header = new StringBuilder(headerPart.substring(start, end));\n            start = end + 2;\n            while (start < len) {\n                int nonWs = start;\n                while (nonWs < len) {\n                    char c = headerPart.charAt(nonWs);\n                    if (c != ' '  &&  c != '\\t') {\n                        break;\n                    }\n                    ++nonWs;\n                }\n                if (nonWs == start) {\n                    break;\n                }\n                \n                end = parseEndOfLine(headerPart, nonWs);\n                header.append(\" \").append(headerPart.substring(nonWs, end));\n                start = end + 2;\n            }\n            parseHeaderLine(headers, header.toString());\n        }\n        return headers;\n    }\n\n    \n    protected FileItemHeadersImpl newFileItemHeaders() {\n        return new FileItemHeadersImpl();\n    }\n\n    \n    @Deprecated\n    protected Map<String, String> parseHeaders(String headerPart) {\n        FileItemHeaders headers = getParsedHeaders(headerPart);\n        Map<String, String> result = new HashMap<String, String>();\n        for (Iterator<String> iter = headers.getHeaderNames();  iter.hasNext();) {\n            String headerName = iter.next();\n            Iterator<String> iter2 = headers.getHeaders(headerName);\n            StringBuilder headerValue = new StringBuilder(iter2.next());\n            while (iter2.hasNext()) {\n                headerValue.append(\",\").append(iter2.next());\n            }\n            result.put(headerName, headerValue.toString());\n        }\n        return result;\n    }\n\n    \n    private int parseEndOfLine(String headerPart, int end) {\n        int index = end;\n        for (;;) {\n            int offset = headerPart.indexOf('\\r', index);\n            if (offset == -1  ||  offset + 1 >= headerPart.length()) {\n                throw new IllegalStateException(\n                    \"Expected headers to be terminated by an empty line.\");\n            }\n            if (headerPart.charAt(offset + 1) == '\\n') {\n                return offset;\n            }\n            index = offset + 1;\n        }\n    }\n\n    \n    private void parseHeaderLine(FileItemHeadersImpl headers, String header) {\n        final int colonOffset = header.indexOf(':');\n        if (colonOffset == -1) {\n            \n            return;\n        }\n        String headerName = header.substring(0, colonOffset).trim();\n        String headerValue =\n            header.substring(header.indexOf(':') + 1).trim();\n        headers.addHeader(headerName, headerValue);\n    }\n\n    \n    @Deprecated\n    protected final String getHeader(Map<String, String> headers,\n            String name) {\n        return headers.get(name.toLowerCase(Locale.ENGLISH));\n    }\n\n    \n    private class FileItemIteratorImpl implements FileItemIterator {\n\n        \n        class FileItemStreamImpl implements FileItemStream {\n\n            \n            private final String contentType;\n\n            \n            private final String fieldName;\n\n            \n            private final String name;\n\n            \n            private final boolean formField;\n\n            \n            private final InputStream stream;\n\n            \n            private boolean opened;\n\n            \n            private FileItemHeaders headers;\n\n            \n            FileItemStreamImpl(String pName, String pFieldName,\n                    String pContentType, boolean pFormField,\n                    long pContentLength) throws IOException {\n                name = pName;\n                fieldName = pFieldName;\n                contentType = pContentType;\n                formField = pFormField;\n                final ItemInputStream itemStream = multi.newInputStream();\n                InputStream istream = itemStream;\n                if (fileSizeMax != -1) {\n                    if (pContentLength != -1\n                            &&  pContentLength > fileSizeMax) {\n                        FileSizeLimitExceededException e =\n                            new FileSizeLimitExceededException(\n                                format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                       fieldName, Long.valueOf(fileSizeMax)),\n                                pContentLength, fileSizeMax);\n                        e.setFileName(pName);\n                        e.setFieldName(pFieldName);\n                        throw new FileUploadIOException(e);\n                    }\n                    istream = new LimitedInputStream(istream, fileSizeMax) {\n                        @Override\n                        protected void raiseError(long pSizeMax, long pCount)\n                                throws IOException {\n                            itemStream.close(true);\n                            FileSizeLimitExceededException e =\n                                new FileSizeLimitExceededException(\n                                    format(\"The field %s exceeds its maximum permitted size of %s bytes.\",\n                                           fieldName, Long.valueOf(pSizeMax)),\n                                    pCount, pSizeMax);\n                            e.setFieldName(fieldName);\n                            e.setFileName(name);\n                            throw new FileUploadIOException(e);\n                        }\n                    };\n                }\n                stream = istream;\n            }\n\n            \n            public String getContentType() {\n                return contentType;\n            }\n\n            \n            public String getFieldName() {\n                return fieldName;\n            }\n\n            \n            public String getName() {\n                return Streams.checkFileName(name);\n            }\n\n            \n            public boolean isFormField() {\n                return formField;\n            }\n\n            \n            public InputStream openStream() throws IOException {\n                if (opened) {\n                    throw new IllegalStateException(\n                            \"The stream was already opened.\");\n                }\n                if (((Closeable) stream).isClosed()) {\n                    throw new FileItemStream.ItemSkippedException();\n                }\n                return stream;\n            }\n\n            \n            void close() throws IOException {\n                stream.close();\n            }\n\n            \n            public FileItemHeaders getHeaders() {\n                return headers;\n            }\n\n            \n            public void setHeaders(FileItemHeaders pHeaders) {\n                headers = pHeaders;\n            }\n\n        }\n\n        \n        private final MultipartStream multi;\n\n        \n        private final MultipartStream.ProgressNotifier notifier;\n\n        \n        private final byte[] boundary;\n\n        \n        private FileItemStreamImpl currentItem;\n\n        \n        private String currentFieldName;\n\n        \n        private boolean skipPreamble;\n\n        \n        private boolean itemValid;\n\n        \n        private boolean eof;\n\n        \n        FileItemIteratorImpl(RequestContext ctx)\n                throws FileUploadException, IOException {\n            if (ctx == null) {\n                throw new NullPointerException(\"ctx parameter\");\n            }\n\n            String contentType = ctx.getContentType();\n            if ((null == contentType)\n                    || (!contentType.toLowerCase(Locale.ENGLISH).startsWith(MULTIPART))) {\n                throw new InvalidContentTypeException(\n                        format(\"the request doesn't contain a %s or %s stream, content type header is %s\",\n                               MULTIPART_FORM_DATA, MULTIPART_FORM_DATA, contentType));\n            }\n\n            InputStream input = ctx.getInputStream();\n\n            @SuppressWarnings(\"deprecation\") \n            final int contentLengthInt = ctx.getContentLength();\n\n            final long requestSize = UploadContext.class.isAssignableFrom(ctx.getClass())\n                                     \n                                     ? ((UploadContext) ctx).contentLength()\n                                     : contentLengthInt;\n                                     \n\n            if (sizeMax >= 0) {\n                if (requestSize != -1 && requestSize > sizeMax) {\n                    throw new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(requestSize), Long.valueOf(sizeMax)),\n                               requestSize, sizeMax);\n                }\n                input = new LimitedInputStream(input, sizeMax) {\n                    @Override\n                    protected void raiseError(long pSizeMax, long pCount)\n                            throws IOException {\n                        FileUploadException ex = new SizeLimitExceededException(\n                        format(\"the request was rejected because its size (%s) exceeds the configured maximum (%s)\",\n                                Long.valueOf(pCount), Long.valueOf(pSizeMax)),\n                               pCount, pSizeMax);\n                        throw new FileUploadIOException(ex);\n                    }\n                };\n            }\n\n            String charEncoding = headerEncoding;\n            if (charEncoding == null) {\n                charEncoding = ctx.getCharacterEncoding();\n            }\n\n            boundary = getBoundary(contentType);\n            if (boundary == null) {\n                throw new FileUploadException(\"the request was rejected because no multipart boundary was found\");\n            }\n\n            notifier = new MultipartStream.ProgressNotifier(listener, requestSize);\n            multi = new MultipartStream(input, boundary, notifier);\n            multi.setHeaderEncoding(charEncoding);\n\n            skipPreamble = true;\n            findNextItem();\n        }\n\n        \n        private boolean findNextItem() throws IOException {\n            if (eof) {\n                return false;\n            }\n            if (currentItem != null) {\n                currentItem.close();\n                currentItem = null;\n            }\n            for (;;) {\n                boolean nextPart;\n                if (skipPreamble) {\n                    nextPart = multi.skipPreamble();\n                } else {\n                    nextPart = multi.readBoundary();\n                }\n                if (!nextPart) {\n                    if (currentFieldName == null) {\n                        \n                        eof = true;\n                        return false;\n                    }\n                    \n                    multi.setBoundary(boundary);\n                    currentFieldName = null;\n                    continue;\n                }\n                FileItemHeaders headers = getParsedHeaders(multi.readHeaders());\n                if (currentFieldName == null) {\n                    \n                    String fieldName = getFieldName(headers);\n                    if (fieldName != null) {\n                        String subContentType = headers.getHeader(CONTENT_TYPE);\n                        if (subContentType != null\n                                &&  subContentType.toLowerCase(Locale.ENGLISH)\n                                        .startsWith(MULTIPART_MIXED)) {\n                            currentFieldName = fieldName;\n                            \n                            byte[] subBoundary = getBoundary(subContentType);\n                            multi.setBoundary(subBoundary);\n                            skipPreamble = true;\n                            continue;\n                        }\n                        String fileName = getFileName(headers);\n                        currentItem = new FileItemStreamImpl(fileName,\n                                fieldName, headers.getHeader(CONTENT_TYPE),\n                                fileName == null, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                } else {\n                    String fileName = getFileName(headers);\n                    if (fileName != null) {\n                        currentItem = new FileItemStreamImpl(fileName,\n                                currentFieldName,\n                                headers.getHeader(CONTENT_TYPE),\n                                false, getContentLength(headers));\n                        currentItem.setHeaders(headers);\n                        notifier.noteItem();\n                        itemValid = true;\n                        return true;\n                    }\n                }\n                multi.discardBodyData();\n            }\n        }\n\n        private long getContentLength(FileItemHeaders pHeaders) {\n            try {\n                return Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));\n            } catch (Exception e) {\n                return -1;\n            }\n        }\n\n        \n        public boolean hasNext() throws FileUploadException, IOException {\n            if (eof) {\n                return false;\n            }\n            if (itemValid) {\n                return true;\n            }\n            try {\n                return findNextItem();\n            } catch (FileUploadIOException e) {\n                \n                throw (FileUploadException) e.getCause();\n            }\n        }\n\n        \n        public FileItemStream next() throws FileUploadException, IOException {\n            if (eof  ||  (!itemValid && !hasNext())) {\n                throw new NoSuchElementException();\n            }\n            itemValid = false;\n            return currentItem;\n        }\n\n    }\n\n    \n    public static class FileUploadIOException extends IOException {\n\n        \n        private static final long serialVersionUID = -7047616958165584154L;\n\n        \n        private final FileUploadException cause;\n\n        \n        public FileUploadIOException(FileUploadException pCause) {\n            \n            cause = pCause;\n        }\n\n        \n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    \n    public static class InvalidContentTypeException\n            extends FileUploadException {\n\n        \n        private static final long serialVersionUID = -9073026332015646668L;\n\n        \n        public InvalidContentTypeException() {\n            \n        }\n\n        \n        public InvalidContentTypeException(String message) {\n            super(message);\n        }\n\n    }\n\n    \n    public static class IOFileUploadException extends FileUploadException {\n\n        \n        private static final long serialVersionUID = 1749796615868477269L;\n\n        \n        private final IOException cause;\n\n        \n        public IOFileUploadException(String pMsg, IOException pException) {\n            super(pMsg);\n            cause = pException;\n        }\n\n        \n        @Override\n        public Throwable getCause() {\n            return cause;\n        }\n\n    }\n\n    \n    protected abstract static class SizeException extends FileUploadException {\n\n        \n        private static final long serialVersionUID = -8776225574705254126L;\n\n        \n        private final long actual;\n\n        \n        private final long permitted;\n\n        \n        protected SizeException(String message, long actual, long permitted) {\n            super(message);\n            this.actual = actual;\n            this.permitted = permitted;\n        }\n\n        \n        public long getActualSize() {\n            return actual;\n        }\n\n        \n        public long getPermittedSize() {\n            return permitted;\n        }\n\n    }\n\n    \n    @Deprecated\n    public static class UnknownSizeException\n        extends FileUploadException {\n\n        \n        private static final long serialVersionUID = 7062279004812015273L;\n\n        \n        public UnknownSizeException() {\n            super();\n        }\n\n        \n        public UnknownSizeException(String message) {\n            super(message);\n        }\n\n    }\n\n    \n    public static class SizeLimitExceededException\n            extends SizeException {\n\n        \n        private static final long serialVersionUID = -2474893167098052828L;\n\n        \n        @Deprecated\n        public SizeLimitExceededException() {\n            this(null, 0, 0);\n        }\n\n        \n        @Deprecated\n        public SizeLimitExceededException(String message) {\n            this(message, 0, 0);\n        }\n\n        \n        public SizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n    }\n\n    \n    public static class FileSizeLimitExceededException\n            extends SizeException {\n\n        \n        private static final long serialVersionUID = 8150776562029630058L;\n\n        \n        private String fileName;\n\n        \n        private String fieldName;\n\n        \n        public FileSizeLimitExceededException(String message, long actual,\n                long permitted) {\n            super(message, actual, permitted);\n        }\n\n        \n        public String getFileName() {\n            return fileName;\n        }\n\n        \n        public void setFileName(String pFileName) {\n            fileName = pFileName;\n        }\n\n        \n        public String getFieldName() {\n            return fieldName;\n        }\n\n        \n        public void setFieldName(String pFieldName) {\n            fieldName = pFieldName;\n        }\n\n    }\n\n    \n    public ProgressListener getProgressListener() {\n        return listener;\n    }\n\n    \n    public void setProgressListener(ProgressListener pListener) {\n        listener = pListener;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 10,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-fileupload/commit/c61ff05b3241cb14d989b67209e57aa71540417a",
    "cve_id": "CVE-2014-0050",
    "cwe_id": "CWE-264",
    "filename": "src/main/java/org/apache/commons/fileupload/MultipartStream.java",
    "code": "\npackage org.apache.commons.fileupload;\n\nimport static java.lang.String.format;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.UnsupportedEncodingException;\n\nimport org.apache.commons.fileupload.FileUploadBase.FileUploadIOException;\nimport org.apache.commons.fileupload.util.Closeable;\nimport org.apache.commons.fileupload.util.Streams;\n\n\npublic class MultipartStream {\n\n    \n    public static class ProgressNotifier {\n\n        \n        private final ProgressListener listener;\n\n        \n        private final long contentLength;\n\n        \n        private long bytesRead;\n\n        \n        private int items;\n\n        \n        ProgressNotifier(ProgressListener pListener, long pContentLength) {\n            listener = pListener;\n            contentLength = pContentLength;\n        }\n\n        \n        void noteBytesRead(int pBytes) {\n            \n            bytesRead += pBytes;\n            notifyListener();\n        }\n\n        \n        void noteItem() {\n            ++items;\n            notifyListener();\n        }\n\n        \n        private void notifyListener() {\n            if (listener != null) {\n                listener.update(bytesRead, contentLength, items);\n            }\n        }\n\n    }\n\n    \n\n    \n    public static final byte CR = 0x0D;\n\n    \n    public static final byte LF = 0x0A;\n\n    \n    public static final byte DASH = 0x2D;\n\n    \n    public static final int HEADER_PART_SIZE_MAX = 10240;\n\n    \n    protected static final int DEFAULT_BUFSIZE = 4096;\n\n    \n    protected static final byte[] HEADER_SEPARATOR = {CR, LF, CR, LF};\n\n    \n    protected static final byte[] FIELD_SEPARATOR = {CR, LF};\n\n    \n    protected static final byte[] STREAM_TERMINATOR = {DASH, DASH};\n\n    \n    protected static final byte[] BOUNDARY_PREFIX = {CR, LF, DASH, DASH};\n\n    \n\n    \n    private final InputStream input;\n\n    \n    private int boundaryLength;\n\n    \n    private int keepRegion;\n\n    \n    private byte[] boundary;\n\n    \n    private final int bufSize;\n\n    \n    private final byte[] buffer;\n\n    \n    private int head;\n\n    \n    private int tail;\n\n    \n    private String headerEncoding;\n\n    \n    private final ProgressNotifier notifier;\n\n    \n\n    \n    @Deprecated\n    public MultipartStream() {\n        this(null, null, null);\n    }\n\n    \n    @Deprecated\n    public MultipartStream(InputStream input, byte[] boundary, int bufSize) {\n        this(input, boundary, bufSize, null);\n    }\n\n    \n    public MultipartStream(InputStream input,\n            byte[] boundary,\n            int bufSize,\n            ProgressNotifier pNotifier) {\n        this.input = input;\n        this.bufSize = bufSize;\n        this.buffer = new byte[bufSize];\n        this.notifier = pNotifier;\n\n        \n        \n        this.boundary = new byte[boundary.length + BOUNDARY_PREFIX.length];\n        this.boundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n        this.keepRegion = this.boundary.length;\n        System.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0,\n                BOUNDARY_PREFIX.length);\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n\n        head = 0;\n        tail = 0;\n    }\n\n    \n    MultipartStream(InputStream input,\n            byte[] boundary,\n            ProgressNotifier pNotifier) {\n        this(input, boundary, DEFAULT_BUFSIZE, pNotifier);\n    }\n\n    \n    @Deprecated\n    public MultipartStream(InputStream input,\n            byte[] boundary) {\n        this(input, boundary, DEFAULT_BUFSIZE, null);\n    }\n\n    \n\n    \n    public String getHeaderEncoding() {\n        return headerEncoding;\n    }\n\n    \n    public void setHeaderEncoding(String encoding) {\n        headerEncoding = encoding;\n    }\n\n    \n    public byte readByte() throws IOException {\n        \n        if (head == tail) {\n            head = 0;\n            \n            tail = input.read(buffer, head, bufSize);\n            if (tail == -1) {\n                \n                throw new IOException(\"No more data is available\");\n            }\n            if (notifier != null) {\n                notifier.noteBytesRead(tail);\n            }\n        }\n        return buffer[head++];\n    }\n\n    \n    public boolean readBoundary()\n            throws FileUploadIOException, MalformedStreamException {\n        byte[] marker = new byte[2];\n        boolean nextChunk = false;\n\n        head += boundaryLength;\n        try {\n            marker[0] = readByte();\n            if (marker[0] == LF) {\n                \n                \n                \n                \n                \n                \n                return true;\n            }\n\n            marker[1] = readByte();\n            if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\n                nextChunk = false;\n            } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\n                nextChunk = true;\n            } else {\n                throw new MalformedStreamException(\n                \"Unexpected characters follow a boundary\");\n            }\n        } catch (FileUploadIOException e) {\n            \n            throw e;\n        } catch (IOException e) {\n            throw new MalformedStreamException(\"Stream ended unexpectedly\");\n        }\n        return nextChunk;\n    }\n\n    \n    public void setBoundary(byte[] boundary)\n            throws IllegalBoundaryException {\n        if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\n            throw new IllegalBoundaryException(\n            \"The length of a boundary token can not be changed\");\n        }\n        System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length,\n                boundary.length);\n    }\n\n    \n    public String readHeaders() throws FileUploadIOException, MalformedStreamException {\n        int i = 0;\n        byte b;\n        \n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        int size = 0;\n        while (i < HEADER_SEPARATOR.length) {\n            try {\n                b = readByte();\n            } catch (FileUploadIOException e) {\n                \n                throw e;\n            } catch (IOException e) {\n                throw new MalformedStreamException(\"Stream ended unexpectedly\");\n            }\n            if (++size > HEADER_PART_SIZE_MAX) {\n                throw new MalformedStreamException(\n                        format(\"Header section has more than %s bytes (maybe it is not properly terminated)\",\n                               Integer.valueOf(HEADER_PART_SIZE_MAX)));\n            }\n            if (b == HEADER_SEPARATOR[i]) {\n                i++;\n            } else {\n                i = 0;\n            }\n            baos.write(b);\n        }\n\n        String headers = null;\n        if (headerEncoding != null) {\n            try {\n                headers = baos.toString(headerEncoding);\n            } catch (UnsupportedEncodingException e) {\n                \n                \n                headers = baos.toString();\n            }\n        } else {\n            headers = baos.toString();\n        }\n\n        return headers;\n    }\n\n    \n    public int readBodyData(OutputStream output)\n            throws MalformedStreamException, IOException {\n        final InputStream istream = newInputStream();\n        return (int) Streams.copy(istream, output, false);\n    }\n\n    \n    ItemInputStream newInputStream() {\n        return new ItemInputStream();\n    }\n\n    \n    public int discardBodyData() throws MalformedStreamException, IOException {\n        return readBodyData(null);\n    }\n\n    \n    public boolean skipPreamble() throws IOException {\n        \n        System.arraycopy(boundary, 2, boundary, 0, boundary.length - 2);\n        boundaryLength = boundary.length - 2;\n        try {\n            \n            discardBodyData();\n\n            \n            \n            return readBoundary();\n        } catch (MalformedStreamException e) {\n            return false;\n        } finally {\n            \n            System.arraycopy(boundary, 0, boundary, 2, boundary.length - 2);\n            boundaryLength = boundary.length;\n            boundary[0] = CR;\n            boundary[1] = LF;\n        }\n    }\n\n    \n    public static boolean arrayequals(byte[] a,\n            byte[] b,\n            int count) {\n        for (int i = 0; i < count; i++) {\n            if (a[i] != b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    protected int findByte(byte value,\n            int pos) {\n        for (int i = pos; i < tail; i++) {\n            if (buffer[i] == value) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    \n    protected int findSeparator() {\n        int first;\n        int match = 0;\n        int maxpos = tail - boundaryLength;\n        for (first = head;\n        (first <= maxpos) && (match != boundaryLength);\n        first++) {\n            first = findByte(boundary[0], first);\n            if (first == -1 || (first > maxpos)) {\n                return -1;\n            }\n            for (match = 1; match < boundaryLength; match++) {\n                if (buffer[first + match] != boundary[match]) {\n                    break;\n                }\n            }\n        }\n        if (match == boundaryLength) {\n            return first - 1;\n        }\n        return -1;\n    }\n\n    \n    public static class MalformedStreamException extends IOException {\n\n        \n        private static final long serialVersionUID = 6466926458059796677L;\n\n        \n        public MalformedStreamException() {\n            super();\n        }\n\n        \n        public MalformedStreamException(String message) {\n            super(message);\n        }\n\n    }\n\n    \n    public static class IllegalBoundaryException extends IOException {\n\n        \n        private static final long serialVersionUID = -161533165102632918L;\n\n        \n        public IllegalBoundaryException() {\n            super();\n        }\n\n        \n        public IllegalBoundaryException(String message) {\n            super(message);\n        }\n\n    }\n\n    \n    public class ItemInputStream extends InputStream implements Closeable {\n\n        \n        private long total;\n\n        \n        private int pad;\n\n        \n        private int pos;\n\n        \n        private boolean closed;\n\n        \n        ItemInputStream() {\n            findSeparator();\n        }\n\n        \n        private void findSeparator() {\n            pos = MultipartStream.this.findSeparator();\n            if (pos == -1) {\n                if (tail - head > keepRegion) {\n                    pad = keepRegion;\n                } else {\n                    pad = tail - head;\n                }\n            }\n        }\n\n        \n        public long getBytesRead() {\n            return total;\n        }\n\n        \n        @Override\n        public int available() throws IOException {\n            if (pos == -1) {\n                return tail - head - pad;\n            }\n            return pos - head;\n        }\n\n        \n        private static final int BYTE_POSITIVE_OFFSET = 256;\n\n        \n        @Override\n        public int read() throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (available() == 0 && makeAvailable() == 0) {\n                return -1;\n            }\n            ++total;\n            int b = buffer[head++];\n            if (b >= 0) {\n                return b;\n            }\n            return b + BYTE_POSITIVE_OFFSET;\n        }\n\n        \n        @Override\n        public int read(byte[] b, int off, int len) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            if (len == 0) {\n                return 0;\n            }\n            int res = available();\n            if (res == 0) {\n                res = makeAvailable();\n                if (res == 0) {\n                    return -1;\n                }\n            }\n            res = Math.min(res, len);\n            System.arraycopy(buffer, head, b, off, res);\n            head += res;\n            total += res;\n            return res;\n        }\n\n        \n        @Override\n        public void close() throws IOException {\n            close(false);\n        }\n\n        \n        public void close(boolean pCloseUnderlying) throws IOException {\n            if (closed) {\n                return;\n            }\n            if (pCloseUnderlying) {\n                closed = true;\n                input.close();\n            } else {\n                for (;;) {\n                    int av = available();\n                    if (av == 0) {\n                        av = makeAvailable();\n                        if (av == 0) {\n                            break;\n                        }\n                    }\n                    skip(av);\n                }\n            }\n            closed = true;\n        }\n\n        \n        @Override\n        public long skip(long bytes) throws IOException {\n            if (closed) {\n                throw new FileItemStream.ItemSkippedException();\n            }\n            int av = available();\n            if (av == 0) {\n                av = makeAvailable();\n                if (av == 0) {\n                    return 0;\n                }\n            }\n            long res = Math.min(av, bytes);\n            head += res;\n            return res;\n        }\n\n        \n        private int makeAvailable() throws IOException {\n            if (pos != -1) {\n                return 0;\n            }\n\n            \n            total += tail - head - pad;\n            System.arraycopy(buffer, tail - pad, buffer, 0, pad);\n\n            \n            head = 0;\n            tail = pad;\n\n            for (;;) {\n                int bytesRead = input.read(buffer, tail, bufSize - tail);\n                if (bytesRead == -1) {\n                    \n                    \n                    \n                    final String msg = \"Stream ended unexpectedly\";\n                    throw new MalformedStreamException(msg);\n                }\n                if (notifier != null) {\n                    notifier.noteBytesRead(bytesRead);\n                }\n                tail += bytesRead;\n\n                findSeparator();\n                int av = available();\n\n                if (av > 0 || pos != -1) {\n                    return av;\n                }\n            }\n        }\n\n        \n        public boolean isClosed() {\n            return closed;\n        }\n\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 10,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-fileupload/commit/c61ff05b3241cb14d989b67209e57aa71540417a",
    "cve_id": "CVE-2014-0050",
    "cwe_id": "CWE-264",
    "filename": "src/test/java/org/apache/commons/fileupload/MultipartStreamTest.java",
    "code": "\npackage org.apache.commons.fileupload;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.InputStream;\n\nimport org.junit.Test;\n\n\npublic class MultipartStreamTest {\n\n    static private final String BOUNDARY_TEXT = \"myboundary\";\n\n    @Test\n    public void testThreeParamConstructor() throws Exception {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes();\n        InputStream input = new ByteArrayInputStream(contents);\n        byte[] boundary = BOUNDARY_TEXT.getBytes();\n        int iBufSize = boundary.length;\n        MultipartStream ms = new MultipartStream(\n                input,\n                boundary,\n                iBufSize,\n                new MultipartStream.ProgressNotifier(null, contents.length));\n        assertNotNull(ms);\n    }\n\n    @Test\n    public void testTwoParamConstructor() throws Exception {\n        final String strData = \"foobar\";\n        final byte[] contents = strData.getBytes();\n        InputStream input = new ByteArrayInputStream(contents);\n        byte[] boundary = BOUNDARY_TEXT.getBytes();\n        MultipartStream ms = new MultipartStream(\n                input,\n                boundary,\n                new MultipartStream.ProgressNotifier(null, contents.length));\n        assertNotNull(ms);\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 11,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-imaging/commit/6a79d35d6654d895d0a4b73b3a9282ec9aaeeb06",
    "cve_id": "CVE-2018-17202",
    "cwe_id": "CWE-835",
    "filename": "src/main/java/org/apache/commons/imaging/formats/jpeg/decoder/JpegDecoder.java",
    "code": "\n\npackage org.apache.commons.imaging.formats.jpeg.decoder;\n\nimport static org.apache.commons.imaging.common.BinaryFunctions.read2Bytes;\nimport static org.apache.commons.imaging.common.BinaryFunctions.readBytes;\n\nimport java.awt.image.BufferedImage;\nimport java.awt.image.ColorModel;\nimport java.awt.image.DataBuffer;\nimport java.awt.image.DirectColorModel;\nimport java.awt.image.Raster;\nimport java.awt.image.WritableRaster;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Properties;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFileParser;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\nimport org.apache.commons.imaging.formats.jpeg.JpegConstants;\nimport org.apache.commons.imaging.formats.jpeg.JpegUtils;\nimport org.apache.commons.imaging.formats.jpeg.segments.DhtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.DqtSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SofnSegment;\nimport org.apache.commons.imaging.formats.jpeg.segments.SosSegment;\n\npublic class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor {\n    \n\n    private final DqtSegment.QuantizationTable[] quantizationTables = new DqtSegment.QuantizationTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanDCTables = new DhtSegment.HuffmanTable[4];\n    private final DhtSegment.HuffmanTable[] huffmanACTables = new DhtSegment.HuffmanTable[4];\n    private SofnSegment sofnSegment;\n    private SosSegment sosSegment;\n    private final float[][] scaledQuantizationTables = new float[4][];\n    private BufferedImage image;\n    private ImageReadException imageReadException;\n    private IOException ioException;\n    private final int[] zz = new int[64];\n    private final int[] blockInt = new int[64];\n    private final float[] block = new float[64];\n\n    @Override\n    public boolean beginSOS() {\n        return true;\n    }\n\n    @Override\n    public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {\n        final ByteArrayInputStream is = new ByteArrayInputStream(imageData);\n        try {\n            final int segmentLength = read2Bytes(\"segmentLength\", is, \"Not a Valid JPEG File\", getByteOrder());\n            final byte[] sosSegmentBytes = readBytes(\"SosSegment\",\n                    is, segmentLength - 2, \"Not a Valid JPEG File\");\n            sosSegment = new SosSegment(marker, sosSegmentBytes);\n\n            int hMax = 0;\n            int vMax = 0;\n            for (int i = 0; i < sofnSegment.numberOfComponents; i++) {\n                hMax = Math.max(hMax,\n                        sofnSegment.getComponents(i).horizontalSamplingFactor);\n                vMax = Math.max(vMax,\n                        sofnSegment.getComponents(i).verticalSamplingFactor);\n            }\n            final int hSize = 8 * hMax;\n            final int vSize = 8 * vMax;\n\n            final JpegInputStream bitInputStream = new JpegInputStream(is);\n            final int xMCUs = (sofnSegment.width + hSize - 1) / hSize;\n            final int yMCUs = (sofnSegment.height + vSize - 1) / vSize;\n            final Block[] mcu = allocateMCUMemory();\n            final Block[] scaledMCU = new Block[mcu.length];\n            for (int i = 0; i < scaledMCU.length; i++) {\n                scaledMCU[i] = new Block(hSize, vSize);\n            }\n            final int[] preds = new int[sofnSegment.numberOfComponents];\n            ColorModel colorModel;\n            WritableRaster raster;\n            if (sofnSegment.numberOfComponents == 3) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n            } else if (sofnSegment.numberOfComponents == 1) {\n                colorModel = new DirectColorModel(24, 0x00ff0000, 0x0000ff00,\n                        0x000000ff);\n                raster = Raster.createPackedRaster(DataBuffer.TYPE_INT,\n                        sofnSegment.width, sofnSegment.height, new int[] {\n                                0x00ff0000, 0x0000ff00, 0x000000ff }, null);\n                \n                \n                \n                \n                \n                \n            } else {\n                throw new ImageReadException(sofnSegment.numberOfComponents\n                        + \" components are invalid or unsupported\");\n            }\n            final DataBuffer dataBuffer = raster.getDataBuffer();\n\n            for (int y1 = 0; y1 < vSize * yMCUs; y1 += vSize) {\n                for (int x1 = 0; x1 < hSize * xMCUs; x1 += hSize) {\n                    readMCU(bitInputStream, preds, mcu);\n                    rescaleMCU(mcu, hSize, vSize, scaledMCU);\n                    int srcRowOffset = 0;\n                    int dstRowOffset = y1 * sofnSegment.width + x1;\n                    for (int y2 = 0; y2 < vSize && y1 + y2 < sofnSegment.height; y2++) {\n                        for (int x2 = 0; x2 < hSize\n                                && x1 + x2 < sofnSegment.width; x2++) {\n                            if (scaledMCU.length == 3) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                final int Cb = scaledMCU[1].samples[srcRowOffset + x2];\n                                final int Cr = scaledMCU[2].samples[srcRowOffset + x2];\n                                final int rgb = YCbCrConverter.convertYCbCrToRGB(Y,\n                                        Cb, Cr);\n                                dataBuffer.setElem(dstRowOffset + x2, rgb);\n                            } else if (mcu.length == 1) {\n                                final int Y = scaledMCU[0].samples[srcRowOffset + x2];\n                                dataBuffer.setElem(dstRowOffset + x2, (Y << 16)\n                                        | (Y << 8) | Y);\n                            } else {\n                                throw new ImageReadException(\n                                        \"Unsupported JPEG with \" + mcu.length\n                                                + \" components\");\n                            }\n                        }\n                        srcRowOffset += hSize;\n                        dstRowOffset += sofnSegment.width;\n                    }\n                }\n            }\n            image = new BufferedImage(colorModel, raster,\n                    colorModel.isAlphaPremultiplied(), new Properties());\n            \n            \n            \n            \n            \n            \n        } catch (final ImageReadException imageReadEx) {\n            imageReadException = imageReadEx;\n        } catch (final IOException ioEx) {\n            ioException = ioEx;\n        } catch (final RuntimeException ex) {\n            \n            imageReadException = new ImageReadException(\"Error parsing JPEG\",\n                    ex);\n        }\n    }\n\n    @Override\n    public boolean visitSegment(final int marker, final byte[] markerBytes,\n            final int segmentLength, final byte[] segmentLengthBytes, final byte[] segmentData)\n            throws ImageReadException, IOException {\n        final int[] sofnSegments = {\n                JpegConstants.SOF0_MARKER,\n                JpegConstants.SOF1_MARKER,\n                JpegConstants.SOF2_MARKER,\n                JpegConstants.SOF3_MARKER,\n                JpegConstants.SOF5_MARKER,\n                JpegConstants.SOF6_MARKER,\n                JpegConstants.SOF7_MARKER,\n                JpegConstants.SOF9_MARKER,\n                JpegConstants.SOF10_MARKER,\n                JpegConstants.SOF11_MARKER,\n                JpegConstants.SOF13_MARKER,\n                JpegConstants.SOF14_MARKER,\n                JpegConstants.SOF15_MARKER,\n        };\n\n        if (Arrays.binarySearch(sofnSegments, marker) >= 0) {\n            if (marker != JpegConstants.SOF0_MARKER) {\n                throw new ImageReadException(\"Only sequential, baseline JPEGs \"\n                        + \"are supported at the moment\");\n            }\n            sofnSegment = new SofnSegment(marker, segmentData);\n        } else if (marker == JpegConstants.DQT_MARKER) {\n            final DqtSegment dqtSegment = new DqtSegment(marker, segmentData);\n            for (int i = 0; i < dqtSegment.quantizationTables.size(); i++) {\n                final DqtSegment.QuantizationTable table = dqtSegment.quantizationTables.get(i);\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= quantizationTables.length) {\n                    throw new ImageReadException(\n                            \"Invalid quantization table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                quantizationTables[table.destinationIdentifier] = table;\n                final int[] quantizationMatrixInt = new int[64];\n                ZigZag.zigZagToBlock(table.getElements(), quantizationMatrixInt);\n                final float[] quantizationMatrixFloat = new float[64];\n                for (int j = 0; j < 64; j++) {\n                    quantizationMatrixFloat[j] = quantizationMatrixInt[j];\n                }\n                Dct.scaleDequantizationMatrix(quantizationMatrixFloat);\n                scaledQuantizationTables[table.destinationIdentifier] = quantizationMatrixFloat;\n            }\n        } else if (marker == JpegConstants.DHT_MARKER) {\n            final DhtSegment dhtSegment = new DhtSegment(marker, segmentData);\n            for (int i = 0; i < dhtSegment.huffmanTables.size(); i++) {\n                final DhtSegment.HuffmanTable table = dhtSegment.huffmanTables.get(i);\n                DhtSegment.HuffmanTable[] tables;\n                if (table.tableClass == 0) {\n                    tables = huffmanDCTables;\n                } else if (table.tableClass == 1) {\n                    tables = huffmanACTables;\n                } else {\n                    throw new ImageReadException(\"Invalid huffman table class \"\n                            + table.tableClass);\n                }\n                if (0 > table.destinationIdentifier\n                        || table.destinationIdentifier >= tables.length) {\n                    throw new ImageReadException(\n                            \"Invalid huffman table identifier \"\n                                    + table.destinationIdentifier);\n                }\n                tables[table.destinationIdentifier] = table;\n            }\n        }\n        return true;\n    }\n\n    private void rescaleMCU(final Block[] dataUnits, final int hSize, final int vSize, final Block[] ret) {\n        for (int i = 0; i < dataUnits.length; i++) {\n            final Block dataUnit = dataUnits[i];\n            if (dataUnit.width == hSize && dataUnit.height == vSize) {\n                System.arraycopy(dataUnit.samples, 0, ret[i].samples, 0, hSize\n                        * vSize);\n            } else {\n                final int hScale = hSize / dataUnit.width;\n                final int vScale = vSize / dataUnit.height;\n                if (hScale == 2 && vScale == 2) {\n                    int srcRowOffset = 0;\n                    int dstRowOffset = 0;\n                    for (int y = 0; y < dataUnit.height; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            final int sample = dataUnit.samples[srcRowOffset + (x >> 1)];\n                            ret[i].samples[dstRowOffset + x] = sample;\n                            ret[i].samples[dstRowOffset + hSize + x] = sample;\n                        }\n                        srcRowOffset += dataUnit.width;\n                        dstRowOffset += 2 * hSize;\n                    }\n                } else {\n                    \n                    int dstRowOffset = 0;\n                    for (int y = 0; y < vSize; y++) {\n                        for (int x = 0; x < hSize; x++) {\n                            ret[i].samples[dstRowOffset + x] = dataUnit.samples[(y / vScale)\n                                    * dataUnit.width + (x / hScale)];\n                        }\n                        dstRowOffset += hSize;\n                    }\n                }\n            }\n        }\n    }\n\n    private Block[] allocateMCUMemory() throws ImageReadException {\n        final Block[] mcu = new Block[sosSegment.numberOfComponents];\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = new Block(\n                    8 * frameComponent.horizontalSamplingFactor,\n                    8 * frameComponent.verticalSamplingFactor);\n            mcu[i] = fullBlock;\n        }\n        return mcu;\n    }\n\n    private void readMCU(final JpegInputStream is, final int[] preds, final Block[] mcu)\n            throws IOException, ImageReadException {\n        for (int i = 0; i < sosSegment.numberOfComponents; i++) {\n            final SosSegment.Component scanComponent = sosSegment.getComponents(i);\n            SofnSegment.Component frameComponent = null;\n            for (int j = 0; j < sofnSegment.numberOfComponents; j++) {\n                if (sofnSegment.getComponents(j).componentIdentifier == scanComponent.scanComponentSelector) {\n                    frameComponent = sofnSegment.getComponents(j);\n                    break;\n                }\n            }\n            if (frameComponent == null) {\n                throw new ImageReadException(\"Invalid component\");\n            }\n            final Block fullBlock = mcu[i];\n            for (int y = 0; y < frameComponent.verticalSamplingFactor; y++) {\n                for (int x = 0; x < frameComponent.horizontalSamplingFactor; x++) {\n                    Arrays.fill(zz, 0);\n                    \n                    final int t = decode(\n                            is,\n                            huffmanDCTables[scanComponent.dcCodingTableSelector]);\n                    int diff = receive(t, is);\n                    diff = extend(diff, t);\n                    zz[0] = preds[i] + diff;\n                    preds[i] = zz[0];\n\n                    \n                    int k = 1;\n                    while (true) {\n                        final int rs = decode(\n                                is,\n                                huffmanACTables[scanComponent.acCodingTableSelector]);\n                        final int ssss = rs & 0xf;\n                        final int rrrr = rs >> 4;\n                        final int r = rrrr;\n\n                        if (ssss == 0) {\n                            if (r == 15) {\n                                k += 16;\n                            } else {\n                                break;\n                            }\n                        } else {\n                            k += r;\n\n                            \n                            zz[k] = receive(ssss, is);\n                            zz[k] = extend(zz[k], ssss);\n\n                            if (k == 63) {\n                                break;\n                            } else {\n                                k++;\n                            }\n                        }\n                    }\n\n                    final int shift = (1 << (sofnSegment.precision - 1));\n                    final int max = (1 << sofnSegment.precision) - 1;\n\n                    final float[] scaledQuantizationTable = scaledQuantizationTables[frameComponent.quantTabDestSelector];\n                    ZigZag.zigZagToBlock(zz, blockInt);\n                    for (int j = 0; j < 64; j++) {\n                        block[j] = blockInt[j] * scaledQuantizationTable[j];\n                    }\n                    Dct.inverseDCT8x8(block);\n\n                    int dstRowOffset = 8 * y * 8\n                            * frameComponent.horizontalSamplingFactor + 8 * x;\n                    int srcNext = 0;\n                    for (int yy = 0; yy < 8; yy++) {\n                        for (int xx = 0; xx < 8; xx++) {\n                            float sample = block[srcNext++];\n                            sample += shift;\n                            int result;\n                            if (sample < 0) {\n                                result = 0;\n                            } else if (sample > max) {\n                                result = max;\n                            } else {\n                                result = fastRound(sample);\n                            }\n                            fullBlock.samples[dstRowOffset + xx] = result;\n                        }\n                        dstRowOffset += 8 * frameComponent.horizontalSamplingFactor;\n                    }\n                }\n            }\n        }\n    }\n\n    private static int fastRound(final float x) {\n        return (int) (x + 0.5f);\n    }\n\n    private int extend(int v, final int t) {\n        \n        int vt = (1 << (t - 1));\n        while (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }\n\n    private int receive(final int ssss, final JpegInputStream is) throws IOException,\n            ImageReadException {\n        \n        int i = 0;\n        int v = 0;\n        while (i != ssss) {\n            i++;\n            v = (v << 1) + is.nextBit();\n        }\n        return v;\n    }\n\n    private int decode(final JpegInputStream is, final DhtSegment.HuffmanTable huffmanTable)\n            throws IOException, ImageReadException {\n        \n        int i = 1;\n        int code = is.nextBit();\n        while (code > huffmanTable.getMaxCode(i)) {\n            i++;\n            code = (code << 1) | is.nextBit();\n        }\n        int j = huffmanTable.getValPtr(i);\n        j += code - huffmanTable.getMinCode(i);\n        return huffmanTable.getHuffVal(j);\n    }\n\n    public BufferedImage decode(final ByteSource byteSource) throws IOException,\n            ImageReadException {\n        final JpegUtils jpegUtils = new JpegUtils();\n        jpegUtils.traverseJFIF(byteSource, this);\n        if (imageReadException != null) {\n            throw imageReadException;\n        }\n        if (ioException != null) {\n            throw ioException;\n        }\n        return image;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 12,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-imaging/commit/f5574bfe285edd79207fe8c30f53cb0af06e26bb",
    "cve_id": "CVE-2018-17201",
    "cwe_id": "CWE-835",
    "filename": "src/main/java/org/apache/commons/imaging/formats/rgbe/RgbeInfo.java",
    "code": "\npackage org.apache.commons.imaging.formats.rgbe;\n\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.ByteOrder;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.common.BinaryFunctions;\nimport org.apache.commons.imaging.common.ByteConversions;\nimport org.apache.commons.imaging.common.ImageMetadata;\nimport org.apache.commons.imaging.common.GenericImageMetadata;\nimport org.apache.commons.imaging.common.bytesource.ByteSource;\n\nclass RgbeInfo implements Closeable {\n    \n    private static final byte[] HEADER = new byte[] {\n        0x23, 0x3F, 0x52, 0x41, 0x44, 0x49, 0x41, 0x4E, 0x43, 0x45\n    };\n    private static final Pattern RESOLUTION_STRING = Pattern.compile(\"-Y (\\\\d+) \\\\+X (\\\\d+)\");\n\n    private final InputStream in;\n    private GenericImageMetadata metadata;\n    private int width = -1;\n    private int height = -1;\n    private static final byte[] TWO_TWO = new byte[] { 0x2, 0x2 };\n\n    RgbeInfo(final ByteSource byteSource) throws IOException {\n        this.in = byteSource.getInputStream();\n    }\n\n    ImageMetadata getMetadata() throws IOException, ImageReadException {\n        if (null == metadata) {\n            readMetadata();\n        }\n\n        return metadata;\n    }\n\n    int getWidth() throws IOException, ImageReadException {\n        if (-1 == width) {\n            readDimensions();\n        }\n\n        return width;\n    }\n\n    int getHeight() throws IOException, ImageReadException {\n        if (-1 == height) {\n            readDimensions();\n        }\n\n        return height;\n    }\n\n    @Override\n    public void close() throws IOException {\n        in.close();\n    }\n\n    private void readDimensions() throws IOException, ImageReadException {\n        getMetadata(); \n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n        final String resolution = reader.readNextLine();\n        final Matcher matcher = RESOLUTION_STRING.matcher(resolution);\n\n        if (!matcher.matches()) {\n            throw new ImageReadException(\n                    \"Invalid HDR resolution string. Only \\\"-Y N +X M\\\" is supported. Found \\\"\"\n                            + resolution + \"\\\"\");\n        }\n\n        height = Integer.parseInt(matcher.group(1));\n        width = Integer.parseInt(matcher.group(2));\n    }\n\n    private void readMetadata() throws IOException, ImageReadException {\n        BinaryFunctions.readAndVerifyBytes(in, HEADER, \"Not a valid HDR: Incorrect Header\");\n\n        final InfoHeaderReader reader = new InfoHeaderReader(in);\n\n        if (reader.readNextLine().length() != 0) {\n            throw new ImageReadException(\"Not a valid HDR: Incorrect Header\");\n        }\n\n        metadata = new GenericImageMetadata();\n\n        String info = reader.readNextLine();\n\n        while (info.length() != 0) {\n            final int equals = info.indexOf('=');\n\n            if (equals > 0) {\n                final String variable = info.substring(0, equals);\n                final String value = info.substring(equals + 1);\n\n                if (\"FORMAT\".equals(value) && !\"32-bit_rle_rgbe\".equals(value)) {\n                    throw new ImageReadException(\"Only 32-bit_rle_rgbe images are supported, trying to read \" + value);\n                }\n\n                metadata.add(variable, value);\n            } else {\n                metadata.add(\"<command>\", info);\n            }\n\n            info = reader.readNextLine();\n        }\n    }\n\n    public float[][] getPixelData() throws IOException, ImageReadException {\n        \n        \n        final int ht = getHeight();\n        final int wd = getWidth();\n\n        if (wd >= 32768) {\n            throw new ImageReadException(\"Scan lines must be less than 32768 bytes long\");\n        }\n\n        final byte[] scanLineBytes = ByteConversions.toBytes((short) wd,\n                ByteOrder.BIG_ENDIAN);\n        final byte[] rgbe = new byte[wd * 4];\n        final float[][] out = new float[3][wd * ht];\n\n        for (int i = 0; i < ht; i++) {\n            BinaryFunctions.readAndVerifyBytes(in, TWO_TWO, \"Scan line \" + i + \" expected to start with 0x2 0x2\");\n            BinaryFunctions.readAndVerifyBytes(in, scanLineBytes, \"Scan line \" + i + \" length expected\");\n\n            decompress(in, rgbe);\n\n            for (int channel = 0; channel < 3; channel++) {\n                final int channelOffset = channel * wd;\n                final int eOffset = 3 * wd;\n\n                for (int p = 0; p < wd; p++) {\n                    final int mantissa = rgbe[p + eOffset] & 0xff;\n                    final int pos = p + i * wd;\n\n                    if (0 == mantissa) {\n                        out[channel][pos] = 0;\n                    } else {\n                        final float mult = (float) Math.pow(2, mantissa - (128 + 8));\n                        out[channel][pos] = ((rgbe[p + channelOffset] & 0xff) + 0.5f) * mult;\n                    }\n                }\n            }\n        }\n\n        return out;\n    }\n\n    private static void decompress(final InputStream in, final byte[] out)\n            throws IOException {\n        int position = 0;\n        final int total = out.length;\n\n        while (position < total) {\n            final int n = in.read();\n\n            if (n > 128) {\n                final int value = in.read();\n\n                for (int i = 0; i < (n & 0x7f); i++) {\n                    out[position++] = (byte) value;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    out[position++] = (byte) in.read();\n                }\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 12,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-imaging/commit/f5574bfe285edd79207fe8c30f53cb0af06e26bb",
    "cve_id": "CVE-2018-17201",
    "cwe_id": "CWE-835",
    "filename": "src/test/java/org/apache/commons/imaging/formats/rgbe/RgbeReadTest.java",
    "code": "\npackage org.apache.commons.imaging.formats.rgbe;\n\nimport static org.junit.Assert.assertNotNull;\n\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.List;\n\nimport org.apache.commons.imaging.ImageInfo;\nimport org.apache.commons.imaging.ImageReadException;\nimport org.apache.commons.imaging.Imaging;\nimport org.apache.commons.imaging.common.ImageMetadata;\nimport org.apache.commons.imaging.internal.Debug;\nimport org.junit.Test;\n\npublic class RgbeReadTest extends RgbeBaseTest {\n\n    @Test\n    public void test() throws IOException, ImageReadException {\n        Debug.debug(\"start\");\n\n        final List<File> images = getRgbeImages();\n\n        for (final File imageFile : images) {\n\n            Debug.debug(\"imageFile\", imageFile);\n\n            final ImageMetadata metadata = Imaging.getMetadata(imageFile);\n            assertNotNull(metadata);\n\n            final ImageInfo imageInfo = Imaging.getImageInfo(imageFile);\n            assertNotNull(imageInfo);\n\n            final BufferedImage image = Imaging.getBufferedImage(imageFile);\n            assertNotNull(image);\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 13,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-io/commit/2736b6fe0b3fa22ec8e2b4184897ecadb021fc78",
    "cve_id": "CVE-2021-29425",
    "cwe_id": "CWE-20",
    "filename": "src/main/java/org/apache/commons/io/FilenameUtils.java",
    "code": "\npackage org.apache.commons.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Stack;\n\n\npublic class FilenameUtils {\n\n    private static final String EMPTY_STRING = \"\";\n\n    private static final int NOT_FOUND = -1;\n\n    \n    public static final char EXTENSION_SEPARATOR = '.';\n\n    \n    public static final String EXTENSION_SEPARATOR_STR = Character.toString(EXTENSION_SEPARATOR);\n\n    \n    private static final char UNIX_SEPARATOR = '/';\n\n    \n    private static final char WINDOWS_SEPARATOR = '\\\\';\n\n    \n    private static final char SYSTEM_SEPARATOR = File.separatorChar;\n\n    \n    private static final char OTHER_SEPARATOR;\n    static {\n        if (isSystemWindows()) {\n            OTHER_SEPARATOR = UNIX_SEPARATOR;\n        } else {\n            OTHER_SEPARATOR = WINDOWS_SEPARATOR;\n        }\n    }\n\n    \n    public FilenameUtils() {\n        super();\n    }\n\n    \n    \n    static boolean isSystemWindows() {\n        return SYSTEM_SEPARATOR == WINDOWS_SEPARATOR;\n    }\n\n    \n    \n    private static boolean isSeparator(final char ch) {\n        return ch == UNIX_SEPARATOR || ch == WINDOWS_SEPARATOR;\n    }\n\n    \n    \n    public static String normalize(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, true);\n    }\n    \n    public static String normalize(final String fileName, final boolean unixSeparator) {\n        final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, true);\n    }\n\n    \n    \n    public static String normalizeNoEndSeparator(final String fileName) {\n        return doNormalize(fileName, SYSTEM_SEPARATOR, false);\n    }\n\n    \n    public static String normalizeNoEndSeparator(final String fileName, final boolean unixSeparator) {\n         final char separator = unixSeparator ? UNIX_SEPARATOR : WINDOWS_SEPARATOR;\n        return doNormalize(fileName, separator, false);\n    }\n\n    \n    private static String doNormalize(final String fileName, final char separator, final boolean keepSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n\n        failIfNullBytePresent(fileName);\n\n        int size = fileName.length();\n        if (size == 0) {\n            return fileName;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n\n        final char[] array = new char[size + 2];  \n        fileName.getChars(0, fileName.length(), array, 0);\n\n        \n        final char otherSeparator = separator == SYSTEM_SEPARATOR ? OTHER_SEPARATOR : SYSTEM_SEPARATOR;\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == otherSeparator) {\n                array[i] = separator;\n            }\n        }\n\n        \n        boolean lastIsDirectory = true;\n        if (array[size - 1] != separator) {\n            array[size++] = separator;\n            lastIsDirectory = false;\n        }\n\n        \n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == separator) {\n                System.arraycopy(array, i, array, i - 1, size - i);\n                size--;\n                i--;\n            }\n        }\n\n        \n        for (int i = prefix + 1; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' &&\n                    (i == prefix + 1 || array[i - 2] == separator)) {\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                System.arraycopy(array, i + 1, array, i - 1, size - i);\n                size -=2;\n                i--;\n            }\n        }\n\n        \n        outer:\n        for (int i = prefix + 2; i < size; i++) {\n            if (array[i] == separator && array[i - 1] == '.' && array[i - 2] == '.' &&\n                    (i == prefix + 2 || array[i - 3] == separator)) {\n                if (i == prefix + 2) {\n                    return null;\n                }\n                if (i == size - 1) {\n                    lastIsDirectory = true;\n                }\n                int j;\n                for (j = i - 4 ; j >= prefix; j--) {\n                    if (array[j] == separator) {\n                        \n                        System.arraycopy(array, i + 1, array, j + 1, size - i);\n                        size -= i - j;\n                        i = j + 1;\n                        continue outer;\n                    }\n                }\n                \n                System.arraycopy(array, i + 1, array, prefix, size - i);\n                size -= i + 1 - prefix;\n                i = prefix + 1;\n            }\n        }\n\n        if (size <= 0) {  \n            return EMPTY_STRING;\n        }\n        if (size <= prefix) {  \n            return new String(array, 0, size);\n        }\n        if (lastIsDirectory && keepSeparator) {\n            return new String(array, 0, size);  \n        }\n        return new String(array, 0, size - 1);  \n    }\n\n    \n    \n    public static String concat(final String basePath, final String fullFileNameToAdd) {\n        final int prefix = getPrefixLength(fullFileNameToAdd);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix > 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        if (basePath == null) {\n            return null;\n        }\n        final int len = basePath.length();\n        if (len == 0) {\n            return normalize(fullFileNameToAdd);\n        }\n        final char ch = basePath.charAt(len - 1);\n        if (isSeparator(ch)) {\n            return normalize(basePath + fullFileNameToAdd);\n        }\n        return normalize(basePath + '/' + fullFileNameToAdd);\n    }\n\n    \n    public static boolean directoryContains(final String canonicalParent, final String canonicalChild)\n            throws IOException {\n\n        \n        if (canonicalParent == null) {\n            throw new IllegalArgumentException(\"Directory must not be null\");\n        }\n\n        if (canonicalChild == null) {\n            return false;\n        }\n\n        if (IOCase.SYSTEM.checkEquals(canonicalParent, canonicalChild)) {\n            return false;\n        }\n\n        return IOCase.SYSTEM.checkStartsWith(canonicalChild, canonicalParent);\n    }\n\n    \n    \n    public static String separatorsToUnix(final String path) {\n        if (path == null || path.indexOf(WINDOWS_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(WINDOWS_SEPARATOR, UNIX_SEPARATOR);\n    }\n\n    \n    public static String separatorsToWindows(final String path) {\n        if (path == null || path.indexOf(UNIX_SEPARATOR) == NOT_FOUND) {\n            return path;\n        }\n        return path.replace(UNIX_SEPARATOR, WINDOWS_SEPARATOR);\n    }\n\n    \n    public static String separatorsToSystem(final String path) {\n        if (path == null) {\n            return null;\n        }\n        return isSystemWindows() ? separatorsToWindows(path) : separatorsToUnix(path);\n    }\n\n    \n    \n    public static int getPrefixLength(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int len = fileName.length();\n        if (len == 0) {\n            return 0;\n        }\n        char ch0 = fileName.charAt(0);\n        if (ch0 == ':') {\n            return NOT_FOUND;\n        }\n        if (len == 1) {\n            if (ch0 == '~') {\n                return 2;  \n            }\n            return isSeparator(ch0) ? 1 : 0;\n        }\n        if (ch0 == '~') {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 1);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 1);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND) {\n                return len + 1;  \n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        }\n        final char ch1 = fileName.charAt(1);\n        if (ch1 == ':') {\n            ch0 = Character.toUpperCase(ch0);\n            if (ch0 >= 'A' && ch0 <= 'Z') {\n                if (len == 2 || isSeparator(fileName.charAt(2)) == false) {\n                    return 2;\n                }\n                return 3;\n            } else if (ch0 == UNIX_SEPARATOR) {\n                return 1;\n            }\n            return NOT_FOUND;\n\n        } else if (isSeparator(ch0) && isSeparator(ch1)) {\n            int posUnix = fileName.indexOf(UNIX_SEPARATOR, 2);\n            int posWin = fileName.indexOf(WINDOWS_SEPARATOR, 2);\n            if (posUnix == NOT_FOUND && posWin == NOT_FOUND || posUnix == 2 || posWin == 2) {\n                return NOT_FOUND;\n            }\n            posUnix = posUnix == NOT_FOUND ? posWin : posUnix;\n            posWin = posWin == NOT_FOUND ? posUnix : posWin;\n            return Math.min(posUnix, posWin) + 1;\n        } else {\n            return isSeparator(ch0) ? 1 : 0;\n        }\n    }\n\n    \n    public static int indexOfLastSeparator(final String fileName) {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        final int lastUnixPos = fileName.lastIndexOf(UNIX_SEPARATOR);\n        final int lastWindowsPos = fileName.lastIndexOf(WINDOWS_SEPARATOR);\n        return Math.max(lastUnixPos, lastWindowsPos);\n    }\n\n    \n    public static int indexOfExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return NOT_FOUND;\n        }\n        if (isSystemWindows()) {\n            \n            final int offset = fileName.indexOf(':', getAdsCriticalOffset(fileName));\n            if (offset != -1) {\n                throw new IllegalArgumentException(\"NTFS ADS separator (':') in file name is forbidden.\");\n            }\n        }\n        final int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n        final int lastSeparator = indexOfLastSeparator(fileName);\n        return lastSeparator > extensionPos ? NOT_FOUND : extensionPos;\n    }\n\n    \n    \n    public static String getPrefix(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        final int len = getPrefixLength(fileName);\n        if (len < 0) {\n            return null;\n        }\n        if (len > fileName.length()) {\n            failIfNullBytePresent(fileName + UNIX_SEPARATOR);\n            return fileName + UNIX_SEPARATOR;\n        }\n        final String path = fileName.substring(0, len);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    \n    public static String getPath(final String fileName) {\n        return doGetPath(fileName, 1);\n    }\n\n    \n    public static String getPathNoEndSeparator(final String fileName) {\n        return doGetPath(fileName, 0);\n    }\n\n    \n    private static String doGetPath(final String fileName, final int separatorAdd) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        final int endIndex = index+separatorAdd;\n        if (prefix >= fileName.length() || index < 0 || prefix >= endIndex) {\n            return EMPTY_STRING;\n        }\n        final String path = fileName.substring(prefix, endIndex);\n        failIfNullBytePresent(path);\n        return path;\n    }\n\n    \n    public static String getFullPath(final String fileName) {\n        return doGetFullPath(fileName, true);\n    }\n\n    \n    public static String getFullPathNoEndSeparator(final String fileName) {\n        return doGetFullPath(fileName, false);\n    }\n\n    \n    private static String doGetFullPath(final String fileName, final boolean includeSeparator) {\n        if (fileName == null) {\n            return null;\n        }\n        final int prefix = getPrefixLength(fileName);\n        if (prefix < 0) {\n            return null;\n        }\n        if (prefix >= fileName.length()) {\n            if (includeSeparator) {\n                return getPrefix(fileName);  \n            }\n            return fileName;\n        }\n        final int index = indexOfLastSeparator(fileName);\n        if (index < 0) {\n            return fileName.substring(0, prefix);\n        }\n        int end = index + (includeSeparator ?  1 : 0);\n        if (end == 0) {\n            end++;\n        }\n        return fileName.substring(0, end);\n    }\n\n    \n    public static String getName(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n        final int index = indexOfLastSeparator(fileName);\n        return fileName.substring(index + 1);\n    }\n\n    \n    private static void failIfNullBytePresent(final String path) {\n        final int len = path.length();\n        for (int i = 0; i < len; i++) {\n            if (path.charAt(i) == 0) {\n                throw new IllegalArgumentException(\"Null byte present in file/path name. There are no \" +\n                        \"known legitimate use cases for such data, but several injection attacks may use it\");\n            }\n        }\n    }\n\n    \n    public static String getBaseName(final String fileName) {\n        return removeExtension(getName(fileName));\n    }\n\n    \n    public static String getExtension(final String fileName) throws IllegalArgumentException {\n        if (fileName == null) {\n            return null;\n        }\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return EMPTY_STRING;\n        }\n        return fileName.substring(index + 1);\n    }\n\n    \n    private static int getAdsCriticalOffset(String fileName) {\n        \n        int offset1 = fileName.lastIndexOf(SYSTEM_SEPARATOR);\n        int offset2 = fileName.lastIndexOf(OTHER_SEPARATOR);\n        if (offset1 == -1) {\n            if (offset2 == -1) {\n                return 0;\n            }\n            return offset2 + 1;\n        }\n        if (offset2 == -1) {\n            return offset1 + 1;\n        }\n        return Math.max(offset1, offset2) + 1;\n    }\n\n    \n    \n    public static String removeExtension(final String fileName) {\n        if (fileName == null) {\n            return null;\n        }\n        failIfNullBytePresent(fileName);\n\n        final int index = indexOfExtension(fileName);\n        if (index == NOT_FOUND) {\n            return fileName;\n        }\n        return fileName.substring(0, index);\n    }\n\n    \n    \n    public static boolean equals(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SENSITIVE);\n    }\n\n    \n    public static boolean equalsOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, false, IOCase.SYSTEM);\n    }\n\n    \n    \n    public static boolean equalsNormalized(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SENSITIVE);\n    }\n\n    \n    public static boolean equalsNormalizedOnSystem(final String fileName1, final String fileName2) {\n        return equals(fileName1, fileName2, true, IOCase.SYSTEM);\n    }\n\n    \n    public static boolean equals(\n            String fileName1, String fileName2,\n            final boolean normalized, IOCase caseSensitivity) {\n\n        if (fileName1 == null || fileName2 == null) {\n            return fileName1 == null && fileName2 == null;\n        }\n        if (normalized) {\n            fileName1 = normalize(fileName1);\n            fileName2 = normalize(fileName2);\n            if (fileName1 == null || fileName2 == null) {\n                throw new NullPointerException(\n                    \"Error normalizing one or both of the file names\");\n            }\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        return caseSensitivity.checkEquals(fileName1, fileName2);\n    }\n\n    \n    \n    public static boolean isExtension(final String fileName, final String extension) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extension == null || extension.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        return fileExt.equals(extension);\n    }\n\n    \n    public static boolean isExtension(final String fileName, final String[] extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.length == 0) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    public static boolean isExtension(final String fileName, final Collection<String> extensions) {\n        if (fileName == null) {\n            return false;\n        }\n        failIfNullBytePresent(fileName);\n\n        if (extensions == null || extensions.isEmpty()) {\n            return indexOfExtension(fileName) == NOT_FOUND;\n        }\n        final String fileExt = getExtension(fileName);\n        for (final String extension : extensions) {\n            if (fileExt.equals(extension)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    \n    \n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SENSITIVE);\n    }\n\n    \n    public static boolean wildcardMatchOnSystem(final String fileName, final String wildcardMatcher) {\n        return wildcardMatch(fileName, wildcardMatcher, IOCase.SYSTEM);\n    }\n\n    \n    public static boolean wildcardMatch(final String fileName, final String wildcardMatcher, IOCase caseSensitivity) {\n        if (fileName == null && wildcardMatcher == null) {\n            return true;\n        }\n        if (fileName == null || wildcardMatcher == null) {\n            return false;\n        }\n        if (caseSensitivity == null) {\n            caseSensitivity = IOCase.SENSITIVE;\n        }\n        final String[] wcs = splitOnTokens(wildcardMatcher);\n        boolean anyChars = false;\n        int textIdx = 0;\n        int wcsIdx = 0;\n        final Stack<int[]> backtrack = new Stack<>();\n\n        \n        do {\n            if (backtrack.size() > 0) {\n                final int[] array = backtrack.pop();\n                wcsIdx = array[0];\n                textIdx = array[1];\n                anyChars = true;\n            }\n\n            \n            while (wcsIdx < wcs.length) {\n\n                if (wcs[wcsIdx].equals(\"?\")) {\n                    \n                    textIdx++;\n                    if (textIdx > fileName.length()) {\n                        break;\n                    }\n                    anyChars = false;\n\n                } else if (wcs[wcsIdx].equals(\"*\")) {\n                    \n                    anyChars = true;\n                    if (wcsIdx == wcs.length - 1) {\n                        textIdx = fileName.length();\n                    }\n\n                } else {\n                    \n                    if (anyChars) {\n                        \n                        textIdx = caseSensitivity.checkIndexOf(fileName, textIdx, wcs[wcsIdx]);\n                        if (textIdx == NOT_FOUND) {\n                            \n                            break;\n                        }\n                        final int repeat = caseSensitivity.checkIndexOf(fileName, textIdx + 1, wcs[wcsIdx]);\n                        if (repeat >= 0) {\n                            backtrack.push(new int[] {wcsIdx, repeat});\n                        }\n                    } else {\n                        \n                        if (!caseSensitivity.checkRegionMatches(fileName, textIdx, wcs[wcsIdx])) {\n                            \n                            break;\n                        }\n                    }\n\n                    \n                    textIdx += wcs[wcsIdx].length();\n                    anyChars = false;\n                }\n\n                wcsIdx++;\n            }\n\n            \n            if (wcsIdx == wcs.length && textIdx == fileName.length()) {\n                return true;\n            }\n\n        } while (backtrack.size() > 0);\n\n        return false;\n    }\n\n    \n    static String[] splitOnTokens(final String text) {\n        \n        \n\n        if (text.indexOf('?') == NOT_FOUND && text.indexOf('*') == NOT_FOUND) {\n            return new String[] { text };\n        }\n\n        final char[] array = text.toCharArray();\n        final ArrayList<String> list = new ArrayList<>();\n        final StringBuilder buffer = new StringBuilder();\n        char prevChar = 0;\n        for (final char ch : array) {\n            if (ch == '?' || ch == '*') {\n                if (buffer.length() != 0) {\n                    list.add(buffer.toString());\n                    buffer.setLength(0);\n                }\n                if (ch == '?') {\n                    list.add(\"?\");\n                } else if (prevChar != '*') {\n                    list.add(\"*\");\n                }\n            } else {\n                buffer.append(ch);\n            }\n            prevChar = ch;\n        }\n        if (buffer.length() != 0) {\n            list.add(buffer.toString());\n        }\n\n        return list.toArray( new String[ list.size() ] );\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 13,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/commons-io/commit/2736b6fe0b3fa22ec8e2b4184897ecadb021fc78",
    "cve_id": "CVE-2021-29425",
    "cwe_id": "CWE-20",
    "filename": "src/test/java/org/apache/commons/io/FilenameUtilsTestCase.java",
    "code": "\npackage org.apache.commons.io;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\nimport java.io.BufferedOutputStream;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\n\nimport org.apache.commons.io.testtools.TestUtils;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\nimport org.junit.Assert;\n\n\npublic class FilenameUtilsTestCase {\n\n    @Rule\n    public TemporaryFolder temporaryFolder = new TemporaryFolder();\n\n    private static final String SEP = \"\" + File.separatorChar;\n    private static final boolean WINDOWS = File.separatorChar == '\\\\';\n\n    private File testFile1;\n    private File testFile2;\n\n    private int testFile1Size;\n    private int testFile2Size;\n\n    @Before\n    public void setUp() throws Exception {\n        testFile1 = temporaryFolder.newFile(\"file1-test.txt\");\n        testFile2 = temporaryFolder.newFile(\"file1a-test.txt\");\n\n        testFile1Size = (int) testFile1.length();\n        testFile2Size = (int) testFile2.length();\n        if (!testFile1.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile1\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output3 =\n                new BufferedOutputStream(new FileOutputStream(testFile1))) {\n            TestUtils.generateTestData(output3, testFile1Size);\n        }\n        if (!testFile2.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile2\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output2 =\n                new BufferedOutputStream(new FileOutputStream(testFile2))) {\n            TestUtils.generateTestData(output2, testFile2Size);\n        }\n        if (!testFile1.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile1\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output1 =\n                new BufferedOutputStream(new FileOutputStream(testFile1))) {\n            TestUtils.generateTestData(output1, testFile1Size);\n        }\n        if (!testFile2.getParentFile().exists()) {\n            throw new IOException(\"Cannot create file \" + testFile2\n                    + \" as the parent directory does not exist\");\n        }\n        try (final BufferedOutputStream output =\n                new BufferedOutputStream(new FileOutputStream(testFile2))) {\n            TestUtils.generateTestData(output, testFile2Size);\n        }\n    }\n\n    \n    @Test\n    public void testNormalize() throws Exception {\n        assertEquals(null, FilenameUtils.normalize(null));\n        assertEquals(null, FilenameUtils.normalize(\":\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:\"));\n        assertEquals(null, FilenameUtils.normalize(\"1:a\"));\n        assertEquals(null, FilenameUtils.normalize(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalize(\"\\\\\\\\a\"));\n\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\\\a\\\\b/c.txt\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"C:\\\\a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"\" + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\\\\\\\server\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"~\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"~user\\\\a\\\\b/c.txt\"));\n\n        assertEquals(\"a\" + SEP + \"c\", FilenameUtils.normalize(\"a/b/../c\"));\n        assertEquals(\"c\", FilenameUtils.normalize(\"a/b/../../c\"));\n        assertEquals(\"c\" + SEP, FilenameUtils.normalize(\"a/b/../../c/\"));\n        assertEquals(null, FilenameUtils.normalize(\"a/b/../../../c\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"a/b/..\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"a/b/../\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"a/b/../..\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"a/b/../../\"));\n        assertEquals(null, FilenameUtils.normalize(\"a/b/../../..\"));\n        assertEquals(\"a\" + SEP + \"d\", FilenameUtils.normalize(\"a/b/../c/../d\"));\n        assertEquals(\"a\" + SEP + \"d\" + SEP, FilenameUtils.normalize(\"a/b/../c/../d/\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"a/b//d\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"a/b/././.\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"a/b/./././\"));\n        assertEquals(\"a\" + SEP, FilenameUtils.normalize(\"./a/\"));\n        assertEquals(\"a\", FilenameUtils.normalize(\"./a\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"./\"));\n        assertEquals(\"\", FilenameUtils.normalize(\".\"));\n        assertEquals(null, FilenameUtils.normalize(\"../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"..\"));\n        assertEquals(\"\", FilenameUtils.normalize(\"\"));\n\n        assertEquals(SEP + \"a\", FilenameUtils.normalize(\"/a\"));\n        assertEquals(SEP + \"a\" + SEP, FilenameUtils.normalize(\"/a/\"));\n        assertEquals(SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"/a/b/../c\"));\n        assertEquals(SEP + \"c\", FilenameUtils.normalize(\"/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"/a/b/../../../c\"));\n        assertEquals(SEP + \"a\" + SEP, FilenameUtils.normalize(\"/a/b/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"/a/b/../../..\"));\n        assertEquals(SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"/a/b/../c/../d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"/a/b//d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"/a/b/././.\"));\n        assertEquals(SEP + \"a\", FilenameUtils.normalize(\"/./a\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/./\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalize(\"/\"));\n\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalize(\"~/a\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~/a/\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"~/a/b/../c\"));\n        assertEquals(\"~\" + SEP + \"c\", FilenameUtils.normalize(\"~/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/a/b/../../../c\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~/a/b/..\"));\n        assertEquals(\"~\" + SEP + \"\", FilenameUtils.normalize(\"~/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/a/b/../../..\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"~/a/b/../c/../d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"~/a/b//d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"~/a/b/././.\"));\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalize(\"~/./a\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/./\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"~/..\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~/\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalize(\"~\"));\n\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalize(\"~user/a\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~user/a/\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"~user/a/b/../c\"));\n        assertEquals(\"~user\" + SEP + \"c\", FilenameUtils.normalize(\"~user/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/a/b/../../../c\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"~user/a/b/..\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/a/b/../../..\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"~user/a/b/../c/../d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"~user/a/b//d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"~user/a/b/././.\"));\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalize(\"~user/./a\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/./\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalize(\"~user/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"~user/..\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalize(\"~user/\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalize(\"~user\"));\n\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalize(\"C:/a\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"C:/a/\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"C:/a/b/../c\"));\n        assertEquals(\"C:\" + SEP + \"c\", FilenameUtils.normalize(\"C:/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/a/b/../../../c\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"C:/a/b/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/a/b/../../..\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"C:/a/b/../c/../d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"C:/a/b//d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"C:/a/b/././.\"));\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalize(\"C:/./a\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/./\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalize(\"C:/\"));\n\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalize(\"C:a\"));\n        assertEquals(\"C:\" + \"a\" + SEP, FilenameUtils.normalize(\"C:a/\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"C:a/b/../c\"));\n        assertEquals(\"C:\" + \"c\", FilenameUtils.normalize(\"C:a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:a/b/../../../c\"));\n        assertEquals(\"C:\" + \"a\" + SEP, FilenameUtils.normalize(\"C:a/b/..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:a/b/../../..\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"C:a/b/../c/../d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"C:a/b//d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"C:a/b/././.\"));\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalize(\"C:./a\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:./\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:.\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"C:..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalize(\"C:\"));\n\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalize(\"//server/a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"//server/a/\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalize(\"//server/a/b/../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"c\", FilenameUtils.normalize(\"//server/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/a/b/../../../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP, FilenameUtils.normalize(\"//server/a/b/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/a/b/../../..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalize(\"//server/a/b/../c/../d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalize(\"//server/a/b//d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP, FilenameUtils.normalize(\"//server/a/b/././.\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalize(\"//server/./a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/./\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/.\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/../a\"));\n        assertEquals(null, FilenameUtils.normalize(\"//server/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalize(\"//server/\"));\n    }\n\n    @Test\n    public void testNormalize_with_nullbytes() throws Exception {\n        try {\n            assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"a\\\\b/c\\u0000.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n        }\n\n        try {\n            assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalize(\"\\u0000a\\\\b/c.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testNormalizeUnixWin() throws Exception {\n\n        \n        assertEquals(\"/a/c/\", FilenameUtils.normalize(\"/a/b/../c/\", true));\n        assertEquals(\"/a/c/\", FilenameUtils.normalize(\"\\\\a\\\\b\\\\..\\\\c\\\\\", true));\n\n        \n        assertEquals(\"\\\\a\\\\c\\\\\", FilenameUtils.normalize(\"/a/b/../c/\", false));\n        assertEquals(\"\\\\a\\\\c\\\\\", FilenameUtils.normalize(\"\\\\a\\\\b\\\\..\\\\c\\\\\", false));\n    }\n\n    \n    @Test\n    public void testNormalizeNoEndSeparator() throws Exception {\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(null));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\":\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"1:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"1:\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"1:a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"\\\\\\\\a\"));\n\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"\\\\a\\\\b/c.txt\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"C:\\\\a\\\\b/c.txt\"));\n        assertEquals(\"\" + SEP + \"\" + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"\\\\\\\\server\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"~\\\\a\\\\b/c.txt\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"c.txt\", FilenameUtils.normalizeNoEndSeparator(\"~user\\\\a\\\\b/c.txt\"));\n\n        assertEquals(\"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../c\"));\n        assertEquals(\"c\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../../c\"));\n        assertEquals(\"c\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../../c/\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"a/b/../../../c\"));\n        assertEquals(\"a\", FilenameUtils.normalizeNoEndSeparator(\"a/b/..\"));\n        assertEquals(\"a\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../\"));\n        assertEquals(\"\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../..\"));\n        assertEquals(\"\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../../\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"a/b/../../..\"));\n        assertEquals(\"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../c/../d\"));\n        assertEquals(\"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"a/b/../c/../d/\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"a/b//d\"));\n        assertEquals(\"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"a/b/././.\"));\n        assertEquals(\"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"a/b/./././\"));\n        assertEquals(\"a\", FilenameUtils.normalizeNoEndSeparator(\"./a/\"));\n        assertEquals(\"a\", FilenameUtils.normalizeNoEndSeparator(\"./a\"));\n        assertEquals(\"\", FilenameUtils.normalizeNoEndSeparator(\"./\"));\n        assertEquals(\"\", FilenameUtils.normalizeNoEndSeparator(\".\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"..\"));\n        assertEquals(\"\", FilenameUtils.normalizeNoEndSeparator(\"\"));\n\n        assertEquals(SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"/a\"));\n        assertEquals(SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"/a/\"));\n        assertEquals(SEP + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../c\"));\n        assertEquals(SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"/a/b/../../../c\"));\n        assertEquals(SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"/a/b/../../..\"));\n        assertEquals(SEP + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../c/../d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"/a/b//d\"));\n        assertEquals(SEP + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/././.\"));\n        assertEquals(SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"/./a\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"/./\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"/.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"/../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"/..\"));\n        assertEquals(SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"/\"));\n\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~/a\"));\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~/a/\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../c\"));\n        assertEquals(\"~\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../../../c\"));\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/..\"));\n        assertEquals(\"~\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../../..\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/../c/../d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b//d\"));\n        assertEquals(\"~\" + SEP + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"~/a/b/././.\"));\n        assertEquals(\"~\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~/./a\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~/./\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~/.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~/../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~/..\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~/\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~\"));\n\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~user/a\"));\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../c\"));\n        assertEquals(\"~user\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../../../c\"));\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/..\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../../..\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/../c/../d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b//d\"));\n        assertEquals(\"~user\" + SEP + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"~user/a/b/././.\"));\n        assertEquals(\"~user\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"~user/./a\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"~user/./\"));\n        assertEquals(\"~user\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"~user/.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~user/../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"~user/..\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~user/\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.normalizeNoEndSeparator(\"~user\"));\n\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:/a\"));\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../c\"));\n        assertEquals(\"C:\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../../../c\"));\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../../..\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/../c/../d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b//d\"));\n        assertEquals(\"C:\" + SEP + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"C:/a/b/././.\"));\n        assertEquals(\"C:\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:/./a\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:/./\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:/.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:/../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:/..\"));\n        assertEquals(\"C:\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:/\"));\n\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:a\"));\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:a/\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../c\"));\n        assertEquals(\"C:\" + \"c\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../../../c\"));\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../../..\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/../c/../d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b//d\"));\n        assertEquals(\"C:\" + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"C:a/b/././.\"));\n        assertEquals(\"C:\" + \"a\", FilenameUtils.normalizeNoEndSeparator(\"C:./a\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:./\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"C:..\"));\n        assertEquals(\"C:\" + \"\", FilenameUtils.normalizeNoEndSeparator(\"C:\"));\n\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"//server/a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"c\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../../c\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../../../c\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../..\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../../..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/../c/../d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\" + SEP + \"d\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b//d\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\" + SEP + \"b\", FilenameUtils.normalizeNoEndSeparator(\"//server/a/b/././.\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"a\", FilenameUtils.normalizeNoEndSeparator(\"//server/./a\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"//server/./\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"//server/.\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"//server/../a\"));\n        assertEquals(null, FilenameUtils.normalizeNoEndSeparator(\"//server/..\"));\n        assertEquals(SEP + SEP + \"server\" + SEP + \"\", FilenameUtils.normalizeNoEndSeparator(\"//server/\"));\n    }\n\n    @Test\n    public void testNormalizeNoEndSeparatorUnixWin() throws Exception {\n\n        \n        assertEquals(\"/a/c\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../c/\", true));\n        assertEquals(\"/a/c\", FilenameUtils.normalizeNoEndSeparator(\"\\\\a\\\\b\\\\..\\\\c\\\\\", true));\n\n        \n        assertEquals(\"\\\\a\\\\c\", FilenameUtils.normalizeNoEndSeparator(\"/a/b/../c/\", false));\n        assertEquals(\"\\\\a\\\\c\", FilenameUtils.normalizeNoEndSeparator(\"\\\\a\\\\b\\\\..\\\\c\\\\\", false));\n    }\n\n    \n    @Test\n    public void testConcat() {\n        assertEquals(null, FilenameUtils.concat(\"\", null));\n        assertEquals(null, FilenameUtils.concat(null, null));\n        assertEquals(null, FilenameUtils.concat(null, \"\"));\n        assertEquals(null, FilenameUtils.concat(null, \"a\"));\n        assertEquals(SEP + \"a\", FilenameUtils.concat(null, \"/a\"));\n\n        assertEquals(null, FilenameUtils.concat(\"\", \":\")); \n        assertEquals(null, FilenameUtils.concat(\":\", \"\")); \n\n        assertEquals(\"f\" + SEP, FilenameUtils.concat(\"\", \"f/\"));\n        assertEquals(\"f\", FilenameUtils.concat(\"\", \"f\"));\n        assertEquals(\"a\" + SEP + \"f\" + SEP, FilenameUtils.concat(\"a/\", \"f/\"));\n        assertEquals(\"a\" + SEP + \"f\", FilenameUtils.concat(\"a\", \"f\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"f\" + SEP, FilenameUtils.concat(\"a/b/\", \"f/\"));\n        assertEquals(\"a\" + SEP + \"b\" + SEP + \"f\", FilenameUtils.concat(\"a/b\", \"f\"));\n\n        assertEquals(\"a\" + SEP + \"f\" + SEP, FilenameUtils.concat(\"a/b/\", \"../f/\"));\n        assertEquals(\"a\" + SEP + \"f\", FilenameUtils.concat(\"a/b\", \"../f\"));\n        assertEquals(\"a\" + SEP + \"c\" + SEP + \"g\" + SEP, FilenameUtils.concat(\"a/b/../c/\", \"f/../g/\"));\n        assertEquals(\"a\" + SEP + \"c\" + SEP + \"g\", FilenameUtils.concat(\"a/b/../c\", \"f/../g\"));\n\n        assertEquals(\"a\" + SEP + \"c.txt\" + SEP + \"f\", FilenameUtils.concat(\"a/c.txt\", \"f\"));\n\n        assertEquals(SEP + \"f\" + SEP, FilenameUtils.concat(\"\", \"/f/\"));\n        assertEquals(SEP + \"f\", FilenameUtils.concat(\"\", \"/f\"));\n        assertEquals(SEP + \"f\" + SEP, FilenameUtils.concat(\"a/\", \"/f/\"));\n        assertEquals(SEP + \"f\", FilenameUtils.concat(\"a\", \"/f\"));\n\n        assertEquals(SEP + \"c\" + SEP + \"d\", FilenameUtils.concat(\"a/b/\", \"/c/d\"));\n        assertEquals(\"C:c\" + SEP + \"d\", FilenameUtils.concat(\"a/b/\", \"C:c/d\"));\n        assertEquals(\"C:\" + SEP + \"c\" + SEP + \"d\", FilenameUtils.concat(\"a/b/\", \"C:/c/d\"));\n        assertEquals(\"~\" + SEP + \"c\" + SEP + \"d\", FilenameUtils.concat(\"a/b/\", \"~/c/d\"));\n        assertEquals(\"~user\" + SEP + \"c\" + SEP + \"d\", FilenameUtils.concat(\"a/b/\", \"~user/c/d\"));\n        assertEquals(\"~\" + SEP, FilenameUtils.concat(\"a/b/\", \"~\"));\n        assertEquals(\"~user\" + SEP, FilenameUtils.concat(\"a/b/\", \"~user\"));\n    }\n\n    \n    @Test\n    public void testSeparatorsToUnix() {\n        assertEquals(null, FilenameUtils.separatorsToUnix(null));\n        assertEquals(\"/a/b/c\", FilenameUtils.separatorsToUnix(\"/a/b/c\"));\n        assertEquals(\"/a/b/c.txt\", FilenameUtils.separatorsToUnix(\"/a/b/c.txt\"));\n        assertEquals(\"/a/b/c\", FilenameUtils.separatorsToUnix(\"/a/b\\\\c\"));\n        assertEquals(\"/a/b/c\", FilenameUtils.separatorsToUnix(\"\\\\a\\\\b\\\\c\"));\n        assertEquals(\"D:/a/b/c\", FilenameUtils.separatorsToUnix(\"D:\\\\a\\\\b\\\\c\"));\n    }\n\n    @Test\n    public void testSeparatorsToWindows() {\n        assertEquals(null, FilenameUtils.separatorsToWindows(null));\n        assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToWindows(\"\\\\a\\\\b\\\\c\"));\n        assertEquals(\"\\\\a\\\\b\\\\c.txt\", FilenameUtils.separatorsToWindows(\"\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToWindows(\"\\\\a\\\\b/c\"));\n        assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToWindows(\"/a/b/c\"));\n        assertEquals(\"D:\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToWindows(\"D:/a/b/c\"));\n    }\n\n    @Test\n    public void testSeparatorsToSystem() {\n        if (WINDOWS) {\n            assertEquals(null, FilenameUtils.separatorsToSystem(null));\n            assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToSystem(\"\\\\a\\\\b\\\\c\"));\n            assertEquals(\"\\\\a\\\\b\\\\c.txt\", FilenameUtils.separatorsToSystem(\"\\\\a\\\\b\\\\c.txt\"));\n            assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToSystem(\"\\\\a\\\\b/c\"));\n            assertEquals(\"\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToSystem(\"/a/b/c\"));\n            assertEquals(\"D:\\\\a\\\\b\\\\c\", FilenameUtils.separatorsToSystem(\"D:/a/b/c\"));\n        } else {\n            assertEquals(null, FilenameUtils.separatorsToSystem(null));\n            assertEquals(\"/a/b/c\", FilenameUtils.separatorsToSystem(\"/a/b/c\"));\n            assertEquals(\"/a/b/c.txt\", FilenameUtils.separatorsToSystem(\"/a/b/c.txt\"));\n            assertEquals(\"/a/b/c\", FilenameUtils.separatorsToSystem(\"/a/b\\\\c\"));\n            assertEquals(\"/a/b/c\", FilenameUtils.separatorsToSystem(\"\\\\a\\\\b\\\\c\"));\n            assertEquals(\"D:/a/b/c\", FilenameUtils.separatorsToSystem(\"D:\\\\a\\\\b\\\\c\"));\n        }\n    }\n\n    \n    @Test\n    public void testGetPrefixLength() {\n        assertEquals(-1, FilenameUtils.getPrefixLength(null));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\":\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"1:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"1:\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"1:a\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"\\\\\\\\a\"));\n\n        assertEquals(0, FilenameUtils.getPrefixLength(\"\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"C:\"));\n        assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\\"));\n        assertEquals(9, FilenameUtils.getPrefixLength(\"//server/\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"~\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"~/\"));\n        assertEquals(6, FilenameUtils.getPrefixLength(\"~user\"));\n        assertEquals(6, FilenameUtils.getPrefixLength(\"~user/\"));\n\n        assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"C:a\\\\b\\\\c.txt\"));\n        assertEquals(3, FilenameUtils.getPrefixLength(\"C:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(9, FilenameUtils.getPrefixLength(\"\\\\\\\\server\\\\a\\\\b\\\\c.txt\"));\n\n        assertEquals(0, FilenameUtils.getPrefixLength(\"a/b/c.txt\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"/a/b/c.txt\"));\n        assertEquals(3, FilenameUtils.getPrefixLength(\"C:/a/b/c.txt\"));\n        assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"~/a/b/c.txt\"));\n        assertEquals(6, FilenameUtils.getPrefixLength(\"~user/a/b/c.txt\"));\n\n        assertEquals(0, FilenameUtils.getPrefixLength(\"a\\\\b\\\\c.txt\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(2, FilenameUtils.getPrefixLength(\"~\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(6, FilenameUtils.getPrefixLength(\"~user\\\\a\\\\b\\\\c.txt\"));\n\n        assertEquals(9, FilenameUtils.getPrefixLength(\"//server/a/b/c.txt\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(-1, FilenameUtils.getPrefixLength(\"///a/b/c.txt\"));\n\n        assertEquals(1, FilenameUtils.getPrefixLength(\"/:foo\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"/:/\"));\n        assertEquals(1, FilenameUtils.getPrefixLength(\"/:::::::.txt\"));\n    }\n\n    @Test\n    public void testIndexOfLastSeparator() {\n        assertEquals(-1, FilenameUtils.indexOfLastSeparator(null));\n        assertEquals(-1, FilenameUtils.indexOfLastSeparator(\"noseperator.inthispath\"));\n        assertEquals(3, FilenameUtils.indexOfLastSeparator(\"a/b/c\"));\n        assertEquals(3, FilenameUtils.indexOfLastSeparator(\"a\\\\b\\\\c\"));\n    }\n\n    @Test\n    public void testIndexOfExtension() {\n        assertEquals(-1, FilenameUtils.indexOfExtension(null));\n        assertEquals(-1, FilenameUtils.indexOfExtension(\"file\"));\n        assertEquals(4, FilenameUtils.indexOfExtension(\"file.txt\"));\n        assertEquals(13, FilenameUtils.indexOfExtension(\"a.txt/b.txt/c.txt\"));\n        assertEquals(-1, FilenameUtils.indexOfExtension(\"a/b/c\"));\n        assertEquals(-1, FilenameUtils.indexOfExtension(\"a\\\\b\\\\c\"));\n        assertEquals(-1, FilenameUtils.indexOfExtension(\"a/b.notextension/c\"));\n        assertEquals(-1, FilenameUtils.indexOfExtension(\"a\\\\b.notextension\\\\c\"));\n\n        if (FilenameUtils.isSystemWindows()) {\n            \n        \ttry {\n        \t\tFilenameUtils.indexOfExtension(\"foo.exe:bar.txt\");\n        \t\tthrow new AssertionError(\"Expected Exception\");\n        \t} catch (IllegalArgumentException e) {\n        \t\tassertEquals(\"NTFS ADS separator (':') in file name is forbidden.\", e.getMessage());\n        \t}\n        } else {\n        \t\n        \tassertEquals(11, FilenameUtils.indexOfExtension(\"foo.exe:bar.txt\"));\n        }\n\n    }\n\n    \n    @Test\n    public void testGetPrefix() {\n        assertEquals(null, FilenameUtils.getPrefix(null));\n        assertEquals(null, FilenameUtils.getPrefix(\":\"));\n        assertEquals(null, FilenameUtils.getPrefix(\"1:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.getPrefix(\"1:\"));\n        assertEquals(null, FilenameUtils.getPrefix(\"1:a\"));\n        assertEquals(null, FilenameUtils.getPrefix(\"\\\\\\\\\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(null, FilenameUtils.getPrefix(\"\\\\\\\\a\"));\n\n        assertEquals(\"\", FilenameUtils.getPrefix(\"\"));\n        assertEquals(\"\\\\\", FilenameUtils.getPrefix(\"\\\\\"));\n        assertEquals(\"C:\", FilenameUtils.getPrefix(\"C:\"));\n        assertEquals(\"C:\\\\\", FilenameUtils.getPrefix(\"C:\\\\\"));\n        assertEquals(\"//server/\", FilenameUtils.getPrefix(\"//server/\"));\n        assertEquals(\"~/\", FilenameUtils.getPrefix(\"~\"));\n        assertEquals(\"~/\", FilenameUtils.getPrefix(\"~/\"));\n        assertEquals(\"~user/\", FilenameUtils.getPrefix(\"~user\"));\n        assertEquals(\"~user/\", FilenameUtils.getPrefix(\"~user/\"));\n\n        assertEquals(\"\", FilenameUtils.getPrefix(\"a\\\\b\\\\c.txt\"));\n        assertEquals(\"\\\\\", FilenameUtils.getPrefix(\"\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(\"C:\\\\\", FilenameUtils.getPrefix(\"C:\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(\"\\\\\\\\server\\\\\", FilenameUtils.getPrefix(\"\\\\\\\\server\\\\a\\\\b\\\\c.txt\"));\n\n        assertEquals(\"\", FilenameUtils.getPrefix(\"a/b/c.txt\"));\n        assertEquals(\"/\", FilenameUtils.getPrefix(\"/a/b/c.txt\"));\n        assertEquals(\"C:/\", FilenameUtils.getPrefix(\"C:/a/b/c.txt\"));\n        assertEquals(\"//server/\", FilenameUtils.getPrefix(\"//server/a/b/c.txt\"));\n        assertEquals(\"~/\", FilenameUtils.getPrefix(\"~/a/b/c.txt\"));\n        assertEquals(\"~user/\", FilenameUtils.getPrefix(\"~user/a/b/c.txt\"));\n\n        assertEquals(\"\", FilenameUtils.getPrefix(\"a\\\\b\\\\c.txt\"));\n        assertEquals(\"\\\\\", FilenameUtils.getPrefix(\"\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(\"~\\\\\", FilenameUtils.getPrefix(\"~\\\\a\\\\b\\\\c.txt\"));\n        assertEquals(\"~user\\\\\", FilenameUtils.getPrefix(\"~user\\\\a\\\\b\\\\c.txt\"));\n    }\n\n    @Test\n    public void testGetPrefix_with_nullbyte() {\n        try {\n            assertEquals(\"~user\\\\\", FilenameUtils.getPrefix(\"~u\\u0000ser\\\\a\\\\b\\\\c.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n\n        }\n    }\n\n    @Test\n    public void testGetPath() {\n        assertEquals(null, FilenameUtils.getPath(null));\n        assertEquals(\"\", FilenameUtils.getPath(\"noseperator.inthispath\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"/noseperator.inthispath\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"\\\\noseperator.inthispath\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"a/b/c\"));\n        assertEquals(\"a/b/c/\", FilenameUtils.getPath(\"a/b/c/\"));\n        assertEquals(\"a\\\\b\\\\\", FilenameUtils.getPath(\"a\\\\b\\\\c\"));\n\n        assertEquals(null, FilenameUtils.getPath(\":\"));\n        assertEquals(null, FilenameUtils.getPath(\"1:/a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getPath(\"1:\"));\n        assertEquals(null, FilenameUtils.getPath(\"1:a\"));\n        assertEquals(null, FilenameUtils.getPath(\"///a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getPath(\"//a\"));\n\n        assertEquals(\"\", FilenameUtils.getPath(\"\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"C:\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"C:/\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"//server/\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"~\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"~/\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"~user\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"~user/\"));\n\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"/a/b/c.txt\"));\n        assertEquals(\"\", FilenameUtils.getPath(\"C:a\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"C:a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"C:/a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"//server/a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"~/a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"~user/a/b/c.txt\"));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testGetPath_with_nullbyte() {\n        assertEquals(\"a/b/\", FilenameUtils.getPath(\"~user/a/\\u0000b/c.txt\"));\n    }\n\n\n    @Test\n    public void testGetPathNoEndSeparator() {\n        assertEquals(null, FilenameUtils.getPath(null));\n        assertEquals(\"\", FilenameUtils.getPath(\"noseperator.inthispath\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"/noseperator.inthispath\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"\\\\noseperator.inthispath\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"a/b/c\"));\n        assertEquals(\"a/b/c\", FilenameUtils.getPathNoEndSeparator(\"a/b/c/\"));\n        assertEquals(\"a\\\\b\", FilenameUtils.getPathNoEndSeparator(\"a\\\\b\\\\c\"));\n\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\":\"));\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\"1:/a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\"1:\"));\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\"1:a\"));\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\"///a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getPathNoEndSeparator(\"//a\"));\n\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"C:\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"C:/\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"//server/\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"~\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"~/\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"~user\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"~user/\"));\n\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"/a/b/c.txt\"));\n        assertEquals(\"\", FilenameUtils.getPathNoEndSeparator(\"C:a\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"C:a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"C:/a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"//server/a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"~/a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"~user/a/b/c.txt\"));\n    }\n\n    @Test\n    public void testGetPathNoEndSeparator_with_null_byte() {\n        try {\n            assertEquals(\"a/b\", FilenameUtils.getPathNoEndSeparator(\"~user/a\\u0000/b/c.txt\"));\n        } catch (final IllegalArgumentException ignore) {\n\n        }\n    }\n\n    @Test\n    public void testGetFullPath() {\n        assertEquals(null, FilenameUtils.getFullPath(null));\n        assertEquals(\"\", FilenameUtils.getFullPath(\"noseperator.inthispath\"));\n        assertEquals(\"a/b/\", FilenameUtils.getFullPath(\"a/b/c.txt\"));\n        assertEquals(\"a/b/\", FilenameUtils.getFullPath(\"a/b/c\"));\n        assertEquals(\"a/b/c/\", FilenameUtils.getFullPath(\"a/b/c/\"));\n        assertEquals(\"a\\\\b\\\\\", FilenameUtils.getFullPath(\"a\\\\b\\\\c\"));\n\n        assertEquals(null, FilenameUtils.getFullPath(\":\"));\n        assertEquals(null, FilenameUtils.getFullPath(\"1:/a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getFullPath(\"1:\"));\n        assertEquals(null, FilenameUtils.getFullPath(\"1:a\"));\n        assertEquals(null, FilenameUtils.getFullPath(\"///a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getFullPath(\"//a\"));\n\n        assertEquals(\"\", FilenameUtils.getFullPath(\"\"));\n        assertEquals(\"C:\", FilenameUtils.getFullPath(\"C:\"));\n        assertEquals(\"C:/\", FilenameUtils.getFullPath(\"C:/\"));\n        assertEquals(\"//server/\", FilenameUtils.getFullPath(\"//server/\"));\n        assertEquals(\"~/\", FilenameUtils.getFullPath(\"~\"));\n        assertEquals(\"~/\", FilenameUtils.getFullPath(\"~/\"));\n        assertEquals(\"~user/\", FilenameUtils.getFullPath(\"~user\"));\n        assertEquals(\"~user/\", FilenameUtils.getFullPath(\"~user/\"));\n\n        assertEquals(\"a/b/\", FilenameUtils.getFullPath(\"a/b/c.txt\"));\n        assertEquals(\"/a/b/\", FilenameUtils.getFullPath(\"/a/b/c.txt\"));\n        assertEquals(\"C:\", FilenameUtils.getFullPath(\"C:a\"));\n        assertEquals(\"C:a/b/\", FilenameUtils.getFullPath(\"C:a/b/c.txt\"));\n        assertEquals(\"C:/a/b/\", FilenameUtils.getFullPath(\"C:/a/b/c.txt\"));\n        assertEquals(\"//server/a/b/\", FilenameUtils.getFullPath(\"//server/a/b/c.txt\"));\n        assertEquals(\"~/a/b/\", FilenameUtils.getFullPath(\"~/a/b/c.txt\"));\n        assertEquals(\"~user/a/b/\", FilenameUtils.getFullPath(\"~user/a/b/c.txt\"));\n    }\n\n    @Test\n    public void testGetFullPathNoEndSeparator() {\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(null));\n        assertEquals(\"\", FilenameUtils.getFullPathNoEndSeparator(\"noseperator.inthispath\"));\n        assertEquals(\"a/b\", FilenameUtils.getFullPathNoEndSeparator(\"a/b/c.txt\"));\n        assertEquals(\"a/b\", FilenameUtils.getFullPathNoEndSeparator(\"a/b/c\"));\n        assertEquals(\"a/b/c\", FilenameUtils.getFullPathNoEndSeparator(\"a/b/c/\"));\n        assertEquals(\"a\\\\b\", FilenameUtils.getFullPathNoEndSeparator(\"a\\\\b\\\\c\"));\n\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\":\"));\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\"1:/a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\"1:\"));\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\"1:a\"));\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\"///a/b/c.txt\"));\n        assertEquals(null, FilenameUtils.getFullPathNoEndSeparator(\"//a\"));\n\n        assertEquals(\"\", FilenameUtils.getFullPathNoEndSeparator(\"\"));\n        assertEquals(\"C:\", FilenameUtils.getFullPathNoEndSeparator(\"C:\"));\n        assertEquals(\"C:/\", FilenameUtils.getFullPathNoEndSeparator(\"C:/\"));\n        assertEquals(\"//server/\", FilenameUtils.getFullPathNoEndSeparator(\"//server/\"));\n        assertEquals(\"~\", FilenameUtils.getFullPathNoEndSeparator(\"~\"));\n        assertEquals(\"~/\", FilenameUtils.getFullPathNoEndSeparator(\"~/\"));\n        assertEquals(\"~user\", FilenameUtils.getFullPathNoEndSeparator(\"~user\"));\n        assertEquals(\"~user/\", FilenameUtils.getFullPathNoEndSeparator(\"~user/\"));\n\n        assertEquals(\"a/b\", FilenameUtils.getFullPathNoEndSeparator(\"a/b/c.txt\"));\n        assertEquals(\"/a/b\", FilenameUtils.getFullPathNoEndSeparator(\"/a/b/c.txt\"));\n        assertEquals(\"C:\", FilenameUtils.getFullPathNoEndSeparator(\"C:a\"));\n        assertEquals(\"C:a/b\", FilenameUtils.getFullPathNoEndSeparator(\"C:a/b/c.txt\"));\n        assertEquals(\"C:/a/b\", FilenameUtils.getFullPathNoEndSeparator(\"C:/a/b/c.txt\"));\n        assertEquals(\"//server/a/b\", FilenameUtils.getFullPathNoEndSeparator(\"//server/a/b/c.txt\"));\n        assertEquals(\"~/a/b\", FilenameUtils.getFullPathNoEndSeparator(\"~/a/b/c.txt\"));\n        assertEquals(\"~user/a/b\", FilenameUtils.getFullPathNoEndSeparator(\"~user/a/b/c.txt\"));\n    }\n\n    \n    @Test\n    public void testGetFullPathNoEndSeparator_IO_248() {\n\n        \n        assertEquals(\"/\", FilenameUtils.getFullPathNoEndSeparator(\"/\"));\n        assertEquals(\"\\\\\", FilenameUtils.getFullPathNoEndSeparator(\"\\\\\"));\n\n        \n        assertEquals(\"/\", FilenameUtils.getFullPathNoEndSeparator(\"/abc\"));\n        assertEquals(\"\\\\\", FilenameUtils.getFullPathNoEndSeparator(\"\\\\abc\"));\n\n        \n        assertEquals(\"/abc\", FilenameUtils.getFullPathNoEndSeparator(\"/abc/xyz\"));\n        assertEquals(\"\\\\abc\", FilenameUtils.getFullPathNoEndSeparator(\"\\\\abc\\\\xyz\"));\n    }\n\n    @Test\n    public void testGetName() {\n        assertEquals(null, FilenameUtils.getName(null));\n        assertEquals(\"noseperator.inthispath\", FilenameUtils.getName(\"noseperator.inthispath\"));\n        assertEquals(\"c.txt\", FilenameUtils.getName(\"a/b/c.txt\"));\n        assertEquals(\"c\", FilenameUtils.getName(\"a/b/c\"));\n        assertEquals(\"\", FilenameUtils.getName(\"a/b/c/\"));\n        assertEquals(\"c\", FilenameUtils.getName(\"a\\\\b\\\\c\"));\n    }\n\n    @Test\n    public void testInjectionFailure() {\n        try {\n            assertEquals(\"c\", FilenameUtils.getName(\"a\\\\b\\\\\\u0000c\"));\n        } catch (final IllegalArgumentException ignore) {\n\n        }\n    }\n\n    @Test\n    public void testGetBaseName() {\n        assertEquals(null, FilenameUtils.getBaseName(null));\n        assertEquals(\"noseperator\", FilenameUtils.getBaseName(\"noseperator.inthispath\"));\n        assertEquals(\"c\", FilenameUtils.getBaseName(\"a/b/c.txt\"));\n        assertEquals(\"c\", FilenameUtils.getBaseName(\"a/b/c\"));\n        assertEquals(\"\", FilenameUtils.getBaseName(\"a/b/c/\"));\n        assertEquals(\"c\", FilenameUtils.getBaseName(\"a\\\\b\\\\c\"));\n        assertEquals(\"file.txt\", FilenameUtils.getBaseName(\"file.txt.bak\"));\n    }\n\n    @Test\n    public void testGetBaseName_with_nullByte() {\n        try {\n            assertEquals(\"file.txt\", FilenameUtils.getBaseName(\"fil\\u0000e.txt.bak\"));\n        } catch (final IllegalArgumentException ignore) {\n\n        }\n    }\n\n    @Test\n    public void testGetExtension() {\n        assertEquals(null, FilenameUtils.getExtension(null));\n        assertEquals(\"ext\", FilenameUtils.getExtension(\"file.ext\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"README\"));\n        assertEquals(\"com\", FilenameUtils.getExtension(\"domain.dot.com\"));\n        assertEquals(\"jpeg\", FilenameUtils.getExtension(\"image.jpeg\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"a.b/c\"));\n        assertEquals(\"txt\", FilenameUtils.getExtension(\"a.b/c.txt\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"a/b/c\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"a.b\\\\c\"));\n        assertEquals(\"txt\", FilenameUtils.getExtension(\"a.b\\\\c.txt\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"a\\\\b\\\\c\"));\n        assertEquals(\"\", FilenameUtils.getExtension(\"C:\\\\temp\\\\foo.bar\\\\README\"));\n        assertEquals(\"ext\", FilenameUtils.getExtension(\"../filename.ext\"));\n\n        if (FilenameUtils.isSystemWindows()) {\n            \n        \ttry {\n        \t\tFilenameUtils.getExtension(\"foo.exe:bar.txt\");\n        \t\tthrow new AssertionError(\"Expected Exception\");\n        \t} catch (IllegalArgumentException e) {\n        \t\tassertEquals(\"NTFS ADS separator (':') in file name is forbidden.\", e.getMessage());\n        \t}\n        } else {\n        \t\n        \tassertEquals(\"txt\", FilenameUtils.getExtension(\"foo.exe:bar.txt\"));\n        }\n    }\n\n    @Test\n    public void testRemoveExtension() {\n        assertEquals(null, FilenameUtils.removeExtension(null));\n        assertEquals(\"file\", FilenameUtils.removeExtension(\"file.ext\"));\n        assertEquals(\"README\", FilenameUtils.removeExtension(\"README\"));\n        assertEquals(\"domain.dot\", FilenameUtils.removeExtension(\"domain.dot.com\"));\n        assertEquals(\"image\", FilenameUtils.removeExtension(\"image.jpeg\"));\n        assertEquals(\"a.b/c\", FilenameUtils.removeExtension(\"a.b/c\"));\n        assertEquals(\"a.b/c\", FilenameUtils.removeExtension(\"a.b/c.txt\"));\n        assertEquals(\"a/b/c\", FilenameUtils.removeExtension(\"a/b/c\"));\n        assertEquals(\"a.b\\\\c\", FilenameUtils.removeExtension(\"a.b\\\\c\"));\n        assertEquals(\"a.b\\\\c\", FilenameUtils.removeExtension(\"a.b\\\\c.txt\"));\n        assertEquals(\"a\\\\b\\\\c\", FilenameUtils.removeExtension(\"a\\\\b\\\\c\"));\n        assertEquals(\"C:\\\\temp\\\\foo.bar\\\\README\", FilenameUtils.removeExtension(\"C:\\\\temp\\\\foo.bar\\\\README\"));\n        assertEquals(\"../filename\", FilenameUtils.removeExtension(\"../filename.ext\"));\n    }\n\n    \n    @Test\n    public void testEquals() {\n        assertTrue(FilenameUtils.equals(null, null));\n        assertFalse(FilenameUtils.equals(null, \"\"));\n        assertFalse(FilenameUtils.equals(\"\", null));\n        assertTrue(FilenameUtils.equals(\"\", \"\"));\n        assertTrue(FilenameUtils.equals(\"file.txt\", \"file.txt\"));\n        assertFalse(FilenameUtils.equals(\"file.txt\", \"FILE.TXT\"));\n        assertFalse(FilenameUtils.equals(\"a\\\\b\\\\file.txt\", \"a/b/file.txt\"));\n    }\n\n    @Test\n    public void testEqualsOnSystem() {\n        assertTrue(FilenameUtils.equalsOnSystem(null, null));\n        assertFalse(FilenameUtils.equalsOnSystem(null, \"\"));\n        assertFalse(FilenameUtils.equalsOnSystem(\"\", null));\n        assertTrue(FilenameUtils.equalsOnSystem(\"\", \"\"));\n        assertTrue(FilenameUtils.equalsOnSystem(\"file.txt\", \"file.txt\"));\n        assertEquals(WINDOWS, FilenameUtils.equalsOnSystem(\"file.txt\", \"FILE.TXT\"));\n        assertFalse(FilenameUtils.equalsOnSystem(\"a\\\\b\\\\file.txt\", \"a/b/file.txt\"));\n    }\n\n    \n    @Test\n    public void testEqualsNormalized() {\n        assertTrue(FilenameUtils.equalsNormalized(null, null));\n        assertFalse(FilenameUtils.equalsNormalized(null, \"\"));\n        assertFalse(FilenameUtils.equalsNormalized(\"\", null));\n        assertTrue(FilenameUtils.equalsNormalized(\"\", \"\"));\n        assertTrue(FilenameUtils.equalsNormalized(\"file.txt\", \"file.txt\"));\n        assertFalse(FilenameUtils.equalsNormalized(\"file.txt\", \"FILE.TXT\"));\n        assertTrue(FilenameUtils.equalsNormalized(\"a\\\\b\\\\file.txt\", \"a/b/file.txt\"));\n        assertFalse(FilenameUtils.equalsNormalized(\"a/b/\", \"a/b\"));\n    }\n\n    @Test\n    public void testEqualsNormalizedOnSystem() {\n        assertTrue(FilenameUtils.equalsNormalizedOnSystem(null, null));\n        assertFalse(FilenameUtils.equalsNormalizedOnSystem(null, \"\"));\n        assertFalse(FilenameUtils.equalsNormalizedOnSystem(\"\", null));\n        assertTrue(FilenameUtils.equalsNormalizedOnSystem(\"\", \"\"));\n        assertTrue(FilenameUtils.equalsNormalizedOnSystem(\"file.txt\", \"file.txt\"));\n        assertEquals(WINDOWS, FilenameUtils.equalsNormalizedOnSystem(\"file.txt\", \"FILE.TXT\"));\n        assertTrue(FilenameUtils.equalsNormalizedOnSystem(\"a\\\\b\\\\file.txt\", \"a/b/file.txt\"));\n        assertFalse(FilenameUtils.equalsNormalizedOnSystem(\"a/b/\", \"a/b\"));\n    }\n\n    \n    @Test\n    public void testEqualsNormalizedError_IO_128() {\n        try {\n            FilenameUtils.equalsNormalizedOnSystem(\"//file.txt\", \"file.txt\");\n            fail(\"Invalid normalized first file\");\n        } catch (final NullPointerException e) {\n            \n        }\n        try {\n            FilenameUtils.equalsNormalizedOnSystem(\"file.txt\", \"//file.txt\");\n            fail(\"Invalid normalized second file\");\n        } catch (final NullPointerException e) {\n            \n        }\n        try {\n            FilenameUtils.equalsNormalizedOnSystem(\"//file.txt\", \"//file.txt\");\n            fail(\"Invalid normalized both filse\");\n        } catch (final NullPointerException e) {\n            \n        }\n    }\n\n    @Test\n    public void testEquals_fullControl() {\n        assertFalse(FilenameUtils.equals(\"file.txt\", \"FILE.TXT\", true, IOCase.SENSITIVE));\n        assertTrue(FilenameUtils.equals(\"file.txt\", \"FILE.TXT\", true, IOCase.INSENSITIVE));\n        assertEquals(WINDOWS, FilenameUtils.equals(\"file.txt\", \"FILE.TXT\", true, IOCase.SYSTEM));\n        assertFalse(FilenameUtils.equals(\"file.txt\", \"FILE.TXT\", true, null));\n    }\n\n    \n    @Test\n    public void testIsExtension() {\n        assertFalse(FilenameUtils.isExtension(null, (String) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", (String) null));\n        assertTrue(FilenameUtils.isExtension(\"file\", (String) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"file\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"file.txt\", \"txt\"));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", \"rtf\"));\n\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", (String) null));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"a/b/file.txt\", \"txt\"));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", \"rtf\"));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", (String) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"a.b/file.txt\", \"txt\"));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", \"rtf\"));\n\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", (String) null));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", \"txt\"));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", \"rtf\"));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", (String) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", \"\"));\n        assertTrue(FilenameUtils.isExtension(\"a.b\\\\file.txt\", \"txt\"));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", \"rtf\"));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", \"TXT\"));\n    }\n\n    @Test\n    public void testIsExtension_injection() {\n        try {\n            FilenameUtils.isExtension(\"a.b\\\\fi\\u0000le.txt\", \"TXT\");\n            fail(\"Should throw IAE\");\n        } catch (final IllegalArgumentException ignore) {\n        }\n    }\n\n    @Test\n    public void testIsExtensionArray() {\n        assertFalse(FilenameUtils.isExtension(null, (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", (String[]) null));\n        assertTrue(FilenameUtils.isExtension(\"file\", (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", new String[0]));\n        assertTrue(FilenameUtils.isExtension(\"file.txt\", new String[]{\"txt\"}));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", new String[]{\"rtf\"}));\n        assertTrue(FilenameUtils.isExtension(\"file\", new String[]{\"rtf\", \"\"}));\n        assertTrue(FilenameUtils.isExtension(\"file.txt\", new String[]{\"rtf\", \"txt\"}));\n\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", new String[0]));\n        assertTrue(FilenameUtils.isExtension(\"a/b/file.txt\", new String[]{\"txt\"}));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", new String[]{\"rtf\"}));\n        assertTrue(FilenameUtils.isExtension(\"a/b/file.txt\", new String[]{\"rtf\", \"txt\"}));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", new String[0]));\n        assertTrue(FilenameUtils.isExtension(\"a.b/file.txt\", new String[]{\"txt\"}));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", new String[]{\"rtf\"}));\n        assertTrue(FilenameUtils.isExtension(\"a.b/file.txt\", new String[]{\"rtf\", \"txt\"}));\n\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new String[0]));\n        assertTrue(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new String[]{\"txt\"}));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new String[]{\"rtf\"}));\n        assertTrue(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new String[]{\"rtf\", \"txt\"}));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", (String[]) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[0]));\n        assertTrue(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[]{\"txt\"}));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[]{\"rtf\"}));\n        assertTrue(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[]{\"rtf\", \"txt\"}));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[]{\"TXT\"}));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new String[]{\"TXT\", \"RTF\"}));\n    }\n\n    @Test\n    public void testIsExtensionCollection() {\n        assertFalse(FilenameUtils.isExtension(null, (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", (Collection<String>) null));\n        assertTrue(FilenameUtils.isExtension(\"file\", (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", new ArrayList<String>()));\n        assertTrue(FilenameUtils.isExtension(\"file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"txt\"}))));\n        assertFalse(FilenameUtils.isExtension(\"file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\"}))));\n        assertTrue(FilenameUtils.isExtension(\"file\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"\"}))));\n        assertTrue(FilenameUtils.isExtension(\"file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"txt\"}))));\n\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", new ArrayList<String>()));\n        assertTrue(FilenameUtils.isExtension(\"a/b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"txt\"}))));\n        assertFalse(FilenameUtils.isExtension(\"a/b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\"}))));\n        assertTrue(FilenameUtils.isExtension(\"a/b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"txt\"}))));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", new ArrayList<String>()));\n        assertTrue(FilenameUtils.isExtension(\"a.b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"txt\"}))));\n        assertFalse(FilenameUtils.isExtension(\"a.b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\"}))));\n        assertTrue(FilenameUtils.isExtension(\"a.b/file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"txt\"}))));\n\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new ArrayList<String>()));\n        assertTrue(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"txt\"}))));\n        assertFalse(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\"}))));\n        assertTrue(FilenameUtils.isExtension(\"a\\\\b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"txt\"}))));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", (Collection<String>) null));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<String>()));\n        assertTrue(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"txt\"}))));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\"}))));\n        assertTrue(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"rtf\", \"txt\"}))));\n\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"TXT\"}))));\n        assertFalse(FilenameUtils.isExtension(\"a.b\\\\file.txt\", new ArrayList<>(Arrays.asList(new String[]{\"TXT\", \"RTF\"}))));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 14,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/cxf/commit/d9e2a6e7",
    "cve_id": "CVE-2016-8739",
    "cwe_id": "CWE-611",
    "filename": "rt/rs/extensions/providers/src/main/java/org/apache/cxf/jaxrs/provider/atom/AbstractAtomProvider.java",
    "code": "\n\npackage org.apache.cxf.jaxrs.provider.atom;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Type;\nimport java.util.logging.Logger;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.ext.MessageBodyReader;\nimport javax.ws.rs.ext.MessageBodyWriter;\n\nimport org.apache.abdera.Abdera;\nimport org.apache.abdera.model.Document;\nimport org.apache.abdera.model.Element;\nimport org.apache.abdera.parser.Parser;\nimport org.apache.abdera.parser.ParserOptions;\nimport org.apache.abdera.writer.Writer;\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.cxf.jaxrs.utils.ExceptionUtils;\n\npublic abstract class AbstractAtomProvider<T extends Element> \n    implements MessageBodyWriter<T>, MessageBodyReader<T> {\n\n    private static final Logger LOG = LogUtils.getL7dLogger(AbstractAtomProvider.class);\n    private static final Abdera ATOM_ENGINE = new Abdera();\n    private boolean autodetectCharset;\n    private boolean formattedOutput;\n    \n    public long getSize(T element, Class<?> type, Type genericType, Annotation[] annotations, MediaType mt) {\n        return -1;\n    }\n\n    public void writeTo(T element, Class<?> clazz, Type type, Annotation[] a, \n                        MediaType mt, MultivaluedMap<String, Object> headers, OutputStream os) \n        throws IOException {\n        if (MediaType.APPLICATION_JSON_TYPE.isCompatible(mt)) {\n            Writer w = createWriter(\"json\");\n            if (w == null) {\n                throw ExceptionUtils.toNotSupportedException(null, null);\n            }\n            element.writeTo(w, os);   \n        } else if (formattedOutput) {\n            Writer w = createWriter(\"prettyxml\");\n            if (w != null) {\n                element.writeTo(w, os);\n            } else {\n                element.writeTo(os);\n            }\n        } else {\n            element.writeTo(os);\n        }\n    }\n\n    protected Writer createWriter(String writerName) {\n        Writer w = ATOM_ENGINE.getWriterFactory().getWriter(writerName);\n        if (w == null) {\n            LOG.fine(\"Atom writer \\\"\" + writerName + \"\\\" is not available\");\n        }\n        return w;\n    }\n    \n    public T readFrom(Class<T> clazz, Type t, Annotation[] a, MediaType mt, \n                         MultivaluedMap<String, String> headers, InputStream is) \n        throws IOException {\n        Parser parser = ATOM_ENGINE.getParser();\n        synchronized (parser) {\n            ParserOptions options = parser.getDefaultParserOptions();\n            if (options != null) {\n                options.setAutodetectCharset(autodetectCharset);\n                options.setResolveEntities(false);\n            }\n        }\n        Document<T> doc = parser.parse(is);\n        return doc.getRoot();\n    }\n\n    public void setFormattedOutput(boolean formattedOutput) {\n        this.formattedOutput = formattedOutput;\n    }\n\n    public void setAutodetectCharset(boolean autodetectCharset) {\n        this.autodetectCharset = autodetectCharset;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 14,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/cxf/commit/d9e2a6e7",
    "cve_id": "CVE-2016-8739",
    "cwe_id": "CWE-611",
    "filename": "rt/rs/extensions/providers/src/test/java/org/apache/cxf/jaxrs/provider/atom/AtomPojoProviderTest.java",
    "code": "\npackage org.apache.cxf.jaxrs.provider.atom;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.StringReader;\nimport java.lang.annotation.Annotation;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.xml.bind.Unmarshaller;\nimport javax.xml.bind.annotation.XmlRootElement;\n\nimport org.apache.abdera.model.Entry;\nimport org.apache.abdera.model.Feed;\nimport org.apache.cxf.jaxrs.impl.MetadataMap;\nimport org.apache.cxf.jaxrs.provider.JAXBElementProvider;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\npublic class AtomPojoProviderTest extends Assert {\n\n    private ClassPathXmlApplicationContext ctx;\n    \n    @Before\n    public void setUp() {\n        ctx = \n            new ClassPathXmlApplicationContext(\n                new String[] {\"/org/apache/cxf/jaxrs/provider/atom/servers.xml\"});\n    }\n    \n    @Test\n    public void testWriteFeedWithBuilders() throws Exception {\n        AtomPojoProvider provider = (AtomPojoProvider)ctx.getBean(\"atom\");\n        assertNotNull(provider);\n        provider.setFormattedOutput(true);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        \n        Books books = new Books();\n        List<Book> bs = new ArrayList<Book>();\n        bs.add(new Book(\"a\"));\n        bs.add(new Book(\"b\"));\n        books.setBooks(bs);\n        provider.writeTo(books, Books.class, Books.class, new Annotation[]{},\n                         MediaType.valueOf(\"application/atom+xml\"), null, bos);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        Feed feed = new AtomFeedProvider().readFrom(Feed.class, null, null, null, null, bis);\n        assertEquals(\"Books\", feed.getTitle()); \n        List<Entry> entries = feed.getEntries();\n        assertEquals(2, entries.size());\n        verifyEntry(getEntry(entries, \"a\"), \"a\");\n        verifyEntry(getEntry(entries, \"b\"), \"b\");\n    }\n    \n    @Test\n    public void testWriteFeedWithBuildersNoJaxb() throws Exception {\n        AtomPojoProvider provider = (AtomPojoProvider)ctx.getBean(\"atomNoJaxb\");\n        assertNotNull(provider);\n        provider.setFormattedOutput(true);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        \n        Books books = new Books();\n        List<Book> bs = new ArrayList<Book>();\n        bs.add(new Book(\"a\"));\n        bs.add(new Book(\"b\"));\n        books.setBooks(bs);\n        provider.writeTo(books, Books.class, Books.class, new Annotation[]{},\n                         MediaType.valueOf(\"application/atom+xml\"), null, bos);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        Feed feed = new AtomFeedProvider().readFrom(Feed.class, null, null, null, null, bis);\n        assertEquals(\"Books\", feed.getTitle()); \n        List<Entry> entries = feed.getEntries();\n        assertEquals(2, entries.size());\n        \n        Entry entryA = getEntry(entries, \"a\");\n        verifyEntry(entryA, \"a\");\n        String entryAContent = entryA.getContent();\n        assertTrue(\"<a/>\".equals(entryAContent) || \"<a><a/>\".equals(entryAContent)\n                   || \"<a xmlns=\\\"\\\"/>\".equals(entryAContent));\n        \n        Entry entryB = getEntry(entries, \"b\");\n        verifyEntry(entryB, \"b\");\n        String entryBContent = entryB.getContent();\n        assertTrue(\"<b/>\".equals(entryBContent) || \"<b><b/>\".equals(entryBContent)\n                   || \"<b xmlns=\\\"\\\"/>\".equals(entryBContent));\n    }\n    \n    @Test\n    public void testWriteEntryWithBuilders() throws Exception {\n        AtomPojoProvider provider = (AtomPojoProvider)ctx.getBean(\"atom2\");\n        assertNotNull(provider);\n        provider.setFormattedOutput(true);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        provider.writeTo(new Book(\"a\"), Book.class, Book.class, new Annotation[]{},\n                         MediaType.valueOf(\"application/atom+xml;type=entry\"), null, bos);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        Entry entry = new AtomEntryProvider().readFrom(Entry.class, null, null, null, null, bis);\n        verifyEntry(entry, \"a\");\n        \n    }\n    \n    @Test\n    public void testReadEntryWithBuilders() throws Exception {\n        AtomPojoProvider provider = (AtomPojoProvider)ctx.getBean(\"atom3\");\n        assertNotNull(provider);\n        doTestReadEntry(provider);\n    }\n    \n    @Test\n    public void testReadEntryWithoutBuilders() throws Exception {\n        doTestReadEntry(new AtomPojoProvider());\n    }\n    \n    private void doTestReadEntry(AtomPojoProvider provider) throws Exception {\n        provider.setFormattedOutput(true);\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MediaType mt = MediaType.valueOf(\"application/atom+xml;type=entry\");\n        provider.writeTo(new Book(\"a\"), Book.class, Book.class, new Annotation[]{}, mt, null, bos);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        @SuppressWarnings({\"unchecked\", \"rawtypes\" })\n        Book book = (Book)provider.readFrom((Class)Book.class, Book.class, \n                                            new Annotation[]{}, mt, null, bis);\n        assertEquals(\"a\", book.getName());\n    }\n    \n    \n    @Test\n    public void testReadFeedWithBuilders() throws Exception {\n        AtomPojoProvider provider = (AtomPojoProvider)ctx.getBean(\"atom4\");\n        assertNotNull(provider);\n        doTestReadFeed(provider);\n    }\n    \n    @Test\n    public void testReadFeedWithoutBuilders() throws Exception {\n        AtomPojoProvider provider = new AtomPojoProvider();\n        doTestReadFeed(provider);\n    }\n\n    private void doTestReadFeed(AtomPojoProvider provider) throws Exception {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        MediaType mt = MediaType.valueOf(\"application/atom+xml;type=feed\");\n        Books books = new Books();\n        List<Book> bs = new ArrayList<Book>();\n        bs.add(new Book(\"a\"));\n        bs.add(new Book(\"b\"));\n        books.setBooks(bs);\n        provider.writeTo(books, Books.class, Books.class, new Annotation[]{}, mt, null, bos);\n        ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n        @SuppressWarnings({\"unchecked\", \"rawtypes\" })\n        Books books2 = (Books)provider.readFrom((Class)Books.class, Books.class, \n                                            new Annotation[]{}, mt, null, bis);\n        List<Book> list = books2.getBooks();\n        assertEquals(2, list.size());\n        assertTrue(\"a\".equals(list.get(0).getName()) || \"a\".equals(list.get(1).getName()));\n        assertTrue(\"b\".equals(list.get(0).getName()) || \"b\".equals(list.get(1).getName()));        \n    }\n     \n    @Test\n    public void testReadEntryNoContent() throws Exception {\n        \n        final String entryNoContent =\n            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" \n            + \"<entry xmlns=\\\"http://www.w3.org/2005/Atom\\\">\\n\" \n            + \"  <id>84297856</id>\\n\" \n            + \"</entry>\";\n\n        AtomPojoProvider atomPojoProvider = new AtomPojoProvider();\n        @SuppressWarnings({\n            \"rawtypes\", \"unchecked\"\n        })\n        JaxbDataType type = (JaxbDataType)atomPojoProvider.readFrom((Class)JaxbDataType.class,\n                                  JaxbDataType.class,\n                                  new Annotation[0],\n                                  MediaType.valueOf(\"application/atom+xml;type=entry\"),\n                                  new MetadataMap<String, String>(),\n                                  new ByteArrayInputStream(entryNoContent.getBytes(StandardCharsets.UTF_8)));\n        assertNull(type);\n    }\n    \n    @Test\n    public void testReadEntryWithUpperCaseTypeParam() throws Exception {\n        doReadEntryWithContent(\"application/atom+xml;type=ENTRY\");\n    }\n    \n    @Test\n    public void testReadEntryNoTypeParam() throws Exception {\n        doReadEntryWithContent(\"application/atom+xml\");\n    }\n    \n    private void doReadEntryWithContent(String mediaType) throws Exception {\n        final String entryWithContent =\n            \"<?xml version='1.0' encoding='UTF-8'?>\\n\" \n            + \"<entry xmlns=\\\"http://www.w3.org/2005/Atom\\\">\\n\" \n            + \"  <id>84297856</id>\\n\" \n            + \"  <content type=\\\"application/xml\\\">\\n\" \n            + \"    <jaxbDataType xmlns=\\\"\\\">\\n\" \n            + \"    </jaxbDataType>\\n\" \n            + \"  </content>\\n\" \n            + \"</entry>\";\n\n        AtomPojoProvider atomPojoProvider = new AtomPojoProvider();\n        @SuppressWarnings({\n            \"rawtypes\", \"unchecked\"\n        })\n        JaxbDataType type = (JaxbDataType)atomPojoProvider.readFrom((Class)JaxbDataType.class,\n                                  JaxbDataType.class,\n                                  new Annotation[0],\n                                  MediaType.valueOf(mediaType),\n                                  new MetadataMap<String, String>(),\n                                  new ByteArrayInputStream(entryWithContent.getBytes(StandardCharsets.UTF_8)));\n        assertNotNull(type);\n    }\n    \n    \n    @XmlRootElement\n    public static class JaxbDataType {\n        \n    }\n    \n    private Entry getEntry(List<Entry> entries, String title) {\n        for (Entry e : entries) {\n            if (title.equals(e.getTitle())) {\n                return e;\n            }\n        }\n        return null;\n    }\n    \n    private void verifyEntry(Entry e, String title) {\n        assertNotNull(e);\n        assertEquals(title, e.getTitle());\n    }\n    \n    public static class CustomFeedWriter implements AtomElementWriter<Feed, Books> {\n\n        public void writeTo(Feed feed, Books pojoFeed) {\n            feed.setTitle(\"Books\");\n        }\n        \n    }\n    \n    public static class CustomEntryWriter implements AtomElementWriter<Entry, Book> {\n\n        public void writeTo(Entry entry, Book pojoEntry) {\n            entry.setTitle(pojoEntry.getName());\n        }\n        \n    }\n    \n    public static class CustomEntryReader implements AtomElementReader<Entry, Book> {\n\n        public Book readFrom(Entry element) {\n            try {\n                String s = element.getContent();\n                                \n                Unmarshaller um = \n                    new JAXBElementProvider<Book>().getJAXBContext(Book.class, Book.class)\n                        .createUnmarshaller();\n                return (Book)um.unmarshal(new StringReader(s));\n            } catch (Exception ex) {\n                \n            }\n            return null;\n        }\n        \n    }\n    \n    public static class CustomFeedReader implements AtomElementReader<Feed, Books> {\n\n        public Books readFrom(Feed element) {\n            Books books = new Books();\n            List<Book> list = new ArrayList<Book>();\n            CustomEntryReader entryReader = new CustomEntryReader();\n            for (Entry e : element.getEntries()) {\n                list.add(entryReader.readFrom(e));\n            }\n            books.setBooks(list);\n            return books;\n        }\n        \n    }\n    \n    public static class CustomFeedBuilder extends AbstractFeedBuilder<Books> {\n        @Override\n        public String getBaseUri(Books books) {\n            return \"http://books\";\n        }\n    }\n    \n    public static class CustomEntryBuilder extends AbstractEntryBuilder<Book> {\n        @Override\n        public String getBaseUri(Book books) {\n            return \"http://book\";\n        }\n    }\n    \n        \n    @XmlRootElement\n    public static class Book {\n        private String name = \"Book\";\n\n        public Book() {\n            \n        }\n        \n        public Book(String name) {\n            this.name = name;\n        }\n        \n        public void setName(String name) {\n            this.name = name;\n        }\n\n        public String getName() {\n            return name;\n        }\n        \n        public String getXMLContent() {\n            return \"<\" + name + \"/>\";\n        }\n        \n    }\n    \n    @XmlRootElement\n    public static class Books {\n        \n        private List<Book> books;\n        \n        public Books() {\n            \n        }\n        \n        public List<Book> getBooks() {\n            return books;\n        }\n        \n        public void setBooks(List<Book> list) {\n            books = list;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 15,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/cxf/commit/845eccb6484b43ba02875c71e824db23ae4f20c0",
    "cve_id": "CVE-2015-5253",
    "cwe_id": "CWE-264",
    "filename": "rt/rs/security/sso/saml/src/main/java/org/apache/cxf/rs/security/saml/sso/SAMLSSOResponseValidator.java",
    "code": "\npackage org.apache.cxf.rs.security.saml.sso;\n\nimport java.util.Date;\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport org.w3c.dom.Element;\n\nimport org.apache.cxf.common.logging.LogUtils;\nimport org.apache.wss4j.common.ext.WSSecurityException;\nimport org.apache.wss4j.common.saml.builder.SAML2Constants;\nimport org.apache.wss4j.common.util.DOM2Writer;\nimport org.opensaml.saml.saml2.core.AudienceRestriction;\nimport org.opensaml.saml.saml2.core.AuthnStatement;\n\n\npublic class SAMLSSOResponseValidator {\n    \n    private static final Logger LOG = LogUtils.getL7dLogger(SAMLSSOResponseValidator.class);\n    \n    private String issuerIDP;\n    private String assertionConsumerURL;\n    private String clientAddress;\n    private String requestId;\n    private String spIdentifier;\n    private boolean enforceAssertionsSigned = true;\n    private boolean enforceKnownIssuer = true;\n    private TokenReplayCache<String> replayCache;\n    \n    \n    public void setEnforceAssertionsSigned(boolean enforceAssertionsSigned) {\n        this.enforceAssertionsSigned = enforceAssertionsSigned;\n    }\n    \n    \n    public void setEnforceKnownIssuer(boolean enforceKnownIssuer) {\n        this.enforceKnownIssuer = enforceKnownIssuer;\n    }\n    \n    \n    public SSOValidatorResponse validateSamlResponse(\n        org.opensaml.saml.saml2.core.Response samlResponse,\n        boolean postBinding\n    ) throws WSSecurityException {\n        \n        validateIssuer(samlResponse.getIssuer());\n\n        \n        if (samlResponse.getAssertions() == null || samlResponse.getAssertions().isEmpty()) {\n            LOG.fine(\"The Response must contain at least one Assertion\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        \n        String destination = samlResponse.getDestination();\n        if (samlResponse.isSigned()\n            && (destination == null || !destination.equals(assertionConsumerURL))) {\n            LOG.fine(\"The Response must contain a destination that matches the assertion consumer URL\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        boolean foundValidSubject = false;\n        Date sessionNotOnOrAfter = null;\n        for (org.opensaml.saml.saml2.core.Assertion assertion : samlResponse.getAssertions()) {\n            \n            if (assertion.getIssuer() == null) {\n                LOG.fine(\"Assertion Issuer must not be null\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            validateIssuer(assertion.getIssuer());\n            \n            if (enforceAssertionsSigned && postBinding && assertion.getSignature() == null) {\n                LOG.fine(\"If the HTTP Post binding is used to deliver the Response, \"\n                         + \"the enclosed assertions must be signed\");\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n            \n            \n            if (assertion.getAuthnStatements() != null\n                && !assertion.getAuthnStatements().isEmpty()) {\n                org.opensaml.saml.saml2.core.Subject subject = assertion.getSubject();\n                if (validateAuthenticationSubject(subject, assertion.getID(), postBinding)) {\n                    validateAudienceRestrictionCondition(assertion.getConditions());\n                    foundValidSubject = true;\n                    \n                    for (AuthnStatement authnStatment : assertion.getAuthnStatements()) {\n                        if (authnStatment.getSessionNotOnOrAfter() != null) {\n                            sessionNotOnOrAfter = authnStatment.getSessionNotOnOrAfter().toDate();\n                        }\n                    }\n                }\n            }\n            \n        }\n        \n        if (!foundValidSubject) {\n            LOG.fine(\"The Response did not contain any Authentication Statement that matched \"\n                     + \"the Subject Confirmation criteria\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        SSOValidatorResponse validatorResponse = new SSOValidatorResponse();\n        validatorResponse.setResponseId(samlResponse.getID());\n        validatorResponse.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n        if (samlResponse.getIssueInstant() != null) {\n            validatorResponse.setCreated(samlResponse.getIssueInstant().toDate());\n        }\n        \n        \n        Element assertionElement = samlResponse.getAssertions().get(0).getDOM();\n        Element clonedAssertionElement = (Element)assertionElement.cloneNode(true);\n        validatorResponse.setAssertionElement(clonedAssertionElement);\n        validatorResponse.setAssertion(DOM2Writer.nodeToString(clonedAssertionElement));\n        \n        return validatorResponse;\n    }\n    \n    \n    private void validateIssuer(org.opensaml.saml.saml2.core.Issuer issuer) throws WSSecurityException {\n        if (issuer == null) {\n            return;\n        }\n        \n        \n        if (enforceKnownIssuer && !issuerIDP.startsWith(issuer.getValue())) {\n            LOG.fine(\"Issuer value: \" + issuer.getValue() + \" does not match issuer IDP: \" \n                + issuerIDP);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        if (issuer.getFormat() != null\n            && !SAML2Constants.NAMEID_FORMAT_ENTITY.equals(issuer.getFormat())) {\n            LOG.fine(\"Issuer format is not null and does not equal: \" \n                + SAML2Constants.NAMEID_FORMAT_ENTITY);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    \n    private boolean validateAuthenticationSubject(\n        org.opensaml.saml.saml2.core.Subject subject, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subject.getSubjectConfirmations() == null) {\n            return false;\n        }\n        \n        boolean foundBearerSubjectConf = false;\n        \n        for (org.opensaml.saml.saml2.core.SubjectConfirmation subjectConf \n            : subject.getSubjectConfirmations()) {\n            if (SAML2Constants.CONF_BEARER.equals(subjectConf.getMethod())) {\n                foundBearerSubjectConf = true;\n                validateSubjectConfirmation(subjectConf.getSubjectConfirmationData(), id, postBinding);\n            }\n        }\n        \n        return foundBearerSubjectConf;\n    }\n    \n    \n    private void validateSubjectConfirmation(\n        org.opensaml.saml.saml2.core.SubjectConfirmationData subjectConfData, String id, boolean postBinding\n    ) throws WSSecurityException {\n        if (subjectConfData == null) {\n            LOG.fine(\"Subject Confirmation Data of a Bearer Subject Confirmation is null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        String recipient = subjectConfData.getRecipient();\n        if (recipient == null || !recipient.equals(assertionConsumerURL)) {\n            LOG.fine(\"Recipient \" + recipient + \" does not match assertion consumer URL \"\n                + assertionConsumerURL);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        if (subjectConfData.getNotOnOrAfter() == null\n            || subjectConfData.getNotOnOrAfter().isBeforeNow()) {\n            LOG.fine(\"Subject Conf Data does not contain NotOnOrAfter or it has expired\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        if (postBinding && replayCache != null) {\n            if (replayCache.getId(id) == null) {\n                Date expires = subjectConfData.getNotOnOrAfter().toDate();\n                Date currentTime = new Date();\n                long ttl = expires.getTime() - currentTime.getTime();\n                replayCache.putId(id, ttl / 1000L);\n            } else {\n                LOG.fine(\"Replay attack with token id: \" + id);\n                throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n            }\n        }\n        \n        \n        if (subjectConfData.getAddress() != null\n            && !subjectConfData.getAddress().equals(clientAddress)) {\n            LOG.fine(\"Subject Conf Data address \" + subjectConfData.getAddress() + \" does match\"\n                     + \" client address \" + clientAddress);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        if (subjectConfData.getNotBefore() != null) {\n            LOG.fine(\"The Subject Conf Data must not contain a NotBefore timestamp\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n        \n        if (requestId != null && !requestId.equals(subjectConfData.getInResponseTo())) {\n            LOG.fine(\"The InResponseTo String does match the original request id \" + requestId);\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        \n    }\n    \n    private void validateAudienceRestrictionCondition(\n        org.opensaml.saml.saml2.core.Conditions conditions\n    ) throws WSSecurityException {\n        if (conditions == null) {\n            LOG.fine(\"Conditions are null\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n        List<AudienceRestriction> audienceRestrs = conditions.getAudienceRestrictions();\n        if (!matchSaml2AudienceRestriction(spIdentifier, audienceRestrs)) {\n            LOG.fine(\"Assertion does not contain unique subject provider identifier \" \n                     + spIdentifier + \" in the audience restriction conditions\");\n            throw new WSSecurityException(WSSecurityException.ErrorCode.FAILURE, \"invalidSAMLsecurity\");\n        }\n    }\n    \n    \n    private boolean matchSaml2AudienceRestriction(\n        String appliesTo, List<AudienceRestriction> audienceRestrictions\n    ) {\n        boolean oneMatchFound = false;\n        if (audienceRestrictions != null && !audienceRestrictions.isEmpty()) {\n            for (AudienceRestriction audienceRestriction : audienceRestrictions) {\n                if (audienceRestriction.getAudiences() != null) {\n                    boolean matchFound = false;\n                    for (org.opensaml.saml.saml2.core.Audience audience : audienceRestriction.getAudiences()) {\n                        if (appliesTo.equals(audience.getAudienceURI())) {\n                            matchFound = true;\n                            oneMatchFound = true;\n                            break;\n                        }\n                    }\n                    if (!matchFound) {\n                        return false;\n                    }\n                }\n            }\n        }\n\n        return oneMatchFound;\n    }\n\n    public String getIssuerIDP() {\n        return issuerIDP;\n    }\n\n    public void setIssuerIDP(String issuerIDP) {\n        this.issuerIDP = issuerIDP;\n    }\n\n    public String getAssertionConsumerURL() {\n        return assertionConsumerURL;\n    }\n\n    public void setAssertionConsumerURL(String assertionConsumerURL) {\n        this.assertionConsumerURL = assertionConsumerURL;\n    }\n\n    public String getClientAddress() {\n        return clientAddress;\n    }\n\n    public void setClientAddress(String clientAddress) {\n        this.clientAddress = clientAddress;\n    }\n\n    public String getRequestId() {\n        return requestId;\n    }\n\n    public void setRequestId(String requestId) {\n        this.requestId = requestId;\n    }\n\n    public String getSpIdentifier() {\n        return spIdentifier;\n    }\n\n    public void setSpIdentifier(String spIdentifier) {\n        this.spIdentifier = spIdentifier;\n    }\n    \n    public void setReplayCache(TokenReplayCache<String> replayCache) {\n        this.replayCache = replayCache;\n    }\n    \n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 15,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/cxf/commit/845eccb6484b43ba02875c71e824db23ae4f20c0",
    "cve_id": "CVE-2015-5253",
    "cwe_id": "CWE-264",
    "filename": "rt/rs/security/sso/saml/src/test/java/org/apache/cxf/rs/security/saml/sso/AbstractSAMLCallbackHandler.java",
    "code": "\n\npackage org.apache.cxf.rs.security.saml.sso;\n\nimport java.security.cert.X509Certificate;\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.security.auth.callback.CallbackHandler;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.apache.wss4j.common.saml.SAMLCallback;\nimport org.apache.wss4j.common.saml.bean.ActionBean;\nimport org.apache.wss4j.common.saml.bean.AttributeBean;\nimport org.apache.wss4j.common.saml.bean.AttributeStatementBean;\nimport org.apache.wss4j.common.saml.bean.AuthDecisionStatementBean;\nimport org.apache.wss4j.common.saml.bean.AuthenticationStatementBean;\nimport org.apache.wss4j.common.saml.bean.ConditionsBean;\nimport org.apache.wss4j.common.saml.bean.KeyInfoBean;\nimport org.apache.wss4j.common.saml.bean.KeyInfoBean.CERT_IDENTIFIER;\nimport org.apache.wss4j.common.saml.bean.SubjectBean;\nimport org.apache.wss4j.common.saml.bean.SubjectConfirmationDataBean;\nimport org.apache.wss4j.common.saml.bean.SubjectLocalityBean;\nimport org.apache.wss4j.dom.WSConstants;\nimport org.apache.wss4j.dom.message.WSSecEncryptedKey;\nimport org.joda.time.DateTime;\n\n\npublic abstract class AbstractSAMLCallbackHandler implements CallbackHandler {\n    \n    public enum Statement {\n        AUTHN, ATTR, AUTHZ\n    };\n    \n    protected String subjectName;\n    protected String subjectQualifier;\n    protected String confirmationMethod;\n    protected X509Certificate[] certs;\n    protected Statement statement = Statement.AUTHN;\n    protected CERT_IDENTIFIER certIdentifier = CERT_IDENTIFIER.X509_CERT;\n    protected byte[] ephemeralKey;\n    protected String issuer;\n    protected String subjectNameIDFormat;\n    protected String subjectLocalityIpAddress;\n    protected String subjectLocalityDnsAddress;\n    protected String resource;\n    protected List<Object> customAttributeValues;\n    protected ConditionsBean conditions;\n    protected SubjectConfirmationDataBean subjectConfirmationData;\n    protected DateTime authnInstant;\n    protected DateTime sessionNotOnOrAfter;\n    \n    public DateTime getSessionNotOnOrAfter() {\n        return sessionNotOnOrAfter;\n    }\n\n    public void setSessionNotOnOrAfter(DateTime sessionNotOnOrAfter) {\n        this.sessionNotOnOrAfter = sessionNotOnOrAfter;\n    }\n\n    public DateTime getAuthnInstant() {\n        return authnInstant;\n    }\n\n    public void setAuthnInstant(DateTime authnInstant) {\n        this.authnInstant = authnInstant;\n    }\n\n    public void setSubjectConfirmationData(SubjectConfirmationDataBean subjectConfirmationData) {\n        this.subjectConfirmationData = subjectConfirmationData;\n    }\n    \n    public void setConditions(ConditionsBean conditionsBean) {\n        this.conditions = conditionsBean;\n    }\n    \n    public void setConfirmationMethod(String confMethod) {\n        confirmationMethod = confMethod;\n    }\n    \n    public void setStatement(Statement statement) {\n        this.statement = statement;\n    }\n    \n    public void setCertIdentifier(CERT_IDENTIFIER certIdentifier) {\n        this.certIdentifier = certIdentifier;\n    }\n    \n    public void setCerts(X509Certificate[] certs) {\n        this.certs = certs;\n    }\n    \n    public byte[] getEphemeralKey() {\n        return ephemeralKey;\n    }\n    \n    public void setIssuer(String issuer) {\n        this.issuer = issuer;\n    }\n    \n    public void setSubjectNameIDFormat(String subjectNameIDFormat) {\n        this.subjectNameIDFormat = subjectNameIDFormat;\n    }\n    \n    public void setSubjectLocality(String ipAddress, String dnsAddress) {\n        this.subjectLocalityIpAddress = ipAddress;\n        this.subjectLocalityDnsAddress = dnsAddress;\n    }\n    \n    public void setResource(String resource) {\n        this.resource = resource;\n    }\n    \n    public void setCustomAttributeValues(List<Object> customAttributeValues) {\n        this.customAttributeValues = customAttributeValues;\n    }\n    \n    \n    protected void createAndSetStatement(SubjectBean subjectBean, SAMLCallback callback) {\n        if (statement == Statement.AUTHN) {\n            AuthenticationStatementBean authBean = new AuthenticationStatementBean();\n            if (subjectBean != null) {\n                authBean.setSubject(subjectBean);\n            }\n            if (subjectLocalityIpAddress != null || subjectLocalityDnsAddress != null) {\n                SubjectLocalityBean subjectLocality = new SubjectLocalityBean();\n                subjectLocality.setIpAddress(subjectLocalityIpAddress);\n                subjectLocality.setDnsAddress(subjectLocalityDnsAddress);\n                authBean.setSubjectLocality(subjectLocality);\n            }\n            authBean.setAuthenticationInstant(authnInstant);\n            authBean.setSessionNotOnOrAfter(sessionNotOnOrAfter);\n            authBean.setAuthenticationMethod(\"Password\");\n            callback.setAuthenticationStatementData(Collections.singletonList(authBean));\n        } else if (statement == Statement.ATTR) {\n            AttributeStatementBean attrBean = new AttributeStatementBean();\n            AttributeBean attributeBean = new AttributeBean();\n            if (subjectBean != null) {\n                attrBean.setSubject(subjectBean);\n                attributeBean.setSimpleName(\"role\");\n                attributeBean.setQualifiedName(\"http://custom-ns\");\n            } else {\n                attributeBean.setQualifiedName(\"role\");\n            }\n            if (customAttributeValues != null) {\n                attributeBean.setAttributeValues(customAttributeValues);   \n            } else {\n                attributeBean.addAttributeValue(\"user\");\n            }\n            attrBean.setSamlAttributes(Collections.singletonList(attributeBean));\n            callback.setAttributeStatementData(Collections.singletonList(attrBean));\n        } else {\n            AuthDecisionStatementBean authzBean = new AuthDecisionStatementBean();\n            if (subjectBean != null) {\n                authzBean.setSubject(subjectBean);\n            }\n            ActionBean actionBean = new ActionBean();\n            actionBean.setContents(\"Read\");\n            authzBean.setActions(Collections.singletonList(actionBean));\n            authzBean.setResource(\"endpoint\");\n            authzBean.setDecision(AuthDecisionStatementBean.Decision.PERMIT);\n            authzBean.setResource(resource);\n            callback.setAuthDecisionStatementData(Collections.singletonList(authzBean));\n        }\n    }\n    \n    protected KeyInfoBean createKeyInfo() throws Exception {\n        KeyInfoBean keyInfo = new KeyInfoBean();\n        if (statement == Statement.AUTHN) {\n            keyInfo.setCertificate(certs[0]);\n            keyInfo.setCertIdentifer(certIdentifier);\n        } else if (statement == Statement.ATTR) {\n            \n            DocumentBuilderFactory docBuilderFactory = \n                DocumentBuilderFactory.newInstance();\n            docBuilderFactory.setNamespaceAware(true);\n            DocumentBuilder docBuilder = docBuilderFactory.newDocumentBuilder();\n            Document doc = docBuilder.newDocument();\n                  \n            \n            WSSecEncryptedKey encrKey = new WSSecEncryptedKey();\n            encrKey.setKeyIdentifierType(WSConstants.ISSUER_SERIAL);\n            encrKey.setUseThisCert(certs[0]);\n            encrKey.prepare(doc, null);\n            ephemeralKey = encrKey.getEphemeralKey();\n            Element encryptedKeyElement = encrKey.getEncryptedKeyElement();\n            \n            \n            Element keyInfoElement = \n                doc.createElementNS(\n                    WSConstants.SIG_NS, WSConstants.SIG_PREFIX + \":\" + WSConstants.KEYINFO_LN\n                );\n            keyInfoElement.setAttributeNS(\n                WSConstants.XMLNS_NS, \"xmlns:\" + WSConstants.SIG_PREFIX, WSConstants.SIG_NS\n            );\n            keyInfoElement.appendChild(encryptedKeyElement);\n            \n            keyInfo.setElement(keyInfoElement);\n        }\n        return keyInfo;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 16,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/httpcomponents-client/commit/0554271750599756d4946c0d7ba43d04b1a7b22",
    "cve_id": "HTTPCLIENT-1803",
    "cwe_id": "Not Mapping",
    "filename": "httpclient/src/main/java/org/apache/http/client/utils/URIBuilder.java",
    "code": "\npackage org.apache.http.client.utils;\n\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.http.Consts;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.conn.util.InetAddressUtils;\nimport org.apache.http.message.BasicNameValuePair;\n\n\npublic class URIBuilder {\n\n    private String scheme;\n    private String encodedSchemeSpecificPart;\n    private String encodedAuthority;\n    private String userInfo;\n    private String encodedUserInfo;\n    private String host;\n    private int port;\n    private String path;\n    private String encodedPath;\n    private String encodedQuery;\n    private List<NameValuePair> queryParams;\n    private String query;\n    private Charset charset;\n    private String fragment;\n    private String encodedFragment;\n\n    \n    public URIBuilder() {\n        super();\n        this.port = -1;\n    }\n\n    \n    public URIBuilder(final String string) throws URISyntaxException {\n        super();\n        digestURI(new URI(string));\n    }\n\n    \n    public URIBuilder(final URI uri) {\n        super();\n        digestURI(uri);\n    }\n\n    \n    public URIBuilder setCharset(final Charset charset) {\n        this.charset = charset;\n        return this;\n    }\n\n    \n    public Charset getCharset() {\n        return charset;\n    }\n\n    private List <NameValuePair> parseQuery(final String query, final Charset charset) {\n        if (query != null && !query.isEmpty()) {\n            return URLEncodedUtils.parse(query, charset);\n        }\n        return null;\n    }\n\n    \n    public URI build() throws URISyntaxException {\n        return new URI(buildString());\n    }\n\n    private String buildString() {\n        final StringBuilder sb = new StringBuilder();\n        if (this.scheme != null) {\n            sb.append(this.scheme).append(':');\n        }\n        if (this.encodedSchemeSpecificPart != null) {\n            sb.append(this.encodedSchemeSpecificPart);\n        } else {\n            if (this.encodedAuthority != null) {\n                sb.append(\"//\").append(this.encodedAuthority);\n            } else if (this.host != null) {\n                sb.append(\"//\");\n                if (this.encodedUserInfo != null) {\n                    sb.append(this.encodedUserInfo).append(\"@\");\n                } else if (this.userInfo != null) {\n                    sb.append(encodeUserInfo(this.userInfo)).append(\"@\");\n                }\n                if (InetAddressUtils.isIPv6Address(this.host)) {\n                    sb.append(\"[\").append(this.host).append(\"]\");\n                } else {\n                    sb.append(this.host);\n                }\n                if (this.port >= 0) {\n                    sb.append(\":\").append(this.port);\n                }\n            }\n            if (this.encodedPath != null) {\n                sb.append(normalizePath(this.encodedPath));\n            } else if (this.path != null) {\n                sb.append(encodePath(normalizePath(this.path)));\n            }\n            if (this.encodedQuery != null) {\n                sb.append(\"?\").append(this.encodedQuery);\n            } else if (this.queryParams != null) {\n                sb.append(\"?\").append(encodeUrlForm(this.queryParams));\n            } else if (this.query != null) {\n                sb.append(\"?\").append(encodeUric(this.query));\n            }\n        }\n        if (this.encodedFragment != null) {\n            sb.append(\"#\").append(this.encodedFragment);\n        } else if (this.fragment != null) {\n            sb.append(\"#\").append(encodeUric(this.fragment));\n        }\n        return sb.toString();\n    }\n\n    private void digestURI(final URI uri) {\n        this.scheme = uri.getScheme();\n        this.encodedSchemeSpecificPart = uri.getRawSchemeSpecificPart();\n        this.encodedAuthority = uri.getRawAuthority();\n        this.host = uri.getHost();\n        this.port = uri.getPort();\n        this.encodedUserInfo = uri.getRawUserInfo();\n        this.userInfo = uri.getUserInfo();\n        this.encodedPath = uri.getRawPath();\n        this.path = uri.getPath();\n        this.encodedQuery = uri.getRawQuery();\n        this.queryParams = parseQuery(uri.getRawQuery(), this.charset != null ? this.charset : Consts.UTF_8);\n        this.encodedFragment = uri.getRawFragment();\n        this.fragment = uri.getFragment();\n    }\n\n    private String encodeUserInfo(final String userInfo) {\n        return URLEncodedUtils.encUserInfo(userInfo, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodePath(final String path) {\n        return URLEncodedUtils.encPath(path, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUrlForm(final List<NameValuePair> params) {\n        return URLEncodedUtils.format(params, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    private String encodeUric(final String fragment) {\n        return URLEncodedUtils.encUric(fragment, this.charset != null ? this.charset : Consts.UTF_8);\n    }\n\n    \n    public URIBuilder setScheme(final String scheme) {\n        this.scheme = scheme;\n        return this;\n    }\n\n    \n    public URIBuilder setUserInfo(final String userInfo) {\n        this.userInfo = userInfo;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        this.encodedUserInfo = null;\n        return this;\n    }\n\n    \n    public URIBuilder setUserInfo(final String username, final String password) {\n        return setUserInfo(username + ':' + password);\n    }\n\n    \n    public URIBuilder setHost(final String host) {\n        this.host = host;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    \n    public URIBuilder setPort(final int port) {\n        this.port = port < 0 ? -1 : port;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedAuthority = null;\n        return this;\n    }\n\n    \n    public URIBuilder setPath(final String path) {\n        this.path = path;\n        this.encodedSchemeSpecificPart = null;\n        this.encodedPath = null;\n        return this;\n    }\n\n    \n    public URIBuilder removeQuery() {\n        this.queryParams = null;\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    \n    @Deprecated\n    public URIBuilder setQuery(final String query) {\n        this.queryParams = parseQuery(query, this.charset != null ? this.charset : Consts.UTF_8);\n        this.query = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    \n    public URIBuilder setParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    \n    public URIBuilder addParameters(final List <NameValuePair> nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.addAll(nvps);\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    \n    public URIBuilder setParameters(final NameValuePair... nvps) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        } else {\n            this.queryParams.clear();\n        }\n        for (final NameValuePair nvp: nvps) {\n            this.queryParams.add(nvp);\n        }\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    \n    public URIBuilder addParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    \n    public URIBuilder setParameter(final String param, final String value) {\n        if (this.queryParams == null) {\n            this.queryParams = new ArrayList<NameValuePair>();\n        }\n        if (!this.queryParams.isEmpty()) {\n            for (final Iterator<NameValuePair> it = this.queryParams.iterator(); it.hasNext(); ) {\n                final NameValuePair nvp = it.next();\n                if (nvp.getName().equals(param)) {\n                    it.remove();\n                }\n            }\n        }\n        this.queryParams.add(new BasicNameValuePair(param, value));\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.query = null;\n        return this;\n    }\n\n    \n    public URIBuilder clearParameters() {\n        this.queryParams = null;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        return this;\n    }\n\n    \n    public URIBuilder setCustomQuery(final String query) {\n        this.query = query;\n        this.encodedQuery = null;\n        this.encodedSchemeSpecificPart = null;\n        this.queryParams = null;\n        return this;\n    }\n\n    \n    public URIBuilder setFragment(final String fragment) {\n        this.fragment = fragment;\n        this.encodedFragment = null;\n        return this;\n    }\n\n    \n    public boolean isAbsolute() {\n        return this.scheme != null;\n    }\n\n    \n    public boolean isOpaque() {\n        return this.path == null;\n    }\n\n    public String getScheme() {\n        return this.scheme;\n    }\n\n    public String getUserInfo() {\n        return this.userInfo;\n    }\n\n    public String getHost() {\n        return this.host;\n    }\n\n    public int getPort() {\n        return this.port;\n    }\n\n    public String getPath() {\n        return this.path;\n    }\n\n    public List<NameValuePair> getQueryParams() {\n        if (this.queryParams != null) {\n            return new ArrayList<NameValuePair>(this.queryParams);\n        } else {\n            return new ArrayList<NameValuePair>();\n        }\n    }\n\n    public String getFragment() {\n        return this.fragment;\n    }\n\n    @Override\n    public String toString() {\n        return buildString();\n    }\n\n    private static String normalizePath(final String path) {\n        String s = path;\n        if (s == null) {\n            return null;\n        }\n        int n = 0;\n        for (; n < s.length(); n++) {\n            if (s.charAt(n) != '/') {\n                break;\n            }\n        }\n        if (n > 1) {\n            s = s.substring(n - 1);\n        }\n        return s;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 16,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/httpcomponents-client/commit/0554271750599756d4946c0d7ba43d04b1a7b22",
    "cve_id": "HTTPCLIENT-1803",
    "cwe_id": "Not Mapping",
    "filename": "httpclient/src/test/java/org/apache/http/client/utils/TestURIBuilder.java",
    "code": "\npackage org.apache.http.client.utils;\n\nimport java.net.URI;\nimport java.net.URLEncoder;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.http.Consts;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.message.BasicNameValuePair;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class TestURIBuilder {\n\n    @Test\n    public void testHierarchicalUri() throws Exception {\n        final URI uri = new URI(\"http\", \"stuff\", \"localhost\", 80, \"/some stuff\", \"param=stuff\", \"fragment\");\n        final URIBuilder uribuilder = new URIBuilder(uri);\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://stuff@localhost:80/some%20stuff?param=stuff#fragment\"), result);\n    }\n\n    @Test\n    public void testMutationToRelativeUri() throws Exception {\n        final URI uri = new URI(\"http://stuff@localhost:80/stuff?param=stuff#fragment\");\n        final URIBuilder uribuilder = new URIBuilder(uri).setHost(null);\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http:///stuff?param=stuff#fragment\"), result);\n    }\n\n    @Test\n    public void testMutationRemoveFragment() throws Exception {\n        final URI uri = new URI(\"http://stuff@localhost:80/stuff?param=stuff#fragment\");\n        final URI result = new URIBuilder(uri).setFragment(null).build();\n        Assert.assertEquals(new URI(\"http://stuff@localhost:80/stuff?param=stuff\"), result);\n    }\n\n    @Test\n    public void testMutationRemoveUserInfo() throws Exception {\n        final URI uri = new URI(\"http://stuff@localhost:80/stuff?param=stuff#fragment\");\n        final URI result = new URIBuilder(uri).setUserInfo(null).build();\n        Assert.assertEquals(new URI(\"http://localhost:80/stuff?param=stuff#fragment\"), result);\n    }\n\n    @Test\n    public void testMutationRemovePort() throws Exception {\n        final URI uri = new URI(\"http://stuff@localhost:80/stuff?param=stuff#fragment\");\n        final URI result = new URIBuilder(uri).setPort(-1).build();\n        Assert.assertEquals(new URI(\"http://stuff@localhost/stuff?param=stuff#fragment\"), result);\n    }\n\n    @Test\n    public void testOpaqueUri() throws Exception {\n        final URI uri = new URI(\"stuff\", \"some-stuff\", \"fragment\");\n        final URIBuilder uribuilder = new URIBuilder(uri);\n        final URI result = uribuilder.build();\n        Assert.assertEquals(uri, result);\n    }\n\n    @Test\n    public void testOpaqueUriMutation() throws Exception {\n        final URI uri = new URI(\"stuff\", \"some-stuff\", \"fragment\");\n        final URIBuilder uribuilder = new URIBuilder(uri).setCustomQuery(\"param1&param2=stuff\").setFragment(null);\n        Assert.assertEquals(new URI(\"stuff:?param1&param2=stuff\"), uribuilder.build());\n    }\n\n    @Test\n    public void testHierarchicalUriMutation() throws Exception {\n        final URIBuilder uribuilder = new URIBuilder(\"/\").setScheme(\"http\").setHost(\"localhost\").setPort(80).setPath(\"/stuff\");\n        Assert.assertEquals(new URI(\"http://localhost:80/stuff\"), uribuilder.build());\n    }\n\n    @Test\n    public void testEmpty() throws Exception {\n        final URIBuilder uribuilder = new URIBuilder();\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"\"), result);\n    }\n\n    @Test\n    public void testSetUserInfo() throws Exception {\n        final URI uri = new URI(\"http\", null, \"localhost\", 80, \"/\", \"param=stuff\", null);\n        final URIBuilder uribuilder = new URIBuilder(uri).setUserInfo(\"user\", \"password\");\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://user:password@localhost:80/?param=stuff\"), result);\n    }\n\n    @Test\n    public void testRemoveParameters() throws Exception {\n        final URI uri = new URI(\"http\", null, \"localhost\", 80, \"/\", \"param=stuff\", null);\n        final URIBuilder uribuilder = new URIBuilder(uri).removeQuery();\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://localhost:80/\"), result);\n    }\n\n    @Test\n    public void testSetParameter() throws Exception {\n        final URI uri = new URI(\"http\", null, \"localhost\", 80, \"/\", \"param=stuff&blah&blah\", null);\n        final URIBuilder uribuilder = new URIBuilder(uri).setParameter(\"param\", \"some other stuff\")\n            .setParameter(\"blah\", \"blah\");\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://localhost:80/?param=some+other+stuff&blah=blah\"), result);\n    }\n\n    @Test\n    public void testParameterWithSpecialChar() throws Exception {\n        final URI uri = new URI(\"http\", null, \"localhost\", 80, \"/\", \"param=stuff\", null);\n        final URIBuilder uribuilder = new URIBuilder(uri).addParameter(\"param\", \"1 + 1 = 2\")\n            .addParameter(\"param\", \"blah&blah\");\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://localhost:80/?param=stuff&param=1+%2B+1+%3D+2&\" +\n                \"param=blah%26blah\"), result);\n    }\n\n    @Test\n    public void testAddParameter() throws Exception {\n        final URI uri = new URI(\"http\", null, \"localhost\", 80, \"/\", \"param=stuff&blah&blah\", null);\n        final URIBuilder uribuilder = new URIBuilder(uri).addParameter(\"param\", \"some other stuff\")\n            .addParameter(\"blah\", \"blah\");\n        final URI result = uribuilder.build();\n        Assert.assertEquals(new URI(\"http://localhost:80/?param=stuff&blah&blah&\" +\n                \"param=some+other+stuff&blah=blah\"), result);\n    }\n\n    @Test\n    public void testQueryEncoding() throws Exception {\n        final URI uri1 = new URI(\"https://somehost.com/stuff?client_id=1234567890\" +\n                \"&redirect_uri=https%3A%2F%2Fsomehost.com%2Fblah+blah%2F\");\n        final URI uri2 = new URIBuilder(\"https://somehost.com/stuff\")\n            .addParameter(\"client_id\",\"1234567890\")\n            .addParameter(\"redirect_uri\",\"https://somehost.com/blah blah/\").build();\n        Assert.assertEquals(uri1, uri2);\n    }\n\n    @Test\n    public void testQueryAndParameterEncoding() throws Exception {\n        final URI uri1 = new URI(\"https://somehost.com/stuff?param1=12345&param2=67890\");\n        final URI uri2 = new URIBuilder(\"https://somehost.com/stuff\")\n            .setCustomQuery(\"this&that\")\n            .addParameter(\"param1\",\"12345\")\n            .addParameter(\"param2\",\"67890\").build();\n        Assert.assertEquals(uri1, uri2);\n    }\n\n    @Test\n    public void testPathEncoding() throws Exception {\n        final URI uri1 = new URI(\"https://somehost.com/some%20path%20with%20blanks/\");\n        final URI uri2 = new URIBuilder()\n            .setScheme(\"https\")\n            .setHost(\"somehost.com\")\n            .setPath(\"/some path with blanks/\")\n            .build();\n        Assert.assertEquals(uri1, uri2);\n    }\n\n    @Test\n    public void testAgainstURI() throws Exception {\n        \n        final String scheme=\"https\";\n        final String host=\"localhost\";\n        final String specials=\"/abcd!$&*()_-+.,=:;'~@[]?<>|#^%\\\"{}\\\\\\u00a3`\\u00ac\\u00a6xyz\"; \n        final URI uri = new URI(scheme, specials, host, 80, specials, specials, specials);\n\n        final URI bld = new URIBuilder()\n                .setScheme(scheme)\n                .setHost(host)\n                .setUserInfo(specials)\n                .setPath(specials)\n                .setCustomQuery(specials)\n                .setFragment(specials)\n                .build();\n\n        Assert.assertEquals(uri.getHost(), bld.getHost());\n\n        Assert.assertEquals(uri.getUserInfo(), bld.getUserInfo());\n\n        Assert.assertEquals(uri.getPath(), bld.getPath());\n\n        Assert.assertEquals(uri.getQuery(), bld.getQuery());\n\n        Assert.assertEquals(uri.getFragment(), bld.getFragment());\n\n    }\n\n    @Test\n    public void testAgainstURIEncoded() throws Exception {\n        \n        final String scheme=\"https\";\n        final String host=\"localhost\";\n        final String specials=\"/ abcd!$&*()_-+.,=:;'~<>/@[]|#^%\\\"{}\\\\`xyz\"; \n        final URI uri = new URI(scheme, specials, host, 80, specials, specials, specials);\n\n        final URI bld = new URIBuilder()\n                .setScheme(scheme)\n                .setHost(host)\n                .setUserInfo(specials)\n                .setPath(specials)\n                .setCustomQuery(specials)\n                .setFragment(specials)\n                .build();\n\n        Assert.assertEquals(uri.getHost(), bld.getHost());\n\n        Assert.assertEquals(uri.getRawUserInfo(), bld.getRawUserInfo());\n\n        Assert.assertEquals(uri.getRawPath(), bld.getRawPath());\n\n        Assert.assertEquals(uri.getRawQuery(), bld.getRawQuery());\n\n        Assert.assertEquals(uri.getRawFragment(), bld.getRawFragment());\n\n    }\n\n    @Test\n    public void testBuildAddParametersUTF8() throws Exception {\n        assertAddParameters(Consts.UTF_8);\n    }\n\n    @Test\n    public void testBuildAddParametersISO88591() throws Exception {\n        assertAddParameters(Consts.ISO_8859_1);\n    }\n\n    public void assertAddParameters(final Charset charset) throws Exception {\n        final URI uri = new URIBuilder(\"https://somehost.com/stuff\")\n                .setCharset(charset)\n                .addParameters(createParameters()).build();\n\n        assertBuild(charset, uri);\n    }\n\n    @Test\n    public void testBuildSetParametersUTF8() throws Exception {\n        assertSetParameters(Consts.UTF_8);\n    }\n\n    @Test\n    public void testBuildSetParametersISO88591() throws Exception {\n        assertSetParameters(Consts.ISO_8859_1);\n    }\n\n    public void assertSetParameters(final Charset charset) throws Exception {\n        final URI uri = new URIBuilder(\"https://somehost.com/stuff\")\n                .setCharset(charset)\n                .setParameters(createParameters()).build();\n\n        assertBuild(charset, uri);\n    }\n\n    public void assertBuild(final Charset charset, final URI uri) throws Exception {\n        final String encodedData1 = URLEncoder.encode(\"\\\"1\\u00aa position\\\"\", charset.displayName());\n        final String encodedData2 = URLEncoder.encode(\"Jos\\u00e9 Abra\\u00e3o\", charset.displayName());\n\n        final String uriExpected = String.format(\"https://somehost.com/stuff?parameter1=value1&parameter2=%s&parameter3=%s\", encodedData1, encodedData2);\n\n        Assert.assertEquals(uriExpected, uri.toString());\n    }\n\n    private List<NameValuePair> createParameters() {\n        final List<NameValuePair> parameters = new ArrayList<NameValuePair>();\n        parameters.add(new BasicNameValuePair(\"parameter1\", \"value1\"));\n        parameters.add(new BasicNameValuePair(\"parameter2\", \"\\\"1\\u00aa position\\\"\"));\n        parameters.add(new BasicNameValuePair(\"parameter3\", \"Jos\\u00e9 Abra\\u00e3o\"));\n        return parameters;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 17,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/jspwiki/commit/88d89d6523802c044cfcb7930cba40d8eeb21da2",
    "cve_id": "CVE-2019-0225",
    "cwe_id": "CWE-22",
    "filename": "jspwiki-main/src/main/java/org/apache/wiki/url/DefaultURLConstructor.java",
    "code": "\npackage org.apache.wiki.url;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Properties;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.apache.commons.lang.StringUtils;\nimport org.apache.wiki.WikiContext;\nimport org.apache.wiki.WikiEngine;\nimport org.apache.wiki.ui.Command;\nimport org.apache.wiki.ui.CommandResolver;\nimport org.apache.wiki.util.TextUtil;\n\n\npublic class DefaultURLConstructor\n    implements URLConstructor\n{\n    protected WikiEngine m_engine;\n\n    \n    protected String m_pathPrefix = \"\";\n\n    \n    public void initialize( WikiEngine engine,\n                            Properties properties )\n    {\n        m_engine = engine;\n\n        m_pathPrefix = engine.getBaseURL() + \"/\";\n    }\n\n    \n    protected final String doReplacement( String baseptrn, String name, boolean absolute )\n    {\n        String baseurl = m_pathPrefix;\n\n        if( absolute ) baseurl = m_engine.getBaseURL() + \"/\";\n\n        baseptrn = TextUtil.replaceString( baseptrn, \"%u\", baseurl );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%U\", m_engine.getBaseURL() );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%n\", encodeURI(name) );\n        baseptrn = TextUtil.replaceString( baseptrn, \"%p\", m_pathPrefix );\n\n        return baseptrn;\n    }\n\n    \n    private String encodeURI( String uri )\n    {\n        uri = m_engine.encodeName(uri);\n\n        uri = StringUtils.replace( uri, \"+\", \"%20\" );\n        uri = StringUtils.replace( uri, \"%2F\", \"/\" );\n\n        return uri;\n    }\n\n    \n    public static String getURLPattern( String context, String name )\n        throws IllegalArgumentException\n    {\n        if( context.equals(WikiContext.VIEW) && name == null)\n        {\n            \n            return \"%uWiki.jsp\";\n        }\n\n        \n        Command command = CommandResolver.findCommand( context );\n\n        return command.getURLPattern();\n    }\n\n    \n    private String makeURL( String context,\n                            String name,\n                            boolean absolute )\n    {\n        return doReplacement( getURLPattern(context,name), name, absolute );\n    }\n\n    \n    public String makeURL( String context,\n                           String name,\n                           boolean absolute,\n                           String parameters )\n    {\n        if( parameters != null && parameters.length() > 0 )\n        {\n            if( context.equals(WikiContext.ATTACH) )\n            {\n                parameters = \"?\"+parameters;\n            }\n            else if( context.equals(WikiContext.NONE) )\n            {\n                parameters = (name.indexOf('?') != -1 ) ? \"&amp;\" : \"?\" + parameters;\n            }\n            else\n            {\n                parameters = \"&amp;\"+parameters;\n            }\n        }\n        else\n        {\n            parameters = \"\";\n        }\n        return makeURL( context, name, absolute )+parameters;\n    }\n\n    \n    public String parsePage( String context,\n                             HttpServletRequest request,\n                             String encoding )\n        throws UnsupportedEncodingException\n    {\n        String pagereq = request.getParameter( \"page\" );\n\n        if( context.equals(WikiContext.ATTACH) )\n        {\n            pagereq = parsePageFromURL( request, encoding );\n        }\n\n        return pagereq;\n    }\n\n    \n    \n    \n    public static String parsePageFromURL( HttpServletRequest request,\n                                           String encoding )\n        throws UnsupportedEncodingException\n    {\n        String name = request.getPathInfo();\n\n        if( name == null || name.length() <= 1 )\n        {\n            return null;\n        }\n        else if( name.charAt(0) == '/' )\n        {\n            name = name.substring(1);\n        }\n\n        \n        \n        \n        \n\n        \n\n        return name;\n    }\n\n\n    \n    public String getForwardPage( HttpServletRequest request )\n    {\n        return request.getPathInfo();\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 18,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/bqcuong/vul4j/commit/c90825da4d28d7b1ae9b1484b9a010206be3dec5",
    "cve_id": "PDFBOX-3341",
    "cwe_id": "Not Mapping",
    "filename": "pdfbox/src/main/java/org/apache/pdfbox/pdmodel/encryption/StandardSecurityHandler.java",
    "code": "\npackage org.apache.pdfbox.pdmodel.encryption;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Arrays;\n \nimport javax.crypto.Cipher;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\n\nimport org.apache.pdfbox.cos.COSArray;\nimport org.apache.pdfbox.cos.COSName;\nimport org.apache.pdfbox.cos.COSString;\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.util.Charsets;\n\n\npublic final class StandardSecurityHandler extends SecurityHandler\n{\n    \n    private static final Log LOG = LogFactory.getLog(StandardSecurityHandler.class);\n\n    \n    public static final String FILTER = \"Standard\";\n\n    \n    public static final Class<?> PROTECTION_POLICY_CLASS = StandardProtectionPolicy.class;\n\n    \n    private static final byte[] ENCRYPT_PADDING =\n    {\n        (byte)0x28, (byte)0xBF, (byte)0x4E, (byte)0x5E, (byte)0x4E,\n        (byte)0x75, (byte)0x8A, (byte)0x41, (byte)0x64, (byte)0x00,\n        (byte)0x4E, (byte)0x56, (byte)0xFF, (byte)0xFA, (byte)0x01,\n        (byte)0x08, (byte)0x2E, (byte)0x2E, (byte)0x00, (byte)0xB6,\n        (byte)0xD0, (byte)0x68, (byte)0x3E, (byte)0x80, (byte)0x2F,\n        (byte)0x0C, (byte)0xA9, (byte)0xFE, (byte)0x64, (byte)0x53,\n        (byte)0x69, (byte)0x7A\n    };\n\n    \n    private static final String[] HASHES_2B = new String[] {\"SHA-256\", \"SHA-384\", \"SHA-512\"};\n\n    private static final int DEFAULT_VERSION = 1;\n\n    private StandardProtectionPolicy policy;\n\n    \n    public StandardSecurityHandler()\n    {\n    }\n\n    \n    public StandardSecurityHandler(StandardProtectionPolicy p)\n    {\n        policy = p;\n        keyLength = policy.getEncryptionKeyLength();\n    }\n\n    \n    private int computeVersionNumber()\n    {\n        if(keyLength == 40)\n        {\n            return DEFAULT_VERSION;\n        }\n        else if (keyLength == 128 && policy.isPreferAES())\n        {\n            return 4;\n        }\n        else if (keyLength == 256)\n        {\n            return 5;\n        }\n\n        return 2;\n    }\n\n    \n    private int computeRevisionNumber(int version)\n    {\n        if(version < 2 && !policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 2;\n        }\n        if (version == 5)\n        {\n            \n            return 6;    \n        }\n        if (version == 4)\n        {\n            return 4;\n        }\n        if ( version == 2 || version == 3 || policy.getPermissions().hasAnyRevision3PermissionSet())\n        {\n            return 3;\n        }\n        return 4;\n    }\n\n    \n    @Override\n    public void prepareForDecryption(PDEncryption encryption, COSArray documentIDArray,\n                                     DecryptionMaterial decryptionMaterial)\n                                     throws IOException\n    {\n        if(!(decryptionMaterial instanceof StandardDecryptionMaterial))\n        {\n            throw new IOException(\"Decryption material is not compatible with the document\");\n        }\n        setDecryptMetadata(encryption.isEncryptMetaData());\n        StandardDecryptionMaterial material = (StandardDecryptionMaterial)decryptionMaterial;\n\n        String password = material.getPassword();\n        if(password == null)\n        {\n            password = \"\";\n        }\n\n        int dicPermissions = encryption.getPermissions();\n        int dicRevision = encryption.getRevision();\n        int dicLength = encryption.getVersion() == 1 ? 5 : encryption.getLength() / 8;\n\n        byte[] documentIDBytes = getDocumentIDBytes(documentIDArray);\n\n        \n        boolean encryptMetadata = encryption.isEncryptMetaData();\n        \n        byte[] userKey = encryption.getUserKey();\n        byte[] ownerKey = encryption.getOwnerKey();\n        byte[] ue = null, oe = null;\n\n        Charset passwordCharset = Charsets.ISO_8859_1;\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            passwordCharset = Charsets.UTF_8;\n            ue = encryption.getUserEncryptionKey();\n            oe = encryption.getOwnerEncryptionKey();\n        }\n        \n        AccessPermission currentAccessPermission;\n\n        if( isOwnerPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                                 dicPermissions, documentIDBytes, dicRevision,\n                                 dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = AccessPermission.getOwnerAccessPermission();\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            byte[] computedPassword;\n            if (dicRevision == 6 || dicRevision == 5)\n            {\n                computedPassword = password.getBytes(passwordCharset);\n            }\n            else\n            {\n                computedPassword = getUserPassword(password.getBytes(passwordCharset),\n                        ownerKey, dicRevision, dicLength );\n            }\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    computedPassword,\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, true );\n        }\n        else if( isUserPassword(password.getBytes(passwordCharset), userKey, ownerKey,\n                           dicPermissions, documentIDBytes, dicRevision,\n                           dicLength, encryptMetadata) )\n        {\n            currentAccessPermission = new AccessPermission(dicPermissions);\n            setCurrentAccessPermission(currentAccessPermission);\n            \n            encryptionKey =\n                computeEncryptedKey(\n                    password.getBytes(passwordCharset),\n                    ownerKey, userKey, oe, ue,\n                    dicPermissions,\n                    documentIDBytes,\n                    dicRevision,\n                    dicLength,\n                    encryptMetadata, false );\n        }\n        else\n        {\n            throw new InvalidPasswordException(\"Cannot decrypt PDF, the password is incorrect\");\n        }\n\n        if (dicRevision == 6 || dicRevision == 5)\n        {\n            validatePerms(encryption, dicPermissions, encryptMetadata);\n        }\n\n        if (encryption.getVersion() == 4 || encryption.getVersion() == 5)\n        {\n            \n            \n            \n            PDCryptFilterDictionary stdCryptFilterDictionary = encryption.getStdCryptFilterDictionary();\n\n            if (stdCryptFilterDictionary != null)\n            {\n                COSName cryptFilterMethod = stdCryptFilterDictionary.getCryptFilterMethod();\n                setAES(COSName.AESV2.equals(cryptFilterMethod) || \n                       COSName.AESV3.equals(cryptFilterMethod));\n            }\n        }\n    }\n\n    private byte[] getDocumentIDBytes(COSArray documentIDArray)\n    {\n        \n        \n        byte[] documentIDBytes;\n        if( documentIDArray != null && documentIDArray.size() >= 1 )\n        {\n            COSString id = (COSString)documentIDArray.getObject( 0 );\n            documentIDBytes = id.getBytes();\n        }\n        else\n        {\n            documentIDBytes = new byte[0];\n        }\n        return documentIDBytes;\n    }\n\n    \n    \n    private void validatePerms(PDEncryption encryption, int dicPermissions, boolean encryptMetadata) throws IOException\n    {\n        try\n        {\n            \n            \n            Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"));\n            byte[] perms = cipher.doFinal(encryption.getPerms());\n            \n            \n            if (perms[9] != 'a' || perms[10] != 'd' || perms[11] != 'b')\n            {\n                LOG.warn(\"Verification of permissions failed (constant)\");\n            }\n            \n            \n            \n            int permsP = perms[0] & 0xFF | (perms[1] & 0xFF) << 8 | (perms[2] & 0xFF) << 16 |\n                    (perms[3] & 0xFF) << 24;\n            \n            if (permsP != dicPermissions)\n            {\n                LOG.warn(\"Verification of permissions failed (\" + String.format(\"%08X\",permsP) +\n                        \" != \" + String.format(\"%08X\",dicPermissions) + \")\");\n            }\n            \n            if (encryptMetadata && perms[8] != 'T' || !encryptMetadata && perms[8] != 'F')\n            {\n                LOG.warn(\"Verification of permissions failed (EncryptMetadata)\");\n            }\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n    \n    \n    @Override\n    public void prepareDocumentForEncryption(PDDocument document) throws IOException\n    {\n        PDEncryption encryptionDictionary = document.getEncryption();\n        if(encryptionDictionary == null)\n        {\n            encryptionDictionary = new PDEncryption();\n        }\n        int version = computeVersionNumber();\n        int revision = computeRevisionNumber(version);\n        encryptionDictionary.setFilter(FILTER);\n        encryptionDictionary.setVersion(version);\n        if (version != 4 && version != 5)\n        {\n            \n            encryptionDictionary.removeV45filters();\n        }\n        encryptionDictionary.setRevision(revision);\n        encryptionDictionary.setLength(keyLength);\n\n        String ownerPassword = policy.getOwnerPassword();\n        String userPassword = policy.getUserPassword();\n        if( ownerPassword == null )\n        {\n            ownerPassword = \"\";\n        }\n        if( userPassword == null )\n        {\n            userPassword = \"\";\n        }\n \n        \n        if (ownerPassword.isEmpty())\n        {\n            ownerPassword = userPassword;\n        }\n\n        int permissionInt = policy.getPermissions().getPermissionBytes();\n\n        encryptionDictionary.setPermissions(permissionInt);\n\n        int length = keyLength/8;\n\n        if (revision == 6)\n        {\n            prepareEncryptionDictRev6(ownerPassword, userPassword, encryptionDictionary, permissionInt);\n        }\n        else\n        {\n            prepareEncryptionDictRev2345(ownerPassword, userPassword, encryptionDictionary, permissionInt,\n                    document, revision, length);\n        }\n\n        document.setEncryptionDictionary( encryptionDictionary );\n        document.getDocument().setEncryptionDictionary(encryptionDictionary.getCOSDictionary());\n    }\n\n    private void prepareEncryptionDictRev6(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt)\n            throws IOException\n    {\n        try\n        {\n            SecureRandom rnd = new SecureRandom();\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n\n            \n            encryptionKey = new byte[32];\n            rnd.nextBytes(encryptionKey);\n\n            \n            byte[] userPasswordBytes = truncate127(userPassword.getBytes(Charsets.UTF_8));\n            byte[] userValidationSalt = new byte[8];\n            byte[] userKeySalt = new byte[8];\n            rnd.nextBytes(userValidationSalt);\n            rnd.nextBytes(userKeySalt);\n            byte[] hashU = computeHash2B(concat(userPasswordBytes, userValidationSalt),\n                    userPasswordBytes, null);\n            byte[] u = concat(hashU, userValidationSalt, userKeySalt);\n\n            \n            byte[] hashUE = computeHash2B(concat(userPasswordBytes, userKeySalt),\n                    userPasswordBytes, null);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashUE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] ue = cipher.doFinal(encryptionKey);\n\n            \n            byte[] ownerPasswordBytes = truncate127(ownerPassword.getBytes(Charsets.UTF_8));\n            byte[] ownerValidationSalt = new byte[8];\n            byte[] ownerKeySalt = new byte[8];\n            rnd.nextBytes(ownerValidationSalt);\n            rnd.nextBytes(ownerKeySalt);\n            byte[] hashO = computeHash2B(concat(ownerPasswordBytes, ownerValidationSalt, u),\n                    ownerPasswordBytes, u);\n            byte[] o = concat(hashO, ownerValidationSalt, ownerKeySalt);\n\n            \n            byte[] hashOE = computeHash2B(concat(ownerPasswordBytes, ownerKeySalt, u),\n                    ownerPasswordBytes, u);\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(hashOE, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n            byte[] oe = cipher.doFinal(encryptionKey);\n\n            \n            encryptionDictionary.setUserKey(u);\n            encryptionDictionary.setUserEncryptionKey(ue);\n            encryptionDictionary.setOwnerKey(o);\n            encryptionDictionary.setOwnerEncryptionKey(oe);\n\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV3);\n\n            \n            byte[] perms = new byte[16];\n            perms[0] = (byte) permissionInt;\n            perms[1] = (byte) (permissionInt >>> 8);\n            perms[2] = (byte) (permissionInt >>> 16);\n            perms[3] = (byte) (permissionInt >>> 24);\n            perms[4] = (byte) 0xFF;\n            perms[5] = (byte) 0xFF;\n            perms[6] = (byte) 0xFF;\n            perms[7] = (byte) 0xFF;\n            perms[8] = 'T';    \n            perms[9] = 'a';\n            perms[10] = 'd';\n            perms[11] = 'b';\n            for (int i = 12; i <= 15; i++)\n            {\n                perms[i] = (byte) rnd.nextInt();\n            }\n\n            cipher.init(Cipher.ENCRYPT_MODE, new SecretKeySpec(encryptionKey, \"AES\"),\n                    new IvParameterSpec(new byte[16]));\n\n            byte[] permsEnc = cipher.doFinal(perms);\n\n            encryptionDictionary.setPerms(permsEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private void prepareEncryptionDictRev2345(String ownerPassword, String userPassword,\n            PDEncryption encryptionDictionary, int permissionInt, PDDocument document, \n            int revision, int length)\n            throws IOException\n    {\n        COSArray idArray = document.getDocument().getDocumentID();\n\n        \n        if (idArray == null || idArray.size() < 2)\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            BigInteger time = BigInteger.valueOf(System.currentTimeMillis());\n            md.update(time.toByteArray());\n            md.update(ownerPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(userPassword.getBytes(Charsets.ISO_8859_1));\n            md.update(document.getDocument().toString().getBytes(Charsets.ISO_8859_1));\n\n            byte[] id = md.digest(this.toString().getBytes(Charsets.ISO_8859_1));\n            COSString idString = new COSString(id);\n\n            idArray = new COSArray();\n            idArray.add(idString);\n            idArray.add(idString);\n            document.getDocument().setDocumentID(idArray);\n        }\n\n        COSString id = (COSString) idArray.getObject(0);\n\n        byte[] ownerBytes = computeOwnerPassword(\n                ownerPassword.getBytes(Charsets.ISO_8859_1),\n                userPassword.getBytes(Charsets.ISO_8859_1), revision, length);\n\n        byte[] userBytes = computeUserPassword(\n                userPassword.getBytes(Charsets.ISO_8859_1),\n                ownerBytes, permissionInt, id.getBytes(), revision, length, true);\n\n        encryptionKey = computeEncryptedKey(userPassword.getBytes(Charsets.ISO_8859_1), ownerBytes,\n                null, null, null, permissionInt, id.getBytes(), revision, length, true, false);\n\n        encryptionDictionary.setOwnerKey(ownerBytes);\n        encryptionDictionary.setUserKey(userBytes);\n        \n        if (revision == 4)\n        {\n            prepareEncryptionDictAES(encryptionDictionary, COSName.AESV2);\n        }\n    }\n\n    private void prepareEncryptionDictAES(PDEncryption encryptionDictionary, COSName aesVName)\n    {\n        PDCryptFilterDictionary cryptFilterDictionary = new PDCryptFilterDictionary();\n        cryptFilterDictionary.setCryptFilterMethod(aesVName);\n        cryptFilterDictionary.setLength(keyLength);\n        encryptionDictionary.setStdCryptFilterDictionary(cryptFilterDictionary);\n        encryptionDictionary.setStreamFilterName(COSName.STD_CF);\n        encryptionDictionary.setStringFilterName(COSName.STD_CF);\n        setAES(true);\n    }\n\n    \n    public boolean isOwnerPassword(byte[] ownerPassword, byte[] user, byte[] owner,\n                                   int permissions, byte[] id, int encRevision, int length,\n                                   boolean encryptMetadata) throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {            \n            byte[] truncatedOwnerPassword = truncate127(ownerPassword);\n            \n            byte[] oHash = new byte[32];\n            byte[] oValidationSalt = new byte[8];\n            System.arraycopy(owner, 0, oHash, 0, 32);\n            System.arraycopy(owner, 32, oValidationSalt, 0, 8);\n            \n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedOwnerPassword, oValidationSalt, user);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedOwnerPassword, oValidationSalt, user);\n            }\n\n            return Arrays.equals(hash, oHash);\n        }\n        else\n        {\n            byte[] userPassword = getUserPassword( ownerPassword, owner, encRevision, length );\n            return isUserPassword( userPassword, user, owner, permissions, id, encRevision, length,\n                                   encryptMetadata );\n        }\n    }\n\n    \n    public byte[] getUserPassword( byte[] ownerPassword,  byte[] owner, int encRevision,\n                                   int length ) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n\n        if( encRevision == 2 )\n        {\n            encryptDataRC4(rc4Key, owner, result);\n        }\n        else if( encRevision == 3 || encRevision == 4)\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            byte[] otemp = new byte[ owner.length ];\n            System.arraycopy( owner, 0, otemp, 0, owner.length );\n            \n            for( int i=19; i>=0; i-- )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                result.reset();\n                encryptDataRC4(iterationKey, otemp, result);\n                otemp = result.toByteArray();\n            }\n        }\n        return result.toByteArray();\n    }\n\n    \n    public byte[] computeEncryptedKey(byte[] password, byte[] o, byte[] u, byte[] oe, byte[] ue,\n                                      int permissions, byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata, boolean isOwnerPassword)\n                                      throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return computeEncryptedKeyRev56(password, isOwnerPassword, o, u, oe, ue, encRevision);\n        }\n        else\n        {\n            return computeEncryptedKeyRev234(password, o, permissions, id, encryptMetadata, length, encRevision);\n        }\n    }\n\n    private byte[] computeEncryptedKeyRev234(byte[] password, byte[] o, int permissions, \n            byte[] id, boolean encryptMetadata, int length, int encRevision)\n    {\n        \n\n        \n        byte[] padded = truncateOrPad(password);\n\n        MessageDigest md = MessageDigests.getMD5();\n        md.update(padded);\n\n        md.update(o);\n\n        md.update((byte) permissions);\n        md.update((byte) (permissions >>> 8));\n        md.update((byte) (permissions >>> 16));\n        md.update((byte) (permissions >>> 24));\n\n        md.update(id);\n\n        \n        \n        \n        if (encRevision == 4 && !encryptMetadata)\n        {\n            md.update(new byte[] { (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff });\n        }\n        byte[] digest = md.digest();\n\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n\n        byte[] result = new byte[length];\n        System.arraycopy(digest, 0, result, 0, length);\n        return result;\n    }\n\n    private byte[] computeEncryptedKeyRev56(byte[] password, boolean isOwnerPassword, \n            byte[] o, byte[] u, byte[] oe, byte[] ue, int encRevision) \n            throws IOException\n    {\n        byte[] hash, fileKeyEnc;\n\n        if (isOwnerPassword)\n        {\n            byte[] oKeySalt = new byte[8];\n            System.arraycopy(o, 40, oKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, oKeySalt, u);\n            }\n            else\n            {\n                hash = computeHash2A(password, oKeySalt, u);\n            }\n\n            fileKeyEnc = oe;\n        }\n        else\n        {\n            byte[] uKeySalt = new byte[8];\n            System.arraycopy(u, 40, uKeySalt, 0, 8);\n\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(password, uKeySalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(password, uKeySalt, null);\n            }\n\n            fileKeyEnc = ue;\n        }\n        try\n        {\n            Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n            cipher.init(Cipher.DECRYPT_MODE, new SecretKeySpec(hash, \"AES\"), new IvParameterSpec(new byte[16]));\n            return cipher.doFinal(fileKeyEnc);\n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    \n    public byte[] computeUserPassword(byte[] password, byte[] owner, int permissions,\n                                      byte[] id, int encRevision, int length,\n                                      boolean encryptMetadata) throws IOException\n    {\n        ByteArrayOutputStream result = new ByteArrayOutputStream();\n        byte[] encKey = computeEncryptedKey( password, owner, null, null, null, permissions,\n                id, encRevision, length, encryptMetadata, true );\n        \n        if( encRevision == 2 )\n        {\n            encryptDataRC4(encKey, ENCRYPT_PADDING, result );\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            MessageDigest md = MessageDigests.getMD5();\n            md.update( ENCRYPT_PADDING );\n\n            md.update( id );\n            result.write( md.digest() );\n\n            byte[] iterationKey = new byte[ encKey.length ];\n            for( int i=0; i<20; i++ )\n            {\n                System.arraycopy( encKey, 0, iterationKey, 0, iterationKey.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream(result.toByteArray());\n                result.reset();\n                encryptDataRC4(iterationKey, input, result);\n            }\n\n            byte[] finalResult = new byte[32];\n            System.arraycopy( result.toByteArray(), 0, finalResult, 0, 16 );\n            System.arraycopy( ENCRYPT_PADDING, 0, finalResult, 16, 16 );\n            result.reset();\n            result.write( finalResult );\n        }\n        return result.toByteArray();\n    }\n\n    \n    public byte[] computeOwnerPassword(byte[] ownerPassword, byte[] userPassword,\n                                       int encRevision,  int length ) throws IOException\n    {\n        if( encRevision == 2 && length != 5 )\n        {\n            throw new IOException(\"Expected length=5 actual=\" + length );\n        }\n        \n        byte[] rc4Key = computeRC4key(ownerPassword, encRevision, length);\n        byte[] paddedUser = truncateOrPad( userPassword );\n\n        ByteArrayOutputStream encrypted = new ByteArrayOutputStream();\n        encryptDataRC4(rc4Key, new ByteArrayInputStream(paddedUser), encrypted);\n\n        if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] iterationKey = new byte[ rc4Key.length ];\n            for( int i=1; i<20; i++ )\n            {\n                System.arraycopy( rc4Key, 0, iterationKey, 0, rc4Key.length );\n                for( int j=0; j< iterationKey.length; j++ )\n                {\n                    iterationKey[j] = (byte)(iterationKey[j] ^ (byte)i);\n                }\n                ByteArrayInputStream input = new ByteArrayInputStream( encrypted.toByteArray() );\n                encrypted.reset();\n                encryptDataRC4(iterationKey, input, encrypted );\n            }\n        }\n\n        return encrypted.toByteArray();\n    }\n\n    \n    private byte[] computeRC4key(byte[] ownerPassword, int encRevision, int length)\n    {\n        MessageDigest md = MessageDigests.getMD5();\n        byte[] digest = md.digest(truncateOrPad(ownerPassword));\n        if (encRevision == 3 || encRevision == 4)\n        {\n            for (int i = 0; i < 50; i++)\n            {\n                \n                \n                \n                md.update(digest, 0, length);\n                digest = md.digest();\n            }\n        }\n        byte[] rc4Key = new byte[length];\n        System.arraycopy(digest, 0, rc4Key, 0, length);\n        return rc4Key;\n    }\n\n\n    \n    private byte[] truncateOrPad( byte[] password )\n    {\n        byte[] padded = new byte[ ENCRYPT_PADDING.length ];\n        int bytesBeforePad = Math.min( password.length, padded.length );\n        System.arraycopy( password, 0, padded, 0, bytesBeforePad );\n        System.arraycopy( ENCRYPT_PADDING, 0, padded, bytesBeforePad,\n                          ENCRYPT_PADDING.length-bytesBeforePad );\n        return padded;\n    }\n\n    \n    public boolean isUserPassword(byte[] password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if( encRevision == 2 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            return Arrays.equals(user, passwordBytes);\n        }\n        else if( encRevision == 3 || encRevision == 4 )\n        {\n            byte[] passwordBytes = computeUserPassword( password, owner, permissions, id, encRevision,\n                                                        length, encryptMetadata );\n            \n            return Arrays.equals(Arrays.copyOf(user, 16), Arrays.copyOf(passwordBytes, 16));\n        }\n        else if (encRevision == 6 || encRevision == 5)\n        {\n            byte[] truncatedPassword = truncate127(password);\n            \n            byte[] uHash = new byte[32];\n            byte[] uValidationSalt = new byte[8];\n            System.arraycopy(user, 0, uHash, 0, 32);\n            System.arraycopy(user, 32, uValidationSalt, 0, 8);\n\n            byte[] hash;\n            if (encRevision == 5)\n            {\n                hash = computeSHA256(truncatedPassword, uValidationSalt, null);\n            }\n            else\n            {\n                hash = computeHash2A(truncatedPassword, uValidationSalt, null);\n            }\n\n            return Arrays.equals(hash, uHash);\n        }\n        else\n        {\n            throw new IOException( \"Unknown Encryption Revision \" + encRevision );\n        }\n    }\n\n    \n    public boolean isUserPassword(String password, byte[] user, byte[] owner, int permissions,\n                                  byte[] id, int encRevision,  int length, boolean encryptMetadata)\n                                  throws IOException\n    {\n        if (encRevision == 6 || encRevision == 5)\n        {\n            return isUserPassword(password.getBytes(Charsets.UTF_8), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n        else\n        {\n            return isUserPassword(password.getBytes(Charsets.ISO_8859_1), user, owner, permissions, id,\n                    encRevision, length, encryptMetadata);\n        }\n    }\n\n    \n    public boolean isOwnerPassword(String password, byte[] user, byte[] owner, int permissions,\n                                   byte[] id, int encRevision, int length, boolean encryptMetadata)\n                                   throws IOException\n    {\n        return isOwnerPassword(password.getBytes(Charsets.ISO_8859_1), user,owner,permissions, id,\n                               encRevision, length, encryptMetadata);\n    }\n\n    \n    private byte[] computeHash2A(byte[] password, byte[] salt, byte[] u) throws IOException\n    {\n        byte[] userKey;\n        if (u == null)\n        {\n            userKey = new byte[0];\n        }\n        else if (u.length < 48)\n        {\n            throw new IOException(\"Bad U length\");\n        }\n        else if (u.length > 48)\n        {\n            \n            userKey = new byte[48];\n            System.arraycopy(u, 0, userKey, 0, 48);\n        }\n        else\n        {\n            userKey = u;\n        }\n\n        byte[] truncatedPassword = truncate127(password);\n        byte[] input = concat(truncatedPassword, salt, userKey);\n        return computeHash2B(input, truncatedPassword, userKey);\n    }\n    \n    \n    private static byte[] computeHash2B(byte[] input, byte[] password, byte[] userKey)\n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            byte[] k = md.digest(input);\n            \n            byte[] e = null;\n            for (int round = 0; round < 64 || ((int)e[e.length-1] & 0xFF) > round - 32; round++)\n            {                \n                byte[] k1;\n                if (userKey != null && userKey.length >= 48)\n                {\n                    k1 = new byte[64*(password.length + k.length + 48)];\n                }\n                else\n                {\n                    k1 = new byte[64*(password.length + k.length)];\n                }\n                \n                int pos = 0;\n                for (int i = 0; i < 64; i++)\n                {\n                    System.arraycopy(password, 0, k1, pos, password.length);\n                    pos += password.length;\n                    System.arraycopy(k, 0, k1, pos, k.length);\n                    pos += k.length;\n                    if (userKey != null && userKey.length >= 48)\n                    {\n                        System.arraycopy(userKey, 0, k1, pos, 48);\n                        pos += 48;\n                    }\n                }\n                \n                byte[] kFirst = new byte[16];\n                byte[] kSecond = new byte[16];\n                System.arraycopy(k, 0, kFirst, 0, 16);\n                System.arraycopy(k, 16, kSecond, 0, 16);\n                \n                Cipher cipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n                SecretKeySpec keySpec = new SecretKeySpec(kFirst, \"AES\");\n                IvParameterSpec ivSpec = new IvParameterSpec(kSecond);\n                cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n                e = cipher.doFinal(k1);\n                \n                byte[] eFirst = new byte[16];\n                System.arraycopy(e, 0, eFirst, 0, 16);\n                BigInteger bi = new BigInteger(1, eFirst);\n                BigInteger remainder = bi.mod(new BigInteger(\"3\"));\n                String nextHash = HASHES_2B[remainder.intValue()];\n                \n                md = MessageDigest.getInstance(nextHash);\n                k = md.digest(e);\n            }\n            \n            if (k.length > 32)\n            {\n                byte[] kTrunc = new byte[32];\n                System.arraycopy(k, 0, kTrunc, 0, 32);\n                return kTrunc;\n            }\n            else\n            {\n                return k;\n            }            \n        }\n        catch (GeneralSecurityException e)\n        {\n            logIfStrongEncryptionMissing();\n            throw new IOException(e);\n        }\n    }\n\n    private static byte[] computeSHA256(byte[] input, byte[] password, byte[] userKey) \n            throws IOException\n    {\n        try\n        {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(input);\n            md.update(password);\n            return userKey == null ? md.digest() : md.digest(userKey);\n        }\n        catch (NoSuchAlgorithmException e)\n        {\n            throw new IOException(e);\n        }\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b)\n    {\n        byte[] o = new byte[a.length + b.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        return o;\n    }\n    \n    private static byte[] concat(byte[] a, byte[] b, byte[] c)\n    {\n        byte[] o = new byte[a.length + b.length + c.length];\n        System.arraycopy(a, 0, o, 0, a.length);\n        System.arraycopy(b, 0, o, a.length, b.length);\n        System.arraycopy(c, 0, o, a.length + b.length, c.length);\n        return o;\n    }\n    \n    private static byte[] truncate127(byte[] in)\n    {\n        if (in.length <= 127)\n        {\n            return in;\n        }\n        byte[] trunc = new byte[127];\n        System.arraycopy(in, 0, trunc, 0, 127);\n        return trunc;\n    }\n\n    private static void logIfStrongEncryptionMissing()\n    {\n        try\n        {\n            if (Cipher.getMaxAllowedKeyLength(\"AES\") != Integer.MAX_VALUE)\n            {\n                LOG.warn(\"JCE unlimited strength jurisdiction policy files are not installed\");\n            }\n        }\n        catch (NoSuchAlgorithmException ex)\n        {\n        }\n    }\n\n    \n    @Override\n    public boolean hasProtectionPolicy()\n    {\n        return policy != null;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 19,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/pdfbox/commit/0e14d6a42cc965e23bb1b40f04b4c002dc173b88",
    "cve_id": "CVE-2018-11797",
    "cwe_id": "Not Mapping",
    "filename": "pdfbox/src/main/java/org/apache/pdfbox/cos/COSArray.java",
    "code": "\npackage org.apache.pdfbox.cos;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.apache.pdfbox.pdmodel.common.COSObjectable;\n\n\npublic class COSArray extends COSBase implements Iterable<COSBase>, COSUpdateInfo\n{\n    private final List<COSBase> objects = new ArrayList<>();\n    private boolean needToBeUpdated;\n\n    \n    public COSArray()\n    {\n        \n    }\n\n    \n    public void add( COSBase object )\n    {\n        objects.add( object );\n    }\n\n    \n    public void add( COSObjectable object )\n    {\n        objects.add( object.getCOSObject() );\n    }\n\n    \n    public void add( int i, COSBase object)\n    {\n        objects.add( i, object );\n    }\n\n    \n    public void clear()\n    {\n        objects.clear();\n    }\n\n    \n    public void removeAll( Collection<COSBase> objectsList )\n    {\n        objects.removeAll( objectsList );\n    }\n\n    \n    public void retainAll( Collection<COSBase> objectsList )\n    {\n        objects.retainAll( objectsList );\n    }\n\n    \n    public void addAll( Collection<COSBase> objectsList )\n    {\n        objects.addAll( objectsList );\n    }\n\n    \n    public void addAll( COSArray objectList )\n    {\n        if( objectList != null )\n        {\n            objects.addAll( objectList.objects );\n        }\n    }\n\n    \n    public void addAll( int i, Collection<COSBase> objectList )\n    {\n        objects.addAll( i, objectList );\n    }\n\n    \n    public void set( int index, COSBase object )\n    {\n        objects.set( index, object );\n    }\n\n    \n    public void set( int index, int intVal )\n    {\n        objects.set( index, COSInteger.get(intVal) );\n    }\n\n    \n    public void set( int index, COSObjectable object )\n    {\n        COSBase base = null;\n        if( object != null )\n        {\n            base = object.getCOSObject();\n        }\n        objects.set( index, base );\n    }\n\n    \n    public COSBase getObject( int index )\n    {\n        Object obj = objects.get( index );\n        if( obj instanceof COSObject )\n        {\n            obj = ((COSObject)obj).getObject();\n        }\n        if (obj instanceof COSNull)\n        {\n            obj = null;\n        }\n        return (COSBase)obj;\n    }\n\n    \n    public COSBase get( int index )\n    {\n        return objects.get( index );\n    }\n\n    \n    public int getInt( int index )\n    {\n        return getInt( index, -1 );\n    }\n\n    \n    public int getInt( int index, int defaultValue )\n    {\n        int retval = defaultValue;\n        if ( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSNumber )\n            {\n                retval = ((COSNumber)obj).intValue();\n            }\n        }\n        return retval;\n    }\n\n    \n    public void setInt( int index, int value )\n    {\n        set( index, COSInteger.get( value ) );\n    }\n\n    \n    public void setName( int index, String name )\n    {\n        set( index, COSName.getPDFName( name ) );\n    }\n\n    \n    public String getName( int index )\n    {\n        return getName( index, null );\n    }\n\n    \n    public String getName( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSName )\n            {\n                retval = ((COSName)obj).getName();\n            }\n        }\n        return retval;\n    }\n\n    \n    public void setString( int index, String string )\n    {\n        if ( string != null )\n        {\n            set( index, new COSString( string ) );\n        }\n        else\n        {\n            set( index, null );\n        }\n    }   \n\n    \n    public String getString( int index )\n    {\n        return getString( index, null );\n    }\n\n    \n    public String getString( int index, String defaultValue )\n    {\n        String retval = defaultValue;\n        if( index < size() )\n        {\n            Object obj = objects.get( index );\n            if( obj instanceof COSString )\n            {\n                retval = ((COSString)obj).getString();\n            }\n        }\n        return retval;\n    }\n\n    \n    public int size()\n    {\n        return objects.size();\n    }\n\n    \n    public COSBase remove( int i )\n    {\n        return objects.remove( i );\n    }\n\n    \n    public boolean remove( COSBase o )\n    {\n        return objects.remove( o );\n    }\n\n    \n    public boolean removeObject(COSBase o)\n    {\n        boolean removed = this.remove(o);\n        if (!removed)\n        {\n            for (int i = 0; i < this.size(); i++)\n            {\n                COSBase entry = this.get(i);\n                if (entry instanceof COSObject)\n                {\n                    COSObject objEntry = (COSObject) entry;\n                    if (objEntry.getObject().equals(o))\n                    {\n                        return this.remove(entry);\n                    }\n                }\n            }\n        }\n        return removed;\n    }\n\n    \n    @Override\n    public String toString()\n    {\n        return \"COSArray{\" + objects + \"}\";\n    }\n\n    \n    @Override\n    public Iterator<COSBase> iterator()\n    {\n        return objects.iterator();\n    }\n\n    \n    public int indexOf( COSBase object )\n    {\n        int retval = -1;\n        for( int i=0; retval < 0 && i<size(); i++ )\n        {\n            if( get( i ).equals( object ) )\n            {\n                retval = i;\n            }\n        }\n        return retval;\n    }\n\n    \n    public int indexOfObject(COSBase object)\n    {\n        int retval = -1;\n        for (int i = 0; retval < 0 && i < this.size(); i++)\n        {\n            COSBase item = this.get(i);\n            if (item.equals(object))\n            {\n                retval = i;\n                break;\n            }\n            else if (item instanceof COSObject && ((COSObject) item).getObject().equals(object))\n            {\n                retval = i;\n                break;\n            }\n        }\n        return retval;\n    }\n\n    \n    public void growToSize( int size )\n    {\n        growToSize( size, null );\n    }\n\n    \n    public void growToSize( int size, COSBase object )\n    {\n        while( size() < size )\n        {\n            add( object );\n        }\n    }\n\n    \n    @Override\n    public Object accept(ICOSVisitor visitor) throws IOException\n    {\n        return visitor.visitFromArray(this);\n    }\n\n    @Override\n    public boolean isNeedToBeUpdated() \n    {\n      return needToBeUpdated;\n    }\n    \n    @Override\n    public void setNeedToBeUpdated(boolean flag) \n    {\n      needToBeUpdated = flag;\n    }\n\n    \n    public float[] toFloatArray()\n    {\n        float[] retval = new float[size()];\n        for( int i=0; i<size(); i++ )\n        {\n            retval[i] = ((COSNumber)getObject( i )).floatValue();\n        }\n        return retval;\n    }\n\n    \n    public void setFloatArray( float[] value )\n    {\n        this.clear();\n        for (float aValue : value)\n        {\n            add(new COSFloat(aValue));\n        }\n    }\n\n    \n    public List<? extends COSBase> toList()\n    {\n        List<COSBase> retList = new ArrayList<>(size());\n        for (int i = 0; i < size(); i++)\n        {\n            retList.add(get(i));\n        }\n        return retList;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 20,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/santuario-java/commit/e50488044121cf01ffbc235ca53b9562031d69c5",
    "cve_id": "CVE-2014-8152",
    "cwe_id": "CWE-254",
    "filename": "src/main/java/org/apache/xml/security/stax/ext/InputProcessorChain.java",
    "code": "\npackage org.apache.xml.security.stax.ext;\n\nimport org.apache.xml.security.exceptions.XMLSecurityException;\nimport org.apache.xml.security.stax.ext.stax.XMLSecEvent;\n\nimport javax.xml.stream.XMLStreamException;\nimport java.util.List;\n\n\npublic interface InputProcessorChain extends ProcessorChain {\n\n    \n    void addProcessor(InputProcessor inputProcessor);\n\n    \n    void removeProcessor(InputProcessor inputProcessor);\n\n    \n    List<InputProcessor> getProcessors();\n\n    \n    InboundSecurityContext getSecurityContext();\n\n    \n    DocumentContext getDocumentContext();\n\n    \n    InputProcessorChain createSubChain(InputProcessor inputProcessor) throws XMLStreamException, XMLSecurityException;\n\n    \n    XMLSecEvent processHeaderEvent() throws XMLStreamException, XMLSecurityException;\n\n    \n    XMLSecEvent processEvent() throws XMLStreamException, XMLSecurityException;\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 20,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/santuario-java/commit/e50488044121cf01ffbc235ca53b9562031d69c5",
    "cve_id": "CVE-2014-8152",
    "cwe_id": "CWE-254",
    "filename": "src/main/java/org/apache/xml/security/stax/impl/InputProcessorChainImpl.java",
    "code": "\npackage org.apache.xml.security.stax.impl;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.apache.xml.security.exceptions.XMLSecurityException;\nimport org.apache.xml.security.stax.ext.*;\nimport org.apache.xml.security.stax.ext.stax.XMLSecEvent;\n\nimport javax.xml.stream.XMLStreamException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class InputProcessorChainImpl implements InputProcessorChain {\n\n    protected static final transient Logger log = LoggerFactory.getLogger(InputProcessorChainImpl.class);\n    protected static final transient boolean isDebugEnabled = log.isDebugEnabled();\n\n    private List<InputProcessor> inputProcessors;\n    private int startPos = 0;\n    private int curPos = 0;\n\n    private final InboundSecurityContext inboundSecurityContext;\n    private final DocumentContextImpl documentContext;\n\n    public InputProcessorChainImpl(InboundSecurityContext inboundSecurityContext) {\n        this(inboundSecurityContext, 0);\n    }\n\n    public InputProcessorChainImpl(InboundSecurityContext inboundSecurityContext, int startPos) {\n        this(inboundSecurityContext, new DocumentContextImpl(), startPos, new ArrayList<InputProcessor>(20));\n    }\n\n    public InputProcessorChainImpl(InboundSecurityContext inboundSecurityContext, DocumentContextImpl documentContext) {\n        this(inboundSecurityContext, documentContext, 0, new ArrayList<InputProcessor>(20));\n    }\n\n    protected InputProcessorChainImpl(InboundSecurityContext inboundSecurityContext, DocumentContextImpl documentContextImpl,\n                                      int startPos, List<InputProcessor> inputProcessors) {\n        this.inboundSecurityContext = inboundSecurityContext;\n        this.curPos = this.startPos = startPos;\n        this.documentContext = documentContextImpl;\n        this.inputProcessors = inputProcessors;\n    }\n\n    @Override\n    public void reset() {\n        this.curPos = startPos;\n    }\n\n    @Override\n    public InboundSecurityContext getSecurityContext() {\n        return this.inboundSecurityContext;\n    }\n\n    @Override\n    public DocumentContext getDocumentContext() {\n        return this.documentContext;\n    }\n\n    @Override\n    public synchronized void addProcessor(InputProcessor newInputProcessor) {\n        int startPhaseIdx = 0;\n        int endPhaseIdx = inputProcessors.size();\n\n        XMLSecurityConstants.Phase targetPhase = newInputProcessor.getPhase();\n\n        for (int i = inputProcessors.size() - 1; i >= 0; i--) {\n            InputProcessor inputProcessor = inputProcessors.get(i);\n            if (inputProcessor.getPhase().ordinal() > targetPhase.ordinal()) {\n                startPhaseIdx = i + 1;\n                break;\n            }\n        }\n        for (int i = startPhaseIdx; i < inputProcessors.size(); i++) {\n            InputProcessor inputProcessor = inputProcessors.get(i);\n            if (inputProcessor.getPhase().ordinal() < targetPhase.ordinal()) {\n                endPhaseIdx = i;\n                break;\n            }\n        }\n\n        \n        if (newInputProcessor.getBeforeProcessors().isEmpty()\n                && newInputProcessor.getAfterProcessors().isEmpty()) {\n            inputProcessors.add(startPhaseIdx, newInputProcessor);\n        } else if (newInputProcessor.getBeforeProcessors().isEmpty()) {\n            int idxToInsert = startPhaseIdx;\n\n            for (int i = endPhaseIdx - 1; i >= startPhaseIdx; i--) {\n                InputProcessor inputProcessor = inputProcessors.get(i);\n                if (newInputProcessor.getAfterProcessors().contains(inputProcessor)\n                        || newInputProcessor.getAfterProcessors().contains(inputProcessor.getClass().getName())) {\n                    idxToInsert = i;\n                    break;\n                }\n            }\n            inputProcessors.add(idxToInsert, newInputProcessor);\n        } else if (newInputProcessor.getAfterProcessors().isEmpty()) {\n            int idxToInsert = endPhaseIdx;\n\n            for (int i = startPhaseIdx; i < endPhaseIdx; i++) {\n                InputProcessor inputProcessor = inputProcessors.get(i);\n                if (newInputProcessor.getBeforeProcessors().contains(inputProcessor)\n                        || newInputProcessor.getBeforeProcessors().contains(inputProcessor.getClass().getName())) {\n                    idxToInsert = i + 1;\n                    break;\n                }\n            }\n            inputProcessors.add(idxToInsert, newInputProcessor);\n        } else {\n            boolean found = false;\n            int idxToInsert = startPhaseIdx;\n\n            for (int i = endPhaseIdx - 1; i >= startPhaseIdx; i--) {\n                InputProcessor inputProcessor = inputProcessors.get(i);\n                if (newInputProcessor.getAfterProcessors().contains(inputProcessor)\n                        || newInputProcessor.getAfterProcessors().contains(inputProcessor.getClass().getName())) {\n                    idxToInsert = i;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) {\n                inputProcessors.add(idxToInsert, newInputProcessor);\n            } else {\n                for (int i = startPhaseIdx; i < endPhaseIdx; i++) {\n                    InputProcessor inputProcessor = inputProcessors.get(i);\n                    if (newInputProcessor.getBeforeProcessors().contains(inputProcessor)\n                            || newInputProcessor.getBeforeProcessors().contains(inputProcessor.getClass().getName())) {\n                        idxToInsert = i + 1;\n                        break;\n                    }\n                }\n                inputProcessors.add(idxToInsert, newInputProcessor);\n            }\n        }\n        if (isDebugEnabled) {\n            log.debug(\"Added \" + newInputProcessor.getClass().getName() + \" to input chain: \");\n            for (int i = 0; i < inputProcessors.size(); i++) {\n                InputProcessor inputProcessor = inputProcessors.get(i);\n                log.debug(\"Name: \" + inputProcessor.getClass().getName() + \" phase: \" + inputProcessor.getPhase());\n            }\n        }\n    }\n\n    @Override\n    public synchronized void removeProcessor(InputProcessor inputProcessor) {\n        if (isDebugEnabled) {\n            log.debug(\"Removing processor \" + inputProcessor.getClass().getName() + \" from input chain\");\n        }\n        if (this.inputProcessors.indexOf(inputProcessor) <= curPos) {\n            this.curPos--;\n        }\n        this.inputProcessors.remove(inputProcessor);\n    }\n\n    @Override\n    public List<InputProcessor> getProcessors() {\n        return this.inputProcessors;\n    }\n\n    @Override\n    public XMLSecEvent processHeaderEvent() throws XMLStreamException, XMLSecurityException {\n        return inputProcessors.get(this.curPos++).processNextHeaderEvent(this);\n    }\n\n    @Override\n    public XMLSecEvent processEvent() throws XMLStreamException, XMLSecurityException {\n        return inputProcessors.get(this.curPos++).processNextEvent(this);\n    }\n\n    @Override\n    public void doFinal() throws XMLStreamException, XMLSecurityException {\n        inputProcessors.get(this.curPos++).doFinal(this);\n    }\n\n    @Override\n    public InputProcessorChain createSubChain(InputProcessor inputProcessor) throws XMLStreamException, XMLSecurityException {\n        InputProcessorChainImpl inputProcessorChain;\n        try {\n            inputProcessorChain = new InputProcessorChainImpl(inboundSecurityContext, documentContext.clone(),\n                    inputProcessors.indexOf(inputProcessor) + 1, new ArrayList<InputProcessor>(this.inputProcessors));\n        } catch (CloneNotSupportedException e) {\n            throw new XMLSecurityException(e);\n        }\n        return inputProcessorChain;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 20,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/santuario-java/commit/e50488044121cf01ffbc235ca53b9562031d69c5",
    "cve_id": "CVE-2014-8152",
    "cwe_id": "CWE-254",
    "filename": "src/main/java/org/apache/xml/security/stax/impl/processor/input/XMLSecurityInputProcessor.java",
    "code": "\npackage org.apache.xml.security.stax.impl.processor.input;\n\nimport org.apache.xml.security.exceptions.XMLSecurityException;\nimport org.apache.xml.security.stax.ext.AbstractInputProcessor;\nimport org.apache.xml.security.stax.ext.InputProcessorChain;\nimport org.apache.xml.security.stax.ext.XMLSecurityConstants;\nimport org.apache.xml.security.stax.ext.XMLSecurityProperties;\nimport org.apache.xml.security.stax.ext.stax.XMLSecEndElement;\nimport org.apache.xml.security.stax.ext.stax.XMLSecEvent;\nimport org.apache.xml.security.stax.ext.stax.XMLSecStartElement;\n\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport java.util.ArrayDeque;\n\n\npublic class XMLSecurityInputProcessor extends AbstractInputProcessor {\n\n    private int startIndexForProcessor = 0;\n    private InternalBufferProcessor internalBufferProcessor;\n    private boolean signatureElementFound = false;\n    private boolean encryptedDataElementFound = false;\n\n    public XMLSecurityInputProcessor(XMLSecurityProperties securityProperties) {\n        super(securityProperties);\n        setPhase(XMLSecurityConstants.Phase.POSTPROCESSING);\n    }\n\n    @Override\n    public XMLSecEvent processNextHeaderEvent(InputProcessorChain inputProcessorChain)\n            throws XMLStreamException, XMLSecurityException {\n        return null;\n    }\n\n    @Override\n    public XMLSecEvent processNextEvent(InputProcessorChain inputProcessorChain)\n            throws XMLStreamException, XMLSecurityException {\n\n        \n        if (internalBufferProcessor == null) {\n            internalBufferProcessor = new InternalBufferProcessor(getSecurityProperties());\n            inputProcessorChain.addProcessor(internalBufferProcessor);\n        }\n\n        XMLSecEvent xmlSecEvent = inputProcessorChain.processEvent();\n        switch (xmlSecEvent.getEventType()) {\n            case XMLStreamConstants.START_ELEMENT:\n                final XMLSecStartElement xmlSecStartElement = xmlSecEvent.asStartElement();\n\n                if (xmlSecStartElement.getName().equals(XMLSecurityConstants.TAG_dsig_Signature)) {\n                    signatureElementFound = true;\n                    startIndexForProcessor = internalBufferProcessor.getXmlSecEventList().size() - 1;\n                } else if (xmlSecStartElement.getName().equals(XMLSecurityConstants.TAG_xenc_EncryptedData)) {\n                    encryptedDataElementFound = true;\n\n                    XMLDecryptInputProcessor decryptInputProcessor = new XMLDecryptInputProcessor(getSecurityProperties());\n                    decryptInputProcessor.setPhase(XMLSecurityConstants.Phase.PREPROCESSING);\n                    decryptInputProcessor.addAfterProcessor(XMLEventReaderInputProcessor.class.getName());\n                    decryptInputProcessor.addBeforeProcessor(XMLSecurityInputProcessor.class.getName());\n                    decryptInputProcessor.addBeforeProcessor(XMLSecurityInputProcessor.InternalBufferProcessor.class.getName());\n                    inputProcessorChain.addProcessor(decryptInputProcessor);\n\n                    final ArrayDeque<XMLSecEvent> xmlSecEventList = internalBufferProcessor.getXmlSecEventList();\n                    \n                    xmlSecEventList.pollFirst();\n\n                    \n                    AbstractInputProcessor abstractInputProcessor = new AbstractInputProcessor(getSecurityProperties()) {\n                        @Override\n                        public XMLSecEvent processNextHeaderEvent(InputProcessorChain inputProcessorChain)\n                                throws XMLStreamException, XMLSecurityException {\n                            return processNextEvent(inputProcessorChain);\n                        }\n\n                        @Override\n                        public XMLSecEvent processNextEvent(InputProcessorChain inputProcessorChain)\n                                throws XMLStreamException, XMLSecurityException {\n                            inputProcessorChain.removeProcessor(this);\n                            return xmlSecStartElement;\n                        }\n                    };\n                    abstractInputProcessor.setPhase(XMLSecurityConstants.Phase.PREPROCESSING);\n                    abstractInputProcessor.addBeforeProcessor(decryptInputProcessor);\n                    inputProcessorChain.addProcessor(abstractInputProcessor);\n\n                    \n                    inputProcessorChain.reset();\n                    xmlSecEvent = inputProcessorChain.processEvent();\n\n                    \n                    if (xmlSecEvent.isStartElement() &&\n                            xmlSecEvent.asStartElement().getName().equals(XMLSecurityConstants.TAG_dsig_Signature)) {\n                        signatureElementFound = true;\n                        startIndexForProcessor = internalBufferProcessor.getXmlSecEventList().size() - 1;\n                    }\n                }\n                break;\n            case XMLStreamConstants.END_ELEMENT:\n                XMLSecEndElement xmlSecEndElement = xmlSecEvent.asEndElement();\n                \n                if (signatureElementFound\n                        && xmlSecEndElement.getName().equals(XMLSecurityConstants.TAG_dsig_Signature)) {\n                    XMLSignatureInputHandler inputHandler = new XMLSignatureInputHandler();\n\n                    final ArrayDeque<XMLSecEvent> xmlSecEventList = internalBufferProcessor.getXmlSecEventList();\n                    inputHandler.handle(inputProcessorChain, getSecurityProperties(),\n                            xmlSecEventList, startIndexForProcessor);\n\n                    inputProcessorChain.removeProcessor(internalBufferProcessor);\n\n                    \n                    InternalReplayProcessor internalReplayProcessor =\n                            new InternalReplayProcessor(getSecurityProperties(), xmlSecEventList);\n                    internalReplayProcessor.addBeforeProcessor(XMLSignatureReferenceVerifyInputProcessor.class.getName());\n                    inputProcessorChain.addProcessor(internalReplayProcessor);\n\n                    \n                    InputProcessorChain subInputProcessorChain = inputProcessorChain.createSubChain(this);\n                    while (!xmlSecEventList.isEmpty()) {\n                        subInputProcessorChain.reset();\n                        subInputProcessorChain.processEvent();\n                    }\n                }\n                break;\n        }\n\n        return xmlSecEvent;\n    }\n\n    @Override\n    public void doFinal(InputProcessorChain inputProcessorChain) throws XMLStreamException, XMLSecurityException {\n        if (!signatureElementFound && !encryptedDataElementFound) {\n            throw new XMLSecurityException(\"stax.unsecuredMessage\");\n        }\n        super.doFinal(inputProcessorChain);\n    }\n\n    \n    public class InternalBufferProcessor extends AbstractInputProcessor {\n\n        private final ArrayDeque<XMLSecEvent> xmlSecEventList = new ArrayDeque<XMLSecEvent>();\n\n        InternalBufferProcessor(XMLSecurityProperties securityProperties) {\n            super(securityProperties);\n            setPhase(XMLSecurityConstants.Phase.POSTPROCESSING);\n            addBeforeProcessor(XMLSecurityInputProcessor.class.getName());\n        }\n\n        public ArrayDeque<XMLSecEvent> getXmlSecEventList() {\n            return xmlSecEventList;\n        }\n\n        @Override\n        public XMLSecEvent processNextHeaderEvent(InputProcessorChain inputProcessorChain)\n                throws XMLStreamException, XMLSecurityException {\n            return null;\n        }\n\n        @Override\n        public XMLSecEvent processNextEvent(InputProcessorChain inputProcessorChain)\n                throws XMLStreamException, XMLSecurityException {\n            XMLSecEvent xmlSecEvent = inputProcessorChain.processEvent();\n            xmlSecEventList.push(xmlSecEvent);\n            return xmlSecEvent;\n        }\n    }\n\n    \n    public class InternalReplayProcessor extends AbstractInputProcessor {\n\n        private final ArrayDeque<XMLSecEvent> xmlSecEventList;\n\n        public InternalReplayProcessor(XMLSecurityProperties securityProperties, ArrayDeque<XMLSecEvent> xmlSecEventList) {\n            super(securityProperties);\n            this.xmlSecEventList = xmlSecEventList;\n        }\n\n        @Override\n        public XMLSecEvent processNextHeaderEvent(InputProcessorChain inputProcessorChain)\n                throws XMLStreamException, XMLSecurityException {\n            return null;\n        }\n\n        @Override\n        public XMLSecEvent processNextEvent(InputProcessorChain inputProcessorChain)\n                throws XMLStreamException, XMLSecurityException {\n\n            if (!xmlSecEventList.isEmpty()) {\n                return xmlSecEventList.pollLast();\n            } else {\n                inputProcessorChain.removeProcessor(this);\n                return inputProcessorChain.processEvent();\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 20,
    "sub_id": 3,
    "code_id": 0,
    "human_patch": "https://github.com/apache/santuario-java/commit/e50488044121cf01ffbc235ca53b9562031d69c5",
    "cve_id": "CVE-2014-8152",
    "cwe_id": "CWE-254",
    "filename": "src/test/java/org/apache/xml/security/test/stax/signature/SignatureVerificationTest.java",
    "code": "\npackage org.apache.xml.security.test.stax.signature;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\nimport java.security.Key;\nimport java.security.KeyStore;\nimport java.security.Security;\nimport java.security.cert.X509Certificate;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.apache.xml.security.c14n.Canonicalizer;\nimport org.apache.xml.security.c14n.implementations.Canonicalizer20010315OmitComments;\nimport org.apache.xml.security.exceptions.XMLSecurityException;\nimport org.apache.xml.security.keys.KeyInfo;\nimport org.apache.xml.security.keys.content.KeyName;\nimport org.apache.xml.security.keys.content.X509Data;\nimport org.apache.xml.security.keys.content.x509.XMLX509IssuerSerial;\nimport org.apache.xml.security.signature.XMLSignature;\nimport org.apache.xml.security.stax.config.Init;\nimport org.apache.xml.security.stax.config.TransformerAlgorithmMapper;\nimport org.apache.xml.security.stax.ext.*;\nimport org.apache.xml.security.stax.securityEvent.*;\nimport org.apache.xml.security.stax.securityToken.SecurityTokenConstants;\nimport org.apache.xml.security.test.stax.utils.StAX2DOM;\nimport org.apache.xml.security.test.stax.utils.TestUtils;\nimport org.apache.xml.security.test.stax.utils.XMLSecEventAllocator;\nimport org.apache.xml.security.transforms.Transform;\nimport org.apache.xml.security.transforms.implementations.TransformC14N;\nimport org.apache.xml.security.utils.XMLUtils;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.w3c.dom.Document;\n\n\npublic class SignatureVerificationTest extends AbstractSignatureVerificationTest {\n\n    private XMLInputFactory xmlInputFactory;\n    private TransformerFactory transformerFactory = TransformerFactory.newInstance();\n    \n    @Before\n    public void setUp() throws Exception {\n        Init.init(SignatureVerificationTest.class.getClassLoader().getResource(\"security-config.xml\").toURI(),\n                this.getClass());\n        org.apache.xml.security.Init.init();\n        \n        xmlInputFactory = XMLInputFactory.newInstance();\n        xmlInputFactory.setEventAllocator(new XMLSecEventAllocator());\n    }\n    \n\n    @Test\n    public void testSignatureVerification() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testMultipleElements() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        localNames.add(\"ShippingAddress\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementMultipleSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        List<SignedElementSecurityEvent> signedElementSecurityEventList = securityEventListener.getSecurityEvents(SecurityEventConstants.SignedElement);\n        Assert.assertEquals(2, signedElementSecurityEventList.size());\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID1 = signedElementSecurityEventList.get(0).getCorrelationID();\n        String signedElementCorrelationID2 = signedElementSecurityEventList.get(1).getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents1 = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents2 = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID1)) {\n                signedElementSecurityEvents1.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(signedElementCorrelationID2)) {\n                signedElementSecurityEvents2.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents1.size());\n        Assert.assertEquals(3, signedElementSecurityEvents2.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents1.size() + signedElementSecurityEvents2.size());\n    }\n    \n    @Test\n    public void testHMACSignatureVerification() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        byte[] hmacKey = \"secret\".getBytes(\"ASCII\");\n        SecretKey key = new SecretKeySpec(hmacKey, \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\", document, localNames, key\n        );\n        \n        \n        KeyInfo keyInfo = sig.getKeyInfo();\n        KeyName keyName = new KeyName(document, \"SecretKey\");\n        keyInfo.add(keyName);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(key);\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener,\n                            \"http://www.w3.org/2001/10/xml-exc-c14n#\",\n                            \"http://www.w3.org/2000/09/xmldsig#sha1\",\n                            \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\");\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, null, key,\n                            SecurityTokenConstants.KeyIdentifier_KeyName);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        KeyNameTokenSecurityEvent keyNameSecurityToken = securityEventListener.getSecurityEvent(SecurityEventConstants.KeyNameToken);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = keyNameSecurityToken.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testHMACSignatureVerificationWrongKey() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        byte[] hmacKey = \"secret\".getBytes(\"ASCII\");\n        SecretKey key = new SecretKeySpec(hmacKey, \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\", document, localNames, key\n        );\n        \n        \n        KeyInfo keyInfo = sig.getKeyInfo();\n        KeyName keyName = new KeyName(document, \"SecretKey\");\n        keyInfo.add(keyName);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        \n        byte[] badKey = \"secret2\".getBytes(\"ASCII\");\n        key = new SecretKeySpec(badKey, \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\");\n        properties.setSignatureVerificationKey(key);\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        XMLStreamReader securityStreamReader = inboundXMLSec.processInMessage(xmlStreamReader);\n\n        try {\n            StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n            fail(\"Failure expected on a bad key\");\n        } catch (XMLStreamException ex) {\n            Assert.assertTrue(ex.getCause() instanceof XMLSecurityException);\n            Assert.assertEquals(\"INVALID signature -- core validation failed.\", ex.getCause().getMessage());\n        }\n    }\n    \n    @Test\n    public void testECDSASignatureVerification() throws Exception {\n        \n        if (Security.getProvider(\"BC\") == null) {\n            return;\n        }\n        \n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\n                \"org/apache/xml/security/samples/input/ecdsa.jks\").openStream(), \n                \"security\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"ECDSA\", \"security\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"ECDSA\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\", document, localNames, key\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener, \n                \"http://www.w3.org/2001/10/xml-exc-c14n#\",\n                \"http://www.w3.org/2000/09/xmldsig#sha1\",\n                \"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\");\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testDifferentC14nMethod() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key,\n            \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener, \n                            \"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\",\n                            \"http://www.w3.org/2000/09/xmldsig#sha1\",\n                            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\");\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testC14n11Method() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key,\n            \"http://www.w3.org/2006/12/xml-c14n11\"\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener, \n                            \"http://www.w3.org/2006/12/xml-c14n11\",\n                            \"http://www.w3.org/2000/09/xmldsig#sha1\",\n                            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\");\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testStrongSignatureVerification() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\", document, localNames, key,\n            \"http://www.w3.org/2001/10/xml-exc-c14n#\", \"http://www.w3.org/2001/04/xmlenc#sha256\"\n        );\n        \n        \n        sig.addKeyInfo(cert);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n            inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener, \n                            \"http://www.w3.org/2001/10/xml-exc-c14n#\",\n                            \"http://www.w3.org/2001/04/xmlenc#sha256\",\n                            \"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\");\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509KeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testIssuerSerial() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        KeyInfo keyInfo = sig.getKeyInfo();\n        XMLX509IssuerSerial issuerSerial = \n            new XMLX509IssuerSerial(sig.getDocument(), cert);\n        X509Data x509Data = new X509Data(sig.getDocument());\n        x509Data.add(issuerSerial);\n        keyInfo.add(x509Data);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(cert.getPublicKey());\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_IssuerSerial);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testSubjectName() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        KeyInfo keyInfo = sig.getKeyInfo();\n        X509Data x509Data = new X509Data(sig.getDocument());\n        x509Data.addSubjectName(cert);\n        keyInfo.add(x509Data);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(cert.getPublicKey());\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_X509SubjectName);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testSubjectSKI() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"JCEKS\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"test.jceks\").openStream(), \n            \"secret\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"rsakey\", \"secret\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"rsakey\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        KeyInfo keyInfo = sig.getKeyInfo();\n        X509Data x509Data = new X509Data(sig.getDocument());\n        x509Data.addSKI(cert);\n        keyInfo.add(x509Data);\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(cert.getPublicKey());\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, cert, null,\n                            SecurityTokenConstants.KeyIdentifier_SkiKeyIdentifier);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n    \n    @Test\n    public void testKeyValue() throws Exception {\n        \n        InputStream sourceDocument = \n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n        \n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n            this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(), \n            \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n        \n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n            \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n        \n        \n        sig.addKeyInfo(cert.getPublicKey());\n        \n        \n        \n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader = \n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n  \n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(cert.getPublicKey());\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader = \n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        \n        \n        checkSecurityEvents(securityEventListener);\n        checkSignedElementSecurityEvents(securityEventListener);\n        checkSignatureToken(securityEventListener, null, cert.getPublicKey(),\n                            SecurityTokenConstants.KeyIdentifier_KeyValue);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        KeyValueTokenSecurityEvent keyValueTokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.KeyValueToken);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = keyValueTokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n\n    @Test\n    public void testSignatureVerificationTransformBase64() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext-base64.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\",\n                document, localNames, \"http://www.w3.org/2000/09/xmldsig#base64\", key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n\n        SignedElementSecurityEvent signedElementSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.SignedElement);\n        X509TokenSecurityEvent x509TokenSecurityEvent = securityEventListener.getSecurityEvent(SecurityEventConstants.X509Token);\n        String signedElementCorrelationID = signedElementSecurityEvent.getCorrelationID();\n        String x509TokenCorrelationID = x509TokenSecurityEvent.getCorrelationID();\n\n        List<SecurityEvent> signatureSecurityEvents = new ArrayList<SecurityEvent>();\n        List<SecurityEvent> signedElementSecurityEvents = new ArrayList<SecurityEvent>();\n\n        List<SecurityEvent> securityEvents = securityEventListener.getSecurityEvents();\n        for (int i = 0; i < securityEvents.size(); i++) {\n            SecurityEvent securityEvent = securityEvents.get(i);\n            if (securityEvent.getCorrelationID().equals(signedElementCorrelationID)) {\n                signedElementSecurityEvents.add(securityEvent);\n            } else if (securityEvent.getCorrelationID().equals(x509TokenCorrelationID)) {\n                signatureSecurityEvents.add(securityEvent);\n            }\n        }\n\n        Assert.assertEquals(4, signatureSecurityEvents.size());\n        Assert.assertEquals(3, signedElementSecurityEvents.size());\n        Assert.assertEquals(securityEventListener.getSecurityEvents().size(),\n                signatureSecurityEvents.size() + signedElementSecurityEvents.size());\n    }\n\n    @Test\n    public void testMaximumAllowedReferencesPerManifest() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"Item\");\n        localNames.add(\"PaymentInfo\");\n        localNames.add(\"ShippingAddress\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        int oldval = 0;\n        try {\n            oldval = TestUtils.changeValueOfMaximumAllowedReferencesPerManifest(2);\n            document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n            fail(\"Exception expected\");\n        } catch (XMLStreamException e) {\n            assertTrue(e.getCause() instanceof XMLSecurityException);\n            assertEquals(\"4 references are contained in the Manifest, maximum 2 are allowed. You can raise the maximum \" +\n                    \"via the \\\"MaximumAllowedReferencesPerManifest\\\" property in the configuration.\",\n                    e.getCause().getMessage());\n        } finally {\n            TestUtils.changeValueOfMaximumAllowedReferencesPerManifest(oldval);\n        }\n    }\n\n    @Test\n    public void testMaximumAllowedTransformsPerReference() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        int oldval = 0;\n        try {\n            oldval = TestUtils.changeValueOfMaximumAllowedTransformsPerReference(0);\n            document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n            fail(\"Exception expected\");\n        } catch (XMLStreamException e) {\n            assertTrue(e.getCause() instanceof XMLSecurityException);\n            assertEquals(\"1 transforms are contained in the Reference, maximum 0 are allowed. You can raise the maximum \" +\n                    \"via the \\\"MaximumAllowedTransformsPerReference\\\" property in the configuration.\",\n                    e.getCause().getMessage());\n        } finally {\n            TestUtils.changeValueOfMaximumAllowedTransformsPerReference(oldval);\n        }\n    }\n\n    @Test\n    public void testDisallowMD5Algorithm() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2001/04/xmldsig-more#rsa-md5\", document, localNames, key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        try {\n            document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n            fail(\"Exception expected\");\n        } catch (XMLStreamException e) {\n            assertTrue(e.getCause() instanceof XMLSecurityException);\n            assertEquals(\"The use of MD5 algorithm is strongly discouraged. Nonetheless can it be enabled via the \" +\n                    \"\\\"AllowMD5Algorithm\\\" property in the configuration.\",\n                    e.getCause().getMessage());\n        }\n    }\n\n    @Test\n    public void testAllowMD5Algorithm() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2001/04/xmldsig-more#rsa-md5\", document, localNames, key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        try {\n            TestUtils.switchAllowMD5Algorithm(true);\n            document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n        } finally {\n            TestUtils.switchAllowMD5Algorithm(false);\n        }\n    }\n\n    @Test\n    public void testMaximumAllowedXMLStructureDepth() throws Exception {\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        TestSecurityEventListener securityEventListener = new TestSecurityEventListener();\n        XMLStreamReader securityStreamReader =\n                inboundXMLSec.processInMessage(xmlStreamReader, null, securityEventListener);\n\n        int oldval = 0;\n        try {\n            oldval = TestUtils.changeValueOfMaximumAllowedXMLStructureDepth(5);\n            document = StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n            fail(\"Exception expected\");\n        } catch (XMLStreamException e) {\n            assertTrue(e.getCause() instanceof XMLSecurityException);\n            assertEquals(\"Maximum depth (5) of the XML structure reached. You can raise the maximum via the \" +\n                    \"\\\"MaximumAllowedXMLStructureDepth\\\" property in the configuration.\",\n                    e.getCause().getMessage());\n        } finally {\n            TestUtils.changeValueOfMaximumAllowedXMLStructureDepth(oldval);\n        }\n    }\n\n    @Test\n    public void testCustomC14nAlgo() throws Exception {\n\n        final String customC14N = \"customC14N\";\n        Transform.register(customC14N, TransformC14N.class);\n        Canonicalizer.register(customC14N, Canonicalizer20010315OmitComments.class);\n\n        Field algorithmsClassMapInField = TransformerAlgorithmMapper.class.getDeclaredField(\"algorithmsClassMapIn\");\n        algorithmsClassMapInField.setAccessible(true);\n        @SuppressWarnings(\"unchecked\")\n        Map<String, Class<?>> transformMap = (Map<String, Class<?>>)algorithmsClassMapInField.get(null);\n        transformMap.put(customC14N, org.apache.xml.security.stax.impl.transformer.canonicalizer.Canonicalizer20010315_OmitCommentsTransformer.class);\n\n        \n        InputStream sourceDocument =\n                this.getClass().getClassLoader().getResourceAsStream(\n                        \"ie/baltimore/merlin-examples/merlin-xmlenc-five/plaintext.xml\");\n        DocumentBuilder builder = XMLUtils.createDocumentBuilder(false);\n        Document document = builder.parse(sourceDocument);\n\n        \n        KeyStore keyStore = KeyStore.getInstance(\"jks\");\n        keyStore.load(\n                this.getClass().getClassLoader().getResource(\"transmitter.jks\").openStream(),\n                \"default\".toCharArray()\n        );\n        Key key = keyStore.getKey(\"transmitter\", \"default\".toCharArray());\n        X509Certificate cert = (X509Certificate)keyStore.getCertificate(\"transmitter\");\n\n        \n        List<String> localNames = new ArrayList<String>();\n        localNames.add(\"PaymentInfo\");\n\n        XMLSignature sig = signUsingDOM(\n                \"http://www.w3.org/2000/09/xmldsig#rsa-sha1\", document, localNames, key,\n                customC14N, (List<ReferenceInfo>)null\n        );\n\n        \n        sig.addKeyInfo(cert);\n\n        \n\n        \n        javax.xml.transform.Transformer transformer = transformerFactory.newTransformer();\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        transformer.transform(new DOMSource(document), new StreamResult(baos));\n        final XMLStreamReader xmlStreamReader =\n                xmlInputFactory.createXMLStreamReader(new ByteArrayInputStream(baos.toByteArray()));\n\n        \n        XMLSecurityProperties properties = new XMLSecurityProperties();\n        properties.setSignatureVerificationKey(cert.getPublicKey());\n        InboundXMLSec inboundXMLSec = XMLSec.getInboundWSSec(properties);\n        XMLStreamReader securityStreamReader = inboundXMLSec.processInMessage(xmlStreamReader);\n\n        StAX2DOM.readDoc(XMLUtils.createDocumentBuilder(false), securityStreamReader);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 21,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/shiro/commit/b15ab927709ca18ea4a02538be01919a19ab65af",
    "cve_id": "CVE-2016-6802",
    "cwe_id": "CWE-284",
    "filename": "web/src/main/java/org/apache/shiro/web/util/WebUtils.java",
    "code": "\npackage org.apache.shiro.web.util;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.subject.support.DefaultSubjectContext;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.env.EnvironmentLoader;\nimport org.apache.shiro.web.env.WebEnvironment;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.util.Map;\n\n\npublic class WebUtils {\n\n    \n\n    private static final Logger log = LoggerFactory.getLogger(WebUtils.class);\n\n    public static final String SERVLET_REQUEST_KEY = ServletRequest.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n    public static final String SERVLET_RESPONSE_KEY = ServletResponse.class.getName() + \"_SHIRO_THREAD_CONTEXT_KEY\";\n\n    \n    public static final String SAVED_REQUEST_KEY = \"shiroSavedRequest\";\n\n    \n    public static final String INCLUDE_REQUEST_URI_ATTRIBUTE = \"javax.servlet.include.request_uri\";\n    public static final String INCLUDE_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.include.context_path\";\n    public static final String INCLUDE_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.include.servlet_path\";\n    public static final String INCLUDE_PATH_INFO_ATTRIBUTE = \"javax.servlet.include.path_info\";\n    public static final String INCLUDE_QUERY_STRING_ATTRIBUTE = \"javax.servlet.include.query_string\";\n\n    \n    public static final String FORWARD_REQUEST_URI_ATTRIBUTE = \"javax.servlet.forward.request_uri\";\n    public static final String FORWARD_CONTEXT_PATH_ATTRIBUTE = \"javax.servlet.forward.context_path\";\n    public static final String FORWARD_SERVLET_PATH_ATTRIBUTE = \"javax.servlet.forward.servlet_path\";\n    public static final String FORWARD_PATH_INFO_ATTRIBUTE = \"javax.servlet.forward.path_info\";\n    public static final String FORWARD_QUERY_STRING_ATTRIBUTE = \"javax.servlet.forward.query_string\";\n\n    \n    public static final String DEFAULT_CHARACTER_ENCODING = \"ISO-8859-1\";\n\n    \n    public static String getPathWithinApplication(HttpServletRequest request) {\n        String contextPath = getContextPath(request);\n        String requestUri = getRequestUri(request);\n        if (StringUtils.startsWithIgnoreCase(requestUri, contextPath)) {\n            \n            String path = requestUri.substring(contextPath.length());\n            return (StringUtils.hasText(path) ? path : \"/\");\n        } else {\n            \n            return requestUri;\n        }\n    }\n\n    \n    public static String getRequestUri(HttpServletRequest request) {\n        String uri = (String) request.getAttribute(INCLUDE_REQUEST_URI_ATTRIBUTE);\n        if (uri == null) {\n            uri = request.getRequestURI();\n        }\n        return normalize(decodeAndCleanUriString(request, uri));\n    }\n\n    \n    public static String normalize(String path) {\n        return normalize(path, true);\n    }\n\n    \n    private static String normalize(String path, boolean replaceBackSlash) {\n\n        if (path == null)\n            return null;\n\n        \n        String normalized = path;\n\n        if (replaceBackSlash && normalized.indexOf('\\\\') >= 0)\n            normalized = normalized.replace('\\\\', '/');\n\n        if (normalized.equals(\"/.\"))\n            return \"/\";\n\n        \n        if (!normalized.startsWith(\"/\"))\n            normalized = \"/\" + normalized;\n\n        \n        while (true) {\n            int index = normalized.indexOf(\"//\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 1);\n        }\n\n        \n        while (true) {\n            int index = normalized.indexOf(\"/./\");\n            if (index < 0)\n                break;\n            normalized = normalized.substring(0, index) +\n                    normalized.substring(index + 2);\n        }\n\n        \n        while (true) {\n            int index = normalized.indexOf(\"/../\");\n            if (index < 0)\n                break;\n            if (index == 0)\n                return (null);  \n            int index2 = normalized.lastIndexOf('/', index - 1);\n            normalized = normalized.substring(0, index2) +\n                    normalized.substring(index + 3);\n        }\n\n        \n        return (normalized);\n\n    }\n\n\n    \n    private static String decodeAndCleanUriString(HttpServletRequest request, String uri) {\n        uri = decodeRequestString(request, uri);\n        int semicolonIndex = uri.indexOf(';');\n        return (semicolonIndex != -1 ? uri.substring(0, semicolonIndex) : uri);\n    }\n\n    \n    public static String getContextPath(HttpServletRequest request) {\n        String contextPath = (String) request.getAttribute(INCLUDE_CONTEXT_PATH_ATTRIBUTE);\n        if (contextPath == null) {\n            contextPath = request.getContextPath();\n        }\n        if (\"/\".equals(contextPath)) {\n            \n            contextPath = \"\";\n        }\n        return decodeRequestString(request, contextPath);\n    }\n\n    \n    public static WebEnvironment getRequiredWebEnvironment(ServletContext sc)\n            throws IllegalStateException {\n\n        WebEnvironment we = getWebEnvironment(sc);\n        if (we == null) {\n            throw new IllegalStateException(\"No WebEnvironment found: no EnvironmentLoaderListener registered?\");\n        }\n        return we;\n    }\n\n    \n    public static WebEnvironment getWebEnvironment(ServletContext sc) {\n        return getWebEnvironment(sc, EnvironmentLoader.ENVIRONMENT_ATTRIBUTE_KEY);\n    }\n\n    \n    public static WebEnvironment getWebEnvironment(ServletContext sc, String attrName) {\n        if (sc == null) {\n            throw new IllegalArgumentException(\"ServletContext argument must not be null.\");\n        }\n        Object attr = sc.getAttribute(attrName);\n        if (attr == null) {\n            return null;\n        }\n        if (attr instanceof RuntimeException) {\n            throw (RuntimeException) attr;\n        }\n        if (attr instanceof Error) {\n            throw (Error) attr;\n        }\n        if (attr instanceof Exception) {\n            throw new IllegalStateException((Exception) attr);\n        }\n        if (!(attr instanceof WebEnvironment)) {\n            throw new IllegalStateException(\"Context attribute is not of type WebEnvironment: \" + attr);\n        }\n        return (WebEnvironment) attr;\n    }\n\n\n    \n    @SuppressWarnings({\"deprecation\"})\n    public static String decodeRequestString(HttpServletRequest request, String source) {\n        String enc = determineEncoding(request);\n        try {\n            return URLDecoder.decode(source, enc);\n        } catch (UnsupportedEncodingException ex) {\n            if (log.isWarnEnabled()) {\n                log.warn(\"Could not decode request string [\" + source + \"] with encoding '\" + enc +\n                        \"': falling back to platform default encoding; exception message: \" + ex.getMessage());\n            }\n            return URLDecoder.decode(source);\n        }\n    }\n\n    \n    protected static String determineEncoding(HttpServletRequest request) {\n        String enc = request.getCharacterEncoding();\n        if (enc == null) {\n            enc = DEFAULT_CHARACTER_ENCODING;\n        }\n        return enc;\n    }\n\n    \n\n    public static boolean isWeb(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isWeb((RequestPairSource) requestPairSource);\n    }\n\n    public static boolean isHttp(Object requestPairSource) {\n        return requestPairSource instanceof RequestPairSource && isHttp((RequestPairSource) requestPairSource);\n    }\n\n    public static ServletRequest getRequest(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletRequest();\n        }\n        return null;\n    }\n\n    public static ServletResponse getResponse(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            return ((RequestPairSource) requestPairSource).getServletResponse();\n        }\n        return null;\n    }\n\n    public static HttpServletRequest getHttpRequest(Object requestPairSource) {\n        ServletRequest request = getRequest(requestPairSource);\n        if (request instanceof HttpServletRequest) {\n            return (HttpServletRequest) request;\n        }\n        return null;\n    }\n\n    public static HttpServletResponse getHttpResponse(Object requestPairSource) {\n        ServletResponse response = getResponse(requestPairSource);\n        if (response instanceof HttpServletResponse) {\n            return (HttpServletResponse) response;\n        }\n        return null;\n    }\n\n    private static boolean isWeb(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request != null && response != null;\n    }\n\n    private static boolean isHttp(RequestPairSource source) {\n        ServletRequest request = source.getServletRequest();\n        ServletResponse response = source.getServletResponse();\n        return request instanceof HttpServletRequest && response instanceof HttpServletResponse;\n    }\n\n    \n    public static boolean _isSessionCreationEnabled(Object requestPairSource) {\n        if (requestPairSource instanceof RequestPairSource) {\n            RequestPairSource source = (RequestPairSource) requestPairSource;\n            return _isSessionCreationEnabled(source.getServletRequest());\n        }\n        return true; \n    }\n\n    \n    public static boolean _isSessionCreationEnabled(ServletRequest request) {\n        if (request != null) {\n            Object val = request.getAttribute(DefaultSubjectContext.SESSION_CREATION_ENABLED);\n            if (val != null && val instanceof Boolean) {\n                return (Boolean) val;\n            }\n        }\n        return true; \n    }\n\n    \n    public static HttpServletRequest toHttp(ServletRequest request) {\n        return (HttpServletRequest) request;\n    }\n\n    \n    public static HttpServletResponse toHttp(ServletResponse response) {\n        return (HttpServletResponse) response;\n    }\n\n    \n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative, boolean http10Compatible) throws IOException {\n        RedirectView view = new RedirectView(url, contextRelative, http10Compatible);\n        view.renderMergedOutputModel(queryParams, toHttp(request), toHttp(response));\n    }\n\n    \n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url) throws IOException {\n        issueRedirect(request, response, url, null, true, true);\n    }\n\n    \n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams) throws IOException {\n        issueRedirect(request, response, url, queryParams, true, true);\n    }\n\n    \n    public static void issueRedirect(ServletRequest request, ServletResponse response, String url, Map queryParams, boolean contextRelative) throws IOException {\n        issueRedirect(request, response, url, queryParams, contextRelative, true);\n    }\n\n    \n    public static boolean isTrue(ServletRequest request, String paramName) {\n        String value = getCleanParam(request, paramName);\n        return value != null &&\n                (value.equalsIgnoreCase(\"true\") ||\n                        value.equalsIgnoreCase(\"t\") ||\n                        value.equalsIgnoreCase(\"1\") ||\n                        value.equalsIgnoreCase(\"enabled\") ||\n                        value.equalsIgnoreCase(\"y\") ||\n                        value.equalsIgnoreCase(\"yes\") ||\n                        value.equalsIgnoreCase(\"on\"));\n    }\n\n    \n    public static String getCleanParam(ServletRequest request, String paramName) {\n        return StringUtils.clean(request.getParameter(paramName));\n    }\n\n    public static void saveRequest(ServletRequest request) {\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession();\n        HttpServletRequest httpRequest = toHttp(request);\n        SavedRequest savedRequest = new SavedRequest(httpRequest);\n        session.setAttribute(SAVED_REQUEST_KEY, savedRequest);\n    }\n\n    public static SavedRequest getAndClearSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = getSavedRequest(request);\n        if (savedRequest != null) {\n            Subject subject = SecurityUtils.getSubject();\n            Session session = subject.getSession();\n            session.removeAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    public static SavedRequest getSavedRequest(ServletRequest request) {\n        SavedRequest savedRequest = null;\n        Subject subject = SecurityUtils.getSubject();\n        Session session = subject.getSession(false);\n        if (session != null) {\n            savedRequest = (SavedRequest) session.getAttribute(SAVED_REQUEST_KEY);\n        }\n        return savedRequest;\n    }\n\n    \n    public static void redirectToSavedRequest(ServletRequest request, ServletResponse response, String fallbackUrl)\n            throws IOException {\n        String successUrl = null;\n        boolean contextRelative = true;\n        SavedRequest savedRequest = WebUtils.getAndClearSavedRequest(request);\n        if (savedRequest != null && savedRequest.getMethod().equalsIgnoreCase(AccessControlFilter.GET_METHOD)) {\n            successUrl = savedRequest.getRequestUrl();\n            contextRelative = false;\n        }\n\n        if (successUrl == null) {\n            successUrl = fallbackUrl;\n        }\n\n        if (successUrl == null) {\n            throw new IllegalStateException(\"Success URL not available via saved request or via the \" +\n                    \"successUrlFallback method parameter. One of these must be non-null for \" +\n                    \"issueSuccessRedirect() to work.\");\n        }\n\n        WebUtils.issueRedirect(request, response, successUrl, null, contextRelative);\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 22,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling/commit/7d2365a248943071a44d8495655186e4f14ea294",
    "cve_id": "CVE-2016-5394",
    "cwe_id": "CWE-79",
    "filename": "bundles/extensions/xss/src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            \n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    \n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            \n            \n            \n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        \n        return \"\";\n    }\n\n    \n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    \n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    \n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    \n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    \n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    \n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    \n    private static final String PERCENT = NUMBER + \"%\";\n    \n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    \n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    \n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    \n    private static final String CSS_TOKEN = \"(?i)\" \n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    \n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    \n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            \n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            \n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    \n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    \n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    \n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    \n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    \n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScriptSource(source);\n    }\n\n    \n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    \n    \n    \n\n    \n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    \n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 22,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling/commit/7d2365a248943071a44d8495655186e4f14ea294",
    "cve_id": "CVE-2016-5394",
    "cwe_id": "CWE-79",
    "filename": "bundles/extensions/xss/src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\n\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.xss.XSSAPI;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.owasp.validator.html.AntiSamy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.model.Attribute;\nimport org.powermock.reflect.Whitebox;\n\nimport junit.framework.TestCase;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class XSSAPIImplTest {\n\n    public static final String RUBBISH = \"rubbish\";\n    public static final String RUBBISH_JSON = \"[\\\"rubbish\\\"]\";\n    public static final String RUBBISH_XML = \"<rubbish/>\";\n\n    private XSSAPI xssAPI;\n\n    @Before\n    public void setup() {\n        try {\n            XSSFilterImpl xssFilter = new XSSFilterImpl();\n            setDefaultHandler(xssFilter, \"./src/main/resources/SLING-INF/content/config.xml\");\n\n            xssAPI = new XSSAPIImpl();\n            Whitebox.invokeMethod(xssAPI, \"activate\");\n            Field filterField = XSSAPIImpl.class.getDeclaredField(\"xssFilter\");\n            filterField.setAccessible(true);\n            filterField.set(xssAPI, xssFilter);\n\n            ResourceResolver mockResolver = mock(ResourceResolver.class);\n            when(mockResolver.map(anyString())).thenAnswer(new Answer() {\n                public Object answer(InvocationOnMock invocation) {\n                    Object[] args = invocation.getArguments();\n                    String url = (String) args[0];\n                    return url.replaceAll(\"jcr:\", \"_jcr_\");\n                }\n            });\n\n            SlingHttpServletRequest mockRequest = mock(SlingHttpServletRequest.class);\n            when(mockRequest.getResourceResolver()).thenReturn(mockResolver);\n\n            xssAPI = xssAPI.getRequestSpecificAPI(mockRequest);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void setDefaultHandler(XSSFilterImpl xssFilter, String filename) throws Exception {\n        InputStream policyStream = new FileInputStream(filename);\n        Policy policy = Policy.getInstance(policyStream);\n        AntiSamy antiSamy = new AntiSamy(policy);\n\n        PolicyHandler mockPolicyHandler = mock(PolicyHandler.class);\n        when(mockPolicyHandler.getPolicy()).thenReturn(policy);\n        when(mockPolicyHandler.getAntiSamy()).thenReturn(antiSamy);\n\n        Whitebox.invokeMethod(xssFilter, \"setDefaultHandler\", mockPolicyHandler);\n    }\n\n    @Test\n    public void testEncodeForHTML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForHTMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"\\\" <script>alert('pwned');</script>\", \"&#34; &lt;script>alert(&#39;pwned&#39;);&lt;/script>\"},\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"<b>\", \"&lt;b>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\\"xss:expression(alert('XSS'))\", \"&#34;xss:expression(alert(&#39;XSS&#39;))\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testFilterHTML() {\n        String[][] testData = {\n                \n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"<script>ugly</script>\", \"\"},\n                {\"<b>wow!</b>\", \"<b>wow!</b>\"},\n\n                {\"<p onmouseover='ugly'>nice</p>\", \"<p>nice</p>\"},\n\n                {\"<img src='javascript:ugly'/>\", \"\"},\n                {\"<img src='nice.jpg'/>\", \"<img src=\\\"nice.jpg\\\" />\"},\n\n                {\"<ul><li>1</li><li>2</li></ul>\", \"<ul><li>1</li><li>2</li></ul>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n\n\n                {\"<strike>strike</strike>\", \"<strike>strike</strike>\"},\n                {\"<s>s</s>\", \"<s>s</s>\"},\n\n                {\"<a href=\\\"\\\">empty href</a>\", \"<a href=\\\"\\\">empty href</a>\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Filtering '\" + source + \"'\", expected, xssAPI.filterHTML(source));\n        }\n    }\n\n    @Test\n    public void testGetValidHref() {\n        String[][] testData = {\n                \n                \n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"../parent\", \"../parent\"},\n                {\"repo/g\u00fcnter\", \"repo/g\u00fcnter\"},\n\n                \n                {\"my/page/jcr:content.feed\", \"my/page/_jcr_content.feed\"},\n                {\"my/jcr:content/page/jcr:content\", \"my/_jcr_content/page/_jcr_content\"},\n\n                {\"\\\" onClick=ugly\", \"%22%20onClick=ugly\"},\n                {\"javascript:ugly\", \"\"},\n                {\"http://localhost:4502\", \"http://localhost:4502\"},\n                {\"http://localhost:4502/test\", \"http://localhost:4502/test\"},\n                {\"http://localhost:4502/jcr:content/test\", \"http://localhost:4502/_jcr_content/test\"},\n                {\"http://localhost:4502/test.html?a=b&b=c\", \"http://localhost:4502/test.html?a=b&b=c\"},\n\n                \n                {\"/test/ab cd\", \"/test/ab%20cd\"},\n                {\"http://localhost:4502/test/ab cd\", \"http://localhost:4502/test/ab%20cd\"},\n                {\"/test/ab attr=c\", \"/test/ab%20attr=c\"},\n                {\"http://localhost:4502/test/ab attr=c\", \"http://localhost:4502/test/ab%20attr=c\"},\n                \n                {\"/test/ab\\\"cd\", \"/test/ab%22cd\"},\n                {\"http://localhost:4502/test/ab\\\"cd\", \"http://localhost:4502/test/ab%22cd\"},\n                \n                {\"/test/ab'cd\", \"/test/ab%27cd\"},\n                {\"http://localhost:4502/test/ab'cd\", \"http://localhost:4502/test/ab%27cd\"},\n                \n                {\"/test/ab=cd\", \"/test/ab=cd\"},\n                {\"http://localhost:4502/test/ab=cd\", \"http://localhost:4502/test/ab=cd\"},\n                \n                {\"/test/ab>cd\", \"/test/ab%3Ecd\"},\n                {\"http://localhost:4502/test/ab>cd\", \"http://localhost:4502/test/ab%3Ecd\"},\n                \n                {\"/test/ab<cd\", \"/test/ab%3Ccd\"},\n                {\"http://localhost:4502/test/ab<cd\", \"http://localhost:4502/test/ab%3Ccd\"},\n                \n                {\"/test/ab`cd\", \"/test/ab%60cd\"},\n                {\"http://localhost:4502/test/ab`cd\", \"http://localhost:4502/test/ab%60cd\"},\n                \n                {\"/test/search.html?0_tag:id=test\", \"/test/search.html?0_tag%3Aid=test\"},\n                { \n                        \"/test/jcr:content/search.html?0_tag:id=test\",\n                        \"/test/_jcr_content/search.html?0_tag%3Aid=test\"\n                },\n                { \n                        \"/test/search.html?0_tag:id=test?ing&1_tag:id=abc\",\n                        \"/test/search.html?0_tag%3Aid=test?ing&1_tag%3Aid=abc\",\n                }\n        };\n\n        for (String[] aTestData : testData) {\n            String href = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Requested '\" + href + \"'\", expected, xssAPI.getValidHref(href));\n        }\n    }\n\n    @Test\n    public void testGetValidHrefWithoutHrefConfig() throws Exception {\n        \n        XSSFilterImpl xssFilter = Whitebox.getInternalState(xssAPI, \"xssFilter\");\n        setDefaultHandler(xssFilter, \"./src/test/resources/configWithoutHref.xml\");\n\n        Attribute hrefAttribute = Whitebox.getInternalState(xssFilter, \"hrefAttribute\");\n        Assert.assertEquals(hrefAttribute, XSSFilterImpl.DEFAULT_HREF_ATTRIBUTE);\n\n        \n        testGetValidHref();\n    }\n\n    @Test\n    public void testGetValidInteger() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Integer expected = (aTestData[1] != null) ? new Integer(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating integer '\" + source + \"'\", expected, xssAPI.getValidInteger(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidLong() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Long expected = (aTestData[1] != null) ? new Long(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating long '\" + source + \"'\", expected, xssAPI.getValidLong(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDouble() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100.5\", \"100.5\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Double expected = (aTestData[1] != null) ? new Double(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating double '\" + source + \"'\", expected, xssAPI.getValidDouble(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDimension() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"\", \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"},\n\n                {\"\\\"auto\\\"\", \"\\\"auto\\\"\"},\n                {\"'auto'\", \"\\\"auto\\\"\"},\n                {\"auto\", \"\\\"auto\\\"\"},\n\n                {\"autox\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating dimension '\" + source + \"'\", expected, xssAPI.getValidDimension(source, \"123\"));\n        }\n    }\n\n    @Test\n    public void testEncodeForJSString() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"break\\\"out\", \"break\\\\\\\"out\"},\n                {\"break'out\", \"break\\\\'out\"},\n                {\"'alert(document.cookie)\", \"\\\\'alert(document.cookie)\"},\n                {\"2014-04-22T10:11:24.002+01:00\", \"2014-04-22T10:11:24.002+01:00\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, xssAPI.encodeForJSString(source));\n        }\n    }\n\n    @Test\n    public void testGetValidJSToken() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n                {\"simple\", \"simple\"},\n                {\"clickstreamcloud.thingy\", \"clickstreamcloud.thingy\"},\n\n                {\"break out\", RUBBISH},\n                {\"break,out\", RUBBISH},\n\n                {\"\\\"literal string\\\"\", \"\\\"literal string\\\"\"},\n                {\"'literal string'\", \"'literal string'\"},\n                {\"\\\"bad literal'\", RUBBISH},\n                {\"'literal'); junk'\", \"'literal\\\\'); junk'\"},\n\n                {\"1200\", \"1200\"},\n                {\"3.14\", \"3.14\"},\n                {\"1,200\", RUBBISH},\n                {\"1200 + 1\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating Javascript token '\" + source + \"'\", expected, xssAPI.getValidJSToken(source, RUBBISH));\n        }\n    }\n\n    @Test\n    public void testEncodeForCSSString() {\n        String[][] testData = {\n                \n                {null, null},\n                {\"test\"   , \"test\"},\n                {\"\\\\\"     , \"\\\\5c\"},\n                {\"'\"      , \"\\\\27\"},\n                {\"\\\"\"     , \"\\\\22\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.encodeForCSSString(source);\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, result);\n        }\n    }\n\n    @Test\n    public void testGetValidStyleToken() {\n        String[][] testData = {\n                \n                {null                               , RUBBISH},\n                {\"\"                                 , RUBBISH},\n\n                \n                {\"}\"                                , RUBBISH},\n\n                \n                {\"br\\neak\"                          , RUBBISH},\n\n                \n                {\"javascript:alert(1)\"              , RUBBISH},\n                {\"'javascript:alert(1)'\"            , RUBBISH},\n                {\"\\\"javascript:alert('XSS')\\\"\"      , RUBBISH},\n                {\"url(javascript:alert(1))\"         , RUBBISH},\n                {\"url('javascript:alert(1)')\"       , RUBBISH},\n                {\"url(\\\"javascript:alert('XSS')\\\")\" , RUBBISH},\n\n                \n                {\"expression(alert(1))\"             , RUBBISH},\n                {\"expression  (alert(1))\"           , RUBBISH},\n                {\"expression(this.location='a.co')\" , RUBBISH},\n\n                \n                {\"</style><script>alert(1)</script>\", RUBBISH},\n\n                \n                {\"background-color\"                 , \"background-color\"},\n                {\"-moz-box-sizing\"                  , \"-moz-box-sizing\"},\n                {\".42%\"                             , \".42%\"},\n                {\"#fff\"                             , \"#fff\"},\n\n                \n                {\"'literal string'\"                 , \"'literal string'\"},\n                {\"\\\"literal string\\\"\"               , \"\\\"literal string\\\"\"},\n                {\"'it\\\\'s here'\"                    , \"'it\\\\'s here'\"},\n                {\"\\\"it\\\\\\\"s here\\\"\"                 , \"\\\"it\\\\\\\"s here\\\"\"},\n\n                \n                {\"\\\"bad string\"                     , RUBBISH},\n                {\"'it's here'\"                      , RUBBISH},\n                {\"\\\"it\\\"s here\\\"\"                   , RUBBISH},\n\n                \n                {\"rgb(255, 255, 255)\"               , \"rgb(255, 255, 255)\"},\n\n                \n                {\"rgb(255, 255, 255\"               , RUBBISH},\n                {\"255, 255, 255)\"                  , RUBBISH},\n\n                \n                {\"url(http://example.com/test.png)\", \"url(http://example.com/test.png)\"},\n                {\"url('image/test.png')\"           , \"url('image/test.png')\"},\n\n                \n                {\"color: red\"                      , RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidStyleToken(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating style token '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidCSSColor() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n\n                {\"rgb(0,+0,-0)\", \"rgb(0,+0,-0)\"},\n                {\"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\", \"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\",},\n\n                {\"#ddd\", \"#ddd\"},\n                {\"#eeeeee\", \"#eeeeee\",},\n\n                {\"hsl(0,1,2)\", \"hsl(0,1,2)\"},\n                {\"hsla(0,1,2,3)\", \"hsla(0,1,2,3)\"},\n                {\"currentColor\", \"currentColor\"},\n                {\"transparent\", \"transparent\"},\n\n                {\"\\f\\r\\n\\t MenuText\\f\\r\\n\\t \", \"MenuText\"},\n                {\"expression(99,99,99)\", RUBBISH},\n                {\"blue;\", RUBBISH},\n                {\"url(99,99,99)\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidCSSColor(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating CSS Color '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidMultiLineComment() {\n        String[][] testData = {\n                \n\n                {null               , RUBBISH},\n                {\"blah */ hack\"     , RUBBISH},\n\n                {\"Valid comment\"    , \"Valid comment\"}\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidMultiLineComment(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating multiline comment '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidJSON() {\n        String[][] testData = {\n                {null,      RUBBISH_JSON},\n                {\"\",        \"\"},\n                {\"1]\",      RUBBISH_JSON},\n                {\"{}\",      \"{}\"},\n                {\"{1}\",     RUBBISH_JSON},\n                {\n                        \"{test: 'test'}\",\n                        \"{\\\"test\\\":\\\"test\\\"}\"\n                },\n                {\n                        \"{test:\\\"test}\",\n                        RUBBISH_JSON\n                },\n                {\n                        \"{test1:'test1', test2: {test21: 'test21', test22: 'test22'}}\",\n                        \"{\\\"test1\\\":\\\"test1\\\",\\\"test2\\\":{\\\"test21\\\":\\\"test21\\\",\\\"test22\\\":\\\"test22\\\"}}\"\n                },\n                {\"[]\",      \"[]\"},\n                {\"[1,2]\",   \"[1,2]\"},\n                {\"[1\",      RUBBISH_JSON},\n                {\n                        \"[{test: 'test'}]\",\n                        \"[{\\\"test\\\":\\\"test\\\"}]\"\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidJSON(source, RUBBISH_JSON);\n            if (!result.equals(expected)) {\n                fail(\"Validating JSON '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidXML() {\n        String[][] testData = {\n                {null,      RUBBISH_XML},\n                {\"\",        \"\"},\n                {\n                        \"<t/>\",\n                        \"<t/>\"\n                },\n                {\n                        \"<t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t>test</t>\",\n                        \"<t>test</t>\"\n                },\n                {\n                        \"<t>test\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t t=\\\"t\\\">test</t>\",\n                        \"<t t=\\\"t\\\">test</t>\"\n                },\n                {\n                        \"<t t=\\\"t>test</t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t><w>xyz</w></t>\",\n                        \"<t><w>xyz</w></t>\"\n                },\n                {\n                        \"<t><w>xyz</t></w>\",\n                        RUBBISH_XML\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidXML(source, RUBBISH_XML);\n            if (!result.equals(expected)) {\n                fail(\"Validating XML '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 23,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling/commit/fb2719e8299fadddae62245482de112052a0e08c",
    "cve_id": "CVE-2016-6798",
    "cwe_id": "CWE-611",
    "filename": "bundles/extensions/xss/src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.felix.scr.annotations.Activate;\nimport org.apache.felix.scr.annotations.Component;\nimport org.apache.felix.scr.annotations.Deactivate;\nimport org.apache.felix.scr.annotations.Reference;\nimport org.apache.felix.scr.annotations.Service;\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.commons.json.JSONArray;\nimport org.apache.sling.commons.json.JSONException;\nimport org.apache.sling.commons.json.JSONObject;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component\n@Service(value = XSSAPI.class)\npublic class XSSAPIImpl implements XSSAPI {\n    private static final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter = null;\n\n    private Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    @Activate\n    @SuppressWarnings(\"unused\")\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n    }\n\n    @Deactivate\n    @SuppressWarnings(\"unused\")\n    protected void deactivate() {\n        factory = null;\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String LINK_PREFIX = \"<a href=\\\"\";\n    private static final String LINK_SUFFIX = \"\\\"></a>\";\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            \n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    \n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (url != null && url.length() > 0) {\n            \n            \n            \n            String encodedUrl = url.replaceAll(\"\\\"\", \"%22\")\n                    .replaceAll(\"'\", \"%27\")\n                    .replaceAll(\">\", \"%3E\")\n                    .replaceAll(\"<\", \"%3C\")\n                    .replaceAll(\"`\", \"%60\")\n                    .replaceAll(\" \", \"%20\");\n            int qMarkIx = encodedUrl.indexOf('?');\n            if (qMarkIx > 0) {\n                encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n            }\n\n            encodedUrl = mangleNamespaces(encodedUrl);\n            if (xssFilter.isValidHref(encodedUrl)) {\n                return encodedUrl;\n            }\n        }\n\n        \n        return \"\";\n    }\n\n    \n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    \n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    \n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    \n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    \n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    \n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    \n    private static final String PERCENT = NUMBER + \"%\";\n    \n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    \n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    \n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    \n    private static final String CSS_TOKEN = \"(?i)\" \n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    \n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    \n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            \n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            \n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    \n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    \n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                JSONObject obj = new JSONObject(json);\n                return obj.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                JSONArray arr = new JSONArray(json);\n                return arr.toString();\n            } catch (JSONException e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    \n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    \n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    \n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    \n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    \n    \n    \n\n    \n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public XSSAPI getRequestSpecificAPI(final SlingHttpServletRequest request) {\n        return this;\n    }\n\n    \n    @Override\n    public XSSAPI getResourceResolverSpecificAPI(final ResourceResolver resourceResolver) {\n        return this;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 23,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling/commit/fb2719e8299fadddae62245482de112052a0e08c",
    "cve_id": "CVE-2016-6798",
    "cwe_id": "CWE-611",
    "filename": "bundles/extensions/xss/src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\n\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.xss.XSSAPI;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.owasp.validator.html.AntiSamy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.model.Attribute;\nimport org.powermock.reflect.Whitebox;\n\nimport junit.framework.TestCase;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class XSSAPIImplTest {\n\n    public static final String RUBBISH = \"rubbish\";\n    public static final String RUBBISH_JSON = \"[\\\"rubbish\\\"]\";\n    public static final String RUBBISH_XML = \"<rubbish/>\";\n\n    private XSSAPI xssAPI;\n\n    @Before\n    public void setup() {\n        try {\n            XSSFilterImpl xssFilter = new XSSFilterImpl();\n            setDefaultHandler(xssFilter, \"./src/main/resources/SLING-INF/content/config.xml\");\n\n            xssAPI = new XSSAPIImpl();\n            Whitebox.invokeMethod(xssAPI, \"activate\");\n            Field filterField = XSSAPIImpl.class.getDeclaredField(\"xssFilter\");\n            filterField.setAccessible(true);\n            filterField.set(xssAPI, xssFilter);\n\n            ResourceResolver mockResolver = mock(ResourceResolver.class);\n            when(mockResolver.map(anyString())).thenAnswer(new Answer() {\n                public Object answer(InvocationOnMock invocation) {\n                    Object[] args = invocation.getArguments();\n                    String url = (String) args[0];\n                    return url.replaceAll(\"jcr:\", \"_jcr_\");\n                }\n            });\n\n            SlingHttpServletRequest mockRequest = mock(SlingHttpServletRequest.class);\n            when(mockRequest.getResourceResolver()).thenReturn(mockResolver);\n\n            xssAPI = xssAPI.getRequestSpecificAPI(mockRequest);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void setDefaultHandler(XSSFilterImpl xssFilter, String filename) throws Exception {\n        InputStream policyStream = new FileInputStream(filename);\n        Policy policy = Policy.getInstance(policyStream);\n        AntiSamy antiSamy = new AntiSamy(policy);\n\n        PolicyHandler mockPolicyHandler = mock(PolicyHandler.class);\n        when(mockPolicyHandler.getPolicy()).thenReturn(policy);\n        when(mockPolicyHandler.getAntiSamy()).thenReturn(antiSamy);\n\n        Whitebox.invokeMethod(xssFilter, \"setDefaultHandler\", mockPolicyHandler);\n    }\n\n    @Test\n    public void testEncodeForHTML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForHTMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"\\\" <script>alert('pwned');</script>\", \"&#34; &lt;script>alert(&#39;pwned&#39;);&lt;/script>\"},\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"<b>\", \"&lt;b>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\\"xss:expression(alert('XSS'))\", \"&#34;xss:expression(alert(&#39;XSS&#39;))\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testFilterHTML() {\n        String[][] testData = {\n                \n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"<script>ugly</script>\", \"\"},\n                {\"<b>wow!</b>\", \"<b>wow!</b>\"},\n\n                {\"<p onmouseover='ugly'>nice</p>\", \"<p>nice</p>\"},\n\n                {\"<img src='javascript:ugly'/>\", \"\"},\n                {\"<img src='nice.jpg'/>\", \"<img src=\\\"nice.jpg\\\" />\"},\n\n                {\"<ul><li>1</li><li>2</li></ul>\", \"<ul><li>1</li><li>2</li></ul>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n\n\n                {\"<strike>strike</strike>\", \"<strike>strike</strike>\"},\n                {\"<s>s</s>\", \"<s>s</s>\"},\n\n                {\"<a href=\\\"\\\">empty href</a>\", \"<a href=\\\"\\\">empty href</a>\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Filtering '\" + source + \"'\", expected, xssAPI.filterHTML(source));\n        }\n    }\n\n    @Test\n    public void testGetValidHref() {\n        String[][] testData = {\n                \n                \n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"../parent\", \"../parent\"},\n                {\"repo/g\u00fcnter\", \"repo/g\u00fcnter\"},\n\n                \n                {\"my/page/jcr:content.feed\", \"my/page/_jcr_content.feed\"},\n                {\"my/jcr:content/page/jcr:content\", \"my/_jcr_content/page/_jcr_content\"},\n\n                {\"\\\" onClick=ugly\", \"%22%20onClick=ugly\"},\n                {\"javascript:ugly\", \"\"},\n                {\"http://localhost:4502\", \"http://localhost:4502\"},\n                {\"http://localhost:4502/test\", \"http://localhost:4502/test\"},\n                {\"http://localhost:4502/jcr:content/test\", \"http://localhost:4502/_jcr_content/test\"},\n                {\"http://localhost:4502/test.html?a=b&b=c\", \"http://localhost:4502/test.html?a=b&b=c\"},\n\n                \n                {\"/test/ab cd\", \"/test/ab%20cd\"},\n                {\"http://localhost:4502/test/ab cd\", \"http://localhost:4502/test/ab%20cd\"},\n                {\"/test/ab attr=c\", \"/test/ab%20attr=c\"},\n                {\"http://localhost:4502/test/ab attr=c\", \"http://localhost:4502/test/ab%20attr=c\"},\n                \n                {\"/test/ab\\\"cd\", \"/test/ab%22cd\"},\n                {\"http://localhost:4502/test/ab\\\"cd\", \"http://localhost:4502/test/ab%22cd\"},\n                \n                {\"/test/ab'cd\", \"/test/ab%27cd\"},\n                {\"http://localhost:4502/test/ab'cd\", \"http://localhost:4502/test/ab%27cd\"},\n                \n                {\"/test/ab=cd\", \"/test/ab=cd\"},\n                {\"http://localhost:4502/test/ab=cd\", \"http://localhost:4502/test/ab=cd\"},\n                \n                {\"/test/ab>cd\", \"/test/ab%3Ecd\"},\n                {\"http://localhost:4502/test/ab>cd\", \"http://localhost:4502/test/ab%3Ecd\"},\n                \n                {\"/test/ab<cd\", \"/test/ab%3Ccd\"},\n                {\"http://localhost:4502/test/ab<cd\", \"http://localhost:4502/test/ab%3Ccd\"},\n                \n                {\"/test/ab`cd\", \"/test/ab%60cd\"},\n                {\"http://localhost:4502/test/ab`cd\", \"http://localhost:4502/test/ab%60cd\"},\n                \n                {\"/test/search.html?0_tag:id=test\", \"/test/search.html?0_tag%3Aid=test\"},\n                { \n                        \"/test/jcr:content/search.html?0_tag:id=test\",\n                        \"/test/_jcr_content/search.html?0_tag%3Aid=test\"\n                },\n                { \n                        \"/test/search.html?0_tag:id=test?ing&1_tag:id=abc\",\n                        \"/test/search.html?0_tag%3Aid=test?ing&1_tag%3Aid=abc\",\n                }\n        };\n\n        for (String[] aTestData : testData) {\n            String href = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Requested '\" + href + \"'\", expected, xssAPI.getValidHref(href));\n        }\n    }\n\n    @Test\n    public void testGetValidHrefWithoutHrefConfig() throws Exception {\n        \n        XSSFilterImpl xssFilter = Whitebox.getInternalState(xssAPI, \"xssFilter\");\n        setDefaultHandler(xssFilter, \"./src/test/resources/configWithoutHref.xml\");\n\n        Attribute hrefAttribute = Whitebox.getInternalState(xssFilter, \"hrefAttribute\");\n        Assert.assertEquals(hrefAttribute, XSSFilterImpl.DEFAULT_HREF_ATTRIBUTE);\n\n        \n        testGetValidHref();\n    }\n\n    @Test\n    public void testGetValidInteger() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Integer expected = (aTestData[1] != null) ? new Integer(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating integer '\" + source + \"'\", expected, xssAPI.getValidInteger(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidLong() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Long expected = (aTestData[1] != null) ? new Long(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating long '\" + source + \"'\", expected, xssAPI.getValidLong(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDouble() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100.5\", \"100.5\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Double expected = (aTestData[1] != null) ? new Double(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating double '\" + source + \"'\", expected, xssAPI.getValidDouble(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDimension() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"\", \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"},\n\n                {\"\\\"auto\\\"\", \"\\\"auto\\\"\"},\n                {\"'auto'\", \"\\\"auto\\\"\"},\n                {\"auto\", \"\\\"auto\\\"\"},\n\n                {\"autox\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating dimension '\" + source + \"'\", expected, xssAPI.getValidDimension(source, \"123\"));\n        }\n    }\n\n    @Test\n    public void testEncodeForJSString() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"break\\\"out\", \"break\\\\x22out\"},\n                {\"break'out\", \"break\\\\x27out\"},\n\n                {\"</script>\", \"<\\\\/script>\"},\n\n                {\"'alert(document.cookie)\", \"\\\\x27alert(document.cookie)\"},\n                {\"2014-04-22T10:11:24.002+01:00\", \"2014\\\\u002D04\\\\u002D22T10:11:24.002+01:00\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, xssAPI.encodeForJSString(source));\n        }\n    }\n\n    @Test\n    public void testGetValidJSToken() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n                {\"simple\", \"simple\"},\n                {\"clickstreamcloud.thingy\", \"clickstreamcloud.thingy\"},\n\n                {\"break out\", RUBBISH},\n                {\"break,out\", RUBBISH},\n\n                {\"\\\"literal string\\\"\", \"\\\"literal string\\\"\"},\n                {\"'literal string'\", \"'literal string'\"},\n                {\"\\\"bad literal'\", RUBBISH},\n                {\"'literal'); junk'\", \"'literal\\\\x27); junk'\"},\n\n                {\"1200\", \"1200\"},\n                {\"3.14\", \"3.14\"},\n                {\"1,200\", RUBBISH},\n                {\"1200 + 1\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating Javascript token '\" + source + \"'\", expected, xssAPI.getValidJSToken(source, RUBBISH));\n        }\n    }\n\n    @Test\n    public void testEncodeForCSSString() {\n        String[][] testData = {\n                \n                {null, null},\n                {\"test\"   , \"test\"},\n                {\"\\\\\"     , \"\\\\5c\"},\n                {\"'\"      , \"\\\\27\"},\n                {\"\\\"\"     , \"\\\\22\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.encodeForCSSString(source);\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, result);\n        }\n    }\n\n    @Test\n    public void testGetValidStyleToken() {\n        String[][] testData = {\n                \n                {null                               , RUBBISH},\n                {\"\"                                 , RUBBISH},\n\n                \n                {\"}\"                                , RUBBISH},\n\n                \n                {\"br\\neak\"                          , RUBBISH},\n\n                \n                {\"javascript:alert(1)\"              , RUBBISH},\n                {\"'javascript:alert(1)'\"            , RUBBISH},\n                {\"\\\"javascript:alert('XSS')\\\"\"      , RUBBISH},\n                {\"url(javascript:alert(1))\"         , RUBBISH},\n                {\"url('javascript:alert(1)')\"       , RUBBISH},\n                {\"url(\\\"javascript:alert('XSS')\\\")\" , RUBBISH},\n\n                \n                {\"expression(alert(1))\"             , RUBBISH},\n                {\"expression  (alert(1))\"           , RUBBISH},\n                {\"expression(this.location='a.co')\" , RUBBISH},\n\n                \n                {\"</style><script>alert(1)</script>\", RUBBISH},\n\n                \n                {\"background-color\"                 , \"background-color\"},\n                {\"-moz-box-sizing\"                  , \"-moz-box-sizing\"},\n                {\".42%\"                             , \".42%\"},\n                {\"#fff\"                             , \"#fff\"},\n\n                \n                {\"'literal string'\"                 , \"'literal string'\"},\n                {\"\\\"literal string\\\"\"               , \"\\\"literal string\\\"\"},\n                {\"'it\\\\'s here'\"                    , \"'it\\\\'s here'\"},\n                {\"\\\"it\\\\\\\"s here\\\"\"                 , \"\\\"it\\\\\\\"s here\\\"\"},\n\n                \n                {\"\\\"bad string\"                     , RUBBISH},\n                {\"'it's here'\"                      , RUBBISH},\n                {\"\\\"it\\\"s here\\\"\"                   , RUBBISH},\n\n                \n                {\"rgb(255, 255, 255)\"               , \"rgb(255, 255, 255)\"},\n\n                \n                {\"rgb(255, 255, 255\"               , RUBBISH},\n                {\"255, 255, 255)\"                  , RUBBISH},\n\n                \n                {\"url(http://example.com/test.png)\", \"url(http://example.com/test.png)\"},\n                {\"url('image/test.png')\"           , \"url('image/test.png')\"},\n\n                \n                {\"color: red\"                      , RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidStyleToken(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating style token '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidCSSColor() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n\n                {\"rgb(0,+0,-0)\", \"rgb(0,+0,-0)\"},\n                {\"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\", \"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\",},\n\n                {\"#ddd\", \"#ddd\"},\n                {\"#eeeeee\", \"#eeeeee\",},\n\n                {\"hsl(0,1,2)\", \"hsl(0,1,2)\"},\n                {\"hsla(0,1,2,3)\", \"hsla(0,1,2,3)\"},\n                {\"currentColor\", \"currentColor\"},\n                {\"transparent\", \"transparent\"},\n\n                {\"\\f\\r\\n\\t MenuText\\f\\r\\n\\t \", \"MenuText\"},\n                {\"expression(99,99,99)\", RUBBISH},\n                {\"blue;\", RUBBISH},\n                {\"url(99,99,99)\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidCSSColor(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating CSS Color '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidMultiLineComment() {\n        String[][] testData = {\n                \n\n                {null               , RUBBISH},\n                {\"blah */ hack\"     , RUBBISH},\n\n                {\"Valid comment\"    , \"Valid comment\"}\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidMultiLineComment(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating multiline comment '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidJSON() {\n        String[][] testData = {\n                {null,      RUBBISH_JSON},\n                {\"\",        \"\"},\n                {\"1]\",      RUBBISH_JSON},\n                {\"{}\",      \"{}\"},\n                {\"{1}\",     RUBBISH_JSON},\n                {\n                        \"{test: 'test'}\",\n                        \"{\\\"test\\\":\\\"test\\\"}\"\n                },\n                {\n                        \"{test:\\\"test}\",\n                        RUBBISH_JSON\n                },\n                {\n                        \"{test1:'test1', test2: {test21: 'test21', test22: 'test22'}}\",\n                        \"{\\\"test1\\\":\\\"test1\\\",\\\"test2\\\":{\\\"test21\\\":\\\"test21\\\",\\\"test22\\\":\\\"test22\\\"}}\"\n                },\n                {\"[]\",      \"[]\"},\n                {\"[1,2]\",   \"[1,2]\"},\n                {\"[1\",      RUBBISH_JSON},\n                {\n                        \"[{test: 'test'}]\",\n                        \"[{\\\"test\\\":\\\"test\\\"}]\"\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidJSON(source, RUBBISH_JSON);\n            if (!result.equals(expected)) {\n                fail(\"Validating JSON '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidXML() {\n        String[][] testData = {\n                {null,      RUBBISH_XML},\n                {\"\",        \"\"},\n                {\n                        \"<t/>\",\n                        \"<t/>\"\n                },\n                {\n                        \"<t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t>test</t>\",\n                        \"<t>test</t>\"\n                },\n                {\n                        \"<t>test\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t t=\\\"t\\\">test</t>\",\n                        \"<t t=\\\"t\\\">test</t>\"\n                },\n                {\n                        \"<t t=\\\"t>test</t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t><w>xyz</w></t>\",\n                        \"<t><w>xyz</w></t>\"\n                },\n                {\n                        \"<t><w>xyz</t></w>\",\n                        RUBBISH_XML\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidXML(source, RUBBISH_XML);\n            if (!result.equals(expected)) {\n                fail(\"Validating XML '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 24,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling-org-apache-sling-xss/commit/ec6764d165abc4df8cffd8439761bb2228887db9",
    "cve_id": "CVE-2017-15717",
    "cwe_id": "CWE-79",
    "filename": "src/main/java/org/apache/sling/xss/impl/XSSAPIImpl.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URLDecoder;\nimport java.nio.charset.StandardCharsets;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.annotation.Nonnull;\nimport javax.json.Json;\nimport javax.json.JsonReaderFactory;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\n\nimport org.apache.commons.lang3.StringEscapeUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.sling.xss.ProtectionContext;\nimport org.apache.sling.xss.XSSAPI;\nimport org.apache.sling.xss.XSSFilter;\nimport org.osgi.framework.Constants;\nimport org.osgi.service.component.annotations.Activate;\nimport org.osgi.service.component.annotations.Component;\nimport org.osgi.service.component.annotations.Deactivate;\nimport org.osgi.service.component.annotations.Reference;\nimport org.owasp.encoder.Encode;\nimport org.owasp.esapi.ESAPI;\nimport org.owasp.esapi.Validator;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.XMLReader;\n\n@Component(service = XSSAPI.class,\n           property = {\n                Constants.SERVICE_VENDOR + \"=The Apache Software Foundation\"\n           })\n\npublic class XSSAPIImpl implements XSSAPI {\n\n    private final Logger LOGGER = LoggerFactory.getLogger(XSSAPIImpl.class);\n\n    @Reference\n    private XSSFilter xssFilter;\n\n    private final Validator validator = ESAPI.validator();\n\n    private static final Pattern PATTERN_AUTO_DIMENSION = Pattern.compile(\"['\\\"]?auto['\\\"]?\");\n\n    private SAXParserFactory factory;\n\n    private volatile JsonReaderFactory jsonReaderFactory;\n\n    @Activate\n    protected void activate() {\n        factory = SAXParserFactory.newInstance();\n        factory.setValidating(false);\n        factory.setNamespaceAware(true);\n        try {\n            factory.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n            factory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n        } catch (Exception e) {\n            LOGGER.error(\"SAX parser configuration error: \" + e.getMessage(), e);\n        }\n        Map<String, Object> config = new HashMap<>();\n        config.put(\"org.apache.johnzon.supports-comments\", true);\n        jsonReaderFactory = Json.createReaderFactory(config);\n    }\n\n    @Deactivate\n    protected void deactivate() {\n        factory = null;\n        jsonReaderFactory = null;\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public Integer getValidInteger(String integer, int defaultValue) {\n        if (integer != null && integer.length() > 0) {\n            try {\n                return validator.getValidInteger(\"XSS\", integer, -2000000000, 2000000000, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Long getValidLong(String source, long defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                LongValidationRule ivr = new LongValidationRule( \"number\", ESAPI.encoder(), -9000000000000000000L, 9000000000000000000L );\n                ivr.setAllowNull(false);\n                return ivr.getValid(\"XSS\", source);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public Double getValidDouble(String source, double defaultValue) {\n        if (source != null && source.length() > 0) {\n            try {\n                return validator.getValidDouble(\"XSS\", source, 0d, Double.MAX_VALUE, false);\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    \n    @Override\n    public String getValidDimension(String dimension, String defaultValue) {\n        if (dimension != null && dimension.length() > 0) {\n            if (PATTERN_AUTO_DIMENSION.matcher(dimension).matches()) {\n                return \"\\\"auto\\\"\";\n            }\n\n            try {\n                return validator.getValidInteger(\"XSS\", dimension, -10000, 10000, false).toString();\n            } catch (Exception e) {\n                \n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String MANGLE_NAMESPACE_OUT_SUFFIX = \":\";\n\n    private static final String MANGLE_NAMESPACE_OUT = \"/([^:/]+):\";\n\n    private static final Pattern MANGLE_NAMESPACE_PATTERN = Pattern.compile(MANGLE_NAMESPACE_OUT);\n\n    private static final String MANGLE_NAMESPACE_IN_SUFFIX = \"_\";\n\n    private static final String MANGLE_NAMESPACE_IN_PREFIX = \"/_\";\n\n    private static final String SCHEME_PATTERN = \"://\";\n\n    private String mangleNamespaces(String absPath) {\n        if (absPath != null) {\n            \n            final int schemeIndex = absPath.indexOf(SCHEME_PATTERN);\n            final String manglePath;\n            final String prefix;\n            if (schemeIndex != -1) {\n                final int pathIndex = absPath.indexOf(\"/\", schemeIndex + 3);\n                if (pathIndex != -1) {\n                    prefix = absPath.substring(0, pathIndex);\n                    manglePath = absPath.substring(pathIndex);\n                } else {\n                    prefix = absPath;\n                    manglePath = \"\";\n                }\n            } else {\n                prefix = \"\";\n                manglePath = absPath;\n            }\n            if (manglePath.contains(MANGLE_NAMESPACE_OUT_SUFFIX)) {\n                final Matcher m = MANGLE_NAMESPACE_PATTERN.matcher(manglePath);\n\n                final StringBuffer buf = new StringBuffer();\n                while (m.find()) {\n                    final String replacement = MANGLE_NAMESPACE_IN_PREFIX + m.group(1) + MANGLE_NAMESPACE_IN_SUFFIX;\n                    m.appendReplacement(buf, replacement);\n                }\n\n                m.appendTail(buf);\n\n                absPath = prefix + buf.toString();\n\n            }\n        }\n\n        return absPath;\n    }\n\n    \n    @Override\n    @Nonnull\n    public String getValidHref(final String url) {\n        if (StringUtils.isNotEmpty(url)) {\n            try {\n                String unescapedURL = URLDecoder.decode(url, StandardCharsets.UTF_8.name());\n                \n                unescapedURL = StringEscapeUtils.unescapeXml(unescapedURL);\n                \n                \n                \n                String encodedUrl = unescapedURL.replaceAll(\"\\\"\", \"%22\")\n                        .replaceAll(\"'\", \"%27\")\n                        .replaceAll(\">\", \"%3E\")\n                        .replaceAll(\"<\", \"%3C\")\n                        .replaceAll(\"`\", \"%60\")\n                        .replaceAll(\" \", \"%20\");\n                int qMarkIx = encodedUrl.indexOf('?');\n                if (qMarkIx > 0) {\n                    encodedUrl = encodedUrl.substring(0, qMarkIx) + encodedUrl.substring(qMarkIx).replaceAll(\":\", \"%3A\");\n                }\n\n                encodedUrl = mangleNamespaces(encodedUrl);\n                if (xssFilter.isValidHref(encodedUrl)) {\n                    return encodedUrl;\n                }\n            } catch (UnsupportedEncodingException e) {\n                LOGGER.error(\"Unable to decode url: {}.\", url);\n            }\n        }\n        \n        return \"\";\n    }\n\n    \n    @Override\n    public String getValidJSToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0) {\n            token = token.trim();\n            String q = token.substring(0, 1);\n            if (q.matches(\"['\\\"]\") && token.endsWith(q)) {\n                String literal = token.substring(1, token.length() - 1);\n                return q + encodeForJSString(literal) + q;\n            } else if (token.matches(\"[0-9a-zA-Z_$][0-9a-zA-Z_$.]*\")) {\n                return token;\n            }\n        }\n\n        \n        return defaultValue;\n    }\n\n    private static final String NON_ASCII = \"\\\\x00\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\";\n    \n    private static final String NUMBER = \"[+-]?[\\\\d]*[\\\\.]?[\\\\d]*(?:[e][+-]?\\\\d+)?\";\n    \n    private static final String HEX_DIGITS = \"#[0-9a-f]*\";\n    \n    private static final String IDENTIFIER = \"-?[a-z_\" + NON_ASCII + \"][\\\\w_\\\\-\" + NON_ASCII + \"]*\";\n    \n    private static final String STRING = \"\\\"(?:(?!javascript\\\\s?:)[^\\\"^\\\\\\\\^\\\\n]|(?:\\\\\\\\\\\"))*\\\"|'(?:(?!javascript\\\\s?:)[^'^\\\\\\\\^\\\\n]|(?:\\\\\\\\'))*'\";\n    \n    private static final String DIMENSION = NUMBER + IDENTIFIER;\n    \n    private static final String PERCENT = NUMBER + \"%\";\n    \n    private static final String FUNCTION = IDENTIFIER + \"\\\\((?:(?:\" + NUMBER + \")|(?:\" + IDENTIFIER + \")|(?:[\\\\s]*)|(?:,))*\\\\)\";\n    \n    private static final String URL_UNQUOTED = \"[^\\\"^'^\\\\(^\\\\)^[\" + NON_ASCII + \"]]*\";\n    \n    private static final String URL = \"url\\\\((?:(?:\" + URL_UNQUOTED + \")|(?:\" + STRING + \"))\\\\)\";\n    \n    private static final String CSS_TOKEN = \"(?i)\" \n            + \"(?:\" + NUMBER + \")\"\n            + \"|(?:\" + DIMENSION + \")\"\n            + \"|(?:\" + PERCENT + \")\"\n            + \"|(?:\" + HEX_DIGITS + \")\"\n            + \"|(?:\" + IDENTIFIER + \")\"\n            + \"|(?:\" + STRING + \")\"\n            + \"|(?:\" + FUNCTION + \")\"\n            + \"|(?:\" + URL + \")\";\n\n    \n    @Override\n    public String getValidStyleToken(String token, String defaultValue) {\n        if (token != null && token.length() > 0 && token.matches(CSS_TOKEN)) {\n            return token;\n        }\n\n        return defaultValue;\n   }\n\n    \n    @Override\n    public String getValidCSSColor(String color, String defaultColor) {\n        if (color != null && color.length() > 0) {\n            color = color.trim();\n            \n            if (color.matches(\"(?i)[#a-fghlrs(+0-9-.%,) \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n            \n            if (color.matches(\"(?i)[a-zA-Z \\\\t\\\\n\\\\x0B\\\\f\\\\r]+\")) {\n                return color;\n            }\n        }\n\n        return defaultColor;\n    }\n\n    \n    @Override\n    public String getValidMultiLineComment(String comment, String defaultComment) {\n        if (comment != null && !comment.contains(\"*/\")) {\n            return comment;\n        }\n        return defaultComment;\n    }\n\n    \n    @Override\n    public String getValidJSON(String json, String defaultJson) {\n        if (json == null) {\n            return getValidJSON(defaultJson, \"\");\n        }\n        json = json.trim();\n        if (\"\".equals(json)) {\n            return \"\";\n        }\n        int curlyIx = json.indexOf(\"{\");\n        int straightIx = json.indexOf(\"[\");\n        if (curlyIx >= 0 && (curlyIx < straightIx || straightIx < 0)) {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readObject()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        } else {\n            try {\n                StringWriter output = new StringWriter();\n                Json.createGenerator(output).write(jsonReaderFactory.createReader(new StringReader(json)).readArray()).close();\n                return output.getBuffer().toString();\n            } catch (Exception e) {\n                LOGGER.debug(\"JSON validation failed: \" + e.getMessage(), e);\n            }\n        }\n        return getValidJSON(defaultJson, \"\");\n    }\n\n    \n    @Override\n    public String getValidXML(String xml, String defaultXml) {\n        if (xml == null) {\n            return getValidXML(defaultXml, \"\");\n        }\n        xml = xml.trim();\n        if (\"\".equals(xml)) {\n            return \"\";\n        }\n\n        try {\n            SAXParser parser = factory.newSAXParser();\n            XMLReader reader = parser.getXMLReader();\n            reader.parse(new InputSource(new StringReader(xml)));\n            return xml;\n        } catch (Exception e) {\n            LOGGER.debug(\"XML validation failed: \" + e.getMessage(), e);\n        }\n        return getValidXML(defaultXml, \"\");\n    }\n\n    \n    \n    \n\n    \n    @Override\n    public String encodeForHTML(String source) {\n        return source == null ? null : Encode.forHtml(source);\n    }\n\n    \n    @Override\n    public String encodeForHTMLAttr(String source) {\n        return source == null ? null : Encode.forHtmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForXML(String source) {\n        return source == null ? null : Encode.forXml(source);\n    }\n\n    \n    @Override\n    public String encodeForXMLAttr(String source) {\n        return source == null ? null : Encode.forXmlAttribute(source);\n    }\n\n    \n    @Override\n    public String encodeForJSString(String source) {\n        return source == null ? null : Encode.forJavaScript(source).replace(\"\\\\-\", \"\\\\u002D\");\n    }\n\n    \n    @Override\n    public String encodeForCSSString(String source) {\n        return source == null ? null : Encode.forCssString(source);\n    }\n\n    \n    \n    \n\n    \n    @Override\n    @Nonnull\n    public String filterHTML(String source) {\n        return xssFilter.filter(ProtectionContext.HTML_HTML_CONTENT, source);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 24,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/sling-org-apache-sling-xss/commit/ec6764d165abc4df8cffd8439761bb2228887db9",
    "cve_id": "CVE-2017-15717",
    "cwe_id": "CWE-79",
    "filename": "src/test/java/org/apache/sling/xss/impl/XSSAPIImplTest.java",
    "code": "\npackage org.apache.sling.xss.impl;\n\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.lang.reflect.Field;\n\nimport org.apache.sling.api.SlingHttpServletRequest;\nimport org.apache.sling.api.resource.ResourceResolver;\nimport org.apache.sling.xss.XSSAPI;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.owasp.validator.html.AntiSamy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.model.Attribute;\nimport org.powermock.reflect.Whitebox;\n\nimport junit.framework.TestCase;\n\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class XSSAPIImplTest {\n\n    public static final String RUBBISH = \"rubbish\";\n    public static final String RUBBISH_JSON = \"[\\\"rubbish\\\"]\";\n    public static final String RUBBISH_XML = \"<rubbish/>\";\n\n    private XSSAPI xssAPI;\n\n    @Before\n    public void setup() {\n        try {\n            XSSFilterImpl xssFilter = new XSSFilterImpl();\n            setDefaultHandler(xssFilter, \"./src/main/resources/SLING-INF/content/config.xml\");\n\n            xssAPI = new XSSAPIImpl();\n            Whitebox.invokeMethod(xssAPI, \"activate\");\n            Field filterField = XSSAPIImpl.class.getDeclaredField(\"xssFilter\");\n            filterField.setAccessible(true);\n            filterField.set(xssAPI, xssFilter);\n\n            ResourceResolver mockResolver = mock(ResourceResolver.class);\n            when(mockResolver.map(anyString())).thenAnswer(new Answer() {\n                public Object answer(InvocationOnMock invocation) {\n                    Object[] args = invocation.getArguments();\n                    String url = (String) args[0];\n                    return url.replaceAll(\"jcr:\", \"_jcr_\");\n                }\n            });\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void setDefaultHandler(XSSFilterImpl xssFilter, String filename) throws Exception {\n        InputStream policyStream = new FileInputStream(filename);\n        Policy policy = Policy.getInstance(policyStream);\n        AntiSamy antiSamy = new AntiSamy(policy);\n\n        PolicyHandler mockPolicyHandler = mock(PolicyHandler.class);\n        when(mockPolicyHandler.getPolicy()).thenReturn(policy);\n        when(mockPolicyHandler.getAntiSamy()).thenReturn(antiSamy);\n\n        Whitebox.invokeMethod(xssFilter, \"setDefaultHandler\", mockPolicyHandler);\n    }\n\n    @Test\n    public void testEncodeForHTML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForHTMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"\\\" <script>alert('pwned');</script>\", \"&#34; &lt;script>alert(&#39;pwned&#39;);&lt;/script>\"},\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\", \"\\u30e9\\u30c9\\u30af\\u30ea\\u30d5\\u3001\\u30de\\u30e9\\u30bd\\u30f3\\u4e94\\u8f2a\\u4ee3\\u8868\\u306b1\\u4e07m\\u51fa\\u5834\\u306b\\u3082\\u542b\\u307f\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"HTML Encoding '\" + source + \"'\", expected, xssAPI.encodeForHTMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXML() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script&gt;\"},\n                {\"<b>\", \"&lt;b&gt;\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXML(source));\n        }\n    }\n\n    @Test\n    public void testEncodeForXMLAttr() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"<script>\", \"&lt;script>\"},\n                {\"<b>\", \"&lt;b>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n                {\"\\\"xss:expression(alert('XSS'))\", \"&#34;xss:expression(alert(&#39;XSS&#39;))\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"XML Encoding '\" + source + \"'\", expected, xssAPI.encodeForXMLAttr(source));\n        }\n    }\n\n    @Test\n    public void testFilterHTML() {\n        String[][] testData = {\n                \n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"<script>ugly</script>\", \"\"},\n                {\"<b>wow!</b>\", \"<b>wow!</b>\"},\n\n                {\"<p onmouseover='ugly'>nice</p>\", \"<p>nice</p>\"},\n\n                {\"<img src='javascript:ugly'/>\", \"\"},\n                {\"<img src='nice.jpg'/>\", \"<img src=\\\"nice.jpg\\\" />\"},\n\n                {\"<ul><li>1</li><li>2</li></ul>\", \"<ul><li>1</li><li>2</li></ul>\"},\n\n                {\"g\u00fcnter\", \"g\u00fcnter\"},\n\n\n                {\"<strike>strike</strike>\", \"<strike>strike</strike>\"},\n                {\"<s>s</s>\", \"<s>s</s>\"},\n\n                {\"<a href=\\\"\\\">empty href</a>\", \"<a href=\\\"\\\">empty href</a>\"},\n                {\"<a href=\\\" javascript:alert(23)\\\">space</a>\",\"<a>space</a>\"},\n                {\"<table background=\\\"http://www.google.com\\\"></table>\", \"<table></table>\"},\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Filtering '\" + source + \"'\", expected, xssAPI.filterHTML(source));\n        }\n    }\n\n    @Test\n    public void testGetValidHref() {\n        String[][] testData = {\n                \n                \n                {\n                    \"/base?backHref=%26%23x6a%3b%26%23x61%3b%26%23x76%3b%26%23x61%3b%26%23x73%3b%26%23x63%3b%26%23x72%3b%26%23x69%3b%26%23x70%3b%26%23x74%3b%26%23x3a%3balert%281%29\",\n                    \"/base?backHref=javascript%3Aalert(1)\"\n                },\n                {\n                    \"%26%23x6a%3b%26%23x61%3b%26%23x76%3b%26%23x61%3b%26%23x73%3b%26%23x63%3b%26%23x72%3b%26%23x69%3b%26%23x70%3b%26%23x74%3b%26%23x3a%3balert%281%29\",\n                    \"\"\n                },\n                {\n                    \"&#x6a;&#x61;&#x76;&#x61;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3a;alert(1)\",\n                    \"\"\n                },\n                {\"%2Fscripts%2Ftest.js\", \"/scripts/test.js\"},\n                {\"/etc/commerce/collections/\u4e2d\u6587\", \"/etc/commerce/collections/\u4e2d\u6587\"},\n                {\"/etc/commerce/collections/\\u09aa\\u09b0\\u09c0\\u0995\\u09cd\\u09b7\\u09be\\u09ae\\u09c2\\u09b2\\u0995\", \"/etc/commerce/collections/\\u09aa\\u09b0\\u09c0\\u0995\\u09cd\\u09b7\\u09be\\u09ae\\u09c2\\u09b2\\u0995\"},\n                {null, \"\"},\n                {\"\", \"\"},\n                {\"simple\", \"simple\"},\n\n                {\"../parent\", \"../parent\"},\n                {\"repo/g\u00fcnter\", \"repo/g\u00fcnter\"},\n\n                \n                {\"my/page/jcr:content.feed\", \"my/page/_jcr_content.feed\"},\n                {\"my/jcr:content/page/jcr:content\", \"my/_jcr_content/page/_jcr_content\"},\n\n                {\"\\\" onClick=ugly\", \"%22%20onClick=ugly\"},\n                {\"javascript:ugly\", \"\"},\n                {\"http://localhost:4502\", \"http://localhost:4502\"},\n                {\"http://localhost:4502/test\", \"http://localhost:4502/test\"},\n                {\"http://localhost:4502/jcr:content/test\", \"http://localhost:4502/_jcr_content/test\"},\n                {\"http://localhost:4502/test.html?a=b&b=c\", \"http://localhost:4502/test.html?a=b&b=c\"},\n\n                \n                {\"/test/ab cd\", \"/test/ab%20cd\"},\n                {\"http://localhost:4502/test/ab cd\", \"http://localhost:4502/test/ab%20cd\"},\n                {\"/test/ab attr=c\", \"/test/ab%20attr=c\"},\n                {\"http://localhost:4502/test/ab attr=c\", \"http://localhost:4502/test/ab%20attr=c\"},\n                \n                {\"/test/ab\\\"cd\", \"/test/ab%22cd\"},\n                {\"http://localhost:4502/test/ab\\\"cd\", \"http://localhost:4502/test/ab%22cd\"},\n                \n                {\"/test/ab'cd\", \"/test/ab%27cd\"},\n                {\"http://localhost:4502/test/ab'cd\", \"http://localhost:4502/test/ab%27cd\"},\n                \n                {\"/test/ab=cd\", \"/test/ab=cd\"},\n                {\"http://localhost:4502/test/ab=cd\", \"http://localhost:4502/test/ab=cd\"},\n                \n                {\"/test/ab>cd\", \"/test/ab%3Ecd\"},\n                {\"http://localhost:4502/test/ab>cd\", \"http://localhost:4502/test/ab%3Ecd\"},\n                \n                {\"/test/ab<cd\", \"/test/ab%3Ccd\"},\n                {\"http://localhost:4502/test/ab<cd\", \"http://localhost:4502/test/ab%3Ccd\"},\n                \n                {\"/test/ab`cd\", \"/test/ab%60cd\"},\n                {\"http://localhost:4502/test/ab`cd\", \"http://localhost:4502/test/ab%60cd\"},\n                \n                {\"/test/search.html?0_tag:id=test\", \"/test/search.html?0_tag%3Aid=test\"},\n                { \n                        \"/test/jcr:content/search.html?0_tag:id=test\",\n                        \"/test/_jcr_content/search.html?0_tag%3Aid=test\"\n                },\n                { \n                        \"/test/search.html?0_tag:id=test?ing&1_tag:id=abc\",\n                        \"/test/search.html?0_tag%3Aid=test?ing&1_tag%3Aid=abc\",\n                }\n        };\n\n        for (String[] aTestData : testData) {\n            String href = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Requested '\" + href + \"'\", expected, xssAPI.getValidHref(href));\n        }\n    }\n\n    @Test\n    public void testGetValidHrefWithoutHrefConfig() throws Exception {\n        \n        XSSFilterImpl xssFilter = Whitebox.getInternalState(xssAPI, \"xssFilter\");\n        setDefaultHandler(xssFilter, \"./src/test/resources/configWithoutHref.xml\");\n\n        Attribute hrefAttribute = Whitebox.getInternalState(xssFilter, \"hrefAttribute\");\n        Assert.assertEquals(hrefAttribute, XSSFilterImpl.DEFAULT_HREF_ATTRIBUTE);\n\n        \n        testGetValidHref();\n    }\n\n    @Test\n    public void testGetValidInteger() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Integer expected = (aTestData[1] != null) ? new Integer(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating integer '\" + source + \"'\", expected, xssAPI.getValidInteger(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidLong() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Long expected = (aTestData[1] != null) ? new Long(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating long '\" + source + \"'\", expected, xssAPI.getValidLong(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDouble() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"100.5\", \"100.5\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            Double expected = (aTestData[1] != null) ? new Double(aTestData[1]) : null;\n\n            TestCase.assertEquals(\"Validating double '\" + source + \"'\", expected, xssAPI.getValidDouble(source, 123));\n        }\n    }\n\n    @Test\n    public void testGetValidDimension() {\n        String[][] testData = {\n                \n                \n                {null, \"123\"},\n                {\"\", \"123\"},\n                {\"100\", \"100\"},\n                {\"0\", \"0\"},\n\n                {\"junk\", \"123\"},\n                {\"100.5\", \"123\"},\n                {\"\", \"123\"},\n                {\"null\", \"123\"},\n\n                {\"\\\"auto\\\"\", \"\\\"auto\\\"\"},\n                {\"'auto'\", \"\\\"auto\\\"\"},\n                {\"auto\", \"\\\"auto\\\"\"},\n\n                {\"autox\", \"123\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating dimension '\" + source + \"'\", expected, xssAPI.getValidDimension(source, \"123\"));\n        }\n    }\n\n    @Test\n    public void testEncodeForJSString() {\n        String[][] testData = {\n                \n                \n                {null, null},\n                {\"simple\", \"simple\"},\n\n                {\"break\\\"out\", \"break\\\\x22out\"},\n                {\"break'out\", \"break\\\\x27out\"},\n\n                {\"</script>\", \"<\\\\/script>\"},\n\n                {\"'alert(document.cookie)\", \"\\\\x27alert(document.cookie)\"},\n                {\"2014-04-22T10:11:24.002+01:00\", \"2014\\\\u002D04\\\\u002D22T10:11:24.002+01:00\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, xssAPI.encodeForJSString(source));\n        }\n    }\n\n    @Test\n    public void testGetValidJSToken() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n                {\"simple\", \"simple\"},\n                {\"clickstreamcloud.thingy\", \"clickstreamcloud.thingy\"},\n\n                {\"break out\", RUBBISH},\n                {\"break,out\", RUBBISH},\n\n                {\"\\\"literal string\\\"\", \"\\\"literal string\\\"\"},\n                {\"'literal string'\", \"'literal string'\"},\n                {\"\\\"bad literal'\", RUBBISH},\n                {\"'literal'); junk'\", \"'literal\\\\x27); junk'\"},\n\n                {\"1200\", \"1200\"},\n                {\"3.14\", \"3.14\"},\n                {\"1,200\", RUBBISH},\n                {\"1200 + 1\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            TestCase.assertEquals(\"Validating Javascript token '\" + source + \"'\", expected, xssAPI.getValidJSToken(source, RUBBISH));\n        }\n    }\n\n    @Test\n    public void testEncodeForCSSString() {\n        String[][] testData = {\n                \n                {null, null},\n                {\"test\"   , \"test\"},\n                {\"\\\\\"     , \"\\\\5c\"},\n                {\"'\"      , \"\\\\27\"},\n                {\"\\\"\"     , \"\\\\22\"}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.encodeForCSSString(source);\n            TestCase.assertEquals(\"Encoding '\" + source + \"'\", expected, result);\n        }\n    }\n\n    @Test\n    public void testGetValidStyleToken() {\n        String[][] testData = {\n                \n                {null                               , RUBBISH},\n                {\"\"                                 , RUBBISH},\n\n                \n                {\"}\"                                , RUBBISH},\n\n                \n                {\"br\\neak\"                          , RUBBISH},\n\n                \n                {\"javascript:alert(1)\"              , RUBBISH},\n                {\"'javascript:alert(1)'\"            , RUBBISH},\n                {\"\\\"javascript:alert('XSS')\\\"\"      , RUBBISH},\n                {\"url(javascript:alert(1))\"         , RUBBISH},\n                {\"url('javascript:alert(1)')\"       , RUBBISH},\n                {\"url(\\\"javascript:alert('XSS')\\\")\" , RUBBISH},\n\n                \n                {\"expression(alert(1))\"             , RUBBISH},\n                {\"expression  (alert(1))\"           , RUBBISH},\n                {\"expression(this.location='a.co')\" , RUBBISH},\n\n                \n                {\"</style><script>alert(1)</script>\", RUBBISH},\n\n                \n                {\"background-color\"                 , \"background-color\"},\n                {\"-moz-box-sizing\"                  , \"-moz-box-sizing\"},\n                {\".42%\"                             , \".42%\"},\n                {\"#fff\"                             , \"#fff\"},\n\n                \n                {\"'literal string'\"                 , \"'literal string'\"},\n                {\"\\\"literal string\\\"\"               , \"\\\"literal string\\\"\"},\n                {\"'it\\\\'s here'\"                    , \"'it\\\\'s here'\"},\n                {\"\\\"it\\\\\\\"s here\\\"\"                 , \"\\\"it\\\\\\\"s here\\\"\"},\n\n                \n                {\"\\\"bad string\"                     , RUBBISH},\n                {\"'it's here'\"                      , RUBBISH},\n                {\"\\\"it\\\"s here\\\"\"                   , RUBBISH},\n\n                \n                {\"rgb(255, 255, 255)\"               , \"rgb(255, 255, 255)\"},\n\n                \n                {\"rgb(255, 255, 255\"               , RUBBISH},\n                {\"255, 255, 255)\"                  , RUBBISH},\n\n                \n                {\"url(http://example.com/test.png)\", \"url(http://example.com/test.png)\"},\n                {\"url('image/test.png')\"           , \"url('image/test.png')\"},\n\n                \n                {\"color: red\"                      , RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidStyleToken(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating style token '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidCSSColor() {\n        String[][] testData = {\n                \n                \n                {null, RUBBISH},\n                {\"\", RUBBISH},\n\n                {\"rgb(0,+0,-0)\", \"rgb(0,+0,-0)\"},\n                {\"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\", \"rgba ( 0\\f%, 0%,\\t0%,\\n100%\\r)\",},\n\n                {\"#ddd\", \"#ddd\"},\n                {\"#eeeeee\", \"#eeeeee\",},\n\n                {\"hsl(0,1,2)\", \"hsl(0,1,2)\"},\n                {\"hsla(0,1,2,3)\", \"hsla(0,1,2,3)\"},\n                {\"currentColor\", \"currentColor\"},\n                {\"transparent\", \"transparent\"},\n\n                {\"\\f\\r\\n\\t MenuText\\f\\r\\n\\t \", \"MenuText\"},\n                {\"expression(99,99,99)\", RUBBISH},\n                {\"blue;\", RUBBISH},\n                {\"url(99,99,99)\", RUBBISH}\n        };\n\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidCSSColor(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating CSS Color '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidMultiLineComment() {\n        String[][] testData = {\n                \n\n                {null               , RUBBISH},\n                {\"blah */ hack\"     , RUBBISH},\n\n                {\"Valid comment\"    , \"Valid comment\"}\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidMultiLineComment(source, RUBBISH);\n            if (!result.equals(expected)) {\n                fail(\"Validating multiline comment '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidJSON() {\n        String[][] testData = {\n                {null,      RUBBISH_JSON},\n                {\"\",        \"\"},\n                {\"1]\",      RUBBISH_JSON},\n                {\"{}\",      \"{}\"},\n                {\"{1}\",     RUBBISH_JSON},\n                {\n                        \"{\\\"test\\\": \\\"test\\\"}\",\n                        \"{\\\"test\\\":\\\"test\\\"}\"\n                },\n                {\n                        \"{\\\"test\\\":\\\"test}\",\n                        RUBBISH_JSON\n                },\n                {\n                        \"{\\\"test1\\\":\\\"test1\\\", \\\"test2\\\": {\\\"test21\\\": \\\"test21\\\", \\\"test22\\\": \\\"test22\\\"}}\",\n                        \"{\\\"test1\\\":\\\"test1\\\",\\\"test2\\\":{\\\"test21\\\":\\\"test21\\\",\\\"test22\\\":\\\"test22\\\"}}\"\n                },\n                {\"[]\",      \"[]\"},\n                {\"[1,2]\",   \"[1,2]\"},\n                {\"[1\",      RUBBISH_JSON},\n                {\n                        \"[{\\\"test\\\": \\\"test\\\"}]\",\n                        \"[{\\\"test\\\":\\\"test\\\"}]\"\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidJSON(source, RUBBISH_JSON);\n            if (!result.equals(expected)) {\n                fail(\"Validating JSON '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n\n    @Test\n    public void testGetValidXML() {\n        String[][] testData = {\n                {null,      RUBBISH_XML},\n                {\"\",        \"\"},\n                {\n                        \"<t/>\",\n                        \"<t/>\"\n                },\n                {\n                        \"<t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t>test</t>\",\n                        \"<t>test</t>\"\n                },\n                {\n                        \"<t>test\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t t=\\\"t\\\">test</t>\",\n                        \"<t t=\\\"t\\\">test</t>\"\n                },\n                {\n                        \"<t t=\\\"t>test</t>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<t><w>xyz</w></t>\",\n                        \"<t><w>xyz</w></t>\"\n                },\n                {\n                        \"<t><w>xyz</t></w>\",\n                        RUBBISH_XML\n                },\n                {\n                        \"<?xml version=\\\"1.0\\\"?><!DOCTYPE test SYSTEM \\\"http://nonExistentHost:1234/\\\"><test/>\",\n                        \"<?xml version=\\\"1.0\\\"?><!DOCTYPE test SYSTEM \\\"http://nonExistentHost:1234/\\\"><test/>\"\n                }\n        };\n        for (String[] aTestData : testData) {\n            String source = aTestData[0];\n            String expected = aTestData[1];\n\n            String result = xssAPI.getValidXML(source, RUBBISH_XML);\n            if (!result.equals(expected)) {\n                fail(\"Validating XML '\" + source + \"', expecting '\" + expected + \"', but got '\" + result + \"'\");\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 25,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/a0fdca138feec2c2e94eb75ca1f8b76678b4d152",
    "cve_id": "CVE-2016-4465",
    "cwe_id": "CWE-20",
    "filename": "core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java",
    "code": "\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        \n        \n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex()).matcher((String) value).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    \n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/+([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 25,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/a0fdca138feec2c2e94eb75ca1f8b76678b4d152",
    "cve_id": "CVE-2016-4465",
    "cwe_id": "CWE-20",
    "filename": "core/src/test/java/com/opensymphony/xwork2/validator/URLValidatorTest.java",
    "code": "\npackage com.opensymphony.xwork2.validator;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.XWorkTestCase;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.validator.validators.URLValidator;\n\nimport java.util.regex.Pattern;\n\n\npublic class URLValidatorTest extends XWorkTestCase {\n\n\t\n\tValueStack stack;\n\tActionContext actionContext;\n\t\n\tpublic void testAcceptNullValueForMutualExclusionOfValidators() throws Exception {\n\t\t\n\t\tURLValidator validator = new URLValidator();\n\t\tvalidator.setValidatorContext(new GenericValidatorContext(new Object()));\n\t\tvalidator.setFieldName(\"testingUrl1\");\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.validate(new MyObject());\n\t\t\n\t\tassertFalse(validator.getValidatorContext().hasErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionMessages());\n\t\tassertFalse(validator.getValidatorContext().hasFieldErrors());\n\t}\n\t\n\tpublic void testInvalidEmptyValue() throws Exception {\n\t\t\n\t\tURLValidator validator = new URLValidator();\n\t\tvalidator.setValidatorContext(new GenericValidatorContext(new Object()));\n\t\tvalidator.setFieldName(\"testingUrl2\");\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.validate(new MyObject());\n\t\t\n\t\tassertFalse(validator.getValidatorContext().hasErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionMessages());\n\t\tassertFalse(validator.getValidatorContext().hasFieldErrors());\n\t}\n\t\n\tpublic void testInvalidValue() throws Exception {\n\t\t\n\t\tURLValidator validator = new URLValidator();\n\t\tvalidator.setValidatorContext(new GenericValidatorContext(new Object()));\n\t\tvalidator.setFieldName(\"testingUrl3\");\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.validate(new MyObject());\n\t\t\n\t\tassertTrue(validator.getValidatorContext().hasErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionMessages());\n\t\tassertTrue(validator.getValidatorContext().hasFieldErrors());\n\t}\n\t\n\t\n\tpublic void testValidUrl1() throws Exception {\n\t\t\n\t\tURLValidator validator = new URLValidator();\n\t\tvalidator.setValidatorContext(new GenericValidatorContext(new Object()));\n\t\tvalidator.setFieldName(\"testingUrl4\");\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.validate(new MyObject());\n\t\t\n\t\tassertFalse(validator.getValidatorContext().hasErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionMessages());\n\t\tassertFalse(validator.getValidatorContext().hasFieldErrors());\n\t}\n\t\n\tpublic void testValidUrl2() throws Exception {\n\t\t\n\t\tURLValidator validator = new URLValidator();\n\t\tvalidator.setValidatorContext(new GenericValidatorContext(new Object()));\n\t\tvalidator.setFieldName(\"testingUrl5\");\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.validate(new MyObject());\n\t\t\n\t\tassertFalse(validator.getValidatorContext().hasErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionErrors());\n\t\tassertFalse(validator.getValidatorContext().hasActionMessages());\n\t\tassertFalse(validator.getValidatorContext().hasFieldErrors());\n\t}\n\t\n\tpublic void testValidUrlWithRegex() throws Exception {\n\t\tURLValidator validator = new URLValidator();\n\n        validator.setUrlRegex(\"^myapp:\\\\/\\\\/[a-z]*\\\\.com$\");\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex());\n\n        assertTrue(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n\t}\n\n\tpublic void testValidUrlWithRegexExpression() throws Exception {\n\t\tURLValidator validator = new URLValidator();\n        ActionContext.getContext().getValueStack().push(new MyAction());\n        validator.setValueStack(ActionContext.getContext().getValueStack());\n        validator.setUrlRegexExpression(\"${urlRegex}\");\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex());\n\n        assertTrue(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n\t}\n\n\tpublic void testValidUrlWithDefaultRegex() throws Exception {\n\t\tURLValidator validator = new URLValidator();\n\n        Pattern pattern = Pattern.compile(validator.getUrlRegex());\n\n        assertFalse(pattern.matcher(\"myapp://test.com\").matches());\n        assertFalse(pattern.matcher(\"myap://test.com\").matches());\n        assertFalse(pattern.matcher(\"\").matches());\n        assertFalse(pattern.matcher(\"   \").matches());\n        assertFalse(pattern.matcher(\"no url\").matches());\n\n        assertTrue(pattern.matcher(\"http://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com\").matches());\n        assertTrue(pattern.matcher(\"https://www.opensymphony.com:443/login\").matches());\n        assertTrue(pattern.matcher(\"http://localhost:8080/myapp\").matches());\n    }\n\n\t@Override\n    protected void setUp() throws Exception {\n\t    super.setUp();\n\t\tstack = ActionContext.getContext().getValueStack();\n\t\tactionContext = ActionContext.getContext();\n\t}\n\t\n\t@Override\n    protected void tearDown() throws Exception {\n\t    super.tearDown();\n\t\tstack = null;\n\t\tactionContext = null;\n\t}\n\t\n\t\n\tclass MyObject {\n\t\tpublic String getTestingUrl1() {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic String getTestingUrl2() {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\tpublic String getTestingUrl3() {\n\t\t\treturn \"sasdasd@asddd\";\n\t\t}\n\t\t\n\t\tpublic String getTestingUrl4() {\n\t\t\t\n\t\t\treturn \"http://www.jroller.com1?qwe=qwe\";\n\t\t}\n\t\t\n\t\tpublic String getTestingUrl5() {\n\t\t\treturn \"http://yahoo.com/articles?id=123\";\n\t\t}\n\t}\n\n    class MyAction {\n\n        public String getUrlRegex() {\n            return \"myapp:\\\\/\\\\/[a-z]*\\\\.com\";\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 26,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/bqcuong/vul4j/commit/1a668af7f1ffccea4a3b46d8d8c1fe1c7331ff02",
    "cve_id": "CVE-2014-0116",
    "cwe_id": "CWE-264",
    "filename": "core/src/main/java/org/apache/struts2/interceptor/CookieInterceptor.java",
    "code": "\n\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.AbstractInterceptor;\nimport com.opensymphony.xwork2.ExcludedPatterns;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.ValueStack;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.struts2.ServletActionContext;\n\nimport javax.servlet.http.Cookie;\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n\npublic class CookieInterceptor extends AbstractInterceptor {\n\n    private static final long serialVersionUID = 4153142432948747305L;\n\n    private static final Logger LOG = LoggerFactory.getLogger(CookieInterceptor.class);\n\n    private static final String ACCEPTED_PATTERN = \"[a-zA-Z0-9\\\\.\\\\]\\\\[_'\\\\s]+\";\n\n    private Set<String> cookiesNameSet = Collections.emptySet();\n    private Set<String> cookiesValueSet = Collections.emptySet();\n\n    \n    private Pattern acceptedPattern = Pattern.compile(ACCEPTED_PATTERN, Pattern.CASE_INSENSITIVE);\n    private Pattern excludedPattern = Pattern.compile(ExcludedPatterns.CLASS_ACCESS_PATTERN, Pattern.CASE_INSENSITIVE);\n\n    \n    public void setCookiesName(String cookiesName) {\n        if (cookiesName != null)\n            this.cookiesNameSet = TextParseUtil.commaDelimitedStringToSet(cookiesName);\n    }\n\n    \n    public void setCookiesValue(String cookiesValue) {\n        if (cookiesValue != null)\n            this.cookiesValueSet = TextParseUtil.commaDelimitedStringToSet(cookiesValue);\n    }\n\n    \n    public void setAcceptCookieNames(String pattern) {\n        acceptedPattern = Pattern.compile(pattern);\n    }\n\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"start interception\");\n        }\n\n        \n        final Map<String, String> cookiesMap = new LinkedHashMap<String, String>();\n\n        Cookie[] cookies = ServletActionContext.getRequest().getCookies();\n        if (cookies != null) {\n            final ValueStack stack = ActionContext.getContext().getValueStack();\n\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                String value = cookie.getValue();\n\n                if (isAcceptableName(name) && isAcceptableValue(value)) {\n                    if (cookiesNameSet.contains(\"*\")) {\n                        if (LOG.isDebugEnabled()) {\n                            LOG.debug(\"contains cookie name [*] in configured cookies name set, cookie with name [\" + name + \"] with value [\" + value + \"] will be injected\");\n                        }\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    } else if (cookiesNameSet.contains(cookie.getName())) {\n                        populateCookieValueIntoStack(name, value, cookiesMap, stack);\n                    }\n                } else {\n                    LOG.warn(\"Cookie name [#0] with value [#1] was rejected!\", name, value);\n                }\n            }\n        }\n\n        \n        injectIntoCookiesAwareAction(invocation.getAction(), cookiesMap);\n\n        return invocation.invoke();\n    }\n\n    \n    protected boolean isAcceptableValue(String value) {\n        boolean matches = !excludedPattern.matcher(value).matches();\n        if (!matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie value [#0] matches excludedPattern [#1]\", value, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    \n    protected boolean isAcceptableName(String name) {\n        return !isExcluded(name) && isAccepted(name);\n    }\n\n    \n    protected boolean isAccepted(String name) {\n        boolean matches = acceptedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match acceptedPattern [#1]\", name, ACCEPTED_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    \n    protected boolean isExcluded(String name) {\n        boolean matches = excludedPattern.matcher(name).matches();\n        if (matches) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] matches excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        } else {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Cookie [#0] doesn't match excludedPattern [#1]\", name, ExcludedPatterns.CLASS_ACCESS_PATTERN);\n            }\n        }\n        return matches;\n    }\n\n    \n    protected void populateCookieValueIntoStack(String cookieName, String cookieValue, Map<String, String> cookiesMap, ValueStack stack) {\n        if (cookiesValueSet.isEmpty() || cookiesValueSet.contains(\"*\")) {\n            \n            \n            \n            \n            if (LOG.isDebugEnabled()) {\n                if (cookiesValueSet.isEmpty())\n                    LOG.debug(\"no cookie value is configured, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                else if (cookiesValueSet.contains(\"*\"))\n                    LOG.debug(\"interceptor is configured to accept any value, cookie with name [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n            }\n            cookiesMap.put(cookieName, cookieValue);\n            stack.setValue(cookieName, cookieValue);\n        }\n        else {\n            \n            \n            if (cookiesValueSet.contains(cookieValue)) {\n                if (LOG.isDebugEnabled()) {\n                    LOG.debug(\"both configured cookie name and value matched, cookie [\"+cookieName+\"] with value [\"+cookieValue+\"] will be injected\");\n                }\n\n                cookiesMap.put(cookieName, cookieValue);\n                stack.setValue(cookieName, cookieValue);\n            }\n        }\n    }\n\n    \n    protected void injectIntoCookiesAwareAction(Object action, Map<String, String> cookiesMap) {\n        if (action instanceof CookiesAware) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"action [\"+action+\"] implements CookiesAware, injecting cookies map [\"+cookiesMap+\"]\");\n            }\n            ((CookiesAware)action).setCookiesMap(cookiesMap);\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 26,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/bqcuong/vul4j/commit/1a668af7f1ffccea4a3b46d8d8c1fe1c7331ff02",
    "cve_id": "CVE-2014-0116",
    "cwe_id": "CWE-264",
    "filename": "core/src/test/java/org/apache/struts2/interceptor/CookieInterceptorTest.java",
    "code": "\n\npackage org.apache.struts2.interceptor;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.Cookie;\n\nimport com.opensymphony.xwork2.mock.MockActionInvocation;\nimport org.easymock.MockControl;\nimport org.springframework.mock.web.MockHttpServletRequest;\n\nimport org.apache.struts2.ServletActionContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport com.opensymphony.xwork2.Action;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.ActionSupport;\n\npublic class CookieInterceptorTest extends StrutsInternalTestCase {\n\n\n    public void testIntercepDefault() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        \n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.intercept(invocation);\n\n        assertTrue(action.getCookiesMap().isEmpty());\n        assertNull(action.getCookie1(), null);\n        assertNull(action.getCookie2(), null);\n        assertNull(action.getCookie3(), null);\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie1\"));\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie2\"));\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie3\"));\n    }\n\n    public void testInterceptAll1() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"*\");\n        interceptor.setCookiesValue(\"*\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 3);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), \"cookie2value\");\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), \"cookie2value\");\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), \"cookie2value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n\n    public void testInterceptAll2() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"cookie1, cookie2, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value, cookie2value, cookie3value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 3);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), \"cookie2value\");\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), \"cookie2value\");\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), \"cookie2value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly1() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value, cookie2value, cookie3value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly2() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"*\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly3() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n\n    public void testInterceptSelectedCookiesNameAndValue() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 1);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), null);\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), null);\n    }\n\n    public void testCookiesWithClassPollution() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        String pollution1 = \"model['class']['classLoader']['jarPath']\";\n        String pollution2 = \"model.class.classLoader.jarPath\";\n        String pollution3 = \"class.classLoader.jarPath\";\n        String pollution4 = \"class['classLoader']['jarPath']\";\n        String pollution5 = \"model[\\\"class\\\"]['classLoader']['jarPath']\";\n        String pollution6 = \"class[\\\"classLoader\\\"]['jarPath']\";\n\n        request.setCookies(\n                new Cookie(pollution1, \"pollution1\"),\n                new Cookie(\"pollution1\", pollution1),\n                new Cookie(pollution2, \"pollution2\"),\n                new Cookie(\"pollution2\", pollution2),\n                new Cookie(pollution3, \"pollution3\"),\n                new Cookie(\"pollution3\", pollution3),\n                new Cookie(pollution4, \"pollution4\"),\n                new Cookie(\"pollution4\", pollution4),\n                new Cookie(pollution5, \"pollution5\"),\n                new Cookie(\"pollution5\", pollution5),\n                new Cookie(pollution6, \"pollution6\"),\n                new Cookie(\"pollution6\", pollution6)\n            );\n        ServletActionContext.setRequest(request);\n\n        final Map<String, Boolean> excludedName = new HashMap<String, Boolean>();\n        final Map<String, Boolean> excludedValue = new HashMap<String, Boolean>();\n\n        CookieInterceptor interceptor = new CookieInterceptor() {\n            @Override\n            protected boolean isAcceptableName(String name) {\n                boolean accepted = super.isAcceptableName(name);\n                excludedName.put(name, accepted);\n                return accepted;\n            }\n\n            @Override\n            protected boolean isAcceptableValue(String value) {\n                boolean accepted = super.isAcceptableValue(value);\n                excludedValue.put(value, accepted);\n                return accepted;\n            }\n        };\n        interceptor.setCookiesName(\"*\");\n\n        MockActionInvocation invocation = new MockActionInvocation();\n        invocation.setAction(new MockActionWithCookieAware());\n\n        interceptor.intercept(invocation);\n\n        assertFalse(excludedName.get(pollution1));\n        assertFalse(excludedName.get(pollution2));\n        assertFalse(excludedName.get(pollution3));\n        assertFalse(excludedName.get(pollution4));\n        assertFalse(excludedName.get(pollution5));\n        assertFalse(excludedName.get(pollution6));\n\n        assertFalse(excludedValue.get(pollution1));\n        assertFalse(excludedValue.get(pollution2));\n        assertFalse(excludedValue.get(pollution3));\n        assertFalse(excludedValue.get(pollution4));\n        assertFalse(excludedValue.get(pollution5));\n        assertFalse(excludedValue.get(pollution6));\n    }\n\n    public static class MockActionWithCookieAware extends ActionSupport implements CookiesAware {\n\n        private static final long serialVersionUID = -6202290616812813386L;\n\n        private Map cookies = Collections.EMPTY_MAP;\n        private String cookie1;\n        private String cookie2;\n        private String cookie3;\n\n        public void setCookiesMap(Map<String, String> cookies) {\n            this.cookies = cookies;\n        }\n\n        public Map getCookiesMap() {\n            return this.cookies;\n        }\n\n        public String getCookie1() { return cookie1; }\n        public void setCookie1(String cookie1) { this.cookie1 = cookie1; }\n\n        public String getCookie2() { return cookie2; }\n        public void setCookie2(String cookie2) { this.cookie2 = cookie2; }\n\n        public String getCookie3() { return cookie3; }\n        public void setCookie3(String cookie3) { this.cookie3 = cookie3; }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 27,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/554b9dddb0fbd1e581ef577dd62a7c22955ad0f6",
    "cve_id": "CVE-2016-8738",
    "cwe_id": "CWE-20",
    "filename": "core/src/main/java/com/opensymphony/xwork2/validator/validators/URLValidator.java",
    "code": "\npackage com.opensymphony.xwork2.validator.validators;\n\nimport com.opensymphony.xwork2.validator.ValidationException;\nimport org.apache.commons.lang3.StringUtils;\n\nimport java.util.regex.Pattern;\n\n\npublic class URLValidator extends FieldValidatorSupport {\n\n    private String urlRegex;\n    private String urlRegexExpression;\n\n    public void validate(Object object) throws ValidationException {\n        String fieldName = getFieldName();\n        Object value = this.getFieldValue(fieldName, object);\n\n        \n        \n        if (value == null || value.toString().length() == 0) {\n            return;\n        }\n\n        if (!(value.getClass().equals(String.class)) || !Pattern.compile(getUrlRegex(), Pattern.CASE_INSENSITIVE).matcher(String.valueOf(value)).matches()) {\n            addFieldError(fieldName, object);\n        }\n    }\n\n    \n    public String getUrlRegex() {\n        if (StringUtils.isNotEmpty(urlRegexExpression)) {\n            return (String) parse(urlRegexExpression, String.class);\n        } else if (StringUtils.isNotEmpty(urlRegex)) {\n            return urlRegex;\n        } else {\n            return \"^(https?|ftp):\\\\/\\\\/\" +\n                    \"(([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+\" +\n                    \"(:([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;\\\\?&=-]|%[0-9a-f]{2})+)?\" +\n                    \"@)?(#?\" +\n                    \")((([a-z0-9]\\\\.|[a-z0-9][a-z0-9-]*[a-z0-9]\\\\.)*\" +\n                    \"[a-z][a-z0-9-]*[a-z0-9]\" +\n                    \"|((\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\\\\.){3}\" +\n                    \"(\\\\d|[1-9]\\\\d|1\\\\d{2}|2[0-4][0-9]|25[0-5])\" +\n                    \")(:\\\\d+)?\" +\n                    \")(((\\\\/{0,1}([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)*\" +\n                    \"(\\\\?([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)\" +\n                    \"?)?)?\" +\n                    \"(#([a-z0-9$_\\\\.\\\\+!\\\\*\\\\'\\\\(\\\\),;:@&=-]|%[0-9a-f]{2})*)?\" +\n                    \"$\";\n        }\n    }\n\n    public void setUrlRegex(String urlRegex) {\n        this.urlRegex = urlRegex;\n    }\n\n    public void setUrlRegexExpression(String urlRegexExpression) {\n        this.urlRegexExpression = urlRegexExpression;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 28,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/237432512df0e27013f7c7b9ab59fdce44ca34a5",
    "cve_id": "CVE-2016-4436",
    "cwe_id": "Not Mapping",
    "filename": "core/src/main/java/org/apache/struts2/dispatcher/mapper/DefaultActionMapper.java",
    "code": "\n\npackage org.apache.struts2.dispatcher.mapper;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationManager;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.struts2.RequestUtils;\nimport org.apache.struts2.ServletActionContext;\nimport org.apache.struts2.StrutsConstants;\nimport org.apache.struts2.util.PrefixTrie;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\n\npublic class DefaultActionMapper implements ActionMapper {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultActionMapper.class);\n\n    protected static final String METHOD_PREFIX = \"method:\";\n    protected static final String ACTION_PREFIX = \"action:\";\n\n    protected boolean allowDynamicMethodCalls = false;\n    protected boolean allowSlashesInActionNames = false;\n    protected boolean alwaysSelectFullNamespace = false;\n    protected PrefixTrie prefixTrie = null;\n    protected Pattern allowedActionNames = Pattern.compile(\"[a-zA-Z0-9._!/\\\\-]*\");\n    private boolean allowActionPrefix = false;\n    private boolean allowActionCrossNamespaceAccess = false;\n\n    protected List<String> extensions = new ArrayList<String>() {{\n        add(\"action\");\n        add(\"\");\n    }};\n\n    protected Container container;\n\n    public DefaultActionMapper() {\n        prefixTrie = new PrefixTrie() {\n            {\n                put(METHOD_PREFIX, new ParameterAction() {\n                    public void execute(String key, ActionMapping mapping) {\n                        if (allowDynamicMethodCalls) {\n                            mapping.setMethod(cleanupActionName(key.substring(METHOD_PREFIX.length())));\n                        }\n                    }\n                });\n\n                put(ACTION_PREFIX, new ParameterAction() {\n                    public void execute(final String key, ActionMapping mapping) {\n                        if (allowActionPrefix) {\n                            String name = key.substring(ACTION_PREFIX.length());\n                            if (allowDynamicMethodCalls) {\n                                int bang = name.indexOf('!');\n                                if (bang != -1) {\n                                    String method = cleanupActionName(name.substring(bang + 1));\n                                    mapping.setMethod(method);\n                                    name = name.substring(0, bang);\n                                }\n                            }\n                            String actionName = cleanupActionName(name);\n                            if (allowSlashesInActionNames && !allowActionCrossNamespaceAccess) {\n                                if (actionName.startsWith(\"/\")) {\n                                    actionName = actionName.substring(1);\n                                }\n                            }\n                            if (!allowSlashesInActionNames && !allowActionCrossNamespaceAccess) {\n                                if (actionName.lastIndexOf(\"/\") != -1) {\n                                    actionName = actionName.substring(actionName.lastIndexOf(\"/\") + 1);\n                                }\n                            }\n                            mapping.setName(actionName);\n                        }\n                    }\n                });\n\n            }\n        };\n    }\n\n    \n    protected void addParameterAction(String prefix, ParameterAction parameterAction) {\n        prefixTrie.put(prefix, parameterAction);\n    }\n\n    @Inject(StrutsConstants.STRUTS_ENABLE_DYNAMIC_METHOD_INVOCATION)\n    public void setAllowDynamicMethodCalls(String allow) {\n        allowDynamicMethodCalls = \"true\".equalsIgnoreCase(allow);\n    }\n\n    @Inject(StrutsConstants.STRUTS_ENABLE_SLASHES_IN_ACTION_NAMES)\n    public void setSlashesInActionNames(String allow) {\n        allowSlashesInActionNames = \"true\".equals(allow);\n    }\n\n    @Inject(StrutsConstants.STRUTS_ALWAYS_SELECT_FULL_NAMESPACE)\n    public void setAlwaysSelectFullNamespace(String val) {\n        this.alwaysSelectFullNamespace = \"true\".equals(val);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_ALLOWED_ACTION_NAMES, required = false)\n    public void setAllowedActionNames(String allowedActionNames) {\n        this.allowedActionNames = Pattern.compile(allowedActionNames);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_MAPPER_ACTION_PREFIX_ENABLED)\n    public void setAllowActionPrefix(String allowActionPrefix) {\n        this.allowActionPrefix = \"true\".equalsIgnoreCase(allowActionPrefix);\n    }\n\n    @Inject(value = StrutsConstants.STRUTS_MAPPER_ACTION_PREFIX_CROSSNAMESPACES)\n    public void setAllowActionCrossNamespaceAccess(String allowActionCrossNamespaceAccess) {\n        this.allowActionCrossNamespaceAccess = \"true\".equalsIgnoreCase(allowActionCrossNamespaceAccess);\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(StrutsConstants.STRUTS_ACTION_EXTENSION)\n    public void setExtensions(String extensions) {\n        if (extensions != null && !\"\".equals(extensions)) {\n            List<String> list = new ArrayList<String>();\n            String[] tokens = extensions.split(\",\");\n            Collections.addAll(list, tokens);\n            if (extensions.endsWith(\",\")) {\n                list.add(\"\");\n            }\n            this.extensions = Collections.unmodifiableList(list);\n        } else {\n            this.extensions = null;\n        }\n    }\n\n    public ActionMapping getMappingFromActionName(String actionName) {\n        ActionMapping mapping = new ActionMapping();\n        mapping.setName(actionName);\n        return parseActionName(mapping);\n    }\n\n    public boolean isSlashesInActionNames() {\n        return allowSlashesInActionNames;\n    }\n\n    \n    public ActionMapping getMapping(HttpServletRequest request, ConfigurationManager configManager) {\n        ActionMapping mapping = new ActionMapping();\n        String uri = RequestUtils.getUri(request);\n\n        int indexOfSemicolon = uri.indexOf(\";\");\n        uri = (indexOfSemicolon > -1) ? uri.substring(0, indexOfSemicolon) : uri;\n\n        uri = dropExtension(uri, mapping);\n        if (uri == null) {\n            return null;\n        }\n\n        parseNameAndNamespace(uri, mapping, configManager);\n        handleSpecialParameters(request, mapping);\n        return parseActionName(mapping);\n    }\n\n    protected ActionMapping parseActionName(ActionMapping mapping) {\n        if (mapping.getName() == null) {\n            return null;\n        }\n        if (allowDynamicMethodCalls) {\n            \n            String name = mapping.getName();\n            int exclamation = name.lastIndexOf(\"!\");\n            if (exclamation != -1) {\n                mapping.setName(name.substring(0, exclamation));\n\n                mapping.setMethod(name.substring(exclamation + 1));\n            }\n        }\n        return mapping;\n    }\n\n    \n    public void handleSpecialParameters(HttpServletRequest request, ActionMapping mapping) {\n        \n        Set<String> uniqueParameters = new HashSet<String>();\n        Map parameterMap = request.getParameterMap();\n        for (Object o : parameterMap.keySet()) {\n            String key = (String) o;\n\n            \n            if (key.endsWith(\".x\") || key.endsWith(\".y\")) {\n                key = key.substring(0, key.length() - 2);\n            }\n\n            \n            if (!uniqueParameters.contains(key)) {\n                ParameterAction parameterAction = (ParameterAction) prefixTrie.get(key);\n                if (parameterAction != null) {\n                    parameterAction.execute(key, mapping);\n                    uniqueParameters.add(key);\n                    break;\n                }\n            }\n        }\n    }\n\n    \n    protected void parseNameAndNamespace(String uri, ActionMapping mapping, ConfigurationManager configManager) {\n        String namespace, name;\n        int lastSlash = uri.lastIndexOf(\"/\");\n        if (lastSlash == -1) {\n            namespace = \"\";\n            name = uri;\n        } else if (lastSlash == 0) {\n            \n            \n            \n            namespace = \"/\";\n            name = uri.substring(lastSlash + 1);\n        } else if (alwaysSelectFullNamespace) {\n            \n            namespace = uri.substring(0, lastSlash);\n            name = uri.substring(lastSlash + 1);\n        } else {\n            \n            Configuration config = configManager.getConfiguration();\n            String prefix = uri.substring(0, lastSlash);\n            namespace = \"\";\n            boolean rootAvailable = false;\n            \n            for (PackageConfig cfg : config.getPackageConfigs().values()) {\n                String ns = cfg.getNamespace();\n                if (ns != null && prefix.startsWith(ns) && (prefix.length() == ns.length() || prefix.charAt(ns.length()) == '/')) {\n                    if (ns.length() > namespace.length()) {\n                        namespace = ns;\n                    }\n                }\n                if (\"/\".equals(ns)) {\n                    rootAvailable = true;\n                }\n            }\n\n            name = uri.substring(namespace.length() + 1);\n\n            \n            if (rootAvailable && \"\".equals(namespace)) {\n                namespace = \"/\";\n            }\n        }\n\n        if (!allowSlashesInActionNames) {\n            int pos = name.lastIndexOf('/');\n            if (pos > -1 && pos < name.length() - 1) {\n                name = name.substring(pos + 1);\n            }\n        }\n\n        mapping.setNamespace(namespace);\n        mapping.setName(cleanupActionName(name));\n    }\n\n    \n    protected String cleanupActionName(final String rawActionName) {\n        if (allowedActionNames.matcher(rawActionName).matches()) {\n            return rawActionName;\n        } else {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(\"Action/method [#0] does not match allowed action names pattern [#1], cleaning it up!\",\n                        rawActionName, allowedActionNames);\n            }\n            String cleanActionName = rawActionName;\n            for (String chunk : allowedActionNames.split(rawActionName)) {\n                cleanActionName = cleanActionName.replace(chunk, \"\");\n            }\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"Cleaned action/method name [#0]\", cleanActionName);\n            }\n            return cleanActionName;\n        }\n    }\n\n    \n    protected String dropExtension(String name) {\n        return dropExtension(name, new ActionMapping());\n    }\n\n    \n    protected String dropExtension(String name, ActionMapping mapping) {\n        if (extensions == null) {\n            return name;\n        }\n        for (String ext : extensions) {\n            if (\"\".equals(ext)) {\n                \n                \n                \n                int index = name.lastIndexOf('.');\n                if (index == -1 || name.indexOf('/', index) >= 0) {\n                    return name;\n                }\n            } else {\n                String extension = \".\" + ext;\n                if (name.endsWith(extension)) {\n                    name = name.substring(0, name.length() - extension.length());\n                    mapping.setExtension(ext);\n                    return name;\n                }\n            }\n        }\n        return null;\n    }\n\n    \n    protected String getDefaultExtension() {\n        if (extensions == null) {\n            return null;\n        } else {\n            return extensions.get(0);\n        }\n    }\n\n    \n    public String getUriFromActionMapping(ActionMapping mapping) {\n        StringBuilder uri = new StringBuilder();\n\n        handleNamespace(mapping, uri);\n        handleName(mapping, uri);\n        handleDynamicMethod(mapping, uri);\n        handleExtension(mapping, uri);\n        handleParams(mapping, uri);\n\n        return uri.toString();\n    }\n\n    protected void handleNamespace(ActionMapping mapping, StringBuilder uri) {\n        if (mapping.getNamespace() != null) {\n            uri.append(mapping.getNamespace());\n            if (!\"/\".equals(mapping.getNamespace())) {\n                uri.append(\"/\");\n            }\n        }\n    }\n\n    protected void handleName(ActionMapping mapping, StringBuilder uri) {\n        String name = mapping.getName();\n        if (name.indexOf('?') != -1) {\n            name = name.substring(0, name.indexOf('?'));\n        }\n        uri.append(name);\n    }\n\n    protected void handleDynamicMethod(ActionMapping mapping, StringBuilder uri) {\n        \n        if (StringUtils.isNotEmpty(mapping.getMethod())) {\n            if (allowDynamicMethodCalls) {\n                \n                String name = mapping.getName();\n                if (!name.contains(\"!\")) {\n                    \n                    uri.append(\"!\").append(mapping.getMethod());\n                }\n            } else {\n                uri.append(\"!\").append(mapping.getMethod());\n            }\n        }\n    }\n\n    protected void handleExtension(ActionMapping mapping, StringBuilder uri) {\n        String extension = lookupExtension(mapping.getExtension());\n\n        if (extension != null) {\n            if (extension.length() == 0 || (extension.length() > 0 && uri.indexOf('.' + extension) == -1)) {\n                if (extension.length() > 0) {\n                    uri.append(\".\").append(extension);\n                }\n            }\n        }\n    }\n\n    protected String lookupExtension(String extension) {\n        if (extension == null) {\n            \n            ActionContext context = ActionContext.getContext();\n            if (context != null) {\n                ActionMapping orig = (ActionMapping) context.get(ServletActionContext.ACTION_MAPPING);\n                if (orig != null) {\n                    extension = orig.getExtension();\n                }\n            }\n            if (extension == null) {\n                extension = getDefaultExtension();\n            }\n        }\n        return extension;\n    }\n\n    protected void handleParams(ActionMapping mapping, StringBuilder uri) {\n        String name = mapping.getName();\n        String params = \"\";\n        if (name.indexOf('?') != -1) {\n            params = name.substring(name.indexOf('?'));\n        }\n        if (params.length() > 0) {\n            uri.append(params);\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 28,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/237432512df0e27013f7c7b9ab59fdce44ca34a5",
    "cve_id": "CVE-2016-4436",
    "cwe_id": "Not Mapping",
    "filename": "core/src/test/java/org/apache/struts2/dispatcher/mapper/DefaultActionMapperTest.java",
    "code": "\n\npackage org.apache.struts2.dispatcher.mapper;\n\nimport com.mockobjects.servlet.MockHttpServletRequest;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.Result;\nimport com.opensymphony.xwork2.config.Configuration;\nimport com.opensymphony.xwork2.config.ConfigurationManager;\nimport com.opensymphony.xwork2.config.entities.PackageConfig;\nimport com.opensymphony.xwork2.config.impl.DefaultConfiguration;\nimport org.apache.struts2.ServletActionContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport org.apache.struts2.dispatcher.StrutsResultSupport;\nimport org.apache.struts2.views.jsp.StrutsMockHttpServletRequest;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class DefaultActionMapperTest extends StrutsInternalTestCase {\n\n    private MockHttpServletRequest req;\n    private ConfigurationManager configManager;\n    private Configuration config;\n\n    protected void setUp() throws Exception {\n        super.setUp();\n        req = new MockHttpServletRequest();\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetContextPath(\"/my/namespace\");\n\n        config = new DefaultConfiguration();\n        PackageConfig pkg = new PackageConfig.Builder(\"myns\")\n            .namespace(\"/my/namespace\").build();\n        PackageConfig pkg2 = new PackageConfig.Builder(\"my\").namespace(\"/my\").build();\n        config.addPackageConfig(\"mvns\", pkg);\n        config.addPackageConfig(\"my\", pkg2);\n        configManager = new ConfigurationManager() {\n            public Configuration getConfiguration() {\n                return config;\n            }\n        };\n    }\n\n    public void testGetMapping() throws Exception {\n        req.setupGetRequestURI(\"/my/namespace/actionName.action\");\n        req.setupGetServletPath(\"/my/namespace/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my/namespace\", mapping.getNamespace());\n        assertEquals(\"actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithMethod() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName!add.action\");\n        req.setupGetServletPath(\"/my/namespace/actionName!add.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setAllowDynamicMethodCalls(\"true\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my/namespace\", mapping.getNamespace());\n        assertEquals(\"actionName\", mapping.getName());\n        assertEquals(\"add\", mapping.getMethod());\n    }\n\n    public void testGetMappingWithSlashedName() throws Exception {\n\n        req.setupGetRequestURI(\"/my/foo/actionName.action\");\n        req.setupGetServletPath(\"/my/foo/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setSlashesInActionNames(\"true\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my\", mapping.getNamespace());\n        assertEquals(\"foo/actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithSlashedNameAtRootButNoSlashPackage() throws Exception {\n\n        req.setupGetRequestURI(\"/foo/actionName.action\");\n        req.setupGetServletPath(\"/foo/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setSlashesInActionNames(\"true\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"\", mapping.getNamespace());\n        assertEquals(\"foo/actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithSlashedNameAtRoot() throws Exception {\n        config = new DefaultConfiguration();\n        PackageConfig pkg = new PackageConfig.Builder(\"myns\")\n            .namespace(\"/my/namespace\").build();\n        PackageConfig pkg2 = new PackageConfig.Builder(\"my\").namespace(\"/my\").build();\n        PackageConfig pkg3 = new PackageConfig.Builder(\"root\").namespace(\"/\").build();\n        config.addPackageConfig(\"mvns\", pkg);\n        config.addPackageConfig(\"my\", pkg2);\n        config.addPackageConfig(\"root\", pkg3);\n        configManager = new ConfigurationManager() {\n            public Configuration getConfiguration() {\n                return config;\n            }\n        };\n\n        req.setupGetRequestURI(\"/foo/actionName.action\");\n        req.setupGetServletPath(\"/foo/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setSlashesInActionNames(\"true\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/\", mapping.getNamespace());\n        assertEquals(\"foo/actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n\n\n    public void testGetMappingWithNamespaceSlash() throws Exception {\n\n        req.setupGetRequestURI(\"/my.hh/abc.action\");\n        req.setupGetServletPath(\"/my.hh/abc.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"\", mapping.getNamespace());\n        assertEquals(\"abc\", mapping.getName());\n\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n        mapper = new DefaultActionMapper();\n        mapper.setSlashesInActionNames(\"true\");\n        mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"\", mapping.getNamespace());\n        assertEquals(\"my.hh/abc\", mapping.getName());\n    }\n\n    public void testGetMappingWithUnknownNamespace() throws Exception {\n        req.setupGetRequestURI(\"/bo/foo/actionName.action\");\n        req.setupGetServletPath(\"/bo/foo/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"\", mapping.getNamespace());\n        assertEquals(\"actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithUnknownNamespaceButFullNamespaceSelect() throws Exception {\n        req.setupGetRequestURI(\"/bo/foo/actionName.action\");\n        req.setupGetServletPath(\"/bo/foo/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setAlwaysSelectFullNamespace(\"true\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/bo/foo\", mapping.getNamespace());\n        assertEquals(\"actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithActionName_methodAndName() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setAllowDynamicMethodCalls(\"true\");\n        ActionMapping mapping = mapper.getMappingFromActionName(\"actionName!add\");\n        assertEquals(\"actionName\", mapping.getName());\n        assertEquals(\"add\", mapping.getMethod());\n    }\n\n    public void testGetMappingWithActionName_name() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMappingFromActionName(\"actionName\");\n        assertEquals(\"actionName\", mapping.getName());\n        assertEquals(null, mapping.getMethod());\n    }\n\n    public void testGetMappingWithActionName_noDynamicMethod() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setAllowDynamicMethodCalls(\"false\");\n        ActionMapping mapping = mapper.getMappingFromActionName(\"actionName!add\");\n        assertEquals(\"actionName!add\", mapping.getName());\n        assertEquals(null, mapping.getMethod());\n    }\n\n    public void testGetMappingWithActionName_noDynamicMethodColonPrefix() throws Exception {\n\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.METHOD_PREFIX + \"someMethod\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowDynamicMethodCalls(\"false\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"someServletPath\", actionMapping.getName());\n        assertEquals(null, actionMapping.getMethod());\n    }\n\n    public void testGetMappingWithActionName_null() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMappingFromActionName(null);\n        assertNull(mapping);\n    }\n\n    public void testGetUri() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName.action\");\n        req.setupGetServletPath(\"/my/namespace/actionName.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n        assertEquals(\"/my/namespace/actionName.action\", mapper.getUriFromActionMapping(mapping));\n    }\n\n    public void testGetUriWithSemicolonPresent() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName.action;abc=123rty56\");\n        req.setupGetServletPath(\"/my/namespace/actionName.action;abc=123rty56\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n        assertEquals(\"/my/namespace/actionName.action\", mapper.getUriFromActionMapping(mapping));\n    }\n\n    public void testGetUriWithMethod() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName!add.action\");\n        req.setupGetServletPath(\"/my/namespace/actionName!add.action\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my/namespace/actionName!add.action\", mapper.getUriFromActionMapping(mapping));\n    }\n\n    public void testGetUriWithOriginalExtension() throws Exception {\n        ActionMapping mapping = new ActionMapping(\"actionName\", \"/ns\", null, new HashMap());\n\n        ActionMapping orig = new ActionMapping();\n        orig.setExtension(\"foo\");\n        ActionContext.getContext().put(ServletActionContext.ACTION_MAPPING, orig);\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        assertEquals(\"/ns/actionName.foo\", mapper.getUriFromActionMapping(mapping));\n    }\n\n    public void testGetMappingWithNoExtension() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName\");\n        req.setupGetServletPath(\"/my/namespace/actionName\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\"\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my/namespace\", mapping.getNamespace());\n        assertEquals(\"actionName\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    public void testGetMappingWithNoExtensionButUriHasExtension() throws Exception {\n        req.setupGetParameterMap(new HashMap());\n        req.setupGetRequestURI(\"/my/namespace/actionName.html\");\n        req.setupGetServletPath(\"/my/namespace/actionName.html\");\n        req.setupGetAttribute(null);\n        req.addExpectedGetAttributeName(\"javax.servlet.include.servlet_path\");\n\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\"\");\n        ActionMapping mapping = mapper.getMapping(req, configManager);\n\n        assertEquals(\"/my/namespace\", mapping.getNamespace());\n        assertEquals(\"actionName.html\", mapping.getName());\n        assertNull(mapping.getMethod());\n    }\n\n    \n    \n    \n\n    public void testParseNameAndNamespace1() throws Exception {\n        ActionMapping actionMapping = new ActionMapping();\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.parseNameAndNamespace(\"someAction\", actionMapping, configManager);\n\n        assertEquals(actionMapping.getName(), \"someAction\");\n        assertEquals(actionMapping.getNamespace(), \"\");\n    }\n\n    public void testParseNameAndNamespace2() throws Exception {\n        ActionMapping actionMapping = new ActionMapping();\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.parseNameAndNamespace(\"/someAction\", actionMapping, configManager);\n\n        assertEquals(actionMapping.getName(), \"someAction\");\n        assertEquals(actionMapping.getNamespace(), \"/\");\n    }\n\n    public void testParseNameAndNamespace3() throws Exception {\n        ActionMapping actionMapping = new ActionMapping();\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.parseNameAndNamespace(\"/my/someAction\", actionMapping, configManager);\n\n        assertEquals(actionMapping.getName(), \"someAction\");\n        assertEquals(actionMapping.getNamespace(), \"/my\");\n    }\n\n    public void testParseNameAndNamespace_NoSlashes() throws Exception {\n        ActionMapping actionMapping = new ActionMapping();\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setSlashesInActionNames(\"false\");\n        defaultActionMapper.parseNameAndNamespace(\"/foo/someAction\", actionMapping, configManager);\n\n        assertEquals(actionMapping.getName(), \"someAction\");\n        assertEquals(actionMapping.getNamespace(), \"\");\n    }\n\n    public void testParseNameAndNamespace_AllowSlashes() throws Exception {\n        ActionMapping actionMapping = new ActionMapping();\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setSlashesInActionNames(\"true\");\n        defaultActionMapper.parseNameAndNamespace(\"/foo/someAction\", actionMapping, configManager);\n\n        assertEquals(actionMapping.getName(), \"foo/someAction\");\n        assertEquals(actionMapping.getNamespace(), \"\");\n    }\n\n\n    \n    \n    \n\n    public void testActionPrefixWhenDisabled() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"someServletPath\", actionMapping.getName());\n    }\n\n    public void testActionPrefixWhenEnabled() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"myAction\", actionMapping.getName());\n    }\n\n    public void testActionPrefixWhenSlashesAndCrossNamespaceDisabled() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"my/Action\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        defaultActionMapper.setSlashesInActionNames(\"true\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"my/Action\", actionMapping.getName());\n    }\n\n    public void testActionPrefixWhenSlashesButSlashesDisabledAndCrossNamespaceDisabled() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"my/Action\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        defaultActionMapper.setSlashesInActionNames(\"false\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"Action\", actionMapping.getName());\n    }\n\n    public void testActionPrefixWhenSlashesButSlashesDisabledAndCrossNamespace() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"my/Action\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        defaultActionMapper.setAllowActionCrossNamespaceAccess(\"true\");\n        defaultActionMapper.setSlashesInActionNames(\"false\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"my/Action\", actionMapping.getName());\n    }\n\n    public void testActionPrefixWhenCrossNamespace() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"/my/Action\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        defaultActionMapper.setAllowActionCrossNamespaceAccess(\"true\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"/my/Action\", actionMapping.getName());\n    }\n\n    public void testActionPrefix_fromImageButton() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction\", \"\");\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction.x\", \"\");\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction.y\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"myAction\", actionMapping.getName());\n    }\n\n    public void testActionPrefix_fromIEImageButton() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction.x\", \"\");\n        parameterMap.put(DefaultActionMapper.ACTION_PREFIX + \"myAction.y\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setAllowActionPrefix(\"true\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(\"myAction\", actionMapping.getName());\n    }\n\n    public void testRedirectPrefix() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"redirect:\" + \"http://www.google.com\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setupGetServletPath(\"/someServletPath.action\");\n        request.setParameterMap(parameterMap);\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setContainer(container);\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        Result result = actionMapping.getResult();\n        assertNull(result);\n    }\n\n    public void testUnsafeRedirectPrefix() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"redirect:\" + \"http://%{3*4}\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setupGetServletPath(\"/someServletPath.action\");\n        request.setParameterMap(parameterMap);\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setContainer(container);\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        Result result = actionMapping.getResult();\n        assertNull(result);\n    }\n\n    public void testRedirectActionPrefix() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"redirectAction:\" + \"myAction\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setupGetServletPath(\"/someServletPath.action\");\n        request.setParameterMap(parameterMap);\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setContainer(container);\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n\n        StrutsResultSupport result = (StrutsResultSupport) actionMapping.getResult();\n        assertNull(result);\n    }\n\n    public void testUnsafeRedirectActionPrefix() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"redirectAction:\" + \"%{3*4}\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setupGetServletPath(\"/someServletPath.action\");\n        request.setParameterMap(parameterMap);\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setContainer(container);\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n\n        StrutsResultSupport result = (StrutsResultSupport) actionMapping.getResult();\n        assertNull(result);\n    }\n\n    public void testRedirectActionPrefixWithEmptyExtension() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"redirectAction:\" + \"myAction\", \"\");\n\n        StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setupGetServletPath(\"/someServletPath\");\n        request.setParameterMap(parameterMap);\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.setContainer(container);\n        defaultActionMapper.setExtensions(\",,\");\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n\n        StrutsResultSupport result = (StrutsResultSupport) actionMapping.getResult();\n        assertNull(result);\n    }\n\n    public void testCustomActionPrefix() throws Exception {\n        Map parameterMap = new HashMap();\n        parameterMap.put(\"foo:myAction\", \"\");\n\n        final StrutsMockHttpServletRequest request = new StrutsMockHttpServletRequest();\n        request.setParameterMap(parameterMap);\n        request.setupGetServletPath(\"/someServletPath.action\");\n\n        DefaultActionMapper defaultActionMapper = new DefaultActionMapper();\n        defaultActionMapper.addParameterAction(\"foo\", new ParameterAction() {\n            public void execute(String key, ActionMapping mapping) {\n                mapping.setName(\"myAction\");\n            }\n        });\n        ActionMapping actionMapping = defaultActionMapper.getMapping(request, configManager);\n\n        assertEquals(actionMapping.getName(), \"myAction\");\n    }\n\n    public void testDropExtension() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        String name = mapper.dropExtension(\"foo.action\");\n        assertTrue(\"Name not right: \"+name, \"foo\".equals(name));\n\n        name = mapper.dropExtension(\"foo.action.action\");\n        assertTrue(\"Name not right: \"+name, \"foo.action\".equals(name));\n\n    }\n\n    public void testDropExtensionWhenBlank() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\"action,,\");\n        String name = mapper.dropExtension(\"foo.action\");\n        assertTrue(\"Name not right: \"+name, \"foo\".equals(name));\n        name = mapper.dropExtension(\"foo\");\n        assertTrue(\"Name not right: \"+name, \"foo\".equals(name));\n        assertNull(mapper.dropExtension(\"foo.bar\"));\n        assertNull(mapper.dropExtension(\"foo.\"));\n    }\n\n    public void testDropExtensionEmbeddedDot() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\"action,,\");\n\n        String name = mapper.dropExtension(\"/foo/bar-1.0/baz.action\");\n        assertTrue(\"Name not right: \"+name, \"/foo/bar-1.0/baz\".equals(name));\n\n        name = mapper.dropExtension(\"/foo/bar-1.0/baz\");\n        assertTrue(\"Name not right: \"+name, \"/foo/bar-1.0/baz\".equals(name));\n    }\n\n    public void testGetUriFromActionMapper1() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"/myNamespace\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myNamespace/myActionName!myMethod.action\", uri);\n    }\n\n    public void testGetUriFromActionMapper2() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName!myMethod.action\", uri);\n    }\n\n    public void testGetUriFromActionMapper3() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName!myMethod.action\", uri);\n    }\n\n\n    public void testGetUriFromActionMapper4() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action\", uri);\n    }\n\n    public void testGetUriFromActionMapper5() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action\", uri);\n    }\n\n    \n    public void testGetUriFromActionMapper6() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName?test=bla\");\n        actionMapping.setNamespace(\"/myNamespace\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myNamespace/myActionName!myMethod.action?test=bla\", uri);\n    }\n\n    public void testGetUriFromActionMapper7() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName?test=bla\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName!myMethod.action?test=bla\", uri);\n    }\n\n    public void testGetUriFromActionMapper8() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName?test=bla\");\n        actionMapping.setNamespace(\"\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName!myMethod.action?test=bla\", uri);\n    }\n\n\n    public void testGetUriFromActionMapper9() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName?test=bla\");\n        actionMapping.setNamespace(\"\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action?test=bla\", uri);\n    }\n\n    public void testGetUriFromActionMapper10() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName?test=bla\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action?test=bla\", uri);\n    }\n\n    public void testGetUriFromActionMapper11() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName.action\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action\", uri);\n    }\n\n    public void testGetUriFromActionMapper12() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setName(\"myActionName.action\");\n        actionMapping.setNamespace(\"/\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myActionName.action\", uri);\n    }\n\n    public void testGetUriFromActionMapper_justActionAndMethod() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setExtension(\"\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"myActionName!myMethod\", uri);\n    }\n\n    public void testGetUriFromActionMapperWhenBlankExtension() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\",,\");\n        ActionMapping actionMapping = new ActionMapping();\n        actionMapping.setMethod(\"myMethod\");\n        actionMapping.setName(\"myActionName\");\n        actionMapping.setNamespace(\"/myNamespace\");\n        String uri = mapper.getUriFromActionMapping(actionMapping);\n\n        assertEquals(\"/myNamespace/myActionName!myMethod\", uri);\n    }\n\n    public void testSetExtension() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n        mapper.setExtensions(\"\");\n        assertNull(mapper.extensions);\n        mapper.setExtensions(null);\n        assertNull(mapper.extensions);\n\n        mapper.setExtensions(\",xml\");\n        assertEquals(Arrays.asList(\"\", \"xml\"), mapper.extensions);\n\n        mapper.setExtensions(\"html,xml,\");\n        assertEquals(Arrays.asList(\"html\", \"xml\", \"\"), mapper.extensions);\n\n        mapper.setExtensions(\"html,,xml\");\n        assertEquals(Arrays.asList(\"html\", \"\", \"xml\"), mapper.extensions);\n\n        mapper.setExtensions(\"xml\");\n        assertEquals(Arrays.asList(\"xml\"), mapper.extensions);\n\n        mapper.setExtensions(\",\");\n        assertEquals(Arrays.asList(\"\"), mapper.extensions);\n\n\n    }\n\n    public void testAllowedActionNames() throws Exception {\n        DefaultActionMapper mapper = new DefaultActionMapper();\n\n        String actionName = \"action\";\n        assertEquals(actionName, mapper.cleanupActionName(actionName));\n\n        actionName = \"${action}\";\n        assertEquals(\"action\", mapper.cleanupActionName(actionName));\n\n        actionName = \"${${%{action}}}\";\n        assertEquals(\"action\", mapper.cleanupActionName(actionName));\n\n        actionName = \"${#foo='action',#foo}\";\n        assertEquals(\"fooactionfoo\", mapper.cleanupActionName(actionName));\n\n        actionName = \"test-action\";\n        assertEquals(\"test-action\", mapper.cleanupActionName(actionName));\n\n        actionName = \"test_action\";\n        assertEquals(\"test_action\", mapper.cleanupActionName(actionName));\n\n        actionName = \"test!bar.action\";\n        assertEquals(\"test!bar.action\", mapper.cleanupActionName(actionName));\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 29,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/d832747d647df343ed07a58b1b5e540a05a4d51b",
    "cve_id": "CVE-2015-1831",
    "cwe_id": "Not Mapping",
    "filename": "core/src/test/java/org/apache/struts2/interceptor/CookieInterceptorTest.java",
    "code": "\n\npackage org.apache.struts2.interceptor;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.Cookie;\n\nimport com.opensymphony.xwork2.security.DefaultExcludedPatternsChecker;\nimport com.opensymphony.xwork2.mock.MockActionInvocation;\nimport org.easymock.MockControl;\nimport org.springframework.mock.web.MockHttpServletRequest;\n\nimport org.apache.struts2.ServletActionContext;\nimport org.apache.struts2.StrutsInternalTestCase;\nimport com.opensymphony.xwork2.Action;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.ActionSupport;\n\npublic class CookieInterceptorTest extends StrutsInternalTestCase {\n\n\n    public void testIntercepDefault() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        \n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n\n        interceptor.intercept(invocation);\n\n        assertTrue(action.getCookiesMap().isEmpty());\n        assertNull(action.getCookie1(), null);\n        assertNull(action.getCookie2(), null);\n        assertNull(action.getCookie3(), null);\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie1\"));\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie2\"));\n        assertNull(ActionContext.getContext().getValueStack().findValue(\"cookie3\"));\n    }\n\n    public void testInterceptAll1() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"*\");\n        interceptor.setCookiesValue(\"*\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 3);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), \"cookie2value\");\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), \"cookie2value\");\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), \"cookie2value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n\n    public void testInterceptAll2() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"cookie1, cookie2, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value, cookie2value, cookie3value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 3);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), \"cookie2value\");\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), \"cookie2value\");\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), \"cookie2value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly1() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value, cookie2value, cookie3value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly2() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"*\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n    public void testInterceptSelectedCookiesNameOnly3() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 2);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), \"cookie3value\");\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), \"cookie3value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), \"cookie3value\");\n    }\n\n\n    public void testInterceptSelectedCookiesNameAndValue() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        request.setCookies(new Cookie[] {\n                new Cookie(\"cookie1\", \"cookie1value\"),\n                new Cookie(\"cookie2\", \"cookie2value\"),\n                new Cookie(\"cookie3\", \"cookie3value\")\n            });\n        ServletActionContext.setRequest(request);\n\n        MockActionWithCookieAware action = new MockActionWithCookieAware();\n\n        ActionContext.getContext().getValueStack().push(action);\n\n        MockControl actionInvocationControl = MockControl.createControl(ActionInvocation.class);\n        ActionInvocation invocation = (ActionInvocation) actionInvocationControl.getMock();\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.getAction(), action);\n        actionInvocationControl.expectAndDefaultReturn(\n                                                       invocation.invoke(), Action.SUCCESS);\n\n        actionInvocationControl.replay();\n\n        CookieInterceptor interceptor = new CookieInterceptor();\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"cookie1, cookie3\");\n        interceptor.setCookiesValue(\"cookie1value\");\n        interceptor.intercept(invocation);\n\n        assertFalse(action.getCookiesMap().isEmpty());\n        assertEquals(action.getCookiesMap().size(), 1);\n        assertEquals(action.getCookiesMap().get(\"cookie1\"), \"cookie1value\");\n        assertEquals(action.getCookiesMap().get(\"cookie2\"), null);\n        assertEquals(action.getCookiesMap().get(\"cookie3\"), null);\n        assertEquals(action.getCookie1(), \"cookie1value\");\n        assertEquals(action.getCookie2(), null);\n        assertEquals(action.getCookie3(), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie1\"), \"cookie1value\");\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie2\"), null);\n        assertEquals(ActionContext.getContext().getValueStack().findValue(\"cookie3\"), null);\n    }\n\n    public void testCookiesWithClassPollution() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        String pollution1 = \"model['class']['classLoader']['jarPath']\";\n        String pollution2 = \"model.class.classLoader.jarPath\";\n        String pollution3 = \"class.classLoader.jarPath\";\n        String pollution4 = \"class['classLoader']['jarPath']\";\n        String pollution5 = \"model[\\\"class\\\"]['classLoader']['jarPath']\";\n        String pollution6 = \"class[\\\"classLoader\\\"]['jarPath']\";\n\n        request.setCookies(\n                new Cookie(pollution1, \"pollution1\"),\n                new Cookie(\"pollution1\", pollution1),\n                new Cookie(pollution2, \"pollution2\"),\n                new Cookie(\"pollution2\", pollution2),\n                new Cookie(pollution3, \"pollution3\"),\n                new Cookie(\"pollution3\", pollution3),\n                new Cookie(pollution4, \"pollution4\"),\n                new Cookie(\"pollution4\", pollution4),\n                new Cookie(pollution5, \"pollution5\"),\n                new Cookie(\"pollution5\", pollution5),\n                new Cookie(pollution6, \"pollution6\"),\n                new Cookie(\"pollution6\", pollution6)\n            );\n        ServletActionContext.setRequest(request);\n\n        final Map<String, Boolean> excludedName = new HashMap<String, Boolean>();\n        final Map<String, Boolean> excludedValue = new HashMap<String, Boolean>();\n\n        CookieInterceptor interceptor = new CookieInterceptor() {\n            @Override\n            protected boolean isAcceptableName(String name) {\n                boolean accepted = super.isAcceptableName(name);\n                excludedName.put(name, accepted);\n                return accepted;\n            }\n\n            @Override\n            protected boolean isAcceptableValue(String value) {\n                boolean accepted = super.isAcceptableValue(value);\n                excludedValue.put(value, accepted);\n                return accepted;\n            }\n        };\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"*\");\n\n        MockActionInvocation invocation = new MockActionInvocation();\n        invocation.setAction(new MockActionWithCookieAware());\n\n        interceptor.intercept(invocation);\n\n        assertFalse(excludedName.get(pollution1));\n        assertFalse(excludedName.get(pollution2));\n        assertFalse(excludedName.get(pollution3));\n        assertFalse(excludedName.get(pollution4));\n        assertFalse(excludedName.get(pollution5));\n        assertFalse(excludedName.get(pollution6));\n\n        assertFalse(excludedValue.get(pollution1));\n        assertFalse(excludedValue.get(pollution2));\n        assertFalse(excludedValue.get(pollution3));\n        assertFalse(excludedValue.get(pollution4));\n        assertFalse(excludedValue.get(pollution5));\n        assertFalse(excludedValue.get(pollution6));\n    }\n\n    public void testCookiesWithStrutsInternalsAccess() throws Exception {\n        MockHttpServletRequest request = new MockHttpServletRequest();\n        String sessionCookieName = \"session.userId\";\n        String sessionCookieValue = \"session.userId=1\";\n        String appCookieName = \"application.userId\";\n        String appCookieValue = \"application.userId=1\";\n        String reqCookieName = \"request.userId\";\n        String reqCookieValue = \"request.userId=1\";\n\n        request.setCookies(\n                new Cookie(sessionCookieName, \"1\"),\n                new Cookie(\"1\", sessionCookieValue),\n                new Cookie(appCookieName, \"1\"),\n                new Cookie(\"1\", appCookieValue),\n                new Cookie(reqCookieName, \"1\"),\n                new Cookie(\"1\", reqCookieValue)\n            );\n        ServletActionContext.setRequest(request);\n\n        final Map<String, Boolean> excludedName = new HashMap<String, Boolean>();\n        final Map<String, Boolean> excludedValue = new HashMap<String, Boolean>();\n\n        CookieInterceptor interceptor = new CookieInterceptor() {\n            @Override\n            protected boolean isAcceptableName(String name) {\n                boolean accepted = super.isAcceptableName(name);\n                excludedName.put(name, accepted);\n                return accepted;\n            }\n\n            @Override\n            protected boolean isAcceptableValue(String value) {\n                boolean accepted = super.isAcceptableValue(value);\n                excludedValue.put(value, accepted);\n                return accepted;\n            }\n        };\n        interceptor.setExcludedPatternsChecker(new DefaultExcludedPatternsChecker());\n        interceptor.setCookiesName(\"*\");\n\n        MockActionInvocation invocation = new MockActionInvocation();\n        invocation.setAction(new MockActionWithCookieAware());\n\n        interceptor.intercept(invocation);\n\n        assertFalse(excludedName.get(sessionCookieName));\n        assertFalse(excludedName.get(appCookieName));\n        assertFalse(excludedName.get(reqCookieName));\n\n        assertFalse(excludedValue.get(sessionCookieValue));\n        assertFalse(excludedValue.get(appCookieValue));\n        assertFalse(excludedValue.get(reqCookieValue));\n    }\n\n    public static class MockActionWithCookieAware extends ActionSupport implements CookiesAware {\n\n        private static final long serialVersionUID = -6202290616812813386L;\n\n        private Map cookies = Collections.EMPTY_MAP;\n        private String cookie1;\n        private String cookie2;\n        private String cookie3;\n\n        public void setCookiesMap(Map<String, String> cookies) {\n            this.cookies = cookies;\n        }\n\n        public Map getCookiesMap() {\n            return this.cookies;\n        }\n\n        public String getCookie1() { return cookie1; }\n        public void setCookie1(String cookie1) { this.cookie1 = cookie1; }\n\n        public String getCookie2() { return cookie2; }\n        public void setCookie2(String cookie2) { this.cookie2 = cookie2; }\n\n        public String getCookie3() { return cookie3; }\n        public void setCookie3(String cookie3) { this.cookie3 = cookie3; }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 29,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/d832747d647df343ed07a58b1b5e540a05a4d51b",
    "cve_id": "CVE-2015-1831",
    "cwe_id": "Not Mapping",
    "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/security/DefaultExcludedPatternsChecker.java",
    "code": "package com.opensymphony.xwork2.security;\n\nimport com.opensymphony.xwork2.*;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.regex.Pattern;\n\npublic class DefaultExcludedPatternsChecker implements ExcludedPatternsChecker {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DefaultExcludedPatternsChecker.class);\n\n    public static final String[] EXCLUDED_PATTERNS = {\n            \"(.*\\\\.|^|.*|\\\\[('|\\\"))\\\\bclass(\\\\.|('|\\\")]|\\\\[).*\",\n            \"(^|.*#)dojo(\\\\.|\\\\[).*\",\n            \"(^|.*#)struts(\\\\.|\\\\[).*\",\n            \"(^|.*#)session(\\\\.|\\\\[).*\",\n            \"(^|.*#)request(\\\\.|\\\\[).*\",\n            \"(^|.*#)application(\\\\.|\\\\[).*\",\n            \"(^|.*#)servlet(Request|Response)(\\\\.|\\\\[).*\",\n            \"(^|.*#)parameters(\\\\.|\\\\[).*\",\n            \"(^|.*#)context(\\\\.|\\\\[).*\",\n            \"(^|.*#)_memberAccess(\\\\.|\\\\[).*\"\n    };\n\n    private Set<Pattern> excludedPatterns;\n\n    public DefaultExcludedPatternsChecker() {\n        setExcludedPatterns(EXCLUDED_PATTERNS);\n    }\n\n    @Inject(value = XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, required = false)\n    public void setOverrideExcludePatterns(String excludePatterns) {\n        if (LOG.isWarnEnabled()) {\n            LOG.warn(\"Overriding excluded patterns [#0] with [#1], be aware that this affects all instances and safety of your application!\",\n                    XWorkConstants.OVERRIDE_EXCLUDED_PATTERNS, excludePatterns);\n        }\n        excludedPatterns = new HashSet<Pattern>();\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    @Inject(value = XWorkConstants.ADDITIONAL_EXCLUDED_PATTERNS, required = false)\n    public void setAdditionalExcludePatterns(String excludePatterns) {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Adding additional global patterns [#0] to excluded patterns!\", excludePatterns);\n        }\n        for (String pattern : TextParseUtil.commaDelimitedStringToSet(excludePatterns)) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public void setExcludedPatterns(String commaDelimitedPatterns) {\n        setExcludedPatterns(TextParseUtil.commaDelimitedStringToSet(commaDelimitedPatterns));\n    }\n\n    public void setExcludedPatterns(String[] patterns) {\n        setExcludedPatterns(new HashSet<String>(Arrays.asList(patterns)));\n    }\n\n    public void setExcludedPatterns(Set<String> patterns) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Sets excluded patterns [#0]\", patterns);\n        }\n        excludedPatterns = new HashSet<Pattern>(patterns.size());\n        for (String pattern : patterns) {\n            excludedPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));\n        }\n    }\n\n    public IsExcluded isExcluded(String value) {\n        for (Pattern excludedPattern : excludedPatterns) {\n            if (excludedPattern.matcher(value).matches()) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"[#0] matches excluded pattern [#1]\", value, excludedPattern);\n                }\n                return IsExcluded.yes(excludedPattern);\n            }\n        }\n        return IsExcluded.no(excludedPatterns);\n    }\n\n    public Set<Pattern> getExcludedPatterns() {\n        return excludedPatterns;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 29,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/d832747d647df343ed07a58b1b5e540a05a4d51b",
    "cve_id": "CVE-2015-1831",
    "cwe_id": "Not Mapping",
    "filename": "xwork-core/src/test/java/com/opensymphony/xwork2/security/DefaultExcludedPatternsCheckerTest.java",
    "code": "package com.opensymphony.xwork2.security;\n\nimport com.opensymphony.xwork2.XWorkTestCase;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DefaultExcludedPatternsCheckerTest extends XWorkTestCase {\n\n    public void testHardcodedPatterns() throws Exception {\n        \n        List<String> params = new ArrayList<String>() {\n            {\n                add(\"%{#application['test']}\");\n                add(\"%{#application.test}\");\n                add(\"%{#Application['test']}\");\n                add(\"%{#Application.test}\");\n                add(\"%{#session['test']}\");\n                add(\"%{#session.test}\");\n                add(\"%{#Session['test']}\");\n                add(\"%{#Session.test}\");\n                add(\"%{#struts['test']}\");\n                add(\"%{#struts.test}\");\n                add(\"%{#Struts['test']}\");\n                add(\"%{#Struts.test}\");\n                add(\"%{#request['test']}\");\n                add(\"%{#request.test}\");\n                add(\"%{#Request['test']}\");\n                add(\"%{#Request.test}\");\n                add(\"%{#servletRequest['test']}\");\n                add(\"%{#servletRequest.test}\");\n                add(\"%{#ServletRequest['test']}\");\n                add(\"%{#ServletRequest.test}\");\n                add(\"%{#servletResponse['test']}\");\n                add(\"%{#servletResponse.test}\");\n                add(\"%{#ServletResponse['test']}\");\n                add(\"%{#ServletResponse.test}\");\n                add(\"%{#parameters['test']}\");\n                add(\"%{#parameters.test}\");\n                add(\"%{#Parameters['test']}\");\n                add(\"%{#Parameters.test}\");\n                add(\"#context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse')\");\n                add(\"%{#context.get('com.opensymphony.xwork2.dispatcher.HttpServletResponse')}\");\n                add(\"#_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true)\");\n                add(\"%{#_memberAccess[\\\"allowStaticMethodAccess\\\"]= new java.lang.Boolean(true)}\");\n                add(\"form.class.classLoader\");\n                add(\"form[\\\"class\\\"][\\\"classLoader\\\"]\");\n                add(\"form['class']['classLoader']\");\n                add(\"class['classLoader']\");\n                add(\"class[\\\"classLoader\\\"]\");\n                add(\"class.classLoader.resources.dirContext.docBase=tttt\");\n                add(\"Class.classLoader.resources.dirContext.docBase=tttt\");\n            }\n        };\n\n        ExcludedPatternsChecker checker = new DefaultExcludedPatternsChecker();\n\n        for (String param : params) {\n            \n            ExcludedPatternsChecker.IsExcluded actual = checker.isExcluded(param);\n\n            \n            assertTrue(\"Access to \" + param + \" is possible!\", actual.isExcluded());\n        }\n    }\n\n    public void testParamWithClassInName() throws Exception {\n        \n        List<String> properParams = new ArrayList<String>();\n        properParams.add(\"eventClass\");\n        properParams.add(\"form.eventClass\");\n        properParams.add(\"form[\\\"eventClass\\\"]\");\n        properParams.add(\"form['eventClass']\");\n\n        ExcludedPatternsChecker checker = new DefaultExcludedPatternsChecker();\n\n        for (String properParam : properParams) {\n            \n            ExcludedPatternsChecker.IsExcluded actual = checker.isExcluded(properParam);\n\n            \n            assertFalse(\"Param '\" + properParam + \"' is excluded!\", actual.isExcluded());\n        }\n    }\n\n    public void testStrutsTokenIsExcluded() throws Exception {\n        \n        List<String> tokens = new ArrayList<String>();\n        tokens.add(\"struts.token.name\");\n        tokens.add(\"struts.token\");\n\n        ExcludedPatternsChecker checker = new DefaultExcludedPatternsChecker();\n\n        for (String token : tokens) {\n            \n            ExcludedPatternsChecker.IsExcluded actual = checker.isExcluded(token);\n\n            \n            assertTrue(\"Param '\" + token + \"' is not excluded!\", actual.isExcluded());\n        }\n    }\n\n}",
    "is_vulnerable": 1
  },
  {
    "id": 30,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/f238cf4f1091be19fbcfd086b042c86a1bcaa7fc",
    "cve_id": "CVE-2016-3081",
    "cwe_id": "CWE-77",
    "filename": "core/src/main/java/com/opensymphony/xwork2/ognl/OgnlUtil.java",
    "code": "\npackage com.opensymphony.xwork2.ognl;\n\nimport com.opensymphony.xwork2.XWorkConstants;\nimport com.opensymphony.xwork2.config.ConfigurationException;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.inject.Container;\nimport com.opensymphony.xwork2.inject.Inject;\nimport com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;\nimport com.opensymphony.xwork2.util.CompoundRoot;\nimport com.opensymphony.xwork2.util.TextParseUtil;\nimport com.opensymphony.xwork2.util.reflection.ReflectionException;\nimport ognl.*;\nimport org.apache.commons.lang3.BooleanUtils;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.beans.BeanInfo;\nimport java.beans.IntrospectionException;\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.regex.Pattern;\n\n\n\npublic class OgnlUtil {\n\n    private static final Logger LOG = LogManager.getLogger(OgnlUtil.class);\n    private ConcurrentMap<String, Object> expressions = new ConcurrentHashMap<>();\n    private final ConcurrentMap<Class, BeanInfo> beanInfoCache = new ConcurrentHashMap<>();\n    private TypeConverter defaultConverter;\n\n    private boolean devMode = false;\n    private boolean enableExpressionCache = true;\n    private boolean enableEvalExpression;\n\n    private Set<Class<?>> excludedClasses = new HashSet<>();\n    private Set<Pattern> excludedPackageNamePatterns = new HashSet<>();\n    private Set<String> excludedPackageNames = new HashSet<>();\n\n    private Container container;\n    private boolean allowStaticMethodAccess;\n\n    @Inject\n    public void setXWorkConverter(XWorkConverter conv) {\n        this.defaultConverter = new OgnlTypeConverterWrapper(conv);\n    }\n\n    @Inject(XWorkConstants.DEV_MODE)\n    public void setDevMode(String mode) {\n        this.devMode = BooleanUtils.toBoolean(mode);\n    }\n\n    @Inject(XWorkConstants.ENABLE_OGNL_EXPRESSION_CACHE)\n    public void setEnableExpressionCache(String cache) {\n        enableExpressionCache = BooleanUtils.toBoolean(cache);\n    }\n\n    @Inject(value = XWorkConstants.ENABLE_OGNL_EVAL_EXPRESSION, required = false)\n    public void setEnableEvalExpression(String evalExpression) {\n        enableEvalExpression = \"true\".equals(evalExpression);\n        if(enableEvalExpression){\n            LOG.warn(\"Enabling OGNL expression evaluation may introduce security risks \" +\n                    \"(see http://struts.apache.org/release/2.3.x/docs/s2-013.html for further details)\");\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_CLASSES, required = false)\n    public void setExcludedClasses(String commaDelimitedClasses) {\n        Set<String> classes = TextParseUtil.commaDelimitedStringToSet(commaDelimitedClasses);\n        for (String className : classes) {\n            try {\n                excludedClasses.add(Class.forName(className));\n            } catch (ClassNotFoundException e) {\n                throw new ConfigurationException(\"Cannot load excluded class: \" + className, e);\n            }\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAME_PATTERNS, required = false)\n    public void setExcludedPackageNamePatterns(String commaDelimitedPackagePatterns) {\n        Set<String> packagePatterns = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackagePatterns);\n        for (String pattern : packagePatterns) {\n            excludedPackageNamePatterns.add(Pattern.compile(pattern));\n        }\n    }\n\n    @Inject(value = XWorkConstants.OGNL_EXCLUDED_PACKAGE_NAMES, required = false)\n    public void setExcludedPackageNames(String commaDelimitedPackageNames) {\n        excludedPackageNames = TextParseUtil.commaDelimitedStringToSet(commaDelimitedPackageNames);\n    }\n\n    public Set<Class<?>> getExcludedClasses() {\n        return excludedClasses;\n    }\n\n    public Set<Pattern> getExcludedPackageNamePatterns() {\n        return excludedPackageNamePatterns;\n    }\n\n    public Set<String> getExcludedPackageNames() {\n        return excludedPackageNames;\n    }\n\n    @Inject\n    public void setContainer(Container container) {\n        this.container = container;\n    }\n\n    @Inject(value = XWorkConstants.ALLOW_STATIC_METHOD_ACCESS, required = false)\n    public void setAllowStaticMethodAccess(String allowStaticMethodAccess) {\n        this.allowStaticMethodAccess = Boolean.parseBoolean(allowStaticMethodAccess);\n    }\n\n    \n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context) {\n        setProperties(props, o, context, false);\n    }\n\n    \n    public void setProperties(Map<String, ?> props, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        if (props == null) {\n            return;\n        }\n\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        for (Map.Entry<String, ?> entry : props.entrySet()) {\n            String expression = entry.getKey();\n            internalSetProperty(expression, entry.getValue(), o, context, throwPropertyExceptions);\n        }\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    \n    public void setProperties(Map<String, ?> properties, Object o) {\n        setProperties(properties, o, false);\n    }\n\n    \n    public void setProperties(Map<String, ?> properties, Object o, boolean throwPropertyExceptions) {\n        Map context = createDefaultContext(o, null);\n        setProperties(properties, o, context, throwPropertyExceptions);\n    }\n\n    \n    public void setProperty(String name, Object value, Object o, Map<String, Object> context) {\n        setProperty(name, value, o, context, false);\n    }\n\n    \n    public void setProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) {\n        Ognl.setTypeConverter(context, getTypeConverterFromContext(context));\n\n        Object oldRoot = Ognl.getRoot(context);\n        Ognl.setRoot(context, o);\n\n        internalSetProperty(name, value, o, context, throwPropertyExceptions);\n\n        Ognl.setRoot(context, oldRoot);\n    }\n\n    \n    public Object getRealTarget(String property, Map<String, Object> context, Object root) throws OgnlException {\n        \n        if (\"top\".equals(property)) {\n            return root;\n        }\n\n        if (root instanceof CompoundRoot) {\n            \n            CompoundRoot cr = (CompoundRoot) root;\n\n            try {\n                for (Object target : cr) {\n                    if (OgnlRuntime.hasSetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.hasGetProperty((OgnlContext) context, target, property)\n                            || OgnlRuntime.getIndexedPropertyType((OgnlContext) context, target.getClass(), property) != OgnlRuntime.INDEXED_PROPERTY_NONE\n                            ) {\n                        return target;\n                    }\n                }\n            } catch (IntrospectionException ex) {\n                throw new ReflectionException(\"Cannot figure out real target class\", ex);\n            }\n\n            return null;\n        }\n\n        return root;\n    }\n\n    \n    public void setValue(final String name, final Map<String, Object> context, final Object root, final Object value) throws OgnlException {\n        compileAndExecute(name, context, new OgnlTask<Void>() {\n            public Void execute(Object tree) throws OgnlException {\n                if (isEvalExpression(tree, context)) {\n                    throw new OgnlException(\"Eval expression cannot be used as parameter name\");\n                }\n                Ognl.setValue(tree, context, root, value);\n                return null;\n            }\n        });\n    }\n\n    private boolean isEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (tree instanceof SimpleNode) {\n            SimpleNode node = (SimpleNode) tree;\n            OgnlContext ognlContext = null;\n\n            if (context!=null && context instanceof OgnlContext) {\n                ognlContext = (OgnlContext) context;\n            }\n            return node.isEvalChain(ognlContext);\n        }\n        return false;\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root);\n            }\n        });\n    }\n\n    public Object getValue(final String name, final Map<String, Object> context, final Object root, final Class resultType) throws OgnlException {\n        return compileAndExecute(name, context, new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return Ognl.getValue(tree, context, root, resultType);\n            }\n        });\n    }\n\n\n    public Object compile(String expression) throws OgnlException {\n        return compile(expression, null);\n    }\n\n    private <T> Object compileAndExecute(String expression, Map<String, Object> context, OgnlTask<T> task) throws OgnlException {\n        Object tree;\n        if (enableExpressionCache) {\n            tree = expressions.get(expression);\n            if (tree == null) {\n                tree = Ognl.parseExpression(expression);\n                checkEnableEvalExpression(tree, context);\n            }\n        } else {\n            tree = Ognl.parseExpression(expression);\n            checkEnableEvalExpression(tree, context);\n        }\n\n        final T exec = task.execute(tree);\n        \n        if(enableExpressionCache) {\n            expressions.putIfAbsent(expression, tree);\n        }\n        return exec;\n    }\n\n    public Object compile(String expression, Map<String, Object> context) throws OgnlException {\n        return compileAndExecute(expression,context,new OgnlTask<Object>() {\n            public Object execute(Object tree) throws OgnlException {\n                return tree;\n            }\n        });\n    }\n    \n    private void checkEnableEvalExpression(Object tree, Map<String, Object> context) throws OgnlException {\n        if (!enableEvalExpression && isEvalExpression(tree, context)) {\n            throw new OgnlException(\"Eval expressions has been disabled!\");\n        }\n    }\n\n    \n    public void copy(final Object from, final Object to, final Map<String, Object> context, Collection<String> exclusions, Collection<String> inclusions) {\n        if (from == null || to == null) {\n            LOG.warn(\"Attempting to copy from or to a null source. This is illegal and is bein skipped. This may be due to an error in an OGNL expression, action chaining, or some other event.\");\n            return;\n        }\n\n        TypeConverter converter = getTypeConverterFromContext(context);\n        final Map contextFrom = createDefaultContext(from, null);\n        Ognl.setTypeConverter(contextFrom, converter);\n        final Map contextTo = createDefaultContext(to, null);\n        Ognl.setTypeConverter(contextTo, converter);\n\n        PropertyDescriptor[] fromPds;\n        PropertyDescriptor[] toPds;\n\n        try {\n            fromPds = getPropertyDescriptors(from);\n            toPds = getPropertyDescriptors(to);\n        } catch (IntrospectionException e) {\n            LOG.error(\"An error occurred\", e);\n            return;\n        }\n\n        Map<String, PropertyDescriptor> toPdHash = new HashMap<>();\n\n        for (PropertyDescriptor toPd : toPds) {\n            toPdHash.put(toPd.getName(), toPd);\n        }\n\n        for (PropertyDescriptor fromPd : fromPds) {\n            if (fromPd.getReadMethod() != null) {\n                boolean copy = true;\n                if (exclusions != null && exclusions.contains(fromPd.getName())) {\n                    copy = false;\n                } else if (inclusions != null && !inclusions.contains(fromPd.getName())) {\n                    copy = false;\n                }\n\n                if (copy) {\n                    PropertyDescriptor toPd = toPdHash.get(fromPd.getName());\n                    if ((toPd != null) && (toPd.getWriteMethod() != null)) {\n                        try {\n                            compileAndExecute(fromPd.getName(), context, new OgnlTask<Object>() {\n                                public Void execute(Object expr) throws OgnlException {\n                                    Object value = Ognl.getValue(expr, contextFrom, from);\n                                    Ognl.setValue(expr, contextTo, to, value);\n                                    return null;\n                                }\n                            });\n\n                        } catch (OgnlException e) {\n                            LOG.debug(\"Got OGNL exception\", e);\n                        }\n                    }\n\n                }\n\n            }\n\n        }\n    }\n\n\n    \n    public void copy(Object from, Object to, Map<String, Object> context) {\n        copy(from, to, context, null, null);\n    }\n\n    \n    public PropertyDescriptor[] getPropertyDescriptors(Object source) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(source);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n\n    \n    public PropertyDescriptor[] getPropertyDescriptors(Class clazz) throws IntrospectionException {\n        BeanInfo beanInfo = getBeanInfo(clazz);\n        return beanInfo.getPropertyDescriptors();\n    }\n\n    \n    public Map<String, Object> getBeanMap(final Object source) throws IntrospectionException, OgnlException {\n        Map<String, Object> beanMap = new HashMap<>();\n        final Map sourceMap = createDefaultContext(source, null);\n        PropertyDescriptor[] propertyDescriptors = getPropertyDescriptors(source);\n        for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n            final String propertyName = propertyDescriptor.getDisplayName();\n            Method readMethod = propertyDescriptor.getReadMethod();\n            if (readMethod != null) {\n                final Object value = compileAndExecute(propertyName, null, new OgnlTask<Object>() {\n                    public Object execute(Object expr) throws OgnlException {\n                        return Ognl.getValue(expr, sourceMap, source);\n                    }\n                });\n                beanMap.put(propertyName, value);\n            } else {\n                beanMap.put(propertyName, \"There is no read method for \" + propertyName);\n            }\n        }\n        return beanMap;\n    }\n\n    \n    public BeanInfo getBeanInfo(Object from) throws IntrospectionException {\n        return getBeanInfo(from.getClass());\n    }\n\n\n    \n    public BeanInfo getBeanInfo(Class clazz) throws IntrospectionException {\n        synchronized (beanInfoCache) {\n            BeanInfo beanInfo;\n            beanInfo = beanInfoCache.get(clazz);\n            if (beanInfo == null) {\n                beanInfo = Introspector.getBeanInfo(clazz, Object.class);\n                beanInfoCache.putIfAbsent(clazz, beanInfo);\n            }\n            return beanInfo;\n        }\n    }\n\n    void internalSetProperty(String name, Object value, Object o, Map<String, Object> context, boolean throwPropertyExceptions) throws ReflectionException{\n        try {\n            setValue(name, context, o, value);\n        } catch (OgnlException e) {\n            Throwable reason = e.getReason();\n            String msg = \"Caught OgnlException while setting property '\" + name + \"' on type '\" + o.getClass().getName() + \"'.\";\n            Throwable exception = (reason == null) ? e : reason;\n\n            if (throwPropertyExceptions) {\n                throw new ReflectionException(msg, exception);\n            } else if (devMode) {\n                LOG.warn(msg, exception);\n            }\n        }\n    }\n\n    TypeConverter getTypeConverterFromContext(Map<String, Object> context) {\n        \n        return defaultConverter;\n    }\n\n    protected Map createDefaultContext(Object root) {\n        return createDefaultContext(root, null);\n    }\n\n    protected Map createDefaultContext(Object root, ClassResolver classResolver) {\n        ClassResolver resolver = classResolver;\n        if (resolver == null) {\n            resolver = container.getInstance(CompoundRootAccessor.class);\n        }\n\n        SecurityMemberAccess memberAccess = new SecurityMemberAccess(allowStaticMethodAccess);\n        memberAccess.setExcludedClasses(excludedClasses);\n        memberAccess.setExcludedPackageNamePatterns(excludedPackageNamePatterns);\n        memberAccess.setExcludedPackageNames(excludedPackageNames);\n\n        return Ognl.createDefaultContext(root, resolver, defaultConverter, memberAccess);\n    }\n\n    private interface OgnlTask<T> {\n        T execute(Object tree) throws OgnlException;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 30,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/f238cf4f1091be19fbcfd086b042c86a1bcaa7fc",
    "cve_id": "CVE-2016-3081",
    "cwe_id": "CWE-77",
    "filename": "core/src/test/java/com/opensymphony/xwork2/ognl/OgnlUtilTest.java",
    "code": "\npackage com.opensymphony.xwork2.ognl;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.XWorkException;\nimport com.opensymphony.xwork2.XWorkTestCase;\nimport com.opensymphony.xwork2.conversion.impl.XWorkConverter;\nimport com.opensymphony.xwork2.interceptor.ChainingInterceptor;\nimport com.opensymphony.xwork2.test.User;\nimport com.opensymphony.xwork2.util.*;\nimport com.opensymphony.xwork2.util.reflection.ReflectionContextState;\nimport ognl.*;\n\nimport java.lang.reflect.Method;\nimport java.util.*;\n\npublic class OgnlUtilTest extends XWorkTestCase {\n    \n    private OgnlUtil ognlUtil;\n    \n    @Override\n    public void setUp() throws Exception {\n        super.setUp();\n        ognlUtil = container.getInstance(OgnlUtil.class);\n    }\n    \n    public void testCanSetADependentObject() throws Exception {\n        String dogName = \"fido\";\n\n        OgnlRuntime.setNullHandler(Owner.class, new NullHandler() {\n            public Object nullMethodResult(Map map, Object o, String s, Object[] objects) {\n                return null;\n            }\n\n            public Object nullPropertyValue(Map map, Object o, Object o1) {\n                String methodName = o1.toString();\n                String getter = \"set\" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);\n                Method[] methods = o.getClass().getDeclaredMethods();\n                System.out.println(getter);\n\n                for (Method method : methods) {\n                    String name = method.getName();\n\n                    if (!getter.equals(name) || (method.getParameterTypes().length != 1)) {\n                        continue;\n                    } else {\n                        Class clazz = method.getParameterTypes()[0];\n\n                        try {\n                            Object param = clazz.newInstance();\n                            method.invoke(o, new Object[]{param});\n\n                            return param;\n                        } catch (Exception e) {\n                            throw new RuntimeException(e);\n                        }\n                    }\n                }\n\n                return null;\n            }\n        });\n\n        Owner owner = new Owner();\n        Map context = ognlUtil.createDefaultContext(owner);\n        Map props = new HashMap();\n        props.put(\"dog.name\", dogName);\n\n        ognlUtil.setProperties(props, owner, context);\n        assertNotNull(\"expected Ognl to create an instance of Dog\", owner.getDog());\n        assertEquals(dogName, owner.getDog().getName());\n    }\n\n    public void testCacheEnabled() throws OgnlException {\n        ognlUtil.setEnableExpressionCache(\"true\");\n        Object expr0 = ognlUtil.compile(\"test\");\n        Object expr2 = ognlUtil.compile(\"test\");\n        assertSame(expr0, expr2);\n    }\n\n     public void testCacheDisabled() throws OgnlException {\n        ognlUtil.setEnableExpressionCache(\"false\");\n        Object expr0 = ognlUtil.compile(\"test\");\n        Object expr2 = ognlUtil.compile(\"test\");\n        assertNotSame(expr0, expr2);\n    }\n\n    public void testCanSetDependentObjectArray() {\n        EmailAction action = new EmailAction();\n        Map<String, Object> context = ognlUtil.createDefaultContext(action);\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"email[0].address\", \"addr1\");\n        props.put(\"email[1].address\", \"addr2\");\n        props.put(\"email[2].address\", \"addr3\");\n\n        ognlUtil.setProperties(props, action, context);\n        assertEquals(3, action.email.size());\n        assertEquals(\"addr1\", action.email.get(0).toString());\n        assertEquals(\"addr2\", action.email.get(1).toString());\n        assertEquals(\"addr3\", action.email.get(2).toString());\n    }\n\n    public void testCopySameType() {\n        Foo foo1 = new Foo();\n        Foo foo2 = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo1);\n\n        Calendar cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.FEBRUARY);\n        cal.set(Calendar.DAY_OF_MONTH, 12);\n        cal.set(Calendar.YEAR, 1982);\n\n        foo1.setTitle(\"blah\");\n        foo1.setNumber(1);\n        foo1.setPoints(new long[]{1, 2, 3});\n        foo1.setBirthday(cal.getTime());\n        foo1.setUseful(false);\n\n        ognlUtil.copy(foo1, foo2, context);\n\n        assertEquals(foo1.getTitle(), foo2.getTitle());\n        assertEquals(foo1.getNumber(), foo2.getNumber());\n        assertEquals(foo1.getPoints(), foo2.getPoints());\n        assertEquals(foo1.getBirthday(), foo2.getBirthday());\n        assertEquals(foo1.isUseful(), foo2.isUseful());\n    }\n\n\n    public void testIncudeExcludes() {\n\n        Foo foo1 = new Foo();\n        Foo foo2 = new Foo();\n\n        Calendar cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.FEBRUARY);\n        cal.set(Calendar.DAY_OF_MONTH, 12);\n        cal.set(Calendar.YEAR, 1982);\n\n        foo1.setPoints(new long[]{1, 2, 3});\n        foo1.setBirthday(cal.getTime());\n        foo1.setUseful(false);\n\n\n        foo1.setTitle(\"foo1 title\");\n        foo1.setNumber(1);\n\n        foo2.setTitle(\"foo2 title\");\n        foo2.setNumber(2);\n\n        Map<String, Object> context = ognlUtil.createDefaultContext(foo1);\n\n        List<String> excludes = new ArrayList<String>();\n        excludes.add(\"title\");\n        excludes.add(\"number\");\n\n        ognlUtil.copy(foo1, foo2, context, excludes, null);\n        \n        assertEquals(foo2.getTitle(), \"foo2 title\");\n        assertEquals(foo2.getNumber(), 2);\n\n        \n        assertEquals(foo1.getPoints(), foo2.getPoints());\n        assertEquals(foo1.getBirthday(), foo2.getBirthday());\n        assertEquals(foo1.isUseful(), foo2.isUseful());\n\n\n        Bar b1 = new Bar();\n        Bar b2 = new Bar();\n\n        b1.setTitle(\"bar1 title\");\n        b1.setSomethingElse(10);\n\n\n        b1.setId(new Long(1));\n\n        b2.setTitle(\"\");\n        b2.setId(new Long(2));\n\n        context = ognlUtil.createDefaultContext(b1);\n        List<String> includes = new ArrayList<String>();\n        includes.add(\"title\");\n        includes.add(\"somethingElse\");\n\n        ognlUtil.copy(b1, b2, context, null, includes);\n        \n        assertEquals(b1.getTitle(), b2.getTitle());\n        assertEquals(b1.getSomethingElse(), b2.getSomethingElse());\n\n        \n        assertEquals(b2.getId(), new Long(2));\n\n    }\n\n\n    public void testCopyUnevenObjects() {\n        Foo foo = new Foo();\n        Bar bar = new Bar();\n\n        Map<String, Object> context = ognlUtil.createDefaultContext(foo);\n\n        Calendar cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.FEBRUARY);\n        cal.set(Calendar.DAY_OF_MONTH, 12);\n        cal.set(Calendar.YEAR, 1982);\n\n        foo.setTitle(\"blah\");\n        foo.setNumber(1);\n        foo.setPoints(new long[]{1, 2, 3});\n        foo.setBirthday(cal.getTime());\n        foo.setUseful(false);\n\n        ognlUtil.copy(foo, bar, context);\n\n        assertEquals(foo.getTitle(), bar.getTitle());\n        assertEquals(0, bar.getSomethingElse());\n    }\n\n    public void testDeepSetting() {\n        Foo foo = new Foo();\n        foo.setBar(new Bar());\n\n        Map<String, Object> context = ognlUtil.createDefaultContext(foo);\n\n        Map<String, Object> props = new HashMap();\n        props.put(\"bar.title\", \"i am barbaz\");\n        ognlUtil.setProperties(props, foo, context);\n\n        assertEquals(foo.getBar().getTitle(), \"i am barbaz\");\n    }\n\n    public void testNoExceptionForUnmatchedGetterAndSetterWithThrowPropertyException() {\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"myIntegerProperty\", new Integer(1234));\n\n        TestObject testObject = new TestObject();\n\n        \n        ognlUtil.setProperties(props, testObject, true);\n        assertEquals(1234, props.get(\"myIntegerProperty\"));\n    }\n\n    public void testExceptionForWrongPropertyNameWithThrowPropertyException() {\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"myStringProperty\", \"testString\");\n\n        TestObject testObject = new TestObject();\n\n        try {\n            ognlUtil.setProperties(props, testObject, true);\n            fail(\"Should rise NoSuchPropertyException because of wrong property name\");\n        } catch (Exception e) {\n            \n        }\n    }\n\n    public void testOgnlHandlesCrapAtTheEndOfANumber() {\n        Foo foo = new Foo();\n        Map<String, Object> context = ognlUtil.createDefaultContext(foo);\n\n        Map<String, Object> props = new HashMap<String, Object>();\n        props.put(\"aLong\", \"123a\");\n\n        ognlUtil.setProperties(props, foo, context);\n        assertEquals(0, foo.getALong());\n    }\n\n    \n    public void testSetIndexedValue() {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        Map<String, Object> stackContext = stack.getContext();\n        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.TRUE);\n        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);\n        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);\n\n        User user = new User();\n        stack.push(user);\n\n        \n        user.setList(new ArrayList<String>());\n        user.getList().add(\"\");\n\n        String[] foo = new String[]{\"asdf\"};\n        stack.setValue(\"list[0]\", foo);\n        assertNotNull(user.getList());\n        assertEquals(1, user.getList().size());\n        assertEquals(String.class, user.getList().get(0).getClass());\n        assertEquals(\"asdf\", user.getList().get(0));\n    }\n\n    public void testSetPropertiesBoolean() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"useful\", \"true\");\n        ognlUtil.setProperties(props, foo, context);\n\n        assertEquals(true, foo.isUseful());\n\n        props = new HashMap();\n        props.put(\"useful\", \"false\");\n        ognlUtil.setProperties(props, foo, context);\n\n        assertEquals(false, foo.isUseful());\n    }\n\n    public void testSetPropertiesDate() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"birthday\", \"02/12/1982\");\n        \n        ognlUtil.setProperties(props, foo, context);\n\n        Calendar cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.FEBRUARY);\n        cal.set(Calendar.DAY_OF_MONTH, 12);\n        cal.set(Calendar.YEAR, 1982);\n\n        assertEquals(cal.getTime(), foo.getBirthday());\n        \n        \n        props.put(\"event\", \"18/10/2006 14:23:45\");\n        props.put(\"meeting\", \"09/09/2006 14:30\");\n        context.put(ActionContext.LOCALE, Locale.UK);\n\n        ognlUtil.setProperties(props, foo, context);\n        \n        cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.OCTOBER);\n        cal.set(Calendar.DAY_OF_MONTH, 18);\n        cal.set(Calendar.YEAR, 2006);\n        cal.set(Calendar.HOUR_OF_DAY, 14);\n        cal.set(Calendar.MINUTE, 23);\n        cal.set(Calendar.SECOND, 45);\n        \n        assertEquals(cal.getTime(), foo.getEvent());\n        \n        cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.SEPTEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 9);\n        cal.set(Calendar.YEAR, 2006);\n        cal.set(Calendar.HOUR_OF_DAY, 14);\n        cal.set(Calendar.MINUTE, 30);\n        \n        assertEquals(cal.getTime(), foo.getMeeting());\n        \n        \n        props.put(\"event\", \"1996-12-19T16:39:57Z\");\n        ognlUtil.setProperties(props, foo, context);\n        \n        cal = Calendar.getInstance();\n        cal.clear();\n        cal.set(Calendar.MONTH, Calendar.DECEMBER);\n        cal.set(Calendar.DAY_OF_MONTH, 19);\n        cal.set(Calendar.YEAR, 1996);\n        cal.set(Calendar.HOUR_OF_DAY, 16);\n        cal.set(Calendar.MINUTE, 39);\n        cal.set(Calendar.SECOND, 57);\n        \n        assertEquals(cal.getTime(), foo.getEvent());\n        \n        \n        props.put(\"calendar\", \"1996-12-19T16:39:57Z\");\n        ognlUtil.setProperties(props, foo, context);\n        assertEquals(cal, foo.getCalendar());\n    }\n\n    public void testSetPropertiesInt() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"number\", \"2\");\n        ognlUtil.setProperties(props, foo, context);\n\n        assertEquals(2, foo.getNumber());\n    }\n\n    public void testSetPropertiesLongArray() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"points\", new String[]{\"1\", \"2\"});\n        ognlUtil.setProperties(props, foo, context);\n\n        assertNotNull(foo.getPoints());\n        assertEquals(2, foo.getPoints().length);\n        assertEquals(1, foo.getPoints()[0]);\n        assertEquals(2, foo.getPoints()[1]);\n    }\n\n    public void testSetPropertiesString() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"title\", \"this is a title\");\n        ognlUtil.setProperties(props, foo, context);\n\n        assertEquals(foo.getTitle(), \"this is a title\");\n    }\n\n    public void testSetProperty() {\n        Foo foo = new Foo();\n        Map context = ognlUtil.createDefaultContext(foo);\n        assertFalse(123456 == foo.getNumber());\n        ognlUtil.setProperty(\"number\", \"123456\", foo, context);\n        assertEquals(123456, foo.getNumber());\n    }\n\n\n    public void testSetList() throws Exception {\n        ChainingInterceptor foo = new ChainingInterceptor();\n        ChainingInterceptor foo2 = new ChainingInterceptor();\n\n        OgnlContext context = (OgnlContext) ognlUtil.createDefaultContext(null);\n        SimpleNode expression = (SimpleNode) Ognl.parseExpression(\"{'a','ruby','b','tom'}\");\n\n\n        Ognl.getValue(expression, context, \"aksdj\");\n\n        final ValueStack stack = ActionContext.getContext().getValueStack();\n\n        Object result = Ognl.getValue(ognlUtil.compile(\"{\\\"foo\\\",'ruby','b','tom'}\"), context, foo);\n        foo.setIncludes((Collection) result);\n\n        assertEquals(4, foo.getIncludes().size());\n        assertEquals(\"foo\", foo.getIncludes().toArray()[0]);\n        assertEquals(\"ruby\", foo.getIncludes().toArray()[1]);\n        assertEquals(\"b\", \"\" + foo.getIncludes().toArray()[2]);\n        assertEquals(\"tom\", foo.getIncludes().toArray()[3]);\n\n        Object result2 = Ognl.getValue(ognlUtil.compile(\"{\\\"foo\\\",'ruby','b','tom'}\"), context, foo2);\n        ognlUtil.setProperty(\"includes\", result2, foo2, context);\n\n        assertEquals(4, foo.getIncludes().size());\n        assertEquals(\"foo\", foo.getIncludes().toArray()[0]);\n        assertEquals(\"ruby\", foo.getIncludes().toArray()[1]);\n        assertEquals(\"b\", \"\" + foo.getIncludes().toArray()[2]);\n        assertEquals(\"tom\", foo.getIncludes().toArray()[3]);\n\n        result = ActionContext.getContext().getValueStack().findValue(\"{\\\"foo\\\",'ruby','b','tom'}\");\n\n        foo.setIncludes((Collection) result);\n        assertEquals(ArrayList.class, result.getClass());\n\n        assertEquals(4, foo.getIncludes().size());\n        assertEquals(\"foo\", foo.getIncludes().toArray()[0]);\n        assertEquals(\"ruby\", foo.getIncludes().toArray()[1]);\n        assertEquals(\"b\", \"\" + foo.getIncludes().toArray()[2]);\n        assertEquals(\"tom\", foo.getIncludes().toArray()[3]);\n    }\n\n\n    public void testStringToLong() {\n        Foo foo = new Foo();\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        Map props = new HashMap();\n        props.put(\"ALong\", \"123\");\n\n        ognlUtil.setProperties(props, foo, context);\n        assertEquals(123, foo.getALong());\n\n        props.put(\"ALong\", new String[]{\"123\"});\n\n        foo.setALong(0);\n        ognlUtil.setProperties(props, foo, context);\n        assertEquals(123, foo.getALong());\n    }\n\n    public void testNullProperties() {\n        Foo foo = new Foo();\n        foo.setALong(88);\n\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        ognlUtil.setProperties(null, foo, context);\n        assertEquals(88, foo.getALong());\n\n        Map props = new HashMap();\n        props.put(\"ALong\", \"99\");\n        ognlUtil.setProperties(props, foo, context);\n        assertEquals(99, foo.getALong());\n    }\n    \n    public void testCopyNull() {\n        Foo foo = new Foo();\n        Map context = ognlUtil.createDefaultContext(foo);\n   \t\tognlUtil.copy(null, null, context);\n\n   \t\tognlUtil.copy(foo, null, context);\n   \t\tognlUtil.copy(null, foo, context);\n    }\n    \n    public void testGetTopTarget() throws Exception {\n        Foo foo = new Foo();\n        Map context = ognlUtil.createDefaultContext(foo);\n\n        CompoundRoot root = new CompoundRoot();\n        Object top = ognlUtil.getRealTarget(\"top\", context, root);\n        assertEquals(root, top); \n        \n        root.push(foo);\n        Object val = ognlUtil.getRealTarget(\"unknown\", context, root);\n        assertNull(val); \n    }\n    \n    public void testGetBeanMap() throws Exception {\n    \tBar bar = new Bar();\n    \tbar.setTitle(\"I have beer\");\n        \n    \tFoo foo = new Foo();\n        foo.setALong(123);\n        foo.setNumber(44);\n        foo.setBar(bar);\n        foo.setTitle(\"Hello Santa\");\n        foo.setUseful(true);\n        \n        \n        Map beans = ognlUtil.getBeanMap(foo);\n        assertNotNull(beans);\n        assertEquals(19, beans.size());\n        assertEquals(\"Hello Santa\", beans.get(\"title\"));\n        assertEquals(new Long(\"123\"), beans.get(\"ALong\"));\n        assertEquals(new Integer(\"44\"), beans.get(\"number\"));\n        assertEquals(bar, beans.get(\"bar\"));\n        assertEquals(Boolean.TRUE, beans.get(\"useful\"));\n    }\n\n    public void testGetBeanMapNoReadMethod() throws Exception {\n    \tMyWriteBar bar = new MyWriteBar();\n    \tbar.setBar(\"Sams\");\n    \t\n    \tMap beans = ognlUtil.getBeanMap(bar);\n    \tassertEquals(2, beans.size());\n    \tassertEquals(new Integer(\"1\"), beans.get(\"id\"));\n    \tassertEquals(\"There is no read method for bar\", beans.get(\"bar\"));\n    }\n\n    \n    public void testSetBigIndexedValue() {\n        ValueStack stack = ActionContext.getContext().getValueStack();\n        Map stackContext = stack.getContext();\n        stackContext.put(ReflectionContextState.CREATE_NULL_OBJECTS, Boolean.FALSE);\n        stackContext.put(ReflectionContextState.DENY_METHOD_EXECUTION, Boolean.TRUE);\n        stackContext.put(XWorkConverter.REPORT_CONVERSION_ERRORS, Boolean.TRUE);\n\n        User user = new User();\n        stack.push(user);\n\n        \n        user.setList(new ArrayList());\n\n        String[] foo = new String[]{\"asdf\"};\n        ((OgnlValueStack)stack).setDevMode(\"true\");\n        try {\n            stack.setValue(\"list.1114778947765\", foo);\n            fail(\"non-valid expression: list.1114778947765\"); \n        }\n        catch(RuntimeException ex) {\n            ; \n        }\n        \n        try {\n            stack.setValue(\"1114778947765\", foo);\n            fail(\"non-valid expression: 1114778947765\"); \n        }\n        catch(RuntimeException ex) {\n            ;\n        }\n        \n        try {\n            stack.setValue(\"1234\", foo);\n            fail(\"non-valid expression: 1114778947765\"); \n        }\n        catch(RuntimeException ex) {\n            ;\n        }\n        \n        ((OgnlValueStack)stack).setDevMode(\"false\");\n        stack.setValue(\"list.1114778947765\", foo);\n        stack.setValue(\"1114778947765\", foo);\n        stack.setValue(\"1234\", foo);\n    }\n\n    public void testAvoidCallingMethodsOnObjectClass() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setExcludedClasses(Object.class.getName());\n            ognlUtil.setValue(\"class.classLoader.defaultAssertionStatus\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(NoSuchPropertyException.class, expected.getClass());\n        assertEquals(\"com.opensymphony.xwork2.util.Foo.class\", expected.getMessage());\n    }\n\n    public void testAvoidCallingMethodsOnObjectClassUpperCased() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setExcludedClasses(Object.class.getName());\n            ognlUtil.setValue(\"Class.ClassLoader.DefaultAssertionStatus\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(NoSuchPropertyException.class, expected.getClass());\n        assertEquals(\"com.opensymphony.xwork2.util.Foo.Class\", expected.getMessage());\n    }\n\n    public void testAvoidCallingMethodsOnObjectClassAsMap() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setExcludedClasses(Object.class.getName());\n            ognlUtil.setValue(\"class['classLoader']['defaultAssertionStatus']\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(NoSuchPropertyException.class, expected.getClass());\n        assertEquals(\"com.opensymphony.xwork2.util.Foo.class\", expected.getMessage());\n    }\n\n    public void testAvoidCallingMethodsOnObjectClassAsMap2() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setValue(\"foo['class']['classLoader']['defaultAssertionStatus']\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(NoSuchPropertyException.class, expected.getClass());\n        assertEquals(\"com.opensymphony.xwork2.util.Foo.foo\", expected.getMessage());\n    }\n\n    public void testAvoidCallingMethodsOnObjectClassAsMapWithQuotes() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setExcludedClasses(Object.class.getName());\n            ognlUtil.setValue(\"class[\\\"classLoader\\\"]['defaultAssertionStatus']\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(NoSuchPropertyException.class, expected.getClass());\n        assertEquals(\"com.opensymphony.xwork2.util.Foo.class\", expected.getMessage());\n    }\n\n    public void testAvoidCallingToString() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setValue(\"toString\", ognlUtil.createDefaultContext(foo), foo, null);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(OgnlException.class, expected.getClass());\n        assertEquals(\"toString\", expected.getMessage());\n    }\n\n    public void testAvoidCallingMethodsWithBraces() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setValue(\"toString()\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(InappropriateExpressionException.class, expected.getClass());\n        assertEquals(expected.getMessage(), \"Inappropriate OGNL expression: toString()\");\n    }\n\n    public void testAvoidCallingSomeClasses() throws Exception {\n        Foo foo = new Foo();\n\n        Exception expected = null;\n        try {\n            ognlUtil.setExcludedClasses(Runtime.class.getName());\n            ognlUtil.setValue(\"@java.lang.Runtime@getRuntime().exec('mate')\", ognlUtil.createDefaultContext(foo), foo, true);\n            fail();\n        } catch (OgnlException e) {\n            expected = e;\n        }\n        assertNotNull(expected);\n        assertSame(MethodFailedException.class, expected.getClass());\n        assertEquals(expected.getMessage(), \"Method \\\"getRuntime\\\" failed for object class java.lang.Runtime\");\n    }\n\n    public static class Email {\n        String address;\n\n        public void setAddress(String address) {\n            this.address = address;\n        }\n\n        @Override\n        public String toString() {\n            return address;\n        }\n    }\n\n    static class TestObject {\n        private Integer myIntegerProperty;\n        private Long myLongProperty;\n        private String myStrProperty;\n\n        public void setMyIntegerProperty(Integer myIntegerProperty) {\n            this.myIntegerProperty = myIntegerProperty;\n        }\n\n        public String getMyIntegerProperty() {\n            return myIntegerProperty.toString();\n        }\n\n        public void setMyLongProperty(Long myLongProperty) {\n            this.myLongProperty = myLongProperty;\n        }\n\n        public Long getMyLongProperty() {\n            return myLongProperty;\n        }\n\n        public void setMyStrProperty(String myStrProperty) {\n            this.myStrProperty = myStrProperty;\n        }\n\n        public String getMyStrProperty() {\n            return myStrProperty;\n        }\n    }\n\n    class EmailAction {\n        public List email = new OgnlList(Email.class);\n\n        public List getEmail() {\n            return this.email;\n        }\n    }\n\n    class OgnlList extends ArrayList {\n        private Class clazz;\n\n        public OgnlList(Class clazz) {\n            this.clazz = clazz;\n        }\n\n        @Override\n        public synchronized Object get(int index) {\n            while (index >= this.size()) {\n                try {\n                    this.add(clazz.newInstance());\n                } catch (Exception e) {\n                    throw new XWorkException(e);\n                }\n            }\n\n            return super.get(index);\n        }\n    }\n    \n    private class MyWriteBar {\n    \tprivate int id;\n    \t\n    \tpublic int getId() {\n    \t\treturn id;\n    \t}\n    \t\n    \tpublic void setBar(String name) {\n    \t\tif (\"Sams\".equals(name))\n    \t\t\tid = 1;\n    \t\telse\n    \t\t\tid = 999;\n    \t}\n    \t\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 31,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/fc2179cf1ac9fbfb61e3430fa88b641d87253327",
    "cve_id": "CVE-2016-2162",
    "cwe_id": "CWE-79",
    "filename": "core/src/main/java/com/opensymphony/xwork2/interceptor/I18nInterceptor.java",
    "code": "\n\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.Locale;\nimport java.util.Map;\n\n\npublic class I18nInterceptor extends AbstractInterceptor {\n    private static final long serialVersionUID = 2496830135246700300L;\n\n    protected static final Logger LOG = LogManager.getLogger(I18nInterceptor.class);\n\n    public static final String DEFAULT_SESSION_ATTRIBUTE = \"WW_TRANS_I18N_LOCALE\";\n    public static final String DEFAULT_PARAMETER = \"request_locale\";\n    public static final String DEFAULT_REQUESTONLY_PARAMETER = \"request_only_locale\";\n\n    protected String parameterName = DEFAULT_PARAMETER;\n    protected String requestOnlyParameterName = DEFAULT_REQUESTONLY_PARAMETER;\n    protected String attributeName = DEFAULT_SESSION_ATTRIBUTE;\n\n    \n    protected enum Storage { SESSION, NONE }\n\n    public I18nInterceptor() {\n        LOG.debug(\"new I18nInterceptor()\");\n    }\n\n    public void setParameterName(String parameterName) {\n        this.parameterName = parameterName;\n    }\n\n    public void setRequestOnlyParameterName(String requestOnlyParameterName) {\n        this.requestOnlyParameterName = requestOnlyParameterName;\n    }\n\n    public void setAttributeName(String attributeName) {\n        this.attributeName = attributeName;\n    }\n\n    @Override\n    public String intercept(ActionInvocation invocation) throws Exception {\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"Intercept '{}/{}' {\", invocation.getProxy().getNamespace(), invocation.getProxy().getActionName());\n        }\n\n        LocaleFinder localeFinder = new LocaleFinder(invocation);\n        Locale locale = getLocaleFromParam(localeFinder.getRequestedLocale());\n        locale = storeLocale(invocation, locale, localeFinder.getStorage());\n        saveLocale(invocation, locale);\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"before Locale: {}\", invocation.getStack().findValue(\"locale\"));\n        }\n\n        final String result = invocation.invoke();\n\n        if (LOG.isDebugEnabled()) {\n            LOG.debug(\"after Locale {}\", invocation.getStack().findValue(\"locale\"));\n            LOG.debug(\"intercept } \");\n        }\n\n        return result;\n    }\n\n    \n    protected Locale storeLocale(ActionInvocation invocation, Locale locale, String storage) {\n        \n        Map<String, Object> session = invocation.getInvocationContext().getSession();\n\n        if (session != null) {\n            synchronized (session) {\n                if (locale == null) {\n                    storage = Storage.NONE.toString();\n                    locale = readStoredLocale(invocation, session);\n                }\n\n                if (Storage.SESSION.toString().equals(storage)) {\n                    session.put(attributeName, locale);\n                }\n            }\n        }\n        return locale;\n    }\n\n    protected class LocaleFinder {\n        protected String storage = Storage.SESSION.toString();\n        protected Object requestedLocale = null;\n\n        protected ActionInvocation actionInvocation = null;\n\n        protected LocaleFinder(ActionInvocation invocation) {\n            actionInvocation = invocation;\n            find();\n        }\n\n        protected void find() {\n            \n            Map<String, Object> params = actionInvocation.getInvocationContext().getParameters();\n\n            storage = Storage.SESSION.toString();\n\n            requestedLocale = findLocaleParameter(params, parameterName);\n            if (requestedLocale != null) {\n                return;\n            }\n\n            requestedLocale = findLocaleParameter(params, requestOnlyParameterName);\n            if (requestedLocale != null) {\n                storage = Storage.NONE.toString();\n            }\n        }\n\n        public String getStorage() {\n            return storage;\n        }\n\n        public Object getRequestedLocale() {\n            return requestedLocale;\n        }\n    }\n\n    \n    protected Locale getLocaleFromParam(Object requestedLocale) {\n        Locale locale = null;\n        if (requestedLocale != null) {\n            locale = (requestedLocale instanceof Locale) ?\n                    (Locale) requestedLocale :\n                    LocalizedTextUtil.localeFromString(requestedLocale.toString(), null);\n            if (locale != null) {\n                LOG.debug(\"Applied request locale: {}\", locale);\n            }\n        }\n        return locale;\n    }\n\n    \n    protected Locale readStoredLocale(ActionInvocation invocation, Map<String, Object> session) {\n        Locale locale = this.readStoredLocalFromSession(invocation, session);\n\n        if (locale != null) {\n            return locale;\n        }\n\n        return this.readStoredLocalFromCurrentInvocation(invocation);\n    }\n\n    protected Locale readStoredLocalFromSession(ActionInvocation invocation, Map<String, Object> session) {\n         \n        Object sessionLocale = session.get(attributeName);\n        if (sessionLocale != null && sessionLocale instanceof Locale) {\n            Locale locale = (Locale) sessionLocale;\n            LOG.debug(\"Applied session locale: {}\", locale);\n            return locale;\n        }\n        return null;\n    }\n\n    protected Locale readStoredLocalFromCurrentInvocation(ActionInvocation invocation) {\n        \n        Locale locale = invocation.getInvocationContext().getLocale();\n        if (locale != null) {\n            LOG.debug(\"Applied invocation context locale: {}\", locale);\n        }\n        return locale;\n    }\n\n    protected Object findLocaleParameter(Map<String, Object> params, String parameterName) {\n        Object requestedLocale = params.remove(parameterName);\n        if (requestedLocale != null && requestedLocale.getClass().isArray()\n                && ((Object[]) requestedLocale).length > 0) {\n            requestedLocale = ((Object[]) requestedLocale)[0];\n\n            LOG.debug(\"Requested locale: {}\", requestedLocale);\n        }\n        return requestedLocale;\n    }\n\n    \n    protected void saveLocale(ActionInvocation invocation, Locale locale) {\n        invocation.getInvocationContext().setLocale(locale);\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 31,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/fc2179cf1ac9fbfb61e3430fa88b641d87253327",
    "cve_id": "CVE-2016-2162",
    "cwe_id": "CWE-79",
    "filename": "core/src/test/java/com/opensymphony/xwork2/interceptor/I18nInterceptorTest.java",
    "code": "\npackage com.opensymphony.xwork2.interceptor;\n\nimport com.opensymphony.xwork2.Action;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.SimpleFooAction;\nimport com.opensymphony.xwork2.mock.MockActionInvocation;\nimport junit.framework.TestCase;\n\nimport java.io.Serializable;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\n\npublic class I18nInterceptorTest extends TestCase {\n\n    private I18nInterceptor interceptor;\n    private ActionContext ac;\n    private Map<String, Serializable> params;\n    private Map session;\n    private ActionInvocation mai;\n\n    public void testEmptyParamAndSession() throws Exception {\n        interceptor.intercept(mai);\n    }\n\n    public void testNoSession() throws Exception {\n        ac.setSession(null);\n        interceptor.intercept(mai);\n    }\n\n    public void testDefaultLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"_\"); \n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.getDefault(), session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    public void testDenmarkLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"da_DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\", \"DK\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    public void testDenmarkLocaleRequestOnly() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_REQUESTONLY_PARAMETER, \"da_DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\", \"DK\");\n        assertNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, mai.getInvocationContext().getLocale()); \n    }\n\n    public void testCountryOnlyLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"DK\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    public void testLanguageOnlyLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"da_\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    public void testWithVariant() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"fr_CA_xx\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale variant = new Locale(\"fr\", \"CA\", \"xx\");\n        Locale locale = (Locale) session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE);\n        assertNotNull(locale); \n        assertEquals(variant, locale);\n        assertEquals(\"xx\", locale.getVariant());\n    }\n\n    public void testWithVariantRequestOnly() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_REQUESTONLY_PARAMETER, \"fr_CA_xx\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n        assertNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE));\n\n        Locale variant = new Locale(\"fr\", \"CA\", \"xx\");\n        Locale locale = mai.getInvocationContext().getLocale();\n        assertNotNull(locale); \n        assertEquals(variant, locale);\n        assertEquals(\"xx\", locale.getVariant());\n    }\n\n    public void testRealLocaleObjectInParams() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, Locale.CANADA_FRENCH);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.CANADA_FRENCH, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    public void testRealLocalesInParams() throws Exception {\n        Locale[] locales = new Locale[] { Locale.CANADA_FRENCH };\n        assertTrue(locales.getClass().isArray());\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, locales);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.CANADA_FRENCH, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE));\n    }\n\n    public void testSetParameterAndAttributeNames() throws Exception {\n        interceptor.setAttributeName(\"hello\");\n        interceptor.setParameterName(\"world\");\n\n        params.put(\"world\", Locale.CHINA);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(\"world\")); \n\n        assertNotNull(session.get(\"hello\")); \n        assertEquals(Locale.CHINA, session.get(\"hello\"));\n    }\n\n    public void testActionContextLocaleIsPreservedWhenNotOverridden() throws Exception {\n        final Locale locale1 = Locale.TRADITIONAL_CHINESE;\n        mai.getInvocationContext().setLocale(locale1);\n        interceptor.intercept(mai);\n\n        Locale locale = (Locale) session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE);\n        assertNull(locale); \n        locale = mai.getInvocationContext().getLocale();\n        assertEquals(locale1, locale);\n    }\n\n    @Override\n    protected void setUp() throws Exception {\n        interceptor = new I18nInterceptor();\n        interceptor.init();\n        params = new HashMap<>();\n        session = new HashMap();\n\n        Map<String, Object> ctx = new HashMap<>();\n        ctx.put(ActionContext.PARAMETERS, params);\n        ctx.put(ActionContext.SESSION, session);\n        ac = new ActionContext(ctx);\n\n        Action action = new SimpleFooAction();\n        mai = new MockActionInvocation();\n        ((MockActionInvocation) mai).setAction(action);\n        ((MockActionInvocation) mai).setInvocationContext(ac);\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        interceptor.destroy();\n        interceptor = null;\n        ac = null;\n        params = null;\n        session = null;\n        mai = null;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 31,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/fc2179cf1ac9fbfb61e3430fa88b641d87253327",
    "cve_id": "CVE-2016-2162",
    "cwe_id": "CWE-79",
    "filename": "core/src/test/java/org/apache/struts2/interceptor/I18nInterceptorTest.java",
    "code": "\npackage org.apache.struts2.interceptor;\n\nimport com.opensymphony.xwork2.Action;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.mock.MockActionInvocation;\nimport org.apache.struts2.StrutsStatics;\nimport org.easymock.EasyMock;\nimport org.easymock.IArgumentMatcher;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Map;\n\nimport static org.jmock.expectation.AssertMo.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\npublic class I18nInterceptorTest {\n    private I18nInterceptor interceptor;\n    private ActionInvocation mai;\n    private ActionContext ac;\n    private Map<String, Object> params;\n    private Map session;\n\n    @Before\n    public void setUp() throws Exception {\n        interceptor = new I18nInterceptor();\n        interceptor.init();\n        params = new HashMap<String, Object>();\n        session = new HashMap();\n\n        Map<String, Object> ctx = new HashMap<String, Object>();\n        ctx.put(ActionContext.PARAMETERS, params);\n        ctx.put(ActionContext.SESSION, session);\n        ac = new ActionContext(ctx);\n\n        Action action = new Action() {\n            public String execute() throws Exception {\n                return SUCCESS;\n            }\n        };\n        mai = new MockActionInvocation();\n        ((MockActionInvocation) mai).setAction(action);\n        ((MockActionInvocation) mai).setInvocationContext(ac);\n    }\n\n    @After\n    public void tearDown() throws Exception {\n        interceptor.destroy();\n        interceptor = null;\n        ac = null;\n        params = null;\n        session = null;\n        mai = null;\n    }\n\n    static class CookieMatcher implements IArgumentMatcher {\n        private Cookie expected;\n\n        CookieMatcher(Cookie cookie) {\n            expected = cookie;\n        }\n\n        public boolean matches(Object argument) {\n            Cookie cookie = ((Cookie) argument);\n            return\n                (cookie.getName().equals(expected.getName()) &&\n                 cookie.getValue().equals(expected.getValue()));\n        }\n\n        public static Cookie eqCookie(Cookie ck) {\n            EasyMock.reportMatcher(new CookieMatcher(ck));\n            return null;\n        }\n\n        public void appendTo(StringBuffer buffer) {\n            buffer\n                .append(\"Received\")\n                .append(expected.getName())\n                .append(\"/\")\n                .append(expected.getValue());\n        }\n    }\n\n    @Test\n    public void testCookieCreation() throws Exception {\n\n        params.put(I18nInterceptor.DEFAULT_COOKIE_PARAMETER, \"da_DK\");\n\n        final Cookie cookie = new Cookie(I18nInterceptor.DEFAULT_COOKIE_ATTRIBUTE, \"da_DK\");\n\n        HttpServletResponse response = EasyMock.createMock(HttpServletResponse.class);\n        response.addCookie(CookieMatcher.eqCookie(cookie));\n        EasyMock.replay(response);\n\n        ac.put(StrutsStatics.HTTP_RESPONSE, response);\n        interceptor.intercept(mai);\n\n        EasyMock.verify(response);\n\n        Locale denmark = new Locale(\"da\", \"DK\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testNoSession() throws Exception {\n        ac.setSession(null);\n        interceptor.intercept(mai);\n    }\n\n    @Test\n    public void testDefaultLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"_\"); \n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.getDefault(), session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testDenmarkLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"da_DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\", \"DK\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testDenmarkLocaleRequestOnly() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_REQUESTONLY_PARAMETER, \"da_DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\", \"DK\");\n        assertNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, mai.getInvocationContext().getLocale()); \n    }\n\n    @Test\n    public void testCountryOnlyLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"DK\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"DK\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testLanguageOnlyLocale() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"da_\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale denmark = new Locale(\"da\");\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(denmark, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testWithVariant() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, \"fr_CA_xx\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        Locale variant = new Locale(\"fr\", \"CA\", \"xx\");\n        Locale locale = (Locale) session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE);\n        assertNotNull(locale); \n        assertEquals(variant, locale);\n        assertEquals(\"xx\", locale.getVariant());\n    }\n\n    @Test\n    public void testWithVariantRequestOnly() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_REQUESTONLY_PARAMETER, \"fr_CA_xx\");\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n        assertNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE));\n\n        Locale variant = new Locale(\"fr\", \"CA\", \"xx\");\n        Locale locale = mai.getInvocationContext().getLocale();\n        assertNotNull(locale); \n        assertEquals(variant, locale);\n        assertEquals(\"xx\", locale.getVariant());\n    }\n\n    @Test\n    public void testRealLocaleObjectInParams() throws Exception {\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, Locale.CANADA_FRENCH);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.CANADA_FRENCH, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n    }\n\n    @Test\n    public void testRealLocalesInParams() throws Exception {\n        Locale[] locales = new Locale[]{Locale.CANADA_FRENCH};\n        assertTrue(locales.getClass().isArray());\n        params.put(I18nInterceptor.DEFAULT_PARAMETER, locales);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(I18nInterceptor.DEFAULT_PARAMETER)); \n\n        assertNotNull(session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE)); \n        assertEquals(Locale.CANADA_FRENCH, session.get(I18nInterceptor.DEFAULT_SESSION_ATTRIBUTE));\n    }\n\n    @Test\n    public void testSetParameterAndAttributeNames() throws Exception {\n        interceptor.setAttributeName(\"hello\");\n        interceptor.setParameterName(\"world\");\n\n        params.put(\"world\", Locale.CHINA);\n        interceptor.intercept(mai);\n\n        assertNull(params.get(\"world\")); \n\n        assertNotNull(session.get(\"hello\")); \n        assertEquals(Locale.CHINA, session.get(\"hello\"));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 32,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/struts/commit/1f301038a751bf16e525607c3db513db835b2999",
    "cve_id": "CVE-2014-7809",
    "cwe_id": "CWE-352",
    "filename": "core/src/main/java/org/apache/struts2/util/TokenHelper.java",
    "code": "\n\npackage org.apache.struts2.util;\n\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.util.LocalizedTextUtil;\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\nimport java.math.BigInteger;\nimport java.util.Map;\nimport java.util.Random;\n\n\npublic class TokenHelper {\n\n\t\n\tpublic static final String TOKEN_NAMESPACE = \"struts.tokens\";\n\n\t\n    public static final String DEFAULT_TOKEN_NAME = \"token\";\n\n    \n    public static final String TOKEN_NAME_FIELD = \"struts.token.name\";\n    private static final Logger LOG = LoggerFactory.getLogger(TokenHelper.class);\n    private static final Random RANDOM = new Random();\n\n\n    \n    public static String setToken() {\n        return setToken(DEFAULT_TOKEN_NAME);\n    }\n\n\t\n\tpublic static String setToken( String tokenName ) {\n\t\tString token = generateGUID();\n\t\tsetSessionToken(tokenName, token);\n\t\treturn token;\n\t}\n\n\t\n\tpublic static void setSessionToken( String tokenName, String token ) {\n\t\tMap<String, Object> session = ActionContext.getContext().getSession();\n\t\ttry {\n\t\t\tsession.put(buildTokenSessionAttributeName(tokenName), token);\n\t\t} catch ( IllegalStateException e ) {\n\t\t\t\n            String msg = \"Error creating HttpSession due response is commited to client. You can use the CreateSessionInterceptor or create the HttpSession from your action before the result is rendered to the client: \" + e.getMessage();\n            if (LOG.isErrorEnabled()) {\n                LOG.error(msg, e);\n            }\n\t\t\tthrow new IllegalArgumentException(msg);\n\t\t}\n\t}\n\n\n\t\n\tpublic static String buildTokenSessionAttributeName( String tokenName ) {\n\t\treturn TOKEN_NAMESPACE + \".\" + tokenName;\n\t}\n\n\t\n    public static String getToken() {\n        return getToken(DEFAULT_TOKEN_NAME);\n    }\n\n    \n    public static String getToken(String tokenName) {\n        if (tokenName == null ) {\n            return null;\n        }\n        Map params = ActionContext.getContext().getParameters();\n        String[] tokens = (String[]) params.get(tokenName);\n        String token;\n\n        if ((tokens == null) || (tokens.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token mapped to token name \" + tokenName);\n            }\n\n            return null;\n        }\n\n        token = tokens[0];\n\n        return token;\n    }\n\n    \n    public static String getTokenName() {\n        Map params = ActionContext.getContext().getParameters();\n\n        if (!params.containsKey(TOKEN_NAME_FIELD)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Could not find token name in params.\");\n            }\n\n            return null;\n        }\n\n        String[] tokenNames = (String[]) params.get(TOKEN_NAME_FIELD);\n        String tokenName;\n\n        if ((tokenNames == null) || (tokenNames.length < 1)) {\n            if (LOG.isWarnEnabled()) {\n        \tLOG.warn(\"Got a null or empty token name.\");\n            }\n\n            return null;\n        }\n\n        tokenName = tokenNames[0];\n\n        return tokenName;\n    }\n\n    \n    public static boolean validToken() {\n        String tokenName = getTokenName();\n\n        if (tokenName == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token name found -> Invalid token \");\n            }\n            return false;\n        }\n\n        String token = getToken(tokenName);\n\n        if (token == null) {\n            if (LOG.isDebugEnabled()) {\n                LOG.debug(\"no token found for token name \"+tokenName+\" -> Invalid token \");\n            }\n            return false;\n        }\n\n        Map session = ActionContext.getContext().getSession();\n\t\tString tokenSessionName = buildTokenSessionAttributeName(tokenName);\n        String sessionToken = (String) session.get(tokenSessionName);\n\n        if (!token.equals(sessionToken)) {\n            if (LOG.isWarnEnabled()) {\n                LOG.warn(LocalizedTextUtil.findText(TokenHelper.class, \"struts.internal.invalid.token\", ActionContext.getContext().getLocale(), \"Form token {0} does not match the session token {1}.\", new Object[]{\n                        token, sessionToken\n                }));\n            }\n\n            return false;\n        }\n\n        \n        session.remove(tokenSessionName);\n\n        return true;\n    }\n\n    public static String generateGUID() {\n        return new BigInteger(165, RANDOM).toString(36).toUpperCase();\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 33,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tika/commit/8a6a9e1344f5b10ebfa1a189dc3c30d0da2b9d4",
    "cve_id": "CVE-2018-8017",
    "cwe_id": "CWE-835",
    "filename": "tika-parsers/src/main/java/org/apache/tika/parser/iptc/IptcAnpaParser.java",
    "code": "\npackage org.apache.tika.parser.iptc;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Collections;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Locale;\nimport java.util.Set;\nimport java.util.TimeZone;\n\nimport org.apache.tika.exception.TikaException;\nimport org.apache.tika.metadata.Metadata;\nimport org.apache.tika.metadata.TikaCoreProperties;\nimport org.apache.tika.mime.MediaType;\nimport org.apache.tika.parser.ParseContext;\nimport org.apache.tika.parser.Parser;\nimport org.apache.tika.sax.XHTMLContentHandler;\nimport org.xml.sax.ContentHandler;\nimport org.xml.sax.SAXException;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\n\npublic class IptcAnpaParser implements Parser {\n    \n    private static final long serialVersionUID = -6062820170212879115L;\n\n    private static final MediaType TYPE =\n        MediaType.text(\"vnd.iptc.anpa\");\n\n    private static final Set<MediaType> SUPPORTED_TYPES =\n        Collections.singleton(TYPE);\n\n    public Set<MediaType> getSupportedTypes(ParseContext context) {\n        return SUPPORTED_TYPES;\n    }\n\n    public void parse(\n           InputStream stream, ContentHandler handler,\n           Metadata metadata, ParseContext context)\n           throws IOException, SAXException, TikaException {\n\n        HashMap<String,String> properties = this.loadProperties(stream);\n        this.setMetadata(metadata, properties);\n\n        XHTMLContentHandler xhtml = new XHTMLContentHandler(handler, metadata);\n        xhtml.startDocument();\n        \n        xhtml.startElement(\"p\");\n        String body = clean(properties.get(\"body\"));\n        if (body != null)\n           xhtml.characters(body);\n        xhtml.endElement(\"p\");\n        xhtml.endDocument();\n    }\n\n    \n    public void parse(\n            InputStream stream, ContentHandler handler, Metadata metadata)\n            throws IOException, SAXException, TikaException {\n        parse(stream, handler, metadata, new ParseContext());\n    }\n\n\n   private int FMT_ANPA_1312    = 0x00;   \n   private int FMT_ANPA_UPI     = 0x01;   \n   private int FMT_ANPA_UPI_DL  = 0x02;   \n   private int FMT_IPTC_7901    = 0x03;   \n   private int FMT_IPTC_PHOTO   = 0x04;   \n   private int FMT_IPTC_CHAR    = 0x05;   \n   private int FMT_NITF         = 0x06;   \n   private int FMT_NITF_TT      = 0x07;   \n   private int FMT_NITF_RB      = 0x08;   \n   private int FMT_IPTC_AP      = 0x09;   \n   private int FMT_IPTC_BLM     = 0x0A;   \n   private int FMT_IPTC_NYT     = 0x0B;   \n   private int FMT_IPTC_RTR     = 0x0C;   \n\n   private int FORMAT = FMT_ANPA_1312;    \n\n   private final static char SOH = 0x01;    \n   private final static char STX = 0x02;    \n   private final static char ETX = 0x03;    \n   private final static char EOT = 0x04;    \n   private final static char SYN = 0x16;    \n\n   private final static char BS = 0x08;    \n   private final static char TB = 0x09;    \n   private final static char LF = 0x0A;    \n   private final static char FF = 0x0C;    \n   private final static char CR = 0x0D;    \n   private final static char XQ = 0x11;    \n   private final static char XS = 0x13;    \n   private final static char FS = 0x1F;    \n\n   private final static char HY = 0x2D;    \n   private final static char SP = 0x20;    \n   private final static char LT = 0x3C;    \n   private final static char EQ = 0x3D;    \n   private final static char CT = 0x5E;    \n\n   private final static char SL = 0x91;    \n   private final static char SR = 0x92;    \n   private final static char DL = 0x93;    \n   private final static char DR = 0x94;    \n\n\n   \n   private HashMap<String,String> loadProperties(InputStream is) {\n      \n      HashMap<String,String> properties = new HashMap<String,String>();\n\n      FORMAT = this.scanFormat(is);\n\n      byte[] residual = this.getSection(is,\"residual\");\n\n      byte[] header = this.getSection(is,\"header\");\n      parseHeader(header, properties);\n\n      byte[] body = this.getSection(is,\"body\");\n      parseBody(body, properties);\n\n      byte[] footer = this.getSection(is,\"footer\");\n      parseFooter(footer, properties);\n       \n      return (properties);\n   }\n\n\n   private int scanFormat(InputStream is) {\n      int format    = this.FORMAT;\n      int  maxsize  = 524288;     \n\n      byte[] buf = new byte[maxsize];\n      try {\n         if (is.markSupported()) {\n            is.mark(maxsize);\n         }\n         int msgsize = is.read(buf);                \n\n         String message = (new String(buf, UTF_8)).toLowerCase(Locale.ROOT);\n         \n         \n         \n         \n\n         if (message.contains(\"ap-wf\")) {\n            format = this.FMT_IPTC_AP;\n         }\n         if (message.contains(\"reuters\")) {\n            format = this.FMT_IPTC_RTR;\n         }\n         if (message.contains(\"new york times\")) {\n            format = this.FMT_IPTC_NYT;\n         }\n         if (message.contains(\"bloomberg news\")) {\n            format = this.FMT_IPTC_BLM;\n         }\n      }\n      catch (IOException eio) {\n         \n      }\n\n      try {\n         if (is.markSupported()) {\n            is.reset();\n         }\n      }\n      catch (IOException eio) {\n         \n      }\n      return (format);\n   }\n\n\n   private void setFormat(int format) {\n      this.FORMAT = format;\n   }\n\n\n   private String getFormatName() {\n      \n      String name = \"\";\n      \n      if (FORMAT == this.FMT_IPTC_AP) {\n         name = \"Associated Press\";\n      }\n      \n      else if(FORMAT == this.FMT_IPTC_BLM) {\n         name = \"Bloomberg\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_NYT) {\n         name = \"New York Times\";\n      }\n\n      else if(FORMAT == this.FMT_IPTC_RTR) {\n         name = \"Reuters\";\n      }\n\n      return (name);\n   }\n\n\n   private byte[] getSection(InputStream is, String name) {\n\n      byte[] value = new byte[0];\n\n      if (name.equals(\"residual\")) {\n         \n         int  maxsize  = 8192;     \n         byte bstart   = SYN;     \n         byte bfinish  = SOH;     \n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if(name.equals(\"header\")) {\n         \n         int  maxsize  = 8192;     \n         byte bstart   = SOH;     \n         byte bfinish  = STX;     \n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"body\")) {\n         \n         int  maxsize  = 524288;     \n         byte bstart   = STX;     \n         byte bfinish  = ETX;     \n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      else if (name.equals(\"footer\")) {\n         \n         int maxsize   = 8192;     \n         byte bstart   = ETX;     \n         byte bfinish  = EOT;     \n         value = getSection(is, maxsize, bstart, bfinish, true);\n      }\n\n      return (value);\n   }\n\n\n   private byte[] getSection(InputStream is, int maxsize, byte bstart, byte bfinish, boolean ifincomplete) {\n      byte[] value  = new byte[0];\n\n      try {\n         boolean started = false;                   \n         boolean finished = false;                  \n         int read = 0;                              \n         int start = 0;                             \n\n         \n         \n         int streammax = is.available();\n         maxsize = Math.min(maxsize, streammax);\n\n         is.mark(maxsize);\n         byte[] buf = new byte[maxsize];\n         int totsize = 0;\n         int remainder = maxsize - totsize;\n         while (remainder > 0) {\n            int msgsize = is.read(buf, maxsize-remainder, maxsize);    \n            if (msgsize == -1) {\n               remainder = msgsize = 0;\n            }\n            remainder -= msgsize;\n            totsize   += msgsize;\n         }\n\n         \n         for (read=0; read < totsize; read++) {\n            byte b = buf[read];\n\n            if (!started) {\n               started = (b == bstart);\n               start = read + 1;\n               continue;\n            }\n\n            if (finished = (b == bfinish)) {\n\n               break;\n            }\n\n            \n            continue;\n         }\n\n         \n         is.reset();\n\n         if (finished) {\n            \n            is.skip(read);\n            value = new byte[read-start];\n            System.arraycopy(buf, start, value, 0, read-start);\n         }\n         else {\n            if (ifincomplete && started) {\n               \n               value = new byte[read-start];\n               System.arraycopy(buf, start, value, 0, read-start);\n            }\n         }\n      }\n      catch (IOException eio) {\n         \n      }\n\n      return (value);\n   }\n\n\n   private boolean parseHeader(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String env_serviceid = \"\";\n      String env_category = \"\";\n      String env_urgency = \"\";\n      String hdr_edcode = \"\";\n      String hdr_subject = \"\";\n      String hdr_date = \"\";\n      String hdr_time = \"\";\n\n      int read = 0;\n\n      while (read < value.length) {\n\n         \n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != FS) {\n               env_serviceid += (char)(val_next & 0xff);  \n            }\n            else {\n               break;\n            }\n         }\n\n         \n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next != XS) {   \n               env_category += (char)(val_next & 0xff);  \n            }\n            else {\n               val_next = value[read];  \n               if (val_next == XQ) {\n                  read++;\n               }\n               break;\n            }\n         }\n\n         \n         while (read < value.length) {\n            boolean subject = true;\n            byte val_next = value[read++];\n            while ((subject) && (val_next != SP) && (val_next != 0x00)) {  \n               hdr_subject += (char)(val_next & 0xff);  \n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               while (val_next == SP) {  \n                  subject = false;\n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (val_next != SP) {\n                     --read;  \n                  }\n               }\n            }\n            if (!subject) {\n               break;\n            }\n         }\n\n         \n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (hdr_date.length() == 0) {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  \n                  ||   (val_next == HY)) {\n                  hdr_date += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n            else if (val_next == SP) {\n               while (val_next == SP) {  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               continue;\n            }\n            else {\n               while (((val_next >= (byte)0x30) && (val_next <= (byte)0x39))  \n                  ||   (val_next == HY)) {\n                  hdr_time += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n            }\n         }\n         break; \n      }\n\n      \n\n      added = (env_serviceid.length() + env_category.length() + hdr_subject.length() + \n               hdr_date.length() + hdr_time.length()) > 0; \n      return added;\n   }\n\n   private boolean parseBody(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String bdy_heading = \"\";\n      String bdy_title = \"\";\n      String bdy_source = \"\";\n      String bdy_author = \"\";\n      String bdy_body = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         \n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      \n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               \n               while ((val_next != LT) && (val_next != CR) && (val_next != LF)) {   \n                  bdy_heading += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  \n               }\n               if (val_next == LT) {\n                  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n               while (bdy_heading.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  \n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               \n\n               \n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     \n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        \n                        if (read == 1) {\n                           byte[] resize = new byte[value.length + 1];\n                           System.arraycopy(value, 0, resize, 1, value.length);\n                           value = resize;\n                        }\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n         \n         while (read < value.length) {\n            byte val_next = value[read++];\n            if (val_next == CT) {      \n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               \n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF)) {   \n                  bdy_title += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  \n               }\n\n               if (val_next == CT) {      \n                   --read;\n               }\n\n               if (val_next == LT) {\n                  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while (bdy_title.length() > 0 && ((val_next == CR) || (val_next == LF))) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  \n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n            }\n            else {\n               \n\n               \n               if (FORMAT == this.FMT_IPTC_BLM) {\n                  if (val_next == TB) {\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n\n               \n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  if (val_next != CT) {\n                     \n                     if ((val_next != SP) && (val_next != TB) && (val_next != CR) && (val_next != LF)) {\n                        --read;\n                     }\n                     value[--read] = CT;\n                     continue;\n                  }\n               }\n            }\n            break;\n         }\n\n\n         \n         \n         \n         boolean metastarted = false;\n         String longline = \"\";\n         String longkey = \"\";\n         while (read < value.length) {\n            byte val_next = value[read++];\n\n            \n            if ((val_next == SP) || (val_next == TB) || (val_next == CR) || (val_next == LF)) {\n               continue;\n            }\n\n            if (val_next == CT) {      \n               val_next =  (read < value.length) ? value[read++] : 0x00;\n               String tmp_line = \"\";\n               while ((val_next != LT) && (val_next != CT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {\n                  \n                  tmp_line += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  \n               }\n\n               if (val_next == CT) {      \n                   --read;\n               }\n\n               if (val_next == LT) {\n                  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n               }\n\n               while ((val_next == CR) || (val_next == LF)) {\n                  val_next =  (read < value.length) ? value[read++] : 0x00;  \n                  if ((val_next != CR) && (val_next != LF)) {\n                     --read;\n                  }\n               }\n               if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"by\") || longline.equals(\"bdy_author\")) {\n                  longkey = \"bdy_author\";\n\n                  \n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  \n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_author += tmp_line.substring(tmp_line.indexOf(\" \"), term);\n                  metastarted = true;\n                  longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n               }\n               else if (FORMAT == this.FMT_IPTC_BLM) {\n                  String byline = \"   by \";\n                  if (tmp_line.toLowerCase(Locale.ROOT).contains(byline)) {\n                     longkey = \"bdy_author\";\n\n                     int term = tmp_line.length();\n                     term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n                     term = Math.min(term, (tmp_line.contains(\"\\n\") ? tmp_line.indexOf(\"\\n\") : term));\n                     term = (term > 0 ) ? term : tmp_line.length();\n                     \n                     bdy_author += tmp_line.substring(tmp_line.toLowerCase(Locale.ROOT).indexOf(byline) + byline.length(), term) + \" \";\n                     metastarted = true;\n                     longline = ((tmp_line.contains(\"=\")) && (!longline.equals(longkey)) ? longkey : \"\");\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).startsWith(\"c.\")) {\n                     \n                     \n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n                  else if(tmp_line.toLowerCase(Locale.ROOT).trim().startsWith(\"(\") && tmp_line.toLowerCase(Locale.ROOT).trim().endsWith(\")\")) {\n                     \n                     \n                     if (val_next == TB) {\n                        value[--read] = CT;\n                        continue;\n                     }\n                  }\n               }\n\n               else if (tmp_line.toLowerCase(Locale.ROOT).startsWith(\"eds\") || longline.equals(\"bdy_source\")) {\n                  longkey = \"bdy_source\";\n                  \n                  tmp_line = (longline.equals(longkey) ? \" \" : \"\") + tmp_line;\n\n                  \n                  int term = tmp_line.length();\n                  term = Math.min(term, (tmp_line.contains(\"<\") ? tmp_line.indexOf(\"<\")  : term));\n                  term = Math.min(term, (tmp_line.contains(\"=\") ? tmp_line.indexOf(\"=\")  : term));\n\n                  term = (term > 0 ) ? term : tmp_line.length();\n                  bdy_source += tmp_line.substring(tmp_line.indexOf(\" \") + 1, term) + \" \";\n                  metastarted = true;\n                  longline = (!longline.equals(longkey) ? longkey  : \"\");\n               }\n               else {\n                  \n                  \n                  if (!metastarted) {\n                     bdy_title += \" , \" + tmp_line;     \n                  }\n                  else {\n                     \n                     bdy_body += \" \" + tmp_line + \" , \";     \n                  }\n               }\n            }\n            else {  \n               while ((read < value.length) && (val_next != 0))  {\n                  \n                  bdy_body += (char)(val_next & 0xff);  \n                  val_next =  (read < value.length) ? value[read++] : 0x00;\n                  if (read > value.length) { break; }  \n               }\n\n            }\n            \n         }\n         done = true; \n      }\n      properties.put(\"body\", bdy_body);\n      properties.put(\"title\", bdy_title);\n      properties.put(\"subject\", bdy_heading);\n      properties.put(\"author\", bdy_author);\n      properties.put(\"source\", bdy_source);\n\n      added = (bdy_body.length() + bdy_title.length() + bdy_heading.length() + bdy_author.length() +\n               bdy_source.length()) > 0;\n      return added;\n   }\n\n\n   private boolean parseFooter(byte[] value, HashMap<String,String> properties) {\n      boolean added = false;\n\n      String ftr_source = \"\";\n      String ftr_datetime = \"\";\n\n      int read = 0;\n      boolean done = false;\n\n      while (!done && (read < value.length)) {\n\n         \n         byte val_next = value[read++];\n         byte val_peek =  (read < value.length) ? value[read+1] : 0x00;  \n\n         while (((val_next < (byte)0x30) || (val_next > (byte)0x39)) && (val_next != 0)) {  \n            ftr_source += (char)(val_next & 0xff);  \n            val_next =  (read < value.length) ? value[read] : 0x00;  \n            read++;\n            if (read > value.length) { break; }  \n         }\n\n         while ((val_next != LT) && (val_next != CR) && (val_next != LF) && (val_next != 0))  {  \n            \n            ftr_datetime += (char)(val_next & 0xff);  \n            val_next =  (read < value.length) ? value[read++] : 0x00;  \n            if (read > value.length) { break; }  \n         }\n         if (val_next == LT) {\n            \n            val_next =  (read < value.length) ? value[read++] : 0x00;\n         }\n\n         if (ftr_datetime.length() > 0) {\n            \n            String format_out = \"yyyy-MM-dd'T'HH:mm:ss'Z'\";\n            Date dateunix = new Date();\n            try {\n               \n               String format_in = \"MM-dd-yy HHmmzzz\";\n\n               if (FORMAT == this.FMT_IPTC_RTR) {\n                  \n                  format_in = \"HH:mm MM-dd-yy\";\n               }\n               SimpleDateFormat dfi = new SimpleDateFormat(format_in, Locale.ROOT);\n               dfi.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n               dateunix = dfi.parse(ftr_datetime);\n            }\n            catch (ParseException ep) {\n               \n            }\n            SimpleDateFormat dfo = new SimpleDateFormat(format_out, Locale.ROOT);\n            dfo.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n            ftr_datetime = dfo.format(dateunix);\n         }\n         while ((val_next == CR) || (val_next == LF)) {\n            val_next =  (read < value.length) ? value[read++] : 0x00;  \n            if ((val_next != CR) && (val_next != LF)) {\n               --read;\n            }\n         }\n         done = true; \n      }\n\n      properties.put(\"publisher\", ftr_source);\n      properties.put(\"created\", ftr_datetime);\n      properties.put(\"modified\", ftr_datetime);\n\n      added = (ftr_source.length() + ftr_datetime.length()) > 0; \n      return added;\n   }\n\n\n   private void setMetadata(Metadata metadata, HashMap<String,String> properties) {\n\n      \n      \n      metadata.set(Metadata.CONTENT_TYPE,  clean(\"text/anpa-1312\"));\n      metadata.set(TikaCoreProperties.TITLE,         clean(properties.get(\"title\")));\n      metadata.set(TikaCoreProperties.SUBJECT,       clean(properties.get(\"subject\")));\n      metadata.set(TikaCoreProperties.CREATOR,        clean(properties.get(\"author\")));\n      metadata.set(TikaCoreProperties.CREATED, clean(properties.get(\"created\")));\n      metadata.set(TikaCoreProperties.MODIFIED,      clean(properties.get(\"modified\")));\n      metadata.set(TikaCoreProperties.SOURCE,      clean(properties.get(\"source\")));\n\n      metadata.set(TikaCoreProperties.PUBLISHER,     clean(this.getFormatName()));\n\n\n   }\n\n   private String clean(String value) {\n      if (value == null) {\n         value = \"\";\n      }\n\n      value = value.replaceAll(\"``\", \"`\");\n      value = value.replaceAll(\"''\", \"'\");\n      value = value.replaceAll(new String(new char[] {SL}), \"'\");\n      value = value.replaceAll(new String(new char[] {SR}), \"'\");\n      value = value.replaceAll(new String(new char[] {DL}), \"\\\"\");\n      value = value.replaceAll(new String(new char[] {DR}), \"\\\"\");\n      value = value.trim();\n\n      return (value);\n   }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "arquillian/arquillian-tomee-common/src/main/java/org/apache/openejb/arquillian/common/Setup.java",
    "code": "\npackage org.apache.openejb.arquillian.common;\n\nimport org.apache.openejb.loader.ProvisioningUtil;\nimport org.apache.openejb.loader.SystemInstance;\nimport org.apache.openejb.loader.provisining.ProvisioningResolver;\nimport org.apache.tomee.util.QuickServerXmlParser;\nimport org.codehaus.swizzle.stream.ReplaceStringsInputStream;\nimport org.jboss.arquillian.container.spi.client.container.LifecycleException;\nimport org.jboss.shrinkwrap.api.ArchivePaths;\nimport org.jboss.shrinkwrap.api.ShrinkWrap;\nimport org.jboss.shrinkwrap.api.asset.StringAsset;\nimport org.jboss.shrinkwrap.api.exporter.ZipExporter;\nimport org.jboss.shrinkwrap.api.spec.JavaArchive;\n\nimport java.io.File;\nimport java.io.FileFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.Method;\nimport java.net.Socket;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static java.util.Collections.emptyMap;\n\n\npublic class Setup {\n    private static final Logger LOGGER = Logger.getLogger(Setup.class.getName()); \n    public static final String TOMEE_BEAN_DISCOVERER_JAR = \"lib\" + File.separator + \"xx-arquillian-tomee-bean-discoverer.jar\"; \n    private static final String DEFAULT_MEM_CONFIG = (javaVersion() >= 1.8 ? \"\" : \"-XX:PermSize=64m -XX:MaxPermSize=256m \")\n                                                            + \"-Xmx512m -Xms256m -XX:ReservedCodeCacheSize=64m\";\n\n    private static double javaVersion() {\n        try {\n            return Double.parseDouble(System.getProperty(\"java.version\", \"1.7\").substring(0, 3));\n        } catch (final Exception nfe) {\n            return 1.6;\n        }\n    }\n\n    public static void exportProperties(final File tomeeHome, final TomEEConfiguration c, final boolean defaultMem) {\n        final int httpPort = c.getHttpPort();\n        System.setProperty(\"java.naming.provider.url\", \"http://\" + c.getHost() + \":\" + httpPort + \"/tomee/ejb\");\n        System.setProperty(\"connect.tries\", \"90\");\n        System.setProperty(\"server.http.port\", String.valueOf(httpPort));\n        System.setProperty(\"server.shutdown.port\", String.valueOf(c.getStopPort()));\n        if (defaultMem) {\n            System.setProperty(\"java.opts\", DEFAULT_MEM_CONFIG + \" -Dtomee.httpPort=\" + httpPort);\n        } else {\n            System.setProperty(\"java.opts\", \"-Dtomee.httpPort=\" + httpPort);\n        }\n        System.setProperty(\"openejb.home\", tomeeHome.getAbsolutePath());\n        System.setProperty(\"tomee.home\", tomeeHome.getAbsolutePath());\n    }\n\n    public static void updateServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n        final File serverXml = Files.path(new File(tomeeHome.getAbsolutePath()), \"conf\", \"server.xml\");\n        if (!serverXml.exists()) {\n            return;\n        }\n\n        final QuickServerXmlParser ports = QuickServerXmlParser.parse(serverXml);\n        if (configuration.getKeepServerXmlAsThis()) {\n            \n            configuration.setHttpPort(Integer.parseInt(ports.http()));\n            configuration.setStopPort(Integer.parseInt(ports.stop()));\n            return; \n        }\n\n        final Map<String, String> replacements = new HashMap<>();\n        replacements.put(ports.http(), String.valueOf(configuration.getHttpPort()));\n        replacements.put(ports.https(), String.valueOf(configuration.getHttpsPort()));\n        replacements.put(ports.stop(), String.valueOf(configuration.getStopPort()));\n        replacements.put(ports.ajp(), String.valueOf(ajpPort(configuration)));\n\n        if (configuration.isUnpackWars()) {\n            replacements.put(\"unpackWARs=\\\"false\\\"\", \"unpackWARs=\\\"true\\\"\");\n        } else {\n            replacements.put(\"unpackWARs=\\\"true\\\"\", \"unpackWARs=\\\"false\\\"\");\n        }\n\n        replace(replacements, serverXml, true);\n    }\n\n    public static File findHome(File directory) {\n\n        directory = directory.getAbsoluteFile();\n\n        final File f = findHomeImpl(directory);\n\n        if (null == f) {\n            LOGGER.log(Level.INFO, \"Unable to find home in: \" + directory);\n        }\n\n        return f;\n    }\n\n    public static File findHomeImpl(final File directory) {\n        final File conf = new File(directory, \"conf\").getAbsoluteFile();\n        final File webapps = new File(directory, \"webapps\").getAbsoluteFile();\n\n        if (conf.exists() && conf.isDirectory() && webapps.exists() && webapps.isDirectory()) {\n            return directory;\n        }\n\n        final File[] files = directory.listFiles();\n        if (null != files) {\n\n            for (final File file : files) {\n                if (\".\".equals(file.getName()) || \"..\".equals(file.getName())) {\n                    continue;\n                }\n\n                final File found = findHome(file);\n\n                if (found != null) {\n                    return found;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    public static File downloadAndUnpack(final File dir, final String artifactID, final String defaultTempDir) throws LifecycleException {\n\n        final File zipFile = downloadFile(artifactID, null, defaultTempDir);\n\n        Zips.unzip(zipFile, dir);\n\n        return findHome(dir);\n    }\n\n    public static File downloadFile(final String artifactName, final String altUrl, final String defaultTempDir) {\n        final String cache = SystemInstance.isInitialized() ?\n            SystemInstance.get().getOptions().get(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, (String) null) :\n            System.getProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n        if (cache == null && defaultTempDir != null) { \n            System.setProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER, defaultTempDir);\n        }\n\n        try {\n            final File artifact = MavenCache.getArtifact(artifactName, altUrl);\n            if (artifact == null) {\n                throw new NullPointerException(String.format(\"No such artifact: %s\", artifactName));\n            }\n            return artifact.getAbsoluteFile();\n        } finally {\n            if (cache == null) {\n                System.clearProperty(ProvisioningResolver.OPENEJB_DEPLOYER_CACHE_FOLDER);\n            }\n        }\n    }\n\n    public static boolean isRunning(final String host, final int port) {\n        Socket socket = null;\n        try {\n            socket = new Socket(host, port);\n            socket.getOutputStream().close();\n            return true;\n        } catch (final Exception e) {\n            return false;\n        } finally {\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (final IOException ignored) {\n                    \n                }\n            }\n        }\n    }\n\n    public static void replace(final Map<String, String> replacements, final File file, final boolean escape) throws IOException {\n\n        InputStream in = IO.read(file);\n\n        if (escape) {\n            final Map<String, String> escaped = new HashMap<>();\n            for (final Map.Entry<String, String> entry : replacements.entrySet()) {\n                final String key = entry.getKey();\n                final String value = entry.getValue();\n                if (key.startsWith(\"\\\"\") && key.endsWith(\"\\\"\")) {\n                    escaped.put(key, value);\n                } else {\n                    escaped.put(\"\\\"\" + key + \"\\\"\", \"\\\"\" + value + \"\\\"\");\n                }\n            }\n\n            replacements.clear();\n            replacements.putAll(escaped);\n        }\n\n        in = new ReplaceStringsInputStream(in, replacements);\n\n        final String data = IO.slurp(in);\n\n        IO.copy(data.getBytes(), file);\n\n        if (LOGGER.isLoggable(Level.FINE)) {\n            IO.copy(data.getBytes(), System.out);\n        }\n    }\n\n    public static void removeUselessWebapps(final File tomeeHome, final String... exceptions) {\n        final File webapps = new File(tomeeHome, \"webapps\");\n        if (webapps.isDirectory()) {\n            final File[] files = webapps.listFiles();\n            if (files != null) {\n                for (final File webapp : files) {\n                    boolean delete = true;\n                    if (exceptions != null) {\n                        for (final String ignore : exceptions) {\n                            if (webapp.getName().equals(ignore)) {\n                                delete = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (delete) {\n                        org.apache.openejb.loader.Files.delete(webapp);\n                    }\n                }\n            }\n        }\n    }\n\n    public static void configureServerXml(final File tomeeHome, final TomEEConfiguration configuration) throws IOException {\n\n        if (configuration.getServerXml() != null) {\n\n            final File serverXml = new File(configuration.getServerXml());\n\n            if (!serverXml.exists()) {\n                LOGGER.severe(\"Provided server.xml doesn't exist: '\" + serverXml.getPath() + \"'\");\n            } else {\n\n                \n                final String data = IO.slurp(serverXml);\n\n                IO.copy(data.getBytes(), Files.path(tomeeHome, \"conf\", \"server.xml\"));\n            }\n        }\n        updateServerXml(tomeeHome, configuration);\n    }\n\n    private static int ajpPort(final TomEEConfiguration config) {\n        try {\n            final Method ajbPort = config.getClass().getMethod(\"getAjpPort\");\n            return (Integer) ajbPort.invoke(config);\n        } catch (final Exception e) {\n            return Integer.parseInt(QuickServerXmlParser.DEFAULT_AJP_PORT);\n        }\n    }\n\n    public static void configureSystemProperties(final File tomeeHome, final TomEEConfiguration configuration) {\n        final File file = Files.path(tomeeHome, \"conf\", \"system.properties\");\n\n        \n        final Properties properties = new Properties();\n\n        if (file.exists()) {\n            try {\n                IO.readProperties(file, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't read \" + file.getAbsolutePath(), e);\n            }\n        }\n\n        if (configuration.getProperties() != null) {\n            try {\n                final InputStream bytes = IO.read(configuration.getProperties().getBytes());\n                IO.readProperties(bytes, properties);\n            } catch (final IOException e) {\n                LOGGER.log(Level.SEVERE, \"Can't parse <property name=\\\"properties\\\"> value '\" + configuration.getProperties() + \"'\", e);\n            }\n        }\n\n        if (configuration.isQuickSession()) {\n            properties.put(\"openejb.session.manager\", \"org.apache.tomee.catalina.session.QuickSessionManager\");\n        }\n\n        try {\n            IO.writeProperties(file, properties);\n        } catch (final IOException e) {\n            LOGGER.log(Level.SEVERE, \"Can't save system properties \" + file.getAbsolutePath(), e);\n        }\n    }\n\n\n    public static void synchronizeFolder(final File tomeeHome, final String src, final String dir) {\n        if (src != null && !src.isEmpty()) {\n            final File confSrc = new File(src);\n            if (confSrc.exists()) {\n                final File conf = new File(tomeeHome, dir);\n                final Collection<File> files = org.apache.openejb.loader.Files.collect(confSrc, TrueFilter.INSTANCE);\n                files.remove(confSrc);\n                for (final File f : files) {\n                    if (f.equals(confSrc) || f.getName().startsWith(\".\")) {\n                        continue;\n                    }\n\n                    final String relativize = relativize(f, confSrc);\n                    if (f.isDirectory()) {\n                        final String path = dir + '/' + relativize;\n                        Files.mkdir(new File(tomeeHome, path));\n                        synchronizeFolder(tomeeHome, f.getAbsolutePath(), path);\n                    } else {\n                        try {\n                            final File to = new File(conf, relativize);\n                            Files.mkdir(to.getParentFile());\n                            org.apache.openejb.loader.IO.copy(f, to);\n                        } catch (final Exception e) {\n                            LOGGER.log(Level.WARNING, \"Ignoring copy of \" + f.getAbsolutePath(), e);\n                        }\n                    }\n                }\n            } else {\n                LOGGER.warning(\"Can't find \" + confSrc.getAbsolutePath());\n            }\n        }\n    }\n\n    private static String relativize(final File f, final File base) {\n        return f.getAbsolutePath().substring(base.getAbsolutePath().length() + 1);\n    }\n\n    public static void installArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        ShrinkWrap.create(JavaArchive.class, destination.getName())\n                .addClasses(BeanDicovererInstaller.class, TestClassDiscoverer.class, ArquillianFilterRunner.class, Discover.class)\n                .addAsManifestResource(new StringAsset(BeanDicovererInstaller.class.getName()), ArchivePaths.create(\"org.apache.openejb.extension\"))\n                .as(ZipExporter.class).exportTo(destination, false);\n    }\n\n    public static void removeArquillianBeanDiscoverer(final File home) {\n        final File destination = new File(home, TOMEE_BEAN_DISCOVERER_JAR);\n        Files.delete(destination);\n    }\n\n    public static Map<File, String> addTomEELibraries(final File libFolder, final String additionalLibs, final boolean parseArgs) {\n        if (additionalLibs == null) {\n            return emptyMap();\n        }\n        final String libs = additionalLibs.trim();\n        if (libs.isEmpty()) {\n            return emptyMap();\n        }\n\n        try { \n            if (!SystemInstance.isInitialized()) {\n                SystemInstance.init(new Properties());\n            }\n        } catch (final Exception e) {\n            \n        }\n\n        final Map<File, String> configs = new HashMap<>();\n        for (final String lib : libs.split(\"\\n\")) {\n            final String trim = lib.trim();\n            if (trim.isEmpty() || trim.startsWith(\"#\")) {\n                continue;\n            }\n\n            final String args;\n            if (parseArgs) { \n                int argsIdx = trim.indexOf('=');\n                if (argsIdx < 0) {\n                    argsIdx = trim.indexOf('?');\n                }\n                if (argsIdx > 0) {\n                    args = trim.substring(argsIdx);\n                } else {\n                    args = \"\";\n                }\n            } else {\n                args = null;\n            }\n\n            final Set<String> locations = ProvisioningUtil.realLocation(trim);\n            for (final String location : locations) {\n                final File from = new File(location);\n                try {\n                    final File to = new File(libFolder, from.getName());\n                    org.apache.openejb.loader.IO.copy(from, to);\n                    if (args != null) {\n                        configs.put(to, args);\n                    }\n                } catch (final IOException e) {\n                    throw new IllegalArgumentException(e);\n                }\n            }\n        }\n        return configs;\n    }\n\n    private static class TrueFilter implements FileFilter {\n        private static final TrueFilter INSTANCE = new TrueFilter();\n\n        @Override\n        public boolean accept(final File pathname) {\n            return true;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "arquillian/arquillian-tomee-common/src/main/java/org/apache/openejb/arquillian/common/TomEEConfiguration.java",
    "code": "\npackage org.apache.openejb.arquillian.common;\n\n\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\nimport org.jboss.arquillian.container.spi.ConfigurationException;\nimport org.jboss.arquillian.container.spi.client.container.ContainerConfiguration;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\n\nimport static java.util.Arrays.asList;\n\n@SuppressWarnings(\"UnusedDeclaration\")\npublic class TomEEConfiguration implements ContainerConfiguration {\n\n    protected boolean exportConfAsSystemProperty;\n    protected int httpsPort = 8443;\n    protected int httpPort = 8080;\n    protected int stopPort = 8005;\n    protected String dir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-apache-tomee\";\n    protected String appWorkingDir = System.getProperty(\"java.io.tmpdir\") + \"/arquillian-tomee-app-working-dir\";\n    protected String host = \"localhost\";\n    protected String stopHost = \"localhost\"; \n    protected String stopCommand = \"SHUTDOWN\"; \n    protected String serverXml;\n    protected String portRange = \"\"; \n    protected String preloadClasses; \n    protected boolean quickSession = true;\n    protected boolean unpackWars = true;\n\n    protected String properties = \"\";\n    protected String webContextToUseWithEars;\n    protected boolean keepServerXmlAsThis;\n    protected boolean singleDumpByArchiveName;\n    protected Collection<String> singleDeploymentByArchiveName = Collections.emptyList();\n\n    public boolean isUnpackWars() {\n        return unpackWars;\n    }\n\n    public void setUnpackWars(final boolean unpackWars) {\n        this.unpackWars = unpackWars;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public int getHttpPort() {\n        return httpPort;\n    }\n\n    public void setHttpPort(final int httpPort) {\n        this.httpPort = httpPort;\n    }\n\n    public int getStopPort() {\n        return stopPort;\n    }\n\n    public void setStopPort(final int stopPort) {\n        this.stopPort = stopPort;\n    }\n\n    public String getDir() {\n        return dir;\n    }\n\n    public void setDir(final String dir) {\n        this.dir = dir;\n    }\n\n    public String getAppWorkingDir() {\n        return appWorkingDir;\n    }\n\n    public void setAppWorkingDir(final String appWorkingDir) {\n        this.appWorkingDir = appWorkingDir;\n    }\n\n    public void validate() throws ConfigurationException {\n    }\n\n    public boolean getExportConfAsSystemProperty() {\n        return exportConfAsSystemProperty;\n    }\n\n    public void setExportConfAsSystemProperty(final boolean exportConfAsSystemProperty) {\n        this.exportConfAsSystemProperty = exportConfAsSystemProperty;\n    }\n\n    public String getHost() {\n        return host;\n    }\n\n    public void setHost(final String host) {\n        this.host = host;\n    }\n\n    public String getServerXml() {\n        return serverXml;\n    }\n\n    public void setServerXml(final String serverXml) {\n        this.serverXml = serverXml;\n    }\n\n    public String getProperties() {\n        return properties;\n    }\n\n    @Multiline\n    public void setProperties(final String properties) {\n        this.properties = properties;\n    }\n\n    public String systemProperties() {\n        return properties.replaceAll(\"\\n *\", \"\\n\");\n    }\n\n    public String getPortRange() {\n        return portRange;\n    }\n\n    public void setPortRange(final String portRange) {\n        this.portRange = portRange;\n    }\n\n    public boolean isQuickSession() {\n        return quickSession;\n    }\n\n    public void setQuickSession(final boolean quickSession) {\n        this.quickSession = quickSession;\n    }\n\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (stopPort > 0) {\n            value.add(stopPort);\n        }\n        if (httpPort > 0) {\n            value.add(httpPort);\n        }\n        if (httpsPort > 0) {\n            value.add(httpsPort);\n        }\n        return toInts(value);\n    }\n\n    protected int[] toInts(final List<Integer> values) {\n        final int[] array = new int[values.size()];\n        for (int i = 0; i < array.length; i++) {\n            array[i] = values.get(i);\n        }\n        return array;\n    }\n\n    public String getStopHost() {\n        return stopHost;\n    }\n\n    public void setStopHost(final String stopHost) {\n        this.stopHost = stopHost;\n    }\n\n    public String getStopCommand() {\n        return stopCommand + Character.toString((char) 0); \n    }\n\n    public void setStopCommand(final String stopCommand) {\n        this.stopCommand = stopCommand;\n    }\n\n    public String getPreloadClasses() {\n        return preloadClasses;\n    }\n\n    public void setPreloadClasses(final String preloadClasses) {\n        this.preloadClasses = preloadClasses;\n    }\n\n    public String getWebContextToUseWithEars() {\n        return webContextToUseWithEars;\n    }\n\n    public void setWebContextToUseWithEars(final String webContextToUseWithEars) {\n        this.webContextToUseWithEars = webContextToUseWithEars;\n    }\n\n    public boolean getKeepServerXmlAsThis() {\n        return keepServerXmlAsThis;\n    }\n\n    public void setKeepServerXmlAsThis(final boolean keepServerXmlAsThis) {\n        this.keepServerXmlAsThis = keepServerXmlAsThis;\n    }\n\n    public boolean isSingleDumpByArchiveName() {\n        return singleDumpByArchiveName;\n    }\n\n    public void setSingleDumpByArchiveName(final boolean singleDumpByArchiveName) {\n        this.singleDumpByArchiveName = singleDumpByArchiveName;\n    }\n\n    public boolean isSingleDeploymentByArchiveName(final String name) {\n        return singleDeploymentByArchiveName.contains(name) || singleDeploymentByArchiveName.contains(\"*\") || singleDeploymentByArchiveName.contains(\"true\");\n    }\n\n    public void setSingleDeploymentByArchiveName(final String singleDeploymentByArchiveName) {\n        this.singleDeploymentByArchiveName = singleDeploymentByArchiveName == null || singleDeploymentByArchiveName.trim().isEmpty() ?\n                Collections.<String>emptyList() : new HashSet<String>(asList(singleDeploymentByArchiveName.split(\" *, *\")));\n        this.singleDumpByArchiveName = true; \n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "arquillian/arquillian-tomee-embedded/src/main/java/org/apache/openejb/arquillian/embedded/EmbeddedTomEEConfiguration.java",
    "code": "\npackage org.apache.openejb.arquillian.embedded;\n\nimport org.apache.openejb.OpenEJBRuntimeException;\nimport org.apache.openejb.arquillian.common.IO;\nimport org.apache.openejb.arquillian.common.Prefixes;\nimport org.apache.openejb.arquillian.common.TomEEConfiguration;\nimport org.jboss.arquillian.config.descriptor.api.Multiline;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n\n@Prefixes({\"tomee\", \"tomee.embedded\"})\npublic class EmbeddedTomEEConfiguration extends TomEEConfiguration {\n    private int httpsPort = 8443;\n    private boolean ssl;\n    private boolean withEjbRemote;\n    private String keystoreFile;\n    private String keystorePass;\n    private String keystoreType = \"JKS\";\n    private String clientAuth;\n    private String keyAlias;\n    private String sslProtocol;\n    private String users;\n    private String roles;\n    private boolean webResourcesCached = true;\n\n    public boolean isWebResourcesCached() {\n        return webResourcesCached;\n    }\n\n    public void setWebResourcesCached(final boolean webResourcesCached) {\n        this.webResourcesCached = webResourcesCached;\n    }\n\n    public boolean isWithEjbRemote() {\n        return withEjbRemote;\n    }\n\n    public void setWithEjbRemote(final boolean withEjbRemote) {\n        this.withEjbRemote = withEjbRemote;\n    }\n\n    public int getHttpsPort() {\n        return httpsPort;\n    }\n\n    public void setHttpsPort(final int httpsPort) {\n        this.httpsPort = httpsPort;\n    }\n\n    public boolean isSsl() {\n        return ssl;\n    }\n\n    public void setSsl(final boolean ssl) {\n        this.ssl = ssl;\n    }\n\n    public String getKeystoreFile() {\n        return keystoreFile;\n    }\n\n    public void setKeystoreFile(final String keystoreFile) {\n        this.keystoreFile = keystoreFile;\n    }\n\n    public String getKeystorePass() {\n        return keystorePass;\n    }\n\n    public void setKeystorePass(final String keystorePass) {\n        this.keystorePass = keystorePass;\n    }\n\n    public String getKeystoreType() {\n        return keystoreType;\n    }\n\n    public void setKeystoreType(final String keystoreType) {\n        this.keystoreType = keystoreType;\n    }\n\n    public String getClientAuth() {\n        return clientAuth;\n    }\n\n    public void setClientAuth(final String clientAuth) {\n        this.clientAuth = clientAuth;\n    }\n\n    public String getKeyAlias() {\n        return keyAlias;\n    }\n\n    public void setKeyAlias(final String keyAlias) {\n        this.keyAlias = keyAlias;\n    }\n\n    public String getSslProtocol() {\n        return sslProtocol;\n    }\n\n    public void setSslProtocol(final String sslProtocol) {\n        this.sslProtocol = sslProtocol;\n    }\n\n    public String getUsers() {\n        return users;\n    }\n\n    public Properties getUsersAsProperties() {\n        return toProperties(users);\n    }\n\n    @Multiline\n    public void setUsers(final String users) {\n        this.users = users;\n    }\n\n    public String getRoles() {\n        return roles;\n    }\n\n    public Properties getRolesAsProperties() {\n        return toProperties(roles);\n    }\n\n    @Multiline\n    public void setRoles(final String roles) {\n        this.roles = roles;\n    }\n\n    @Override\n    public int[] portsAlreadySet() {\n        final List<Integer> value = new ArrayList<Integer>();\n        if (getStopPort() > 0) {\n            value.add(getStopPort());\n        }\n        if (getHttpPort() > 0) {\n            value.add(getHttpPort());\n        }\n        if (getHttpsPort() > 0) {\n            value.add(getHttpsPort());\n        }\n        return toInts(value);\n    }\n\n    public Properties systemPropertiesAsProperties() {\n        if (properties == null || properties.isEmpty()) {\n            return new Properties();\n        }\n\n        return toProperties(properties);\n    }\n\n    private static Properties toProperties(final String value) {\n        if (value == null || value.isEmpty()) {\n            return null;\n        }\n\n        final Properties properties = new Properties();\n        final ByteArrayInputStream bais = new ByteArrayInputStream(value.getBytes());\n        try {\n            properties.load(bais);\n        } catch (final IOException e) {\n            throw new OpenEJBRuntimeException(e);\n        } finally {\n            try {\n                IO.close(bais);\n            } catch (final IOException ignored) {\n                \n            }\n        }\n        return properties;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 3,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "container/openejb-core/src/main/java/org/apache/openejb/core/rmi/BlacklistClassResolver.java",
    "code": "\npackage org.apache.openejb.core.rmi;\n\nimport java.io.ObjectStreamClass;\n\npublic class BlacklistClassResolver {\n    public static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver(\n        toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\",\n            \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\")),\n        toArray(System.getProperty(\"tomee.serialization.class.whitelist\")));\n\n    private final String[] blacklist;\n    private final String[] whitelist;\n\n    protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n        this.whitelist = whitelist;\n        this.blacklist = blacklist;\n    }\n\n    protected boolean isBlacklisted(final String name) {\n        return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n    }\n\n    public final ObjectStreamClass check(final ObjectStreamClass classDesc) {\n        check(classDesc.getName());\n        return classDesc;\n    }\n\n    public final String check(final String name) {\n        if (isBlacklisted(name)) {\n            throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n        }\n        return name;\n    }\n\n    private static String[] toArray(final String property) {\n        return property == null ? null : property.split(\" *, *\");\n    }\n\n    private static boolean contains(final String[] list, final String name) {\n        if (list != null) {\n            for (final String white : list) {\n                if (name.startsWith(white)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 4,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "container/openejb-core/src/test/java/org/apache/openejb/core/rmi/BlacklistClassResolverTest.java",
    "code": "\npackage org.apache.openejb.core.rmi;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class BlacklistClassResolverTest {\n    @Test\n    public void blacklistDefault() {\n        assertTrue(BlacklistClassResolver.DEFAULT.isBlacklisted(\"org.codehaus.groovy.runtime.Foo\"));\n        assertTrue(BlacklistClassResolver.DEFAULT.isBlacklisted(\"org.apache.commons.collections.functors.Foo\"));\n        assertTrue(BlacklistClassResolver.DEFAULT.isBlacklisted(\"org.apache.xalan.Foo\"));\n    }\n\n    @Test\n    public void implicitWhiteList() {\n        assertFalse(BlacklistClassResolver.DEFAULT.isBlacklisted(\"org.apache.tomee.Foo\"));\n    }\n\n    @Test\n    public void whiteList() {\n        assertFalse(new BlacklistClassResolver(null, new String[] { \"org.apache.xalan\" }).isBlacklisted(\"org.apache.xalan.Foo\"));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 5,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "server/openejb-client/src/main/java/org/apache/openejb/client/EjbObjectInputStream.java",
    "code": "\npackage org.apache.openejb.client;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectStreamClass;\nimport java.lang.reflect.Proxy;\n\n\npublic class EjbObjectInputStream extends ObjectInputStream {\n    private static final BlacklistClassResolver DEFAULT = new BlacklistClassResolver();\n\n    public EjbObjectInputStream(final InputStream in) throws IOException {\n        super(in);\n    }\n\n    @Override\n    protected Class<?> resolveClass(final ObjectStreamClass classDesc) throws IOException, ClassNotFoundException {\n        final String n = DEFAULT.check(classDesc.getName());\n        final ClassLoader classloader = getClassloader();\n        try {\n            return Class.forName(n, false, classloader);\n        } catch (ClassNotFoundException e) {\n\n            if (n.equals(\"boolean\")) {\n                return boolean.class;\n            }\n            if (n.equals(\"byte\")) {\n                return byte.class;\n            }\n            if (n.equals(\"char\")) {\n                return char.class;\n            }\n            if (n.equals(\"short\")) {\n                return short.class;\n            }\n            if (n.equals(\"int\")) {\n                return int.class;\n            }\n            if (n.equals(\"long\")) {\n                return long.class;\n            }\n            if (n.equals(\"float\")) {\n                return float.class;\n            }\n            if (n.equals(\"double\")) {\n                return double.class;\n            }\n\n            \n            return Class.forName(n, false, null);\n        }\n    }\n\n    @Override\n    protected Class resolveProxyClass(final String[] interfaces) throws IOException, ClassNotFoundException {\n        final Class[] cinterfaces = new Class[interfaces.length];\n        for (int i = 0; i < interfaces.length; i++) {\n            cinterfaces[i] = getClassloader().loadClass(interfaces[i]);\n        }\n\n        try {\n            return Proxy.getProxyClass(getClassloader(), cinterfaces);\n        } catch (IllegalArgumentException e) {\n            throw new ClassNotFoundException(null, e);\n        }\n    }\n\n    ClassLoader getClassloader() {\n        return Thread.currentThread().getContextClassLoader();\n    }\n\n    public static class BlacklistClassResolver {\n        private static final String[] WHITELIST = toArray(System.getProperty(\"tomee.serialization.class.whitelist\"));\n        private static final String[] BLACKLIST = toArray(System.getProperty(\n            \"tomee.serialization.class.blacklist\", \"org.codehaus.groovy.runtime.,org.apache.commons.collections.functors.,org.apache.xalan,java.lang.Process\"));\n\n        private final String[] blacklist;\n        private final String[] whitelist;\n\n        protected BlacklistClassResolver() {\n            this(BLACKLIST, WHITELIST);\n        }\n\n        protected BlacklistClassResolver(final String[] blacklist, final String[] whitelist) {\n            this.whitelist = whitelist;\n            this.blacklist = blacklist;\n        }\n\n        protected boolean isBlacklisted(final String name) {\n            return (whitelist != null && !contains(whitelist, name)) || contains(blacklist, name);\n        }\n\n        public final String check(final String name) {\n            if (isBlacklisted(name)) {\n                throw new SecurityException(name + \" is not whitelisted as deserialisable, prevented before loading.\");\n            }\n            return name;\n        }\n\n        private static String[] toArray(final String property) {\n            return property == null ? null : property.split(\" *, *\");\n        }\n\n        private static boolean contains(final String[] list, String name) {\n            if (list != null) {\n                for (final String white : list) {\n                    if (name.startsWith(white)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 34,
    "sub_id": 6,
    "code_id": 0,
    "human_patch": "https://github.com/apache/tomee/commit/58cdbbef9c77ab2b44870f9d606593b49cde76d9",
    "cve_id": "CVE-2015-8581",
    "cwe_id": "CWE-502",
    "filename": "tomee/tomee-common/src/main/java/org/apache/tomee/installer/Installer.java",
    "code": "\npackage org.apache.tomee.installer;\n\nimport org.apache.openejb.loader.Options;\nimport org.apache.openejb.loader.SystemInstance;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.jar.JarFile;\n\npublic class Installer implements InstallerInterface {\n    private final Alerts alerts = new Alerts();\n\n    private final Paths paths;\n    private Status status = Status.NONE;\n    private boolean force;\n\n    private static final boolean listenerInstalled;\n    private static final boolean agentInstalled;\n    static {\n        final Options opts = SystemInstance.get().getOptions();\n        \n        listenerInstalled = \"OpenEJBListener\".equals(opts.get(\"openejb.embedder.source\", \"\"))\n                || \"ServerListener\".equals(opts.get(\"openejb.embedder.source\", \"\"));\n\n        \n        agentInstalled = InstallerTools.invokeStaticNoArgMethod(\n                \"org.apache.openejb.javaagent.Agent\", \"getInstrumentation\") != null;\n    }\n\n    public static boolean isListenerInstalled() {\n        return listenerInstalled;\n    }\n\n    public static boolean isAgentInstalled() {\n        return agentInstalled;\n    }\n\n    public Installer(final Paths paths) {\n        this.paths = paths;\n\n        if (listenerInstalled && agentInstalled) {\n            status = Status.INSTALLED;\n        }\n    }\n\n    public Installer(final Paths paths, final boolean force) {\n        this(paths);\n        this.force = force;\n    }\n\n    @Override\n    public PathsInterface getPaths() {\n        return paths;\n    }\n\n    @Override\n    public Alerts getAlerts() {\n        return alerts;\n    }\n\n    @Override\n    public void reset() {\n        alerts.reset();\n    }\n\n    @Override\n    public Status getStatus() {\n        return status;\n    }\n\n    @Override\n    public void installAll() {\n        installListener();\n        installJavaagent();\n        installConfigFiles(false);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        \n        addTomEEJuli();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    \n    \n    private void addTomEEJuli() {\n        final File original = new File(paths.getCatalinaBinDir(), \"tomcat-juli.jar\");\n\n        final File juli = paths.findOpenEJBJar(\"tomee-juli\");\n        try {\n            Installers.copyFile(juli, new File(original.getAbsolutePath()));\n            if (!juli.delete()) { \n                juli.deleteOnExit();\n            }\n        } catch (final IOException e) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void addTomEEAdminConfInTomcatUsers() {\n        addTomEEAdminConfInTomcatUsers(false);\n    }\n\n    public void addTomEEAdminConfInTomcatUsers(final boolean securityActivated) {\n        \n        final String tomcatUsersXml = Installers.readAll(paths.getTomcatUsersXml(), alerts);\n\n        \n        if (tomcatUsersXml == null) {\n            return;\n        }\n\n        if (tomcatUsersXml.contains(\"tomee-admin\")) {\n            alerts.addWarning(\"Can't add tomee user to tomcat-users.xml\");\n            return;\n        }\n\n        \n        if (!Installers.backup(paths.getTomcatUsersXml(), alerts)) {\n            return;\n        }\n\n        \n        final String roleUserTags =\n                \"  <role rolename=\\\"tomee-admin\\\" />\\n\" +\n                        \"  <user username=\\\"tomee\\\" password=\\\"tomee\\\" roles=\\\"tomee-admin,manager-gui\\\" />\\n\";\n        final String content;\n        if (!securityActivated) {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI -->\\n\" +\n                            \"  <!--\\n\" +\n                            roleUserTags +\n                            \"  -->\\n\" +\n                            \"</tomcat-users>\\n\";\n        } else {\n            content =\n                    \"  <!-- Activate those lines to get access to TomEE GUI\\n -->\" +\n                            roleUserTags +\n                            \"</tomcat-users>\\n\";\n\n        }\n        final String newTomcatUsers = tomcatUsersXml.replace(\"</tomcat-users>\", content);\n\n        \n        if (Installers.writeAll(paths.getTomcatUsersXml(), newTomcatUsers, alerts)) {\n            alerts.addInfo(\"Add tomee user to tomcat-users.xml\");\n        }\n    }\n\n    public void installFull() {\n        installListener(\"org.apache.tomee.catalina.ServerListener\");\n        installJavaagent();\n\n        commentDeploymentDir();\n        installConfigFiles(true);\n\n        removeTomcatLibJar(\"annotations-api.jar\");\n        \n        addTomEEJuli(); \n        moveLibs();\n\n        addTomEEAdminConfInTomcatUsers();\n        addTomEELinkToTomcatHome();\n\n        workaroundOnBat();\n\n        if (!alerts.hasErrors()) {\n            status = Status.REBOOT_REQUIRED;\n        }\n    }\n\n    private void workaroundOnBat() {\n        final File setclasspath = new File(paths.getCatalinaBinDir(), \"setclasspath.bat\");\n        String bat = Installers.readAll(setclasspath, alerts);\n        if (bat == null || bat.contains(\" NOT DEFINED \") ) {\n            return;\n        }\n\n        \n        bat = bat \n                .replace(\"not \\\"%JRE_HOME%\\\" == \\\"\\\"\", \"DEFINED JRE_HOME\")\n                .replace(\"not \\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"DEFINED JAVA_HOME\")\n                .replace(\"not \\\"%_RUNJAVA%\\\" == \\\"\\\"\", \"DEFINED _RUNJAVA\")\n                .replace(\"not \\\"%_RUNJDB%\\\" == \\\"\\\"\", \"DEFINED _RUNJDB\")\n                .replace(\"\\\"%JAVA_HOME%\\\" == \\\"\\\"\", \"NOT DEFINED JAVA_HOME\");\n\n        \n        if (!Installers.writeAll(setclasspath, bat, alerts)) {\n            alerts.addInfo(\"Can't add workarounds for setclasspath.bat\");\n        }\n    }\n\n    private void removeTomcatLibJar(final String name) {\n        final File jar = new File(paths.getCatalinaLibDir(), name);\n        removeJar(jar);\n    }\n\n    private void commentDeploymentDir() {\n        final File tomeeXml = new File(paths.getCatalinaConfDir(), \"tomee.xml\");\n        if (!tomeeXml.exists()) {\n            Installers.writeAll(tomeeXml,\n                    \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n                            \"<tomee>\\n\" +\n                            \"  <!-- see http://tomee.apache.org/containers-and-resources.html -->\\n\\n\" +\n                            \"  <!-- activate next line to be able to deploy applications in apps -->\\n\" +\n                            \"  <!-- <Deployments dir=\\\"apps\\\" /> -->\\n\" +\n                            \"</tomee>\\n\", alerts);\n        }\n    }\n\n    private void addTomEELinkToTomcatHome() {\n        final File home = paths.getHome();\n        if(!home.exists()) {\n            return;\n        }\n        final String indeJsp = Installers.readAll(home, alerts);\n        if (indeJsp == null) {\n            return;\n        }\n\n        if (!indeJsp.contains(\"tomcatUrl\")) { \n            alerts.addWarning(\"webapps/ROOT/index.jsp was modified\");\n            return;\n        }\n\n        final String newIndeJsp = indeJsp.replaceFirst(\"<div id=\\\"actions\\\">\",\n                \"<div id=\\\"actions\\\">\\n\" +\n                        \"                    <div class=\\\"button\\\">\\n\" +\n                        \"                        <a class=\\\"container shadow\\\" href=\\\"/tomee\\\"><span>TomEE Gui</span></a>\\n\" +\n                        \"                    </div>\");\n        Installers.writeAll(home, newIndeJsp, alerts);\n    }\n\n    private void moveLibs() {\n        final File libs = paths.getCatalinaLibDir();\n        final File[] files = paths.getOpenEJBLibDir().listFiles();\n        if (files != null) {\n            for (final File file : files) {\n                if (file.isDirectory()) {\n                    continue;\n                }\n                if (!file.getName().endsWith(\".jar\")) {\n                    continue;\n                }\n\n                try {\n                    Installers.copyFile(file, new File(libs, file.getName()));\n                    if (!file.delete()) {\n                        file.deleteOnExit();\n                    }\n                    alerts.addInfo(\"Copy \" + file.getName() + \" to lib\");\n                } catch (final IOException e) {\n                    alerts.addError(\"Unable to \" + file.getName() + \" to Tomcat lib directory.  This will need to be \" +\n                            \"performed manually.\", e);\n                }\n            }\n        }\n    }\n\n    \n\n    private void removeJar(final File jar) {\n        if (jar.exists()) {\n            if (!jar.delete()) {\n                jar.deleteOnExit();\n            }\n            alerts.addInfo(\"Please restart the server or delete manually \" + jar.getName());\n        }\n    }\n\n    public void installListener() {\n        installListener(\"org.apache.tomee.loader.OpenEJBListener\");\n    }\n\n    public void installListener(final String listener) {\n        if (listenerInstalled && !force) {\n            \n            return;\n        }\n        boolean copyOpenEJBLoader = true;\n\n        \n        final File destination = new File(paths.getCatalinaLibDir(), paths.getOpenEJBTomcatLoaderJar().getName());\n        if (destination.exists()) {\n            if (paths.getOpenEJBTomcatLoaderJar().length() == destination.length()) {\n                copyOpenEJBLoader = false;\n            }\n        }\n        if (copyOpenEJBLoader) {\n            try {\n                Installers.copyFile(paths.getOpenEJBTomcatLoaderJar(), destination);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBTomcatLoaderJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB Tomcat loader jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n        \n        final String serverXmlOriginal = Installers.readAll(paths.getServerXmlFile(), alerts);\n\n        \n        if (serverXmlOriginal == null) {\n            return;\n        }\n\n        \n        if (serverXmlOriginal.contains(listener)) {\n            alerts.addWarning(\"OpenEJB Listener already declared in Tomcat server.xml file.\");\n            return;\n        }\n\n        \n        if (!Installers.backup(paths.getServerXmlFile(), alerts)) {\n            return;\n        }\n\n        \n        String newServerXml = null;\n        try {\n            newServerXml = Installers.replace(serverXmlOriginal,\n                    \"<Server\",\n                    \"<Server\",\n                    \">\",\n                    \">\\r\\n\" +\n                            \"  <!-- TomEE plugin for Tomcat -->\\r\\n\" +\n                            \"  <Listener className=\\\"\" + listener + \"\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error while adding listener to server.xml file\", e);\n        }\n\n        \n        try {\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"<Connector port=\\\"8080\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n\n            newServerXml = Installers.replace(newServerXml,\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"<Connector port=\\\"8443\\\"\",\n                    \"/>\",\n                    \"xpoweredBy=\\\"false\\\" server=\\\"Apache TomEE\\\" />\");\n        } catch (final IOException e) {\n            alerts.addError(\"Error adding server attribute to server.xml file\", e);\n        }\n\n        \n        if (Installers.writeAll(paths.getServerXmlFile(), newServerXml, alerts)) {\n            alerts.addInfo(\"Add OpenEJB listener to server.xml\");\n        }\n    }\n\n    \n    \n    \n    \n    public void installJavaagent() {\n        if (agentInstalled && !force) {\n            \n            return;\n        }\n\n        \n        \n        \n        boolean copyJavaagentJar = true;\n        final File javaagentJar = new File(paths.getCatalinaLibDir(), \"openejb-javaagent.jar\");\n        if (javaagentJar.exists()) {\n            if (paths.getOpenEJBJavaagentJar().length() == javaagentJar.length()) {\n                copyJavaagentJar = false;\n            }\n        }\n\n        if (copyJavaagentJar) {\n            try {\n                Installers.copyFile(paths.getOpenEJBJavaagentJar(), javaagentJar);\n                alerts.addInfo(\"Copy \" + paths.getOpenEJBJavaagentJar().getName() + \" to lib\");\n            } catch (final IOException e) {\n                alerts.addError(\"Unable to copy OpenEJB javaagent jar to Tomcat lib directory.  This will need to be performed manually.\", e);\n            }\n        }\n\n\n        \n        \n        \n\n        \n        final String catalinaShOriginal = Installers.readAll(paths.getCatalinaShFile(), alerts);\n\n        \n        if (catalinaShOriginal == null) {\n            return;\n        }\n\n        \n        if (catalinaShOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.sh file.\");\n            return;\n        }\n\n        \n        if (!Installers.backup(paths.getCatalinaShFile(), alerts)) {\n            return;\n        }\n\n        \n        String openejbJavaagentPath = paths.getCatalinaHomeDir().toURI().relativize(javaagentJar.toURI()).getPath();\n        final String newCatalinaSh = catalinaShOriginal.replace(\"# ----- Execute The Requested Command\",\n                \"# Add OpenEJB javaagent\\n\" +\n                        \"if [ -r \\\"$CATALINA_HOME\\\"/\" + openejbJavaagentPath + \" ]; then\\n\" +\n                        \"  JAVA_OPTS=\\\"\\\\\\\"-javaagent:$CATALINA_HOME/\" + openejbJavaagentPath + \"\\\\\\\" $JAVA_OPTS\\\"\\n\" +\n                        \"fi\\n\" +\n                        \"\\n\" +\n                        \"# ----- Execute The Requested Command\");\n\n        \n        if (Installers.writeAll(paths.getCatalinaShFile(), newCatalinaSh, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.sh\");\n        }\n\n        boolean isCatalinaShExecutable = paths.getCatalinaShFile().canExecute();\n        if(!isCatalinaShExecutable) {\n            try {\n                isCatalinaShExecutable = paths.getCatalinaShFile().setExecutable(true);\n            } catch (final SecurityException e) {\n                alerts.addWarning(\"Cannot change CatalinaSh executable attribute.\");\n            }\n        }\n        if(!isCatalinaShExecutable) {\n            alerts.addWarning(\"CatalinaSh is not executable.\");\n        }\n\n        \n        \n        \n\n        \n        final String catalinaBatOriginal = Installers.readAll(paths.getCatalinaBatFile(), alerts);\n\n        \n        if (catalinaBatOriginal == null) {\n            return;\n        }\n\n        \n        if (catalinaBatOriginal.contains(\"Add OpenEJB javaagent\")) {\n            alerts.addWarning(\"OpenEJB javaagent already declared in Tomcat catalina.bat file.\");\n            return;\n        }\n\n        \n        if (!Installers.backup(paths.getCatalinaBatFile(), alerts)) {\n            return;\n        }\n\n        \n        openejbJavaagentPath = openejbJavaagentPath.replace('/', '\\\\');\n        final String newCatalinaBat = catalinaBatOriginal.replace(\"rem ----- Execute The Requested Command\",\n                \"rem Add OpenEJB javaagent\\r\\n\" +\n                        \"if not exist \\\"%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" goto noOpenEJBJavaagent\\r\\n\" +\n                        \"set JAVA_OPTS=\\\"-javaagent:%CATALINA_HOME%\\\\\" + openejbJavaagentPath + \"\\\" %JAVA_OPTS%\\r\\n\" +\n                        \":noOpenEJBJavaagent\\r\\n\" +\n                        \"\\r\\n\" +\n                        \"rem ----- Execute The Requested Command\");\n\n        \n        if (Installers.writeAll(paths.getCatalinaBatFile(), newCatalinaBat, alerts)) {\n            alerts.addInfo(\"Add OpenEJB JavaAgent to catalina.bat\");\n        }\n    }\n\n    \n    public void installConfigFiles(final boolean builtIn) {\n        final File openejbCoreJar = paths.getOpenEJBCoreJar();\n        final File confDir = paths.getCatalinaConfDir();\n        final Alerts alerts = this.alerts;\n\n        if (openejbCoreJar == null) {\n            \n            return;\n        }\n        final JarFile coreJar;\n        try {\n            coreJar = new JarFile(openejbCoreJar);\n        } catch (final IOException e) {\n            return;\n        }\n\n        \n        \n        \n        final File openEjbXmlFile = new File(confDir, \"tomee.xml\");\n        if (!openEjbXmlFile.exists()) {\n            \n            final String openEjbXml = Installers.readEntry(coreJar, \"default.openejb.conf\", alerts);\n            if (openEjbXml != null) {\n                if (Installers.writeAll(openEjbXmlFile, openEjbXml.replace(\"<openejb>\", \"<tomee>\").replace(\"</openejb>\", \"</tomee>\"), alerts)) {\n                    alerts.addInfo(\"Copy tomee.xml to conf\");\n                }\n            }\n        }\n\n\n        \n        \n        \n        \n        final String openejbLoggingProps = \"################################\\r\\n\" +\n                \"# OpenEJB/TomEE specific loggers\\r\\n\" +\n                \"################################\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# ACTIVATE LEVEL/HANDLERS YOU WANT\\r\\n\" +\n                \"# IF YOU ACTIVATE 5tomee.org.apache.juli.FileHandler\\r\\n\" +\n                \"# ADD IT TO handlers LINE LIKE:\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# handlers = 1catalina.org.apache.juli.FileHandler, 2localhost.org.apache.juli.FileHandler, 3manager.org.apache.juli.FileHandler, 4host-manager.org.apache.juli.FileHandler, 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# LEVELS:\\r\\n\" +\n                \"# =======\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.options.level     = INFO\\r\\n\" +\n                \"# OpenEJB.server.level      = INFO\\r\\n\" +\n                \"# OpenEJB.startup.level     = INFO\\r\\n\" +\n                \"# OpenEJB.startup.service.level = WARNING\\r\\n\" +\n                \"# OpenEJB.startup.config.level = INFO\\r\\n\" +\n                \"# OpenEJB.hsql.level        = INFO\\r\\n\" +\n                \"# CORBA-Adapter.level       = WARNING\\r\\n\" +\n                \"# Transaction.level         = WARNING\\r\\n\" +\n                \"# org.apache.activemq.level = SEVERE\\r\\n\" +\n                \"# org.apache.geronimo.level = SEVERE\\r\\n\" +\n                \"# openjpa.level             = WARNING\\r\\n\" +\n                \"# OpenEJB.cdi.level         = INFO\\r\\n\" +\n                \"# org.apache.webbeans.level = INFO\\r\\n\" +\n                \"# org.apache.openejb.level = FINE\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# HANDLERS:\\r\\n\" +\n                \"# =========\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# OpenEJB.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.options.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.server.handlers      = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.handlers     = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.service.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.startup.config.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.hsql.handlers        = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# CORBA-Adapter.handlers       = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# Transaction.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.activemq.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.geronimo.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# openjpa.handlers             = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# OpenEJB.cdi.handlers         = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.webbeans.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"# org.apache.openejb.handlers = 5tomee.org.apache.juli.FileHandler, java.util.logging.ConsoleHandler\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# TOMEE HANDLER SAMPLE:\\r\\n\" +\n                \"# =====================\\r\\n\" +\n                \"#\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.level = FINEST\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.directory = ${catalina.base}/logs\\r\\n\" +\n                \"# 5tomee.org.apache.juli.FileHandler.prefix = tomee.\\r\\n\";\n        final File loggingPropsFile = new File(confDir, \"logging.properties\");\n        String newLoggingProps = null;\n        if (!loggingPropsFile.exists()) {\n            newLoggingProps = openejbLoggingProps;\n        } else {\n            final String loggingPropsOriginal = Installers.readAll(loggingPropsFile, alerts);\n            if (!loggingPropsOriginal.toLowerCase().contains(\"openejb\")) {\n                \n                newLoggingProps = loggingPropsOriginal +\n                        \"\\r\\n\\r\\n\" +\n                        openejbLoggingProps + \"\\r\\n\";\n            }\n        }\n        if (builtIn) {\n            installTomEEJuli(alerts, loggingPropsFile, newLoggingProps);\n        }\n\n        final File openejbSystemProperties = new File(confDir, \"system.properties\");\n        if (!openejbSystemProperties.exists()) {\n            FileWriter systemPropertiesWriter = null;\n            try {\n                systemPropertiesWriter = new FileWriter(openejbSystemProperties);\n\n                systemPropertiesWriter.write(\"# all this properties are added at JVM system properties at startup\\n\");\n                systemPropertiesWriter.write(\"# here some default Apache TomEE system properties\\n\");\n                systemPropertiesWriter.write(\"# for more information please see http://tomee.apache.org/properties-listing.html\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.check.classloader.verbose = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.subcontext = webservices\\n\");\n                systemPropertiesWriter.write(\"# tomee.jaxws.oldsubcontext = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# if you want to propagate a deployment on a cluster when a tomcat cluster is defined\\n\");\n                systemPropertiesWriter.write(\"# tomee.cluster.deployment = false\\n\");\n\n                systemPropertiesWriter.write(\"\\n\");\n                systemPropertiesWriter.write(\"# openejb.system.apps = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.servicemanager.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.descriptors.output = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.strict.interface.declaration = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.conf.file = conf/tomee.xml\\n\");\n                systemPropertiesWriter.write(\"# openejb.debuggable-vm-hackery = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.skip = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.webservices.enabled = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.validation.output.level = MEDIUM\\n\");\n                systemPropertiesWriter.write(\"# openejb.user.mbeans.list = *\\n\");\n                systemPropertiesWriter.write(\"# openejb.deploymentId.format = {appId}/{ejbJarId}/{ejbName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.format = {deploymentId}{interfaceType.annotationName}\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.include = .*\\n\");\n                systemPropertiesWriter.write(\"# openejb.deployments.package.exclude = \\n\");\n                systemPropertiesWriter.write(\"# openejb.autocreate.jta-datasource-from-non-jta-one = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.altdd.prefix = \\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.default.system.interceptors = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jndiname.failoncollision = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.wsAddress.format = /{ejbDeploymentId}\\n\");\n                systemPropertiesWriter.write(\"# org.apache.openejb.server.webservices.saaj.provider = \\n\");\n                systemPropertiesWriter.write(\"# openejb.nobanner = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.offline = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jmx.active = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.exclude-include.order = include-exclude\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.exclude =\\n\");\n                systemPropertiesWriter.write(\"# openejb.additional.include =\\n\");\n                systemPropertiesWriter.write(\"# openejb.crosscontext = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.jsessionid-support = \\n\");\n                systemPropertiesWriter.write(\"# openejb.myfaces.disable-default-values = true\\n\");\n                systemPropertiesWriter.write(\"# openejb.web.xml.major = \\n\");\n                systemPropertiesWriter.write(\"# openjpa.Log = \\n\");\n                systemPropertiesWriter.write(\"# openejb.jdbc.log = false\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.provider = org.apache.openjpa.persistence.PersistenceProviderImpl\\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.transactionType = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.jtaDataSource = \\n\");\n                systemPropertiesWriter.write(\"# javax.persistence.nonJtaDataSource = \\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# Properties for JAS RS\\n\");\n                systemPropertiesWriter.write(\"# openejb.jaxrs.application = \\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreRequests = false\\n\");\n                systemPropertiesWriter.write(\"# openejb.cxf-rs.wadl-generator.ignoreMessageWriters = true\\n\");\n\n                systemPropertiesWriter.write(\"#\\n\");\n                systemPropertiesWriter.write(\"# These properties are only for cxf service (SOAP webservices) and TomEE+\\n\");\n                systemPropertiesWriter.write(\"# If you don't use special tricks and sun default implementation, uncommenting these 4 lines forces TomEE to use it without overhead at all = \\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MessageFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPMessageFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPFactory = com.sun.xml.messaging.saaj.soap.ver1_1.SOAPFactory1_1Impl\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.SOAPConnectionFactory = com.sun.xml.messaging.saaj.client.p2p.HttpSOAPConnectionFactory\\n\");\n                systemPropertiesWriter.write(\"# javax.xml.soap.MetaFactory = com.sun.xml.messaging.saaj.soap.SAAJMetaFactoryImpl\\n\");\n            } catch (final IOException e) {\n                \n            } finally {\n                if (systemPropertiesWriter != null) {\n                    try {\n                        systemPropertiesWriter.close();\n                    } catch (final IOException e) {\n                        \n                    }\n                }\n            }\n        }\n\n        \n        \n        \n        final JarFile openejbTomcatCommonJar;\n        try {\n            openejbTomcatCommonJar = new JarFile(paths.geOpenEJBTomcatCommonJar());\n        } catch (final IOException e) {\n            return;\n        }\n        final File webXmlFile = new File(confDir, \"web.xml\");\n        final String webXml = Installers.readEntry(openejbTomcatCommonJar, \"conf/web.xml\", alerts);\n        if (Installers.writeAll(webXmlFile, webXml, alerts)) {\n            alerts.addInfo(\"Set jasper in production mode in TomEE web.xml\");\n        }\n    }\n\n    private void installTomEEJuli(final Alerts alerts, final File loggingPropsFile, final String newLoggingProps) {\n        if (newLoggingProps != null && Installers.writeAll(\n                loggingPropsFile,\n                newLoggingProps.replace(\"java.util.logging.ConsoleHandler\", \"org.apache.tomee.jul.formatter.AsyncConsoleHandler\"),\n                alerts)) {\n            alerts.addInfo(\"Append OpenEJB config to logging.properties\");\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 35,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/apereo/java-cas-client/commit/ab6cbdc3daa451b4fef89c0bd0f4e6568f3aa9ef",
    "cve_id": "CVE-2014-4172",
    "cwe_id": "CWE-74",
    "filename": "cas-client-core/src/main/java/org/jasig/cas/client/validation/AbstractUrlBasedTicketValidator.java",
    "code": "\npackage org.jasig.cas.client.validation;\n\nimport java.io.UnsupportedEncodingException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.jasig.cas.client.ssl.HttpURLConnectionFactory;\nimport org.jasig.cas.client.ssl.HttpsURLConnectionFactory;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n\npublic abstract class AbstractUrlBasedTicketValidator implements TicketValidator {\n\n    protected final Logger logger = LoggerFactory.getLogger(getClass());\n\n    \n    private HttpURLConnectionFactory urlConnectionFactory = new HttpsURLConnectionFactory();\n\n    \n    private final String casServerUrlPrefix;\n\n    \n    private boolean renew;\n\n    \n    private Map<String, String> customParameters;\n\n    private String encoding;\n\n    \n    protected AbstractUrlBasedTicketValidator(final String casServerUrlPrefix) {\n        this.casServerUrlPrefix = casServerUrlPrefix;\n        CommonUtils.assertNotNull(this.casServerUrlPrefix, \"casServerUrlPrefix cannot be null.\");\n    }\n\n    \n    protected void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        \n    }\n\n    \n    protected abstract String getUrlSuffix();\n\n    \n    protected abstract void setDisableXmlSchemaValidation(boolean disabled);\n\n    \n    protected final String constructValidationUrl(final String ticket, final String serviceUrl) {\n        final Map<String, String> urlParameters = new HashMap<String, String>();\n\n        logger.debug(\"Placing URL parameters in map.\");\n        urlParameters.put(\"ticket\", ticket);\n        urlParameters.put(\"service\", encodeUrl(serviceUrl));\n\n        if (this.renew) {\n            urlParameters.put(\"renew\", \"true\");\n        }\n\n        logger.debug(\"Calling template URL attribute map.\");\n        populateUrlAttributeMap(urlParameters);\n\n        logger.debug(\"Loading custom parameters from configuration.\");\n        if (this.customParameters != null) {\n            urlParameters.putAll(this.customParameters);\n        }\n\n        final String suffix = getUrlSuffix();\n        final StringBuilder buffer = new StringBuilder(urlParameters.size() * 10 + this.casServerUrlPrefix.length()\n                + suffix.length() + 1);\n\n        int i = 0;\n\n        buffer.append(this.casServerUrlPrefix);\n        if (!this.casServerUrlPrefix.endsWith(\"/\")) {\n            buffer.append(\"/\");\n        }\n        buffer.append(suffix);\n\n        for (Map.Entry<String, String> entry : urlParameters.entrySet()) {\n            final String key = entry.getKey();\n            final String value = entry.getValue();\n\n            if (value != null) {\n                buffer.append(i++ == 0 ? \"?\" : \"&\");\n                buffer.append(key);\n                buffer.append(\"=\");\n                buffer.append(value);\n            }\n        }\n\n        return buffer.toString();\n\n    }\n\n    \n    protected final String encodeUrl(final String url) {\n        if (url == null) {\n            return null;\n        }\n\n        try {\n            return URLEncoder.encode(url, \"UTF-8\");\n        } catch (final UnsupportedEncodingException e) {\n            return url;\n        }\n    }\n\n    \n    protected abstract Assertion parseResponseFromServer(final String response) throws TicketValidationException;\n\n    \n\n    protected abstract String retrieveResponseFromServer(URL validationUrl, String ticket);\n\n    public final Assertion validate(final String ticket, final String service) throws TicketValidationException {\n        final String validationUrl = constructValidationUrl(ticket, service);\n        logger.debug(\"Constructing validation url: {}\", validationUrl);\n\n        try {\n            logger.debug(\"Retrieving response from server.\");\n            final String serverResponse = retrieveResponseFromServer(new URL(validationUrl), ticket);\n\n            if (serverResponse == null) {\n                throw new TicketValidationException(\"The CAS server returned no response.\");\n            }\n\n            logger.debug(\"Server response: {}\", serverResponse);\n\n            return parseResponseFromServer(serverResponse);\n        } catch (final MalformedURLException e) {\n            throw new TicketValidationException(e);\n        }\n    }\n\n    public final void setRenew(final boolean renew) {\n        this.renew = renew;\n    }\n\n    public final void setCustomParameters(final Map<String, String> customParameters) {\n        this.customParameters = customParameters;\n    }\n\n    public final void setEncoding(final String encoding) {\n        this.encoding = encoding;\n    }\n\n    protected final String getEncoding() {\n        return this.encoding;\n    }\n\n    protected final boolean isRenew() {\n        return this.renew;\n    }\n\n    protected final String getCasServerUrlPrefix() {\n        return this.casServerUrlPrefix;\n    }\n\n    protected final Map<String, String> getCustomParameters() {\n        return this.customParameters;\n    }\n\n    protected HttpURLConnectionFactory getURLConnectionFactory() {\n        return this.urlConnectionFactory;\n    }\n\n    public void setURLConnectionFactory(final HttpURLConnectionFactory urlConnectionFactory) {\n        this.urlConnectionFactory = urlConnectionFactory;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 35,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/apereo/java-cas-client/commit/ab6cbdc3daa451b4fef89c0bd0f4e6568f3aa9ef",
    "cve_id": "CVE-2014-4172",
    "cwe_id": "CWE-74",
    "filename": "cas-client-core/src/main/java/org/jasig/cas/client/validation/Cas20ServiceTicketValidator.java",
    "code": "\npackage org.jasig.cas.client.validation;\n\nimport java.io.StringReader;\nimport java.util.*;\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport org.jasig.cas.client.authentication.AttributePrincipal;\nimport org.jasig.cas.client.authentication.AttributePrincipalImpl;\nimport org.jasig.cas.client.proxy.Cas20ProxyRetriever;\nimport org.jasig.cas.client.proxy.ProxyGrantingTicketStorage;\nimport org.jasig.cas.client.proxy.ProxyRetriever;\nimport org.jasig.cas.client.util.CommonUtils;\nimport org.jasig.cas.client.util.XmlUtils;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\n\n\npublic class Cas20ServiceTicketValidator extends AbstractCasProtocolUrlBasedTicketValidator {\n\n    \n    private String proxyCallbackUrl;\n\n    \n    private ProxyGrantingTicketStorage proxyGrantingTicketStorage;\n\n    \n    private ProxyRetriever proxyRetriever;\n\n    \n    public Cas20ServiceTicketValidator(final String casServerUrlPrefix) {\n        super(casServerUrlPrefix);\n        this.proxyRetriever = new Cas20ProxyRetriever(casServerUrlPrefix, getEncoding(), getURLConnectionFactory());\n    }\n\n    \n    protected final void populateUrlAttributeMap(final Map<String, String> urlParameters) {\n        urlParameters.put(\"pgtUrl\", encodeUrl(this.proxyCallbackUrl));\n    }\n\n    protected String getUrlSuffix() {\n        return \"serviceValidate\";\n    }\n\n    protected final Assertion parseResponseFromServer(final String response) throws TicketValidationException {\n        final String error = XmlUtils.getTextForElement(response, \"authenticationFailure\");\n\n        if (CommonUtils.isNotBlank(error)) {\n            throw new TicketValidationException(error);\n        }\n\n        final String principal = XmlUtils.getTextForElement(response, \"user\");\n        final String proxyGrantingTicketIou = XmlUtils.getTextForElement(response, \"proxyGrantingTicket\");\n\n        final String proxyGrantingTicket;\n        if (CommonUtils.isBlank(proxyGrantingTicketIou) || this.proxyGrantingTicketStorage == null) {\n            proxyGrantingTicket = null;\n        } else {\n            proxyGrantingTicket = this.proxyGrantingTicketStorage.retrieve(proxyGrantingTicketIou);\n        }\n\n        if (CommonUtils.isEmpty(principal)) {\n            throw new TicketValidationException(\"No principal was found in the response from the CAS server.\");\n        }\n\n        final Assertion assertion;\n        final Map<String, Object> attributes = extractCustomAttributes(response);\n        if (CommonUtils.isNotBlank(proxyGrantingTicket)) {\n            final AttributePrincipal attributePrincipal = new AttributePrincipalImpl(principal, attributes,\n                    proxyGrantingTicket, this.proxyRetriever);\n            assertion = new AssertionImpl(attributePrincipal);\n        } else {\n            assertion = new AssertionImpl(new AttributePrincipalImpl(principal, attributes));\n        }\n\n        customParseResponse(response, assertion);\n\n        return assertion;\n    }\n\n    \n    protected Map<String, Object> extractCustomAttributes(final String xml) {\n        final SAXParserFactory spf = SAXParserFactory.newInstance();\n        spf.setNamespaceAware(true);\n        spf.setValidating(false);\n        try {\n            final SAXParser saxParser = spf.newSAXParser();\n            final XMLReader xmlReader = saxParser.getXMLReader();\n            final CustomAttributeHandler handler = new CustomAttributeHandler();\n            xmlReader.setContentHandler(handler);\n            xmlReader.parse(new InputSource(new StringReader(xml)));\n            return handler.getAttributes();\n        } catch (final Exception e) {\n            logger.error(e.getMessage(), e);\n            return Collections.emptyMap();\n        }\n    }\n\n    \n    protected void customParseResponse(final String response, final Assertion assertion)\n            throws TicketValidationException {\n        \n    }\n\n    public final void setProxyCallbackUrl(final String proxyCallbackUrl) {\n        this.proxyCallbackUrl = proxyCallbackUrl;\n    }\n\n    public final void setProxyGrantingTicketStorage(final ProxyGrantingTicketStorage proxyGrantingTicketStorage) {\n        this.proxyGrantingTicketStorage = proxyGrantingTicketStorage;\n    }\n\n    public final void setProxyRetriever(final ProxyRetriever proxyRetriever) {\n        this.proxyRetriever = proxyRetriever;\n    }\n\n    protected final String getProxyCallbackUrl() {\n        return this.proxyCallbackUrl;\n    }\n\n    protected final ProxyGrantingTicketStorage getProxyGrantingTicketStorage() {\n        return this.proxyGrantingTicketStorage;\n    }\n\n    protected final ProxyRetriever getProxyRetriever() {\n        return this.proxyRetriever;\n    }\n\n    private class CustomAttributeHandler extends DefaultHandler {\n\n        private Map<String, Object> attributes;\n\n        private boolean foundAttributes;\n\n        private String currentAttribute;\n\n        private StringBuilder value;\n\n        @Override\n        public void startDocument() throws SAXException {\n            this.attributes = new HashMap<String, Object>();\n        }\n\n        @Override\n        public void startElement(final String namespaceURI, final String localName, final String qName,\n                final Attributes attributes) throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = true;\n            } else if (this.foundAttributes) {\n                this.value = new StringBuilder();\n                this.currentAttribute = localName;\n            }\n        }\n\n        @Override\n        public void characters(final char[] chars, final int start, final int length) throws SAXException {\n            if (this.currentAttribute != null) {\n                value.append(chars, start, length);\n            }\n        }\n\n        @Override\n        public void endElement(final String namespaceURI, final String localName, final String qName)\n                throws SAXException {\n            if (\"attributes\".equals(localName)) {\n                this.foundAttributes = false;\n                this.currentAttribute = null;\n            } else if (this.foundAttributes) {\n                final Object o = this.attributes.get(this.currentAttribute);\n\n                if (o == null) {\n                    this.attributes.put(this.currentAttribute, this.value.toString());\n                } else {\n                    final List<Object> items;\n                    if (o instanceof List) {\n                        items = (List<Object>) o;\n                    } else {\n                        items = new LinkedList<Object>();\n                        items.add(o);\n                        this.attributes.put(this.currentAttribute, items);\n                    }\n                    items.add(this.value.toString());\n                }\n            }\n        }\n\n        public Map<String, Object> getAttributes() {\n            return this.attributes;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 35,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/apereo/java-cas-client/commit/ab6cbdc3daa451b4fef89c0bd0f4e6568f3aa9ef",
    "cve_id": "CVE-2014-4172",
    "cwe_id": "CWE-74",
    "filename": "cas-client-core/src/test/java/org/jasig/cas/client/validation/Cas10TicketValidatorTests.java",
    "code": "\npackage org.jasig.cas.client.validation;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.fail;\nimport java.io.UnsupportedEncodingException;\nimport org.jasig.cas.client.PublicTestHttpServer;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic final class Cas10TicketValidatorTests extends AbstractTicketValidatorTests {\n\n    private static final PublicTestHttpServer server = PublicTestHttpServer.instance(8090);\n\n    private Cas10TicketValidator ticketValidator;\n\n    public Cas10TicketValidatorTests() {\n        super();\n    }\n\n    \n\n    @Before\n    public void setUp() throws Exception {\n        this.ticketValidator = new Cas10TicketValidator(CONST_CAS_SERVER_URL_PREFIX + \"8090\");\n    }\n\n    @Test\n    public void testNoResponse() throws Exception {\n        server.content = \"no\\n\\n\".getBytes(server.encoding);\n        try {\n            this.ticketValidator.validate(\"testTicket\", \"myService\");\n            fail(\"ValidationException expected.\");\n        } catch (final TicketValidationException e) {\n            \n        }\n    }\n\n    @Test\n    public void testYesResponse() throws TicketValidationException, UnsupportedEncodingException {\n        server.content = \"yes\\nusername\\n\\n\".getBytes(server.encoding);\n        final Assertion assertion = this.ticketValidator.validate(\"testTicket\", \"myService\");\n        assertEquals(CONST_USERNAME, assertion.getPrincipal().getName());\n    }\n\n    @Test\n    public void testBadResponse() throws UnsupportedEncodingException {\n        server.content = \"falalala\\n\\n\".getBytes(server.encoding);\n        try {\n            this.ticketValidator.validate(\"testTicket\", \"myService\");\n            fail(\"ValidationException expected.\");\n        } catch (final TicketValidationException e) {\n            \n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 36,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/cloudfoundry/uaa/commit/a61bfabbad22f646ecf1f00016b448b26a60daf",
    "cve_id": "CVE-2018-1192",
    "cwe_id": "CWE-200",
    "filename": "server/src/main/java/org/cloudfoundry/identity/uaa/authentication/UaaAuthenticationDetails.java",
    "code": "\npackage org.cloudfoundry.identity.uaa.authentication;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport org.bouncycastle.util.encoders.Base64;\nimport org.springframework.security.web.authentication.WebAuthenticationDetails;\nimport org.springframework.util.StringUtils;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.Serializable;\n\n\npublic class UaaAuthenticationDetails implements Serializable {\n\n    public static final String ADD_NEW = \"add_new\";\n\n    public static final UaaAuthenticationDetails UNKNOWN = new UaaAuthenticationDetails();\n\n    private boolean addNew;\n\n    private final String origin;\n\n    private String sessionId;\n\n    private String clientId;\n\n    private UaaAuthenticationDetails() {\n        this.origin = \"unknown\";\n        this.sessionId = \"unknown\";\n        this.clientId = \"unknown\";\n    }\n\n    public UaaAuthenticationDetails(HttpServletRequest request) {\n        this(request, null);\n    }\n    public UaaAuthenticationDetails(HttpServletRequest request, String clientId) {\n        WebAuthenticationDetails webAuthenticationDetails = new WebAuthenticationDetails(request);\n        this.origin = webAuthenticationDetails.getRemoteAddress();\n        this.sessionId = webAuthenticationDetails.getSessionId();\n\n        if (clientId == null) {\n            this.clientId = request.getParameter(\"client_id\");\n            if(!StringUtils.hasText(this.clientId)) {\n                String authHeader = request.getHeader(\"Authorization\");\n                if(StringUtils.hasText(authHeader) && authHeader.startsWith(\"Basic \")) {\n                    String decodedCredentials = new String(Base64.decode(authHeader.substring(\"Basic \".length())));\n                    String[] split = decodedCredentials.split(\":\");\n                    this.clientId = split[0];\n                }\n            }\n        } else {\n            this.clientId = clientId;\n        }\n        this.addNew = Boolean.parseBoolean(request.getParameter(ADD_NEW));\n    }\n\n    public UaaAuthenticationDetails(@JsonProperty(\"addNew\") boolean addNew,\n                                    @JsonProperty(\"clientId\") String clientId,\n                                    @JsonProperty(\"origin\") String origin,\n                                    @JsonProperty(\"sessionId\") String sessionId) {\n        this.addNew = addNew;\n        this.clientId = clientId;\n        this.origin = origin;\n        this.sessionId = sessionId;\n    }\n\n    public String getOrigin() {\n        return origin;\n    }\n\n    public String getSessionId() {\n        return sessionId;\n    }\n\n    public String getClientId() {\n        return clientId;\n    }\n\n    public boolean isAddNew() {\n        return addNew;\n    }\n\n    public void setAddNew(boolean addNew) {\n        this.addNew = addNew;\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (origin != null) {\n            sb.append(\"remoteAddress=\").append(origin);\n        }\n        if (clientId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"clientId=\").append(clientId);\n        }\n        if (sessionId != null) {\n            if (sb.length() > 0) {\n                sb.append(\", \");\n            }\n            sb.append(\"sessionId=\").append(sessionId);\n        }\n        return sb.toString();\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((clientId == null) ? 0 : clientId.hashCode());\n        result = prime * result + ((origin == null) ? 0 : origin.hashCode());\n        result = prime * result + ((sessionId == null) ? 0 : sessionId.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass() != obj.getClass())\n            return false;\n        UaaAuthenticationDetails other = (UaaAuthenticationDetails) obj;\n        if (clientId == null) {\n            if (other.clientId != null)\n                return false;\n        }\n        else if (!clientId.equals(other.clientId))\n            return false;\n        if (origin == null) {\n            if (other.origin != null)\n                return false;\n        }\n        else if (!origin.equals(other.origin))\n            return false;\n        if (sessionId == null) {\n            if (other.sessionId != null)\n                return false;\n        }\n        else if (!sessionId.equals(other.sessionId))\n            return false;\n        return true;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 37,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/cloudfoundry/uaa/commit/daeedbe499453b06856556f5e9f7e80d2d1ceb03",
    "cve_id": "CVE-2019-3775",
    "cwe_id": "CWE-287",
    "filename": "server/src/main/java/org/cloudfoundry/identity/uaa/security/ScimUserSelfUpdateAllowed.java",
    "code": "package org.cloudfoundry.identity.uaa.security;\n\nimport org.apache.commons.io.IOUtils;\nimport org.cloudfoundry.identity.uaa.scim.ScimUser;\nimport org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;\nimport org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;\nimport org.cloudfoundry.identity.uaa.util.JsonUtils;\nimport org.cloudfoundry.identity.uaa.util.UaaUrlUtils;\nimport org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\npublic class ScimUserSelfUpdateAllowed {\n\n    public static final int USER_ID_PATH_PARAMETER_INDEX = 1;\n    private ScimUserProvisioning scimUserProvisioning;\n\n    public ScimUserSelfUpdateAllowed(ScimUserProvisioning scimUserProvisioning) {\n        this.scimUserProvisioning = scimUserProvisioning;\n    }\n\n    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 37,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/cloudfoundry/uaa/commit/daeedbe499453b06856556f5e9f7e80d2d1ceb03",
    "cve_id": "CVE-2019-3775",
    "cwe_id": "CWE-287",
    "filename": "server/src/test/java/org/cloudfoundry/identity/uaa/security/ScimUserSelfUpdateAllowedTest.java",
    "code": "package org.cloudfoundry.identity.uaa.security;\n\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.cloudfoundry.identity.uaa.scim.ScimUser;\nimport org.cloudfoundry.identity.uaa.scim.ScimUserProvisioning;\nimport org.cloudfoundry.identity.uaa.scim.exception.ScimResourceNotFoundException;\nimport org.cloudfoundry.identity.uaa.util.JsonUtils;\nimport org.cloudfoundry.identity.uaa.zone.IdentityZone;\nimport org.cloudfoundry.identity.uaa.zone.IdentityZoneHolder;\nimport org.cloudfoundry.identity.uaa.zone.MultitenancyFixture;\nimport org.junit.jupiter.api.AfterEach;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Nested;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\nimport org.springframework.mock.web.MockHttpServletRequest;\n\nimport java.io.IOException;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.mockito.ArgumentMatchers.anyString;\nimport static org.mockito.Mockito.*;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n\nclass ScimUserSelfUpdateAllowedTest {\n    private ScimUserSelfUpdateAllowed scimUserSelfUpdateAllowed;\n    private MockHttpServletRequest httpRequest;\n    private ScimUserProvisioning mockScimUserProvisioning;\n    private ScimUser scimUserFromRequest;\n    private ScimUser scimUserFromDB;\n    private IdentityZone identityZone;\n    private String scimUserID;\n\n    @BeforeEach\n    void setUp() {\n        httpRequest = new MockHttpServletRequest();\n\n        mockScimUserProvisioning = mock(ScimUserProvisioning.class);\n        scimUserSelfUpdateAllowed = new ScimUserSelfUpdateAllowed(mockScimUserProvisioning);\n\n        scimUserFromRequest = new ScimUser();\n        scimUserID = RandomStringUtils.randomAlphabetic(5);\n        scimUserFromRequest.setUserName(\"originalUserName\");\n        scimUserFromRequest.setPrimaryEmail(\"originalEmail@uaa.com\");\n        ScimUser.Name scimUserName = new ScimUser.Name(\"originalGivenName\", \"originalFamilyName\");\n        scimUserFromRequest.setName(scimUserName);\n        scimUserFromRequest.setVerified(false);\n        scimUserFromRequest.setActive(false);\n        scimUserFromRequest.setOrigin(\"originalOrigin\");\n        httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n\n\n        scimUserFromDB = new ScimUser();\n        scimUserFromDB.setId(scimUserID);\n        scimUserFromDB.setUserName(\"originalUserName\");\n        scimUserFromDB.setPrimaryEmail(\"originalEmail@uaa.com\");\n        ScimUser.Name scimUserNameFromDB = new ScimUser.Name(\"originalGivenName\", \"originalFamilyName\");\n        scimUserFromDB.setName(scimUserNameFromDB);\n        scimUserFromDB.setVerified(false);\n        scimUserFromDB.setActive(false);\n        scimUserFromDB.setOrigin(\"originalOrigin\");\n\n        identityZone = MultitenancyFixture.identityZone(RandomStringUtils.randomAlphabetic(5), RandomStringUtils.randomAlphabetic(5));\n        IdentityZoneHolder.set(identityZone);\n\n        when(mockScimUserProvisioning.retrieve(scimUserID, identityZone.getId())).thenReturn(scimUserFromDB);\n        httpRequest.setPathInfo(\"/Users/\" + scimUserID);\n    }\n\n    @Nested\n    class WithInternalUserStoreEnabled {\n        @ParameterizedTest\n        @ValueSource(strings = {\"PUT\", \"PATCH\"})\n        public void isAllowedToUpdateScimUser_WithSameValue(String method) throws IOException {\n            httpRequest.setMethod(method);\n\n            assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(true));\n        }\n\n\n        @Nested\n        class WhenScimUserDoesNotExist {\n            @BeforeEach\n            void setupNoUserInDB() {\n                when(mockScimUserProvisioning.retrieve(scimUserID, identityZone.getId())).thenThrow(ScimResourceNotFoundException.class);\n            }\n\n            @ParameterizedTest\n            @ValueSource(strings = {\"PUT\", \"PATCH\"})\n            void isAllowed(String method) throws IOException {\n                httpRequest.setMethod(method);\n\n                assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(true));\n            }\n        }\n\n        @Nested\n        class WhenChangingAnAllowedField {\n            @Nested\n            class WhenChangingName {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setName(new ScimUser.Name(\"updatedGivenName\", \"updatedFamilyName\"));\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isAllowedToUpdateGivenAndFamilyName(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(true));\n                }\n            }\n        }\n\n        @Nested\n        class WhenAttemptingToUpdateAFieldThatIsNotAllowedToBeUpdated {\n\n            @Nested\n            class WhenUpdatingTheEmailField {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setEmails(null);\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isNotAllowedToUpdateField(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(false));\n                }\n            }\n\n            @Nested\n            class WhenUpdatingTheUsernameField {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setUserName(null);\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isNotAllowedToUpdateField(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(false));\n                }\n            }\n\n            @Nested\n            class WhenUpdatingTheVerifiedField {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setVerified(true);\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isNotAllowedToUpdateField(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(false));\n                }\n            }\n\n            @Nested\n            class WhenUpdatingTheActiveField {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setActive(true);\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isNotAllowedToUpdateField(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(false));\n                }\n            }\n\n            @Nested\n            class WhenUpdatingTheOriginField {\n                @BeforeEach\n                void setup() {\n                    scimUserFromRequest.setOrigin(\"updatedOrigin\");\n                    httpRequest.setContent(JsonUtils.writeValueAsBytes(scimUserFromRequest));\n                }\n\n                @ParameterizedTest\n                @ValueSource(strings = {\"PUT\", \"PATCH\"})\n                void isNotAllowedToUpdateField(String method) throws IOException {\n                    httpRequest.setMethod(method);\n\n                    assertThat(scimUserSelfUpdateAllowed.isAllowed(httpRequest), is(false));\n                }\n            }\n        }\n\n    }\n\n}",
    "is_vulnerable": 1
  },
  {
    "id": 38,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-archiver/commit/58bc24e465c0842981692adbf6d75680298989de",
    "cve_id": "CVE-2018-1002200",
    "cwe_id": "CWE-22",
    "filename": "src/main/java/org/codehaus/plexus/archiver/AbstractUnArchiver.java",
    "code": "\npackage org.codehaus.plexus.archiver;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\nimport org.codehaus.plexus.archiver.util.ArchiveEntryUtils;\nimport org.codehaus.plexus.components.io.attributes.SymlinkUtils;\nimport org.codehaus.plexus.components.io.fileselectors.FileSelector;\nimport org.codehaus.plexus.components.io.resources.PlexusIoResource;\nimport org.codehaus.plexus.logging.AbstractLogEnabled;\nimport org.codehaus.plexus.util.FileUtils;\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.StringUtils;\n\n\npublic abstract class AbstractUnArchiver\n    extends AbstractLogEnabled\n    implements UnArchiver, FinalizerEnabled\n{\n\n    private File destDirectory;\n\n    private File destFile;\n\n    private File sourceFile;\n\n    private boolean overwrite = true;\n\n    private List finalizers;\n\n    private FileSelector[] fileSelectors;\n\n    \n    private boolean useJvmChmod = true;\n\n    \n    private boolean ignorePermissions = false;\n\n    public AbstractUnArchiver()\n    {\n        \n    }\n\n    public AbstractUnArchiver( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public File getDestDirectory()\n    {\n        return destDirectory;\n    }\n\n    @Override\n    public void setDestDirectory( final File destDirectory )\n    {\n        this.destDirectory = destDirectory;\n    }\n\n    @Override\n    public File getDestFile()\n    {\n        return destFile;\n    }\n\n    @Override\n    public void setDestFile( final File destFile )\n    {\n        this.destFile = destFile;\n    }\n\n    @Override\n    public File getSourceFile()\n    {\n        return sourceFile;\n    }\n\n    @Override\n    public void setSourceFile( final File sourceFile )\n    {\n        this.sourceFile = sourceFile;\n    }\n\n    @Override\n    public boolean isOverwrite()\n    {\n        return overwrite;\n    }\n\n    @Override\n    public void setOverwrite( final boolean b )\n    {\n        overwrite = b;\n    }\n\n    @Override\n    public final void extract()\n        throws ArchiverException\n    {\n        validate();\n        execute();\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public final void extract( final String path, final File outputDirectory )\n        throws ArchiverException\n    {\n        validate( path, outputDirectory );\n        execute( path, outputDirectory );\n        runArchiveFinalizers();\n    }\n\n    @Override\n    public void addArchiveFinalizer( final ArchiveFinalizer finalizer )\n    {\n        if ( finalizers == null )\n        {\n            finalizers = new ArrayList();\n        }\n\n        finalizers.add( finalizer );\n    }\n\n    @Override\n    public void setArchiveFinalizers( final List archiveFinalizers )\n    {\n        finalizers = archiveFinalizers;\n    }\n\n    private void runArchiveFinalizers()\n        throws ArchiverException\n    {\n        if ( finalizers != null )\n        {\n            for ( Object finalizer1 : finalizers )\n            {\n                final ArchiveFinalizer finalizer = (ArchiveFinalizer) finalizer1;\n\n                finalizer.finalizeArchiveExtraction( this );\n            }\n        }\n    }\n\n    protected void validate( final String path, final File outputDirectory )\n    {\n    }\n\n    protected void validate()\n        throws ArchiverException\n    {\n        if ( sourceFile == null )\n        {\n            throw new ArchiverException( \"The source file isn't defined.\" );\n        }\n\n        if ( sourceFile.isDirectory() )\n        {\n            throw new ArchiverException( \"The source must not be a directory.\" );\n        }\n\n        if ( !sourceFile.exists() )\n        {\n            throw new ArchiverException( \"The source file \" + sourceFile + \" doesn't exist.\" );\n        }\n\n        if ( destDirectory == null && destFile == null )\n        {\n            throw new ArchiverException( \"The destination isn't defined.\" );\n        }\n\n        if ( destDirectory != null && destFile != null )\n        {\n            throw new ArchiverException( \"You must choose between a destination directory and a destination file.\" );\n        }\n\n        if ( destDirectory != null && !destDirectory.isDirectory() )\n        {\n            destFile = destDirectory;\n            destDirectory = null;\n        }\n\n        if ( destFile != null && destFile.isDirectory() )\n        {\n            destDirectory = destFile;\n            destFile = null;\n        }\n    }\n\n    @Override\n    public void setFileSelectors( final FileSelector[] fileSelectors )\n    {\n        this.fileSelectors = fileSelectors;\n    }\n\n    @Override\n    public FileSelector[] getFileSelectors()\n    {\n        return fileSelectors;\n    }\n\n    protected boolean isSelected( final String fileName, final PlexusIoResource fileInfo )\n        throws ArchiverException\n    {\n        if ( fileSelectors != null )\n        {\n            for ( FileSelector fileSelector : fileSelectors )\n            {\n                try\n                {\n\n                    if ( !fileSelector.isSelected( fileInfo ) )\n                    {\n                        return false;\n                    }\n                }\n                catch ( final IOException e )\n                {\n                    throw new ArchiverException(\n                        \"Failed to check, whether \" + fileInfo.getName() + \" is selected: \" + e.getMessage(), e );\n                }\n            }\n        }\n        return true;\n    }\n\n    protected abstract void execute()\n        throws ArchiverException;\n\n    protected abstract void execute( String path, File outputDirectory )\n        throws ArchiverException;\n\n    \n    @Override\n    public boolean isUseJvmChmod()\n    {\n        return useJvmChmod;\n    }\n\n    \n    @Override\n    public void setUseJvmChmod( final boolean useJvmChmod )\n    {\n        this.useJvmChmod = useJvmChmod;\n    }\n\n    \n    @Override\n    public boolean isIgnorePermissions()\n    {\n        return ignorePermissions;\n    }\n\n    \n    @Override\n    public void setIgnorePermissions( final boolean ignorePermissions )\n    {\n        this.ignorePermissions = ignorePermissions;\n    }\n\n    protected void extractFile( final File srcF, final File dir, final InputStream compressedInputStream,\n                                final String entryName, final Date entryDate, final boolean isDirectory,\n                                final Integer mode, String symlinkDestination )\n        throws IOException, ArchiverException\n    {\n        \n        final File f = FileUtils.resolveFile( dir, entryName );\n\n        try\n        {\n            if ( !isOverwrite() && f.exists() && ( f.lastModified() >= entryDate.getTime() ) )\n            {\n                return;\n            }\n\n            \n            final File dirF = f.getParentFile();\n            if ( dirF != null )\n            {\n                dirF.mkdirs();\n            }\n\n            if ( !StringUtils.isEmpty( symlinkDestination ) )\n            {\n                SymlinkUtils.createSymbolicLink( f, new File( symlinkDestination ) );\n            }\n            else if ( isDirectory )\n            {\n                f.mkdirs();\n            }\n            else\n            {\n                OutputStream out = null;\n                try\n                {\n                    out = new FileOutputStream( f );\n\n                    IOUtil.copy( compressedInputStream, out );\n                    out.close();\n                    out = null;\n                }\n                finally\n                {\n                    IOUtil.close( out );\n                }\n            }\n\n            f.setLastModified( entryDate.getTime() );\n\n            if ( !isIgnorePermissions() && mode != null && !isDirectory )\n            {\n                ArchiveEntryUtils.chmod( f, mode );\n            }\n        }\n        catch ( final FileNotFoundException ex )\n        {\n            getLogger().warn( \"Unable to expand to file \" + f.getPath() );\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 38,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-archiver/commit/58bc24e465c0842981692adbf6d75680298989de",
    "cve_id": "CVE-2018-1002200",
    "cwe_id": "CWE-22",
    "filename": "src/test/java/org/codehaus/plexus/archiver/zip/ZipUnArchiverTest.java",
    "code": "package org.codehaus.plexus.archiver.zip;\n\nimport java.io.File;\nimport java.lang.reflect.Method;\nimport org.codehaus.plexus.PlexusTestCase;\nimport org.codehaus.plexus.archiver.Archiver;\nimport org.codehaus.plexus.archiver.UnArchiver;\nimport org.codehaus.plexus.components.io.fileselectors.FileSelector;\nimport org.codehaus.plexus.components.io.fileselectors.IncludeExcludeFileSelector;\nimport org.codehaus.plexus.util.FileUtils;\n\n\npublic class ZipUnArchiverTest\n    extends PlexusTestCase\n{\n\n    public void testExtractingZipPreservesExecutableFlag()\n        throws Exception\n    {\n\n        String s = \"target/zip-unarchiver-tests\";\n        File testZip = new File( getBasedir(), \"src/test/jars/test.zip\" );\n        File outputDirectory = new File( getBasedir(), s );\n\n        FileUtils.deleteDirectory( outputDirectory );\n\n        ZipUnArchiver zu = getZipUnArchiver( testZip );\n        zu.extract( \"\", outputDirectory );\n        File testScript = new File( outputDirectory, \"test.sh\" );\n\n        final Method canExecute;\n        try\n        {\n            canExecute = File.class.getMethod( \"canExecute\" );\n            canExecute.invoke( testScript );\n            assertTrue( (Boolean) canExecute.invoke( testScript ) );\n        }\n        catch ( NoSuchMethodException ignore )\n        {\n        }\n    }\n\n    public void testZeroFileModeInZip()\n        throws Exception\n    {\n\n        String s = \"target/zip-unarchiver-filemode-tests\";\n        File testZip = new File( getBasedir(), \"src/test/resources/zeroFileMode/foobar.zip\" );\n        File outputDirectory = new File( getBasedir(), s );\n\n        FileUtils.deleteDirectory( outputDirectory );\n\n        ZipUnArchiver zu = getZipUnArchiver( testZip );\n        zu.setIgnorePermissions( false );\n        zu.extract( \"\", outputDirectory );\n\n        File testScript = new File( outputDirectory, \"foo.txt\" );\n\n        final Method canRead;\n        try\n        {\n            canRead = File.class.getMethod( \"canRead\" );\n            canRead.invoke( testScript );\n            assertTrue( (Boolean) canRead.invoke( testScript ) );\n        }\n        catch ( NoSuchMethodException ignore )\n        {\n        }\n    }\n\n    public void testUnarchiveUtf8()\n        throws Exception\n    {\n        File dest = new File( \"target/output/unzip/utf8\" );\n        dest.mkdirs();\n\n        final File zipFile = new File( \"target/output/unzip/utf8-default.zip\" );\n        final ZipArchiver zipArchiver = getZipArchiver( zipFile );\n        zipArchiver.addDirectory( new File( \"src/test/resources/miscUtf8\" ) );\n        zipArchiver.createArchive();\n        final ZipUnArchiver unarchiver = getZipUnArchiver( zipFile );\n        unarchiver.setDestFile( dest );\n        unarchiver.extract();\n        assertTrue( new File( dest, \"aPi\\u00F1ata.txt\" ).exists() );\n        assertTrue( new File( dest, \"an\\u00FCmlaut.txt\" ).exists() );\n        assertTrue( new File( dest, \"\\u20acuro.txt\" ).exists() );\n    }\n\n    private void runUnarchiver( String path, FileSelector[] selectors, boolean[] results )\n        throws Exception\n    {\n        String s = \"target/zip-unarchiver-tests\";\n\n        File testJar = new File( getBasedir(), \"src/test/jars/test.jar\" );\n\n        File outputDirectory = new File( getBasedir(), s );\n\n        ZipUnArchiver zu = getZipUnArchiver( testJar );\n        zu.setFileSelectors( selectors );\n\n        FileUtils.deleteDirectory( outputDirectory );\n\n        zu.extract( path, outputDirectory );\n\n        File f0 = new File( getBasedir(), s + \"/resources/artifactId/test.properties\" );\n\n        assertEquals( results[0], f0.exists() );\n\n        File f1 = new File( getBasedir(), s + \"/resources/artifactId/directory/test.properties\" );\n\n        assertEquals( results[1], f1.exists() );\n\n        File f2 = new File( getBasedir(), s + \"/META-INF/MANIFEST.MF\" );\n\n        assertEquals( results[2], f2.exists() );\n    }\n\n    private ZipUnArchiver getZipUnArchiver( File testJar ) throws Exception\n    {\n        ZipUnArchiver zu = (ZipUnArchiver) lookup( UnArchiver.ROLE, \"zip\" );\n        zu.setSourceFile( testJar );\n        return zu;\n    }\n\n    public void testExtractingADirectoryFromAJarFile()\n        throws Exception\n    {\n        runUnarchiver( \"resources/artifactId\", null,\n                       new boolean[]\n                       {\n                           true, true, false\n                       } );\n        runUnarchiver( \"\", null,\n                       new boolean[]\n                       {\n                           true, true, true\n                       } );\n    }\n\n    public void testSelectors()\n        throws Exception\n    {\n        IncludeExcludeFileSelector fileSelector = new IncludeExcludeFileSelector();\n        runUnarchiver( \"\", new FileSelector[]\n                   {\n                       fileSelector\n        },\n                       new boolean[]\n                       {\n                           true, true, true\n                       } );\n        fileSelector.setExcludes( new String[]\n        {\n            \"**/test.properties\"\n        } );\n        runUnarchiver( \"\", new FileSelector[]\n                   {\n                       fileSelector\n        },\n                       new boolean[]\n                       {\n                           false, false, true\n                       } );\n        fileSelector.setIncludes( new String[]\n        {\n            \"**/test.properties\"\n        } );\n        fileSelector.setExcludes( null );\n        runUnarchiver( \"\", new FileSelector[]\n                   {\n                       fileSelector\n        },\n                       new boolean[]\n                       {\n                           true, true, false\n                       } );\n        fileSelector.setExcludes( new String[]\n        {\n            \"resources/artifactId/directory/test.properties\"\n        } );\n        runUnarchiver( \"\", new FileSelector[]\n                   {\n                       fileSelector\n        },\n                       new boolean[]\n                       {\n                           true, false, false\n                       } );\n    }\n\n    private ZipArchiver getZipArchiver()\n    {\n        try\n        {\n            return (ZipArchiver) lookup( Archiver.ROLE, \"zip\" );\n        }\n        catch ( Exception e )\n        {\n            throw new RuntimeException( e );\n        }\n    }\n\n    private ZipArchiver getZipArchiver( File destFile )\n    {\n        final ZipArchiver zipArchiver = getZipArchiver();\n        zipArchiver.setDestFile( destFile );\n        return zipArchiver;\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 39,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "cve_id": "CVE-2017-1000487",
    "cwe_id": "CWE-78",
    "filename": "src/main/java/org/codehaus/plexus/util/cli/Commandline.java",
    "code": "package org.codehaus.plexus.util.cli;\n\n\n\n\n\n\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.CommandShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Vector;\n\n\npublic class Commandline\n    implements Cloneable\n{\n    \n    protected static final String OS_NAME = \"os.name\";\n\n    \n    protected static final String WINDOWS = \"Windows\";\n\n    protected Vector arguments = new Vector();\n\n    \n    \n    protected Map envVars = Collections.synchronizedMap( new LinkedHashMap() );\n\n    private long pid = -1;\n\n    private Shell shell;\n\n    \n    protected String executable;\n\n    \n    private File workingDir;\n\n    \n    public Commandline( String toProcess, Shell shell )\n    {\n        this.shell = shell;\n\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    \n    public Commandline( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    \n    public Commandline( String toProcess )\n    {\n        setDefaultShell();\n        String[] tmp = new String[0];\n        try\n        {\n            tmp = CommandLineUtils.translateCommandline( toProcess );\n        }\n        catch ( Exception e )\n        {\n            System.err.println( \"Error translating Commandline.\" );\n        }\n        if ( ( tmp != null ) && ( tmp.length > 0 ) )\n        {\n            setExecutable( tmp[0] );\n            for ( int i = 1; i < tmp.length; i++ )\n            {\n                createArgument().setValue( tmp[i] );\n            }\n        }\n    }\n\n    \n    public Commandline()\n    {\n        setDefaultShell();\n    }\n\n    public long getPid()\n    {\n        if ( pid == -1 )\n        {\n            pid = Long.parseLong( String.valueOf( System.currentTimeMillis() ) );\n        }\n\n        return pid;\n    }\n\n    public void setPid( long pid )\n    {\n        this.pid = pid;\n    }\n\n    \n    \n    \n    \n    public class Marker\n    {\n\n        private int position;\n\n        private int realPos = -1;\n\n        Marker( int position )\n        {\n            this.position = position;\n        }\n\n        \n        public int getPosition()\n        {\n            if ( realPos == -1 )\n            {\n                realPos = ( getExecutable() == null ? 0 : 1 );\n                for ( int i = 0; i < position; i++ )\n                {\n                    Arg arg = (Arg) arguments.elementAt( i );\n                    realPos += arg.getParts().length;\n                }\n            }\n            return realPos;\n        }\n    }\n\n    \n    private void setDefaultShell()\n    {\n        \n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            if ( Os.isFamily( Os.FAMILY_WIN9X ) )\n            {\n                setShell( new CommandShell() );\n            }\n            else\n            {\n                setShell( new CmdShell() );\n            }\n        }\n        else\n        {\n            setShell( new BourneShell() );\n        }\n    }\n\n    \n    public Argument createArgument()\n    {\n        return this.createArgument( false );\n    }\n\n    \n    public Argument createArgument( boolean insertAtStart )\n    {\n        Argument argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    \n    public Arg createArg()\n    {\n        return this.createArg( false );\n    }\n\n    \n    public Arg createArg( boolean insertAtStart )\n    {\n        Arg argument = new Argument();\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n        return argument;\n    }\n\n    \n    public void addArg( Arg argument )\n    {\n        this.addArg( argument, false );\n    }\n\n    \n    public void addArg( Arg argument, boolean insertAtStart )\n    {\n        if ( insertAtStart )\n        {\n            arguments.insertElementAt( argument, 0 );\n        }\n        else\n        {\n            arguments.addElement( argument );\n        }\n    }\n\n    \n    public void setExecutable( String executable )\n    {\n        shell.setExecutable( executable );\n        this.executable = executable;\n    }\n\n    public String getExecutable()\n    {\n        String exec = shell.getExecutable();\n\n        if ( exec == null )\n        {\n            exec = executable;\n        }\n\n        return exec;\n    }\n\n    public void addArguments( String[] line )\n    {\n        for ( int i = 0; i < line.length; i++ )\n        {\n            createArgument().setValue( line[i] );\n        }\n    }\n\n    \n    public void addEnvironment( String name, String value )\n    {\n        \n        envVars.put( name, value );\n    }\n\n    \n    public void addSystemEnvironment()\n        throws Exception\n    {\n        Properties systemEnvVars = CommandLineUtils.getSystemEnvVars();\n\n        for ( Iterator i = systemEnvVars.keySet().iterator(); i.hasNext(); )\n        {\n            String key = (String) i.next();\n            if ( !envVars.containsKey( key ) )\n            {\n                addEnvironment( key, systemEnvVars.getProperty( key ) );\n            }\n        }\n    }\n\n    \n    public String[] getEnvironmentVariables()\n        throws CommandLineException\n    {\n        try\n        {\n            addSystemEnvironment();\n        }\n        catch ( Exception e )\n        {\n            throw new CommandLineException( \"Error setting up environmental variables\", e );\n        }\n        String[] environmentVars = new String[envVars.size()];\n        int i = 0;\n        for ( Iterator iterator = envVars.keySet().iterator(); iterator.hasNext(); )\n        {\n            String name = (String) iterator.next();\n            String value = (String) envVars.get( name );\n            environmentVars[i] = name + \"=\" + value;\n            i++;\n        }\n        return environmentVars;\n    }\n\n    \n    public String[] getCommandline()\n    {\n        final String[] args = getArguments();\n        String executable = getExecutable();\n\n        if ( executable == null )\n        {\n            return args;\n        }\n        final String[] result = new String[args.length + 1];\n        result[0] = executable;\n        System.arraycopy( args, 0, result, 1, args.length );\n        return result;\n    }\n\n    \n    public String[] getShellCommandline()\n    {\n        \n        verifyShellState();\n\n        return (String[]) getShell().getShellCommandLine( getArguments() ).toArray( new String[0] );\n    }\n\n    \n    public String[] getArguments()\n    {\n        Vector result = new Vector( arguments.size() * 2 );\n        for ( int i = 0; i < arguments.size(); i++ )\n        {\n            Argument arg = (Argument) arguments.elementAt( i );\n            String[] s = arg.getParts();\n            if ( s != null )\n            {\n                for ( int j = 0; j < s.length; j++ )\n                {\n                    result.addElement( s[j] );\n                }\n            }\n        }\n\n        String[] res = new String[result.size()];\n        result.copyInto( res );\n        return res;\n    }\n\n    public String toString()\n    {\n        return StringUtils.join( getShellCommandline(), \" \" );\n    }\n\n    public int size()\n    {\n        return getCommandline().length;\n    }\n\n    public Object clone()\n    {\n        Commandline c = new Commandline( (Shell) shell.clone() );\n        c.executable = executable;\n        c.workingDir = workingDir;\n        c.addArguments( getArguments() );\n        return c;\n    }\n\n    \n    public void clear()\n    {\n        executable = null;\n        workingDir = null;\n        shell.setExecutable( null );\n        shell.clearArguments();\n        arguments.removeAllElements();\n    }\n\n    \n    public void clearArgs()\n    {\n        arguments.removeAllElements();\n    }\n\n    \n    public Marker createMarker()\n    {\n        return new Marker( arguments.size() );\n    }\n\n    \n    public void setWorkingDirectory( String path )\n    {\n        shell.setWorkingDirectory( path );\n        workingDir = new File( path );\n    }\n\n    \n    public void setWorkingDirectory( File workingDirectory )\n    {\n        shell.setWorkingDirectory( workingDirectory );\n        workingDir = workingDirectory;\n    }\n\n    public File getWorkingDirectory()\n    {\n        File workDir = shell.getWorkingDirectory();\n\n        if ( workDir == null )\n        {\n            workDir = workingDir;\n        }\n\n        return workDir;\n    }\n\n    \n    public Process execute()\n        throws CommandLineException\n    {\n        \n        verifyShellState();\n\n        Process process;\n\n        \n\n        String[] environment = getEnvironmentVariables();\n\n        File workingDir = shell.getWorkingDirectory();\n\n        try\n        {\n            if ( workingDir == null )\n            {\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment );\n            }\n            else\n            {\n                if ( !workingDir.exists() )\n                {\n                    throw new CommandLineException( \"Working directory \\\"\" + workingDir.getPath()\n                        + \"\\\" does not exist!\" );\n                }\n                else if ( !workingDir.isDirectory() )\n                {\n                    throw new CommandLineException( \"Path \\\"\" + workingDir.getPath()\n                        + \"\\\" does not specify a directory.\" );\n                }\n\n                process = Runtime.getRuntime().exec( getShellCommandline(), environment, workingDir );\n            }\n        }\n        catch ( IOException ex )\n        {\n            throw new CommandLineException( \"Error while executing process.\", ex );\n        }\n\n        return process;\n    }\n\n    \n    private void verifyShellState()\n    {\n        if ( shell.getWorkingDirectory() == null )\n        {\n            shell.setWorkingDirectory( workingDir );\n        }\n\n        if ( shell.getExecutable() == null )\n        {\n            shell.setExecutable( executable );\n        }\n    }\n\n    public Properties getSystemEnvVars()\n        throws Exception\n    {\n        return CommandLineUtils.getSystemEnvVars();\n    }\n\n    \n    public void setShell( Shell shell )\n    {\n        this.shell = shell;\n    }\n\n    \n    public Shell getShell()\n    {\n        return shell;\n    }\n\n    \n    public static String[] translateCommandline( String toProcess )\n        throws Exception\n    {\n        return CommandLineUtils.translateCommandline( toProcess );\n    }\n\n    \n    public static String quoteArgument( String argument )\n        throws CommandLineException\n    {\n        return CommandLineUtils.quote( argument );\n    }\n\n    \n    public static String toString( String[] line )\n    {\n        return CommandLineUtils.toString( line );\n    }\n\n    public static class Argument\n        implements Arg\n    {\n        private String[] parts;\n\n        \n        public void setValue( String value )\n        {\n            if ( value != null )\n            {\n                parts = new String[] { value };\n            }\n        }\n\n        \n        public void setLine( String line )\n        {\n            if ( line == null )\n            {\n                return;\n            }\n            try\n            {\n                parts = CommandLineUtils.translateCommandline( line );\n            }\n            catch ( Exception e )\n            {\n                System.err.println( \"Error translating Commandline.\" );\n            }\n        }\n\n        \n        public void setFile( File value )\n        {\n            parts = new String[] { value.getAbsolutePath() };\n        }\n\n        \n        public String[] getParts()\n        {\n            return parts;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 39,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "cve_id": "CVE-2017-1000487",
    "cwe_id": "CWE-78",
    "filename": "src/main/java/org/codehaus/plexus/util/cli/shell/BourneShell.java",
    "code": "package org.codehaus.plexus.util.cli.shell;\n\n\n\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class BourneShell\n    extends Shell\n{\n    private static final char[] BASH_QUOTING_TRIGGER_CHARS = {\n        ' ',\n        '$',\n        ';',\n        '&',\n        '|',\n        '<',\n        '>',\n        '*',\n        '?',\n        '(',\n        ')',\n        '[',\n        ']',\n        '{',\n        '}',\n        '`' };\n\n    public BourneShell()\n    {\n        this( false );\n    }\n\n    public BourneShell( boolean isLoginShell )\n    {\n        setShellCommand( \"/bin/sh\" );\n        setArgumentQuoteDelimiter( '\\'' );\n        setExecutableQuoteDelimiter( '\\\"' );\n        setSingleQuotedArgumentEscaped( true );\n        setSingleQuotedExecutableEscaped( false );\n        setQuotedExecutableEnabled( true );\n        setArgumentEscapePattern(\"'\\\\%s'\");\n\n        if ( isLoginShell )\n        {\n            addShellArg( \"-l\" );\n        }\n    }\n\n    \n    public String getExecutable()\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            return super.getExecutable();\n        }\n\n        return unifyQuotes( super.getExecutable());\n    }\n\n    public List<String> getShellArgsList()\n    {\n        List<String> shellArgs = new ArrayList<String>();\n        List<String> existingShellArgs = super.getShellArgsList();\n\n        if ( ( existingShellArgs != null ) && !existingShellArgs.isEmpty() )\n        {\n            shellArgs.addAll( existingShellArgs );\n        }\n\n        shellArgs.add( \"-c\" );\n\n        return shellArgs;\n    }\n\n    public String[] getShellArgs()\n    {\n        String[] shellArgs = super.getShellArgs();\n        if ( shellArgs == null )\n        {\n            shellArgs = new String[0];\n        }\n\n        if ( ( shellArgs.length > 0 ) && !shellArgs[shellArgs.length - 1].equals( \"-c\" ) )\n        {\n            String[] newArgs = new String[shellArgs.length + 1];\n\n            System.arraycopy( shellArgs, 0, newArgs, 0, shellArgs.length );\n            newArgs[shellArgs.length] = \"-c\";\n\n            shellArgs = newArgs;\n        }\n\n        return shellArgs;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        if ( getWorkingDirectoryAsString() == null )\n        {\n            return null;\n        }\n\n        String dir = getWorkingDirectoryAsString();\n        StringBuilder sb = new StringBuilder();\n        sb.append( \"cd \" );\n\n        sb.append( unifyQuotes( dir ) );\n        sb.append( \" && \" );\n\n        return sb.toString();\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return BASH_QUOTING_TRIGGER_CHARS;\n    }\n\n    \n    protected static String unifyQuotes( String path )\n    {\n        if ( path == null )\n        {\n            return null;\n        }\n\n        if ( path.indexOf( \" \" ) == -1 && path.indexOf( \"'\" ) != -1 && path.indexOf( \"\\\"\" ) == -1 )\n        {\n            return StringUtils.escape( path );\n        }\n\n        return StringUtils.quoteAndEscape( path, '\\\"', BASH_QUOTING_TRIGGER_CHARS );\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 39,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "cve_id": "CVE-2017-1000487",
    "cwe_id": "CWE-78",
    "filename": "src/main/java/org/codehaus/plexus/util/cli/shell/Shell.java",
    "code": "package org.codehaus.plexus.util.cli.shell;\n\n\n\nimport org.codehaus.plexus.util.StringUtils;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n\npublic class Shell\n    implements Cloneable\n{\n    private static final char[] DEFAULT_QUOTING_TRIGGER_CHARS = { ' ' };\n\n    private String shellCommand;\n\n    private List<String> shellArgs = new ArrayList<String>();\n\n    private boolean quotedArgumentsEnabled = true;\n\n    private String executable;\n\n    private String workingDir;\n\n    private boolean quotedExecutableEnabled = true;\n\n    private boolean doubleQuotedArgumentEscaped = false;\n\n    private boolean singleQuotedArgumentEscaped = false;\n\n    private boolean doubleQuotedExecutableEscaped = false;\n\n    private boolean singleQuotedExecutableEscaped = false;\n\n    private char argQuoteDelimiter = '\\\"';\n\n    private char exeQuoteDelimiter = '\\\"';\n\n    private String argumentEscapePattern = \"\\\\%s\";\n\n    \n    public void setShellCommand( String shellCommand )\n    {\n        this.shellCommand = shellCommand;\n    }\n\n    \n    public String getShellCommand()\n    {\n        return shellCommand;\n    }\n\n    \n    public void setShellArgs( String[] shellArgs )\n    {\n        this.shellArgs.clear();\n        this.shellArgs.addAll( Arrays.asList( shellArgs ) );\n    }\n\n    \n    public String[] getShellArgs()\n    {\n        if ( ( shellArgs == null ) || shellArgs.isEmpty() )\n        {\n            return null;\n        }\n        else\n        {\n            return (String[]) shellArgs.toArray( new String[shellArgs.size()] );\n        }\n    }\n\n    \n    public List<String> getCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected List<String> getRawCommandLine( String executable, String[] arguments )\n    {\n        List<String> commandLine = new ArrayList<String>();\n        StringBuilder sb = new StringBuilder();\n\n        if ( executable != null )\n        {\n            String preamble = getExecutionPreamble();\n            if ( preamble != null )\n            {\n                sb.append( preamble );\n            }\n\n            if ( isQuotedExecutableEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedExecutableEscaped(), isDoubleQuotedExecutableEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( getExecutable(), getExecutableQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), '\\\\', false ) );\n            }\n            else\n            {\n                sb.append( getExecutable() );\n            }\n        }\n        for ( int i = 0; i < arguments.length; i++ )\n        {\n            if ( sb.length() > 0 )\n            {\n                sb.append( \" \" );\n            }\n\n            if ( isQuotedArgumentsEnabled() )\n            {\n                char[] escapeChars = getEscapeChars( isSingleQuotedArgumentEscaped(), isDoubleQuotedArgumentEscaped() );\n\n                sb.append( StringUtils.quoteAndEscape( arguments[i], getArgumentQuoteDelimiter(), escapeChars, getQuotingTriggerChars(), getArgumentEscapePattern(), false ) );\n            }\n            else\n            {\n                sb.append( arguments[i] );\n            }\n        }\n\n        commandLine.add( sb.toString() );\n\n        return commandLine;\n    }\n\n    protected char[] getQuotingTriggerChars()\n    {\n        return DEFAULT_QUOTING_TRIGGER_CHARS;\n    }\n\n    protected String getExecutionPreamble()\n    {\n        return null;\n    }\n\n    protected char[] getEscapeChars( boolean includeSingleQuote, boolean includeDoubleQuote )\n    {\n        StringBuilder buf = new StringBuilder( 2 );\n        if ( includeSingleQuote )\n        {\n            buf.append( '\\'' );\n        }\n\n        if ( includeDoubleQuote )\n        {\n            buf.append( '\\\"' );\n        }\n\n        char[] result = new char[buf.length()];\n        buf.getChars( 0, buf.length(), result, 0 );\n\n        return result;\n    }\n\n    protected boolean isDoubleQuotedArgumentEscaped()\n    {\n        return doubleQuotedArgumentEscaped;\n    }\n\n    protected boolean isSingleQuotedArgumentEscaped()\n    {\n        return singleQuotedArgumentEscaped;\n    }\n\n    protected boolean isDoubleQuotedExecutableEscaped()\n    {\n        return doubleQuotedExecutableEscaped;\n    }\n\n    protected boolean isSingleQuotedExecutableEscaped()\n    {\n        return singleQuotedExecutableEscaped;\n    }\n\n    protected void setArgumentQuoteDelimiter( char argQuoteDelimiter )\n    {\n        this.argQuoteDelimiter = argQuoteDelimiter;\n    }\n\n    protected char getArgumentQuoteDelimiter()\n    {\n        return argQuoteDelimiter;\n    }\n\n    protected void setExecutableQuoteDelimiter( char exeQuoteDelimiter )\n    {\n        this.exeQuoteDelimiter = exeQuoteDelimiter;\n    }\n\n    protected char getExecutableQuoteDelimiter()\n    {\n        return exeQuoteDelimiter;\n    }\n\n    protected void setArgumentEscapePattern(String argumentEscapePattern)\n    {\n        this.argumentEscapePattern = argumentEscapePattern;\n    }\n\n    protected String getArgumentEscapePattern() {\n        return argumentEscapePattern;\n    }\n\n    \n    public List<String> getShellCommandLine( String[] arguments )\n    {\n\n        List<String> commandLine = new ArrayList<String>();\n\n        if ( getShellCommand() != null )\n        {\n            commandLine.add( getShellCommand() );\n        }\n\n        if ( getShellArgs() != null )\n        {\n            commandLine.addAll( getShellArgsList() );\n        }\n\n        commandLine.addAll( getCommandLine( getExecutable(), arguments ) );\n\n        return commandLine;\n\n    }\n\n    public List<String> getShellArgsList()\n    {\n        return shellArgs;\n    }\n\n    public void addShellArg( String arg )\n    {\n        shellArgs.add( arg );\n    }\n\n    public void setQuotedArgumentsEnabled( boolean quotedArgumentsEnabled )\n    {\n        this.quotedArgumentsEnabled = quotedArgumentsEnabled;\n    }\n\n    public boolean isQuotedArgumentsEnabled()\n    {\n        return quotedArgumentsEnabled;\n    }\n\n    public void setQuotedExecutableEnabled( boolean quotedExecutableEnabled )\n    {\n        this.quotedExecutableEnabled = quotedExecutableEnabled;\n    }\n\n    public boolean isQuotedExecutableEnabled()\n    {\n        return quotedExecutableEnabled;\n    }\n\n    \n    public void setExecutable( String executable )\n    {\n        if ( ( executable == null ) || ( executable.length() == 0 ) )\n        {\n            return;\n        }\n        this.executable = executable.replace( '/', File.separatorChar ).replace( '\\\\', File.separatorChar );\n    }\n\n    public String getExecutable()\n    {\n        return executable;\n    }\n\n    \n    public void setWorkingDirectory( String path )\n    {\n        if ( path != null )\n        {\n            workingDir = path;\n        }\n    }\n\n    \n    public void setWorkingDirectory( File workingDir )\n    {\n        if ( workingDir != null )\n        {\n            this.workingDir = workingDir.getAbsolutePath();\n        }\n    }\n\n    public File getWorkingDirectory()\n    {\n        return workingDir == null ? null : new File( workingDir );\n    }\n\n    public String getWorkingDirectoryAsString()\n    {\n        return workingDir;\n    }\n\n    public void clearArguments()\n    {\n        shellArgs.clear();\n    }\n\n    public Object clone()\n    {\n        Shell shell = new Shell();\n        shell.setExecutable( getExecutable() );\n        shell.setWorkingDirectory( getWorkingDirectory() );\n        shell.setShellArgs( getShellArgs() );\n        return shell;\n    }\n\n    public String getOriginalExecutable()\n    {\n        return executable;\n    }\n\n    public List<String> getOriginalCommandLine( String executable, String[] arguments )\n    {\n        return getRawCommandLine( executable, arguments );\n    }\n\n    protected void setDoubleQuotedArgumentEscaped( boolean doubleQuotedArgumentEscaped )\n    {\n        this.doubleQuotedArgumentEscaped = doubleQuotedArgumentEscaped;\n    }\n\n    protected void setDoubleQuotedExecutableEscaped( boolean doubleQuotedExecutableEscaped )\n    {\n        this.doubleQuotedExecutableEscaped = doubleQuotedExecutableEscaped;\n    }\n\n    protected void setSingleQuotedArgumentEscaped( boolean singleQuotedArgumentEscaped )\n    {\n        this.singleQuotedArgumentEscaped = singleQuotedArgumentEscaped;\n    }\n\n    protected void setSingleQuotedExecutableEscaped( boolean singleQuotedExecutableEscaped )\n    {\n        this.singleQuotedExecutableEscaped = singleQuotedExecutableEscaped;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 39,
    "sub_id": 3,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "cve_id": "CVE-2017-1000487",
    "cwe_id": "CWE-78",
    "filename": "src/test/java/org/codehaus/plexus/util/cli/CommandlineTest.java",
    "code": "package org.codehaus.plexus.util.cli;\n\n\n\nimport org.codehaus.plexus.util.IOUtil;\nimport org.codehaus.plexus.util.Os;\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.shell.BourneShell;\nimport org.codehaus.plexus.util.cli.shell.CmdShell;\nimport org.codehaus.plexus.util.cli.shell.Shell;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.StringWriter;\nimport java.io.Writer;\n\nimport junit.framework.TestCase;\n\npublic class CommandlineTest\n    extends TestCase\n{\n    private String baseDir;\n\n    \n    public CommandlineTest( final String testName )\n    {\n        super( testName );\n    }\n\n    \n    public void setUp()\n        throws Exception\n    {\n        super.setUp();\n        baseDir = System.getProperty( \"basedir\" );\n\n        if ( baseDir == null )\n        {\n            baseDir = new File( \".\" ).getCanonicalPath();\n        }\n    }\n\n    public void testCommandlineWithoutCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"cd\" );\n            cmd.createArgument().setValue( \".\" );\n\n            \n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCommandlineWithCommandInConstructor()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( \"cd .\", new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n\n            \n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testExecute()\n    {\n        try\n        {\n            \n            Commandline cmd = new Commandline();\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            assertEquals( \"echo\", cmd.getShell().getOriginalExecutable() );\n            cmd.createArgument().setValue( \"Hello\" );\n\n            StringWriter swriter = new StringWriter();\n            Process process = cmd.execute();\n\n            Reader reader = new InputStreamReader( process.getInputStream() );\n\n            char[] chars = new char[16];\n            int read = -1;\n            while ( ( read = reader.read( chars ) ) > -1 )\n            {\n                swriter.write( chars, 0, read );\n            }\n\n            String output = swriter.toString().trim();\n\n            assertEquals( \"Hello\", output );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetLine()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.setExecutable( \"echo\" );\n            cmd.createArgument().setLine( null );\n            cmd.createArgument().setLine( \"Hello\" );\n\n            \n            assertEquals( \"echo Hello\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testCreateCommandInReverseOrder()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \".\" );\n            cmd.createArgument( true ).setValue( \"cd\" );\n\n            \n            assertEquals( \"cd .\", cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testSetFile()\n    {\n        try\n        {\n            Commandline cmd = new Commandline( new Shell() );\n            cmd.setWorkingDirectory( baseDir );\n            cmd.createArgument().setValue( \"more\" );\n            File f = new File( \"test.txt\" );\n            cmd.createArgument().setFile( f );\n            String fileName = f.getAbsolutePath();\n            if ( fileName.indexOf( \" \" ) >= 0 )\n            {\n                fileName = \"\\\"\" + fileName + \"\\\"\";\n            }\n\n            \n            assertEquals( \"more \" + fileName, cmd.toString() );\n        }\n        catch ( Exception e )\n        {\n            fail( e.getMessage() );\n        }\n    }\n\n    public void testGetShellCommandLineWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" a b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    public void testGetShellCommandLineWindowsWithSeveralQuotes()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new CmdShell() );\n        cmd.setExecutable( \"c:\\\\Program Files\\\\xxx\" );\n        cmd.addArguments( new String[] {\n            \"c:\\\\Documents and Settings\\\\whatever\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 4, shellCommandline.length );\n\n        assertEquals( \"cmd.exe\", shellCommandline[0] );\n        assertEquals( \"/X\", shellCommandline[1] );\n        assertEquals( \"/C\", shellCommandline[2] );\n        String expectedShellCmd = \"\\\"c:\" + File.separator + \"Program Files\" + File.separator\n                                  + \"xxx\\\" \\\"c:\\\\Documents and Settings\\\\whatever\\\" b\";\n        expectedShellCmd = \"\\\"\" + expectedShellCmd + \"\\\"\";\n        assertEquals( expectedShellCmd, shellCommandline[3] );\n    }\n\n    \n    public void testGetShellCommandLineBash()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    \n    public void testGetShellCommandLineBash_WithWorkingDirectory()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"hello world\"\n        } );\n        File root = File.listRoots()[0];\n        File workingDirectory = new File( root, \"path with spaces\" );\n        cmd.setWorkingDirectory( workingDirectory );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                                  + \"path with spaces\\\" && /bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"cd \\\"\" + root.getAbsolutePath()\n                               + \"path with spaces\\\" && \\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    \n    public void testGetShellCommandLineBash_WithSingleQuotedArg()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/bin/echo\" );\n        cmd.addArguments( new String[] {\n            \"\\'hello world\\'\"\n        } );\n\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n        String expectedShellCmd = \"/bin/echo \\'hello world\\'\";\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            expectedShellCmd = \"\\\\bin\\\\echo \\'hello world\\'\";\n        }\n        assertEquals( expectedShellCmd, shellCommandline[2] );\n    }\n\n    public void testGetShellCommandLineNonWindows()\n        throws Exception\n    {\n        Commandline cmd = new Commandline( new BourneShell() );\n        cmd.setExecutable( \"/usr/bin\" );\n        cmd.addArguments( new String[] {\n            \"a\",\n            \"b\"\n        } );\n        String[] shellCommandline = cmd.getShellCommandline();\n\n        assertEquals( \"Command line size\", 3, shellCommandline.length );\n\n        assertEquals( \"/bin/sh\", shellCommandline[0] );\n        assertEquals( \"-c\", shellCommandline[1] );\n\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            assertEquals( \"\\\\usr\\\\bin a b\", shellCommandline[2] );\n        }\n        else\n        {\n            assertEquals( \"/usr/bin a b\", shellCommandline[2] );\n        }\n    }\n\n    public void testEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addEnvironment( \"name\", \"value\" );\n        assertEquals( \"name=value\", cmd.getEnvironmentVariables()[0] );\n    }\n\n    public void testEnvironmentWitOverrideSystemEnvironment()\n        throws Exception\n    {\n        Commandline cmd = new Commandline();\n        cmd.addSystemEnvironment();\n        cmd.addEnvironment( \"JAVA_HOME\", \"/usr/jdk1.5\" );\n        String[] environmentVariables = cmd.getEnvironmentVariables();\n\n        for ( int i = 0, size = environmentVariables.length; i < size; i++ )\n        {\n            if ( \"JAVA_HOME=/usr/jdk1.5\".equals( environmentVariables[i] ) )\n            {\n                return;\n            }\n        }\n\n        fail( \"can't find JAVA_HOME=/usr/jdk1.5\" );\n    }\n\n    \n    public void testQuotedPathWithSingleApostrophe()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    \n    public void testQuotedPathWithQuotationMark()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMark() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    \n    public void testQuotedPathWithQuotationMarkAndApostrophe()\n        throws Exception\n    {\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            System.out.println( \"testQuotedPathWithQuotationMarkAndApostrophe() skipped on Windows\" );\n            return;\n        }\n\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n\n        dir = new File( System.getProperty( \"basedir\" ), \"target/test/quoted path\\\"'test\" );\n        createAndCallScript( dir, \"echo Quoted\" );\n    }\n\n    \n    public void testOnlyQuotedPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test/quotedpath\\'test\" );\n\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n\n        createAndCallScript( dir, java.getAbsolutePath() + \" -version\" );\n    }\n\n    public void testDollarSignInArgumentPath()\n        throws Exception\n    {\n        File dir = new File( System.getProperty( \"basedir\" ), \"target/test\" );\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        FileWriter writer = null;\n        try\n        {\n            writer = new FileWriter( new File( dir, \"test$1.txt\" ) );\n            IOUtil.copy( \"Success\", writer );\n        }\n        finally\n        {\n            IOUtil.close( writer );\n        }\n\n        Commandline cmd = new Commandline();\n        \n        cmd.getShell().setQuotedArgumentsEnabled( true );\n        cmd.setExecutable( \"cat\" );\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            cmd.setExecutable( \"dir\" );\n        }\n        cmd.setWorkingDirectory( dir );\n        cmd.createArg().setLine( \"test$1.txt\" );\n\n        executeCommandLine( cmd );\n    }\n\n    public void testTimeOutException() throws Exception\n    {\n        File javaHome = new File( System.getProperty( \"java.home\" ) );\n        File java;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            java = new File( javaHome, \"/bin/java.exe\" );\n        }\n        else\n        {\n            java = new File( javaHome, \"/bin/java\" );\n        }\n\n        if ( !java.exists() )\n        {\n            throw new IOException( java.getAbsolutePath() + \" doesn't exist\" );\n        }\n        \n        Commandline cli = new Commandline();\n        cli.setExecutable( java.getAbsolutePath() );\n        cli.createArg().setLine( \"-version\" );\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n        try\n        {\n            \n            CommandLineUtils.executeCommandLine( cli, new DefaultConsumer(), err, 1 );\n        }\n        catch ( CommandLineTimeOutException e )\n        {\n            \n        }\n        \n    }\n    \n    \n    private static void makeExecutable( File path )\n        throws IOException\n    {\n        if ( path == null )\n        {\n            throw new IllegalArgumentException( \"The file is null\" );\n        }\n\n        if ( !path.isFile() )\n        {\n            throw new IllegalArgumentException( \"The file '\" + path.getAbsolutePath() + \"' should be a file\" );\n        }\n\n        if ( !Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            Process proc = Runtime.getRuntime().exec( new String[] { \"chmod\", \"a+x\", path.getAbsolutePath() } );\n            while ( true )\n            {\n                try\n                {\n                    proc.waitFor();\n                    break;\n                }\n                catch ( InterruptedException e )\n                {\n                    \n                }\n            }\n        }\n    }\n\n    \n    private static void createAndCallScript( File dir, String content )\n        throws Exception\n    {\n        if ( !dir.exists() )\n        {\n            assertTrue( \"Can't create dir:\" + dir.getAbsolutePath(), dir.mkdirs() );\n        }\n\n        \n        File bat;\n        if ( Os.isFamily( Os.FAMILY_WINDOWS ) )\n        {\n            bat = new File( dir, \"echo.bat\" );\n        }\n        else\n        {\n            bat = new File( dir, \"echo\" );\n        }\n\n        Writer w = new FileWriter( bat );\n        try\n        {\n            IOUtil.copy( content, w );\n        }\n        finally\n        {\n            IOUtil.close( w );\n        }\n\n        \n        makeExecutable( bat );\n\n        Commandline cmd = new Commandline();\n        cmd.setExecutable( bat.getAbsolutePath() );\n        cmd.setWorkingDirectory( dir );\n\n        \n        executeCommandLine( cmd );\n    }\n\n    \n    private static void executeCommandLine( Commandline cmd )\n        throws Exception\n    {\n        CommandLineUtils.StringStreamConsumer err = new CommandLineUtils.StringStreamConsumer();\n\n        try\n        {\n            System.out.println( \"Command line is: \" + StringUtils.join( cmd.getShellCommandline(), \" \" ) );\n\n            int exitCode = CommandLineUtils.executeCommandLine( cmd, new DefaultConsumer(), err );\n\n            if ( exitCode != 0 )\n            {\n                String msg = \"Exit code: \" + exitCode + \" - \" + err.getOutput();\n                throw new Exception( msg.toString() );\n            }\n        }\n        catch ( CommandLineException e )\n        {\n            throw new Exception( \"Unable to execute command: \" + e.getMessage(), e );\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 39,
    "sub_id": 4,
    "code_id": 0,
    "human_patch": "https://github.com/codehaus-plexus/plexus-utils/commit/b38a1b3a4352303e4312b2bb601a0d7ec6e28f41",
    "cve_id": "CVE-2017-1000487",
    "cwe_id": "CWE-78",
    "filename": "src/test/java/org/codehaus/plexus/util/cli/shell/BourneShellTest.java",
    "code": "package org.codehaus.plexus.util.cli.shell;\n\n\n\nimport org.codehaus.plexus.util.StringUtils;\nimport org.codehaus.plexus.util.cli.Commandline;\n\nimport java.util.Arrays;\nimport java.util.List;\n\nimport junit.framework.TestCase;\n\npublic class BourneShellTest\n    extends TestCase\n{\n\n    protected Shell newShell()\n    {\n        return new BourneShell();\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd /usr/local/bin && chmod\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/local/'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"/usr/local/\\'something else\\'\\\" && chmod\", executable );\n    }\n\n    public void testQuoteWorkingDirectoryAndExecutable_WDPathWithSingleQuotes_BackslashFileSep()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"\\\\usr\\\\local\\\\'something else'\" );\n        sh.setExecutable( \"chmod\" );\n\n        String executable = StringUtils.join( sh.getShellCommandLine( new String[]{} ).iterator(), \" \" );\n\n        assertEquals( \"/bin/sh -c cd \\\"\\\\usr\\\\local\\\\\\'something else\\'\\\" && chmod\", executable );\n    }\n\n    public void testPreserveSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"\\'some arg with spaces\\'\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( args[0] ) );\n    }\n\n    public void testAddSingleQuotesOnArgumentWithSpaces()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"some arg with spaces\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n    }\n\n    public void testEscapeSingleQuotesOnArgument()\n    {\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \"arg'withquote\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertEquals(\"cd /usr/bin && chmod 'arg'\\\\''withquote'\", shellCommandLine.get(shellCommandLine.size() - 1));\n    }\n\n    public void testArgumentsWithsemicolon()\n    {\n\n        System.out.println( \"---- semi colon tests ----\" );\n\n        Shell sh = newShell();\n\n        sh.setWorkingDirectory( \"/usr/bin\" );\n        sh.setExecutable( \"chmod\" );\n\n        String[] args = { \";some&argwithunix$chars\" };\n\n        List shellCommandLine = sh.getShellCommandLine( args );\n\n        String cli = StringUtils.join( shellCommandLine.iterator(), \" \" );\n        System.out.println( cli );\n        assertTrue( cli.endsWith( \"\\'\" + args[0] + \"\\'\" ) );\n\n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod --password ';password'\", lines[2] );\n\n        commandline = new Commandline( new CmdShell() );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \"--password\" );\n        commandline.createArg().setValue( \";password\" );\n        lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"cmd.exe\", lines[0] );\n        assertEquals( \"/X\", lines[1] );\n        assertEquals( \"/C\", lines[2] );\n        assertEquals( \"\\\"--password ;password\\\"\", lines[3] );\n    }\n\n    public void testBourneShellQuotingCharacters()\n        throws Exception\n    {\n        \n        \n        Commandline commandline = new Commandline( newShell() );\n        commandline.setExecutable( \"chmod\" );\n        commandline.getShell().setQuotedArgumentsEnabled( true );\n        commandline.createArg().setValue( \" \" );\n        commandline.createArg().setValue( \"|\" );\n        commandline.createArg().setValue( \"&&\" );\n        commandline.createArg().setValue( \"||\" );\n        commandline.createArg().setValue( \";\" );\n        commandline.createArg().setValue( \";;\" );\n        commandline.createArg().setValue( \"&\" );\n        commandline.createArg().setValue( \"()\" );\n        commandline.createArg().setValue( \"<\" );\n        commandline.createArg().setValue( \"<<\" );\n        commandline.createArg().setValue( \">\" );\n        commandline.createArg().setValue( \">>\" );\n        commandline.createArg().setValue( \"*\" );\n        commandline.createArg().setValue( \"?\" );\n        commandline.createArg().setValue( \"[\" );\n        commandline.createArg().setValue( \"]\" );\n        commandline.createArg().setValue( \"{\" );\n        commandline.createArg().setValue( \"}\" );\n        commandline.createArg().setValue( \"`\" );\n\n        String[] lines = commandline.getShellCommandline();\n        System.out.println( Arrays.asList( lines ) );\n\n        assertEquals( \"/bin/sh\", lines[0] );\n        assertEquals( \"-c\", lines[1] );\n        assertEquals( \"chmod ' ' '|' '&&' '||' ';' ';;' '&' '()' '<' '<<' '>' '>>' '*' '?' '[' ']' '{' '}' '`'\",\n                      lines[2] );\n\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 40,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/eclipse/rdf4j/commit/df15a4d7a8f2789c043b27c9eafe1b30316cfa79",
    "cve_id": "CVE-2018-20227",
    "cwe_id": "CWE-22",
    "filename": "util/src/main/java/org/eclipse/rdf4j/common/io/ZipUtil.java",
    "code": "\n\npackage org.eclipse.rdf4j.common.io;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Enumeration;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n\npublic class ZipUtil {\n\n\t\n\tprivate final static byte MAGIC_NUMBER[] = { (byte)0x50, (byte)0x4B, (byte)0x03, (byte)0x04 };\n\n\tpublic static boolean isZipStream(InputStream in)\n\t\tthrows IOException\n\t{\n\t\tin.mark(MAGIC_NUMBER.length);\n\t\tbyte[] fileHeader = IOUtil.readBytes(in, MAGIC_NUMBER.length);\n\t\tin.reset();\n\t\treturn Arrays.equals(MAGIC_NUMBER, fileHeader);\n\t}\n\n\t\n\tpublic static void extract(File zipFile, File destDir)\n\t\tthrows IOException\n\t{\n\t\ttry (ZipFile zf = new ZipFile(zipFile)) {\n\t\t\textract(zf, destDir);\n\t\t}\n\t}\n\n\t\n\tpublic static void extract(ZipFile zipFile, File destDir)\n\t\tthrows IOException\n\t{\n\t\tassert destDir.isDirectory();\n\n\t\tEnumeration<? extends ZipEntry> entries = zipFile.entries();\n\t\twhile (entries.hasMoreElements()) {\n\t\t\tZipEntry entry = entries.nextElement();\n\t\t\twriteEntry(zipFile, entry, destDir);\n\t\t}\n\t}\n\n\t\n\tpublic static void writeEntry(ZipFile zipFile, ZipEntry entry, File destDir)\n\t\tthrows IOException\n\t{\n\t\tFile outFile = new File(destDir, entry.getName());\n\n\t\tif (entry.isDirectory()) {\n\t\t\toutFile.mkdirs();\n\t\t}\n\t\telse {\n\t\t\toutFile.getParentFile().mkdirs();\n\n\t\t\ttry (InputStream in = zipFile.getInputStream(entry)) {\n\t\t\t\tIOUtil.writeStream(in, outFile);\n\t\t\t}\n\t\t}\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 41,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/ESAPI/esapi-java-legacy/commit/b7cbc53f9cc967cf1a5a9463d8c6fef9ed6ef4f7",
    "cve_id": "CVE-2013-5960",
    "cwe_id": "CWE-310",
    "filename": "src/main/java/org/owasp/esapi/codecs/PercentCodec.java",
    "code": "\npackage org.owasp.esapi.codecs;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Set;\n\nimport org.owasp.esapi.util.CollectionsUtil;\n\n\npublic class PercentCodec extends Codec\n{\n\tprivate static final String ALPHA_NUMERIC_STR = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\t@SuppressWarnings(\"unused\")\n\tprivate static final String RFC3986_RESERVED_STR = \":/?#[]@!$&'()*+,;=\";\n\tprivate static final String RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR = \"-._~\";\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\tprivate static final boolean ENCODED_NON_ALPHA_NUMERIC_UNRESERVED = true;\n\tprivate static final String UNENCODED_STR = ALPHA_NUMERIC_STR +\n\t\t(ENCODED_NON_ALPHA_NUMERIC_UNRESERVED ? \"\" : RFC3986_NON_ALPHANUMERIC_UNRESERVED_STR);\n\tprivate static final Set<Character> UNENCODED_SET = CollectionsUtil.strToUnmodifiableSet(UNENCODED_STR);\n\n\t\n\tprivate static byte[] toUtf8Bytes(String str)\n\t{\n\t\ttry\n\t\t{\n\t\t\treturn str.getBytes(\"UTF-8\");\n\t\t}\n\t\tcatch(UnsupportedEncodingException e)\n\t\t{\n\t\t\tthrow new IllegalStateException(\"The Java spec requires UTF-8 support.\", e);\n\t\t}\n\t}\n\n\t\n\t\n\t\n\t\n\tprivate static StringBuilder appendTwoUpperHex(StringBuilder sb, int b)\n\t{\n\t\tif(b < Byte.MIN_VALUE || b > Byte.MAX_VALUE)\n\t\t\tthrow new IllegalArgumentException(\"b is not a byte (was \" + b + ')');\n\t\tb &= 0xFF;\n\t\tif(b<0x10)\n\t\t\tsb.append('0');\n\t\treturn sb.append(Integer.toHexString(b).toUpperCase());\n\t}\n\n\t\n\tpublic String encodeCharacter( char[] immune, Character c )\n\t{\n\t\tString cStr = String.valueOf(c.charValue());\n\t\tbyte[] bytes;\n\t\tStringBuilder sb;\n\n\t\tif(UNENCODED_SET.contains(c))\n\t\t\treturn cStr;\n\n\t\tbytes = toUtf8Bytes(cStr);\n\t\tsb = new StringBuilder(bytes.length * 3);\n\t\tfor(byte b : bytes)\n\t\t\tappendTwoUpperHex(sb.append('%'), b);\n\t\treturn sb.toString();\n\t}\n\n\t\n\tpublic Character decodeCharacter( PushbackString input ) {\n\t\tinput.mark();\n\t\tCharacter first = input.next();\n\t\tif ( first == null ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t\n\t\tif (first != '%' ) {\n\t\t\tinput.reset();\n\t\t\treturn null;\n\t\t}\n\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor ( int i=0; i<2; i++ ) {\n\t\t\tCharacter c = input.nextHex();\n\t\t\tif ( c != null ) sb.append( c );\n\t\t}\n\t\tif ( sb.length() == 2 ) {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tint i = Integer.parseInt(sb.toString(), 16);\n\t\t\t\tif (Character.isValidCodePoint(i)) {\n\t\t\t\t\treturn (char) i;\n\t\t\t\t}\n\t\t\t} catch( NumberFormatException ignored ) { }\n\t\t}\n\t\tinput.reset();\n\t\treturn null;\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 42,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/esigate/esigate/commit/30cad23a8f282600c9b045e1af09f6f8a65357b1",
    "cve_id": "CVE-2018-1000854",
    "cwe_id": "CWE-74",
    "filename": "esigate-core/src/main/java/org/esigate/xml/XsltRenderer.java",
    "code": "\n\npackage org.esigate.xml;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.StringReader;\nimport java.io.Writer;\n\nimport javax.xml.transform.Source;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMResult;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\n\nimport nu.validator.htmlparser.common.DoctypeExpectation;\nimport nu.validator.htmlparser.dom.Dom2Sax;\nimport nu.validator.htmlparser.dom.HtmlDocumentBuilder;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.http.client.methods.CloseableHttpResponse;\nimport org.esigate.Driver;\nimport org.esigate.HttpErrorPage;\nimport org.esigate.Renderer;\nimport org.esigate.http.HttpResponseUtils;\nimport org.esigate.impl.DriverRequest;\nimport org.w3c.dom.Document;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n\npublic class XsltRenderer implements Renderer {\n    private static final TransformerFactory TRANSFORMER_FACTORY = TransformerFactory.newInstance();\n    private Transformer transformer;\n\n    \n    public XsltRenderer(String template, Driver driver, DriverRequest originalRequest) throws IOException,\n            HttpErrorPage {\n        StringBuilder templateStringBuilder = new StringBuilder();\n        CloseableHttpResponse response = driver.render(template, originalRequest.getOriginalRequest());\n        templateStringBuilder.append(HttpResponseUtils.toString(response));\n        transformer = createTransformer(IOUtils.toInputStream(templateStringBuilder));\n    }\n\n    \n    public XsltRenderer(String xsl) throws IOException {\n        InputStream templateStream = IOUtils.toInputStream(xsl);\n        transformer = createTransformer(templateStream);\n    }\n\n    private static Transformer createTransformer(InputStream templateStream) throws IOException {\n        try {\n            return TRANSFORMER_FACTORY.newTransformer(new StreamSource(templateStream));\n        } catch (TransformerConfigurationException e) {\n            throw new ProcessingFailedException(\"Failed to create XSLT template\", e);\n        } finally {\n            templateStream.close();\n        }\n    }\n\n    \n    @Override\n    public void render(DriverRequest httpRequest, String src, Writer out) throws IOException {\n        try {\n            HtmlDocumentBuilder htmlDocumentBuilder = new HtmlDocumentBuilder();\n            htmlDocumentBuilder.setDoctypeExpectation(DoctypeExpectation.NO_DOCTYPE_ERRORS);\n            Document document = htmlDocumentBuilder.parse(new InputSource(new StringReader(src)));\n            Source source = new DOMSource(document);\n            DOMResult result = new DOMResult();\n            transformer.transform(source, result);\n            XhtmlSerializer serializer = new XhtmlSerializer(out);\n            Dom2Sax dom2Sax = new Dom2Sax(serializer, serializer);\n            dom2Sax.parse(result.getNode());\n        } catch (TransformerException e) {\n            throw new ProcessingFailedException(\"Failed to transform source\", e);\n        } catch (SAXException e) {\n            throw new ProcessingFailedException(\"Failed serialize transformation result\", e);\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 42,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/esigate/esigate/commit/30cad23a8f282600c9b045e1af09f6f8a65357b1",
    "cve_id": "CVE-2018-1000854",
    "cwe_id": "CWE-74",
    "filename": "esigate-core/src/test/java/org/esigate/xml/XsltRendererTest.java",
    "code": "\n\npackage org.esigate.xml;\n\nimport java.io.IOException;\n\nimport junit.framework.TestCase;\n\nimport org.apache.commons.io.output.StringBuilderWriter;\n\npublic class XsltRendererTest extends TestCase {\n\n    \n    public void testXslt() throws IOException {\n        String src = \"<html><body>The body<br></body></html>\";\n        String result = extractBody(src);\n        assertEquals(\"<body>The body<br /></body>\", result);\n    }\n\n    private String extractBody(String src) throws IOException {\n        String template = \"<?xml version=\\\"1.0\\\"?>\";\n        template +=\n                \"<xsl:stylesheet version=\\\"1.0\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\" \"\n                        + \"xmlns:html=\\\"http://www.w3.org/1999/xhtml\\\" \"\n                        + \"xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\">\";\n        template += \"<xsl:output method=\\\"xml\\\" omit-xml-declaration=\\\"yes\\\"/>\";\n        template += \"<xsl:template match=\\\"//html:body\\\">\";\n        template += \"<xsl:copy-of select=\\\".\\\"/>\";\n        template += \"</xsl:template>\";\n        template += \"<xsl:template match=\\\"text()\\\"/>\";\n        template += \"</xsl:stylesheet>\";\n        StringBuilderWriter out = new StringBuilderWriter();\n        XsltRenderer tested = new XsltRenderer(template);\n        tested.render(null, src, out);\n        return out.toString();\n    }\n\n    \n    public void testParserSupportsUnescapedAmpersandCharacter() throws Exception {\n        String src =\n                \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \"\n                        + \"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\"\n                        + \"<html lang=\\\"fr\\\" xml:lang=\\\"fr\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\"\n                        + \"<head><title>The header</title></head><body>&x=</body></html>\";\n        String result = extractBody(src);\n        assertEquals(\"<body>&amp;x=</body>\", result);\n    }\n\n    \n    public void testParserSupportsDuplicatedId() throws Exception {\n        String src =\n                \"<!DOCTYPE html PUBLIC \\\"-//W3C//DTD XHTML 1.0 Strict//EN\\\" \"\n                        + \"\\\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\\\">\"\n                        + \"<html lang=\\\"fr\\\" xml:lang=\\\"fr\\\" xmlns=\\\"http://www.w3.org/1999/xhtml\\\">\"\n                        + \"<head><title>The header</title></head><body>\"\n                        + \"<span id=\\\"test\\\">a</span><span id=\\\"test\\\">b</span></body></html>\";\n        String result = extractBody(src);\n        assertEquals(\"<body><span id=\\\"test\\\">a</span><span id=\\\"test\\\">b</span></body>\", result);\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 43,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/FasterXML/jackson-dataformat-xml/commit/f0f19a4c924d9db9a1e2830434061c8640092cc0",
    "cve_id": "CVE-2016-3720",
    "cwe_id": "Not Mapping",
    "filename": "src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java",
    "code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; \n\n    \n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    \n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    \n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    \n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    \n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    \n\n    \n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    \n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        \n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        \n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    \n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected transient String _jdkXmlInFactory;\n\n    \n    protected transient String _jdkXmlOutFactory;\n\n    \n    @Override \n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    \n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    \n    \n    \n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    \n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    \n\n    \n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    \n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    \n\n    \n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    \n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    \n\n    \n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    \n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    \n\n    \n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    \n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    \n\n    \n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override \n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override \n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    \n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        \n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        \n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    \n\n    \n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        \n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        \n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    \n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    \n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        \n        \n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        \n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        \n        \n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        \n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    \n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    \n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        \n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        \n        if (b == UTF8_BOM_1) { \n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        \n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            \n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        \n        if (b == BYTE_QMARK) { \n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                \n                return MatchStrength.SOLID_MATCH;\n            }\n            \n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            \n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            \n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        \n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { \n            \n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 44,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/FasterXML/jackson-dataformat-xml/commit/eeff2c312e9d4caa8c9f27b8f740c7529d00524a",
    "cve_id": "CVE-2016-7051",
    "cwe_id": "CWE-611",
    "filename": "src/main/java/com/fasterxml/jackson/dataformat/xml/XmlFactory.java",
    "code": "package com.fasterxml.jackson.dataformat.xml;\n\nimport java.io.*;\n\nimport javax.xml.stream.*;\n\nimport org.codehaus.stax2.io.Stax2ByteArraySource;\nimport org.codehaus.stax2.io.Stax2CharArraySource;\n\nimport com.fasterxml.jackson.core.*;\nimport com.fasterxml.jackson.core.format.InputAccessor;\nimport com.fasterxml.jackson.core.format.MatchStrength;\nimport com.fasterxml.jackson.core.io.IOContext;\nimport com.fasterxml.jackson.core.util.VersionUtil;\n\nimport com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser;\nimport com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator;\nimport com.fasterxml.jackson.dataformat.xml.util.StaxUtil;\n\n\npublic class XmlFactory extends JsonFactory\n{\n    private static final long serialVersionUID = 1; \n\n    \n    public final static String FORMAT_NAME_XML = \"XML\";\n\n    \n    final static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n    \n    final static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n    \n\n    protected int _xmlParserFeatures;\n\n    protected int _xmlGeneratorFeatures;\n\n    \n    protected transient XMLInputFactory _xmlInputFactory;\n\n    protected transient XMLOutputFactory _xmlOutputFactory;\n\n    protected String _cfgNameForTextElement;\n    \n    \n\n    \n    public XmlFactory() { this(null, null, null); }\n\n    public XmlFactory(ObjectCodec oc) {\n        this(oc, null, null);\n    }\n\n    public XmlFactory(XMLInputFactory xmlIn) {\n        this(null, xmlIn, null);\n    }\n    \n    public XmlFactory(XMLInputFactory xmlIn, XMLOutputFactory xmlOut) {\n        this(null, xmlIn, xmlOut);\n    }\n    \n    public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        this(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\n                xmlIn, xmlOut, null);\n    }\n\n    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            \n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }\n\n    \n    protected XmlFactory(XmlFactory src, ObjectCodec oc)\n    {\n        super(src, oc);\n        _xmlParserFeatures = src._xmlParserFeatures;\n        _xmlGeneratorFeatures = src._xmlGeneratorFeatures;\n        _cfgNameForTextElement = src._cfgNameForTextElement;\n        _xmlInputFactory = src._xmlInputFactory;\n        _xmlOutputFactory = src._xmlOutputFactory;\n    }\n    \n    protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n    {\n        \n        xmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n        \n        xmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n    }\n\n    \n    @Override\n    public XmlFactory copy() {\n        _checkInvalidCopy(XmlFactory.class);\n        return new XmlFactory(this, null);\n    }\n\n    @Override\n    public Version version() {\n        return PackageVersion.VERSION;\n    }\n\n    \n\n    \n    protected transient String _jdkXmlInFactory;\n\n    \n    protected transient String _jdkXmlOutFactory;\n\n    \n    @Override \n    protected Object readResolve() {\n        if (_jdkXmlInFactory == null) {\n            throw new IllegalStateException(\"No XMLInputFactory class name read during JDK deserialization\");\n        }\n        if (_jdkXmlOutFactory == null) {\n            throw new IllegalStateException(\"No XMLOutputFactory class name read during JDK deserialization\");\n        }\n        try {\n            XMLInputFactory inf = (XMLInputFactory) Class.forName(_jdkXmlInFactory).newInstance();\n            XMLOutputFactory outf = (XMLOutputFactory) Class.forName(_jdkXmlOutFactory).newInstance();\n            return new XmlFactory(_objectCodec, _xmlParserFeatures, _xmlGeneratorFeatures,\n                    inf, outf, _cfgNameForTextElement);\n        } catch (ClassNotFoundException e) {\n            throw new IllegalArgumentException(e);\n        } catch (InstantiationException e) {\n            throw new IllegalArgumentException(e);\n        } catch (IllegalAccessException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    \n    private void readObject(ObjectInputStream in)\n            throws IOException, ClassNotFoundException\n    {\n        in.defaultReadObject();\n        _jdkXmlInFactory = in.readUTF();\n        _jdkXmlOutFactory = in.readUTF();\n    }\n\n    \n    private void writeObject(ObjectOutputStream out) throws IOException {\n        out.defaultWriteObject();\n        out.writeUTF(_xmlInputFactory.getClass().getName());\n        out.writeUTF(_xmlOutputFactory.getClass().getName());\n    }\n    \n    \n    \n    \n    public void setXMLTextElementName(String name) {\n        _cfgNameForTextElement = name;\n    }\n\n    \n    public String getXMLTextElementName() {\n        return _cfgNameForTextElement;\n    }\n    \n    \n\n    \n    public final XmlFactory configure(FromXmlParser.Feature f, boolean state)\n    {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n    public XmlFactory enable(FromXmlParser.Feature f) {\n        _xmlParserFeatures |= f.getMask();\n        return this;\n    }\n\n    \n    public XmlFactory disable(FromXmlParser.Feature f) {\n        _xmlParserFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n    public final boolean isEnabled(FromXmlParser.Feature f) {\n        return (_xmlParserFeatures & f.getMask()) != 0;\n    }\n\n    \n\n    \n    public final XmlFactory configure(ToXmlGenerator.Feature f, boolean state) {\n        if (state) {\n            enable(f);\n        } else {\n            disable(f);\n        }\n        return this;\n    }\n\n    \n    public XmlFactory enable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures |= f.getMask();\n        return this;\n    }\n\n    \n    public XmlFactory disable(ToXmlGenerator.Feature f) {\n        _xmlGeneratorFeatures &= ~f.getMask();\n        return this;\n    }\n\n    \n    public final boolean isEnabled(ToXmlGenerator.Feature f) {\n        return (_xmlGeneratorFeatures & f.getMask()) != 0;\n    }\n\n    \n\n    \n    public XMLInputFactory getXMLInputFactory() {\n        return _xmlInputFactory;\n    }\n\n    public void setXMLInputFactory(XMLInputFactory f) {\n        _xmlInputFactory = f;\n    }\n\n    \n    public XMLOutputFactory getXMLOutputFactory() {\n        return _xmlOutputFactory;\n    }\n    \n    public void setXMLOutputFactory(XMLOutputFactory f) {\n        _xmlOutputFactory = f;\n    }\n\n    \n\n    \n    @Override\n    public String getFormatName() {\n        return FORMAT_NAME_XML;\n    }\n\n    @Override\n    public MatchStrength hasFormat(InputAccessor acc) throws IOException {\n        return hasXMLFormat(acc);\n    }\n\n    \n    @Override\n    public boolean requiresCustomCodec() { return true; }\n\n    \n\n    \n    @Override\n    public boolean canUseCharArrays() { return false; }\n\n    @Override \n    public Class<FromXmlParser.Feature> getFormatReadFeatureType() {\n        return FromXmlParser.Feature.class;\n    }\n\n    @Override \n    public Class<ToXmlGenerator.Feature> getFormatWriteFeatureType() {\n        return ToXmlGenerator.Feature.class;\n    }\n\n    \n\n    \n    @SuppressWarnings(\"resource\")\n    @Override\n    public JsonParser createParser(String content) throws IOException {\n        Reader r = new StringReader(content);\n        IOContext ctxt = _createContext(r, true);\n        if (_inputDecorator != null) {\n            r = _inputDecorator.decorate(ctxt, r);\n        }\n        return _createParser(r, ctxt);\n    }\n    \n    \n\n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out) throws IOException {\n        return createGenerator(out, JsonEncoding.UTF8);\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(OutputStream out, JsonEncoding enc) throws IOException\n    {\n        \n        IOContext ctxt = _createContext(out, false);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt,\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n    \n    @Override\n    public ToXmlGenerator createGenerator(Writer out) throws IOException\n    {\n        return new ToXmlGenerator(_createContext(out, false),\n                _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    @SuppressWarnings(\"resource\")\n    @Override\n    public ToXmlGenerator createGenerator(File f, JsonEncoding enc) throws IOException\n    {\n        OutputStream out = new FileOutputStream(f);\n        \n        IOContext ctxt = _createContext(out, true);\n        ctxt.setEncoding(enc);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, _createXmlWriter(out));\n    }\n\n    \n\n    \n    public FromXmlParser createParser(XMLStreamReader sr) throws IOException\n    {\n        \n        if (sr.getEventType() != XMLStreamConstants.START_ELEMENT) {\n            try {\n                sr = _initializeXmlReader(sr);\n            } catch (XMLStreamException e) {\n                return StaxUtil.throwXmlAsIOException(e);\n            }\n        }\n\n        \n        FromXmlParser xp = new FromXmlParser(_createContext(sr, false),\n                _generatorFeatures, _xmlGeneratorFeatures, _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    \n    public ToXmlGenerator createGenerator(XMLStreamWriter sw) throws IOException\n    {\n        try {\n            sw = _initializeXmlWriter(sw);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        IOContext ctxt = _createContext(sw, false);\n        return new ToXmlGenerator(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sw);\n    }\n    \n    \n\n    @Override\n    protected FromXmlParser _createParser(InputStream in, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(in);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(r);\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected FromXmlParser _createParser(char[] data, int offset, int len, IOContext ctxt,\n            boolean recycleBuffer) throws IOException\n    {\n        \n        \n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2CharArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n    \n    @Override\n    protected FromXmlParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n    {\n        XMLStreamReader sr;\n        try {\n            sr = _xmlInputFactory.createXMLStreamReader(new Stax2ByteArraySource(data, offset, len));\n            sr = _initializeXmlReader(sr);\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n        FromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n                _objectCodec, sr);\n        if (_cfgNameForTextElement != null) {\n            xp.setXMLTextElementName(_cfgNameForTextElement);\n        }\n        return xp;\n    }\n\n    @Override\n    protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException {\n        \n        VersionUtil.throwInternal();\n        return null;\n    }\n\n    \n\n    protected XMLStreamWriter _createXmlWriter(OutputStream out) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(out, \"UTF-8\"));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n    {\n        try {\n            return _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n        } catch (XMLStreamException e) {\n            return StaxUtil.throwXmlAsIOException(e);\n        }\n    }\n\n    protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n    {\n        \n        \n        sw.setDefaultNamespace(\"\");\n        return sw;\n    }\n\n    protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n    {\n        \n        while (sr.next() != XMLStreamConstants.START_ELEMENT) {\n            ;\n        }\n        return sr;\n    }\n\n    \n\n    private final static byte UTF8_BOM_1 = (byte) 0xEF;\n    private final static byte UTF8_BOM_2 = (byte) 0xBB;\n    private final static byte UTF8_BOM_3 = (byte) 0xBF;\n\n    private final static byte BYTE_x = (byte) 'x';\n    private final static byte BYTE_m = (byte) 'm';\n    private final static byte BYTE_l = (byte) 'l';\n    private final static byte BYTE_D = (byte) 'D';\n\n    private final static byte BYTE_LT = (byte) '<';\n    private final static byte BYTE_QMARK = (byte) '?';\n    private final static byte BYTE_EXCL = (byte) '!';\n    private final static byte BYTE_HYPHEN = (byte) '-';\n    \n    \n    public static MatchStrength hasXMLFormat(InputAccessor acc) throws IOException\n    {\n        \n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        byte b = acc.nextByte();\n        \n        if (b == UTF8_BOM_1) { \n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_2) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != UTF8_BOM_3) {\n                return MatchStrength.NO_MATCH;\n            }\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n        }\n        \n        boolean maybeXmlDecl = (b == BYTE_LT);\n        if (!maybeXmlDecl) {\n            int ch = skipSpace(acc, b);\n            if (ch < 0) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = (byte) ch;\n            \n           if (b != BYTE_LT) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        if (!acc.hasMoreBytes()) {\n            return MatchStrength.INCONCLUSIVE;\n        }\n        b = acc.nextByte();\n        \n        if (b == BYTE_QMARK) { \n            b = acc.nextByte();\n            if (b == BYTE_x) {\n                if (maybeXmlDecl) {\n                    if (acc.hasMoreBytes() && acc.nextByte() == BYTE_m) {\n                        if (acc.hasMoreBytes() && acc.nextByte() == BYTE_l) {\n                            return MatchStrength.FULL_MATCH;\n                        }\n                    }\n                }\n                \n                return MatchStrength.SOLID_MATCH;\n            }\n            \n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        } else if (b == BYTE_EXCL) {\n            \n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            b = acc.nextByte();\n            if (b == BYTE_HYPHEN) {\n                if (!acc.hasMoreBytes()) {\n                    return MatchStrength.INCONCLUSIVE;\n                }\n                if (acc.nextByte() == BYTE_HYPHEN) {\n                    return MatchStrength.SOLID_MATCH;\n                }\n            } else if (b == BYTE_D) {\n                return tryMatch(acc, \"OCTYPE\", MatchStrength.SOLID_MATCH);\n            }\n        } else {\n            \n            if (validXmlNameStartChar(acc, b)) {\n                return MatchStrength.SOLID_MATCH;\n            }\n        }\n        return MatchStrength.NO_MATCH;\n    }\n\n    private final static boolean validXmlNameStartChar(InputAccessor acc, byte b)\n        throws IOException\n    {\n        \n        int ch = (int) b & 0xFF;\n        if (ch >= 'A') { \n            \n            return true;\n        }\n        return false;\n    }\n    \n    private final static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\n        throws IOException\n    {\n        for (int i = 0, len = matchStr.length(); i < len; ++i) {\n            if (!acc.hasMoreBytes()) {\n                return MatchStrength.INCONCLUSIVE;\n            }\n            if (acc.nextByte() != matchStr.charAt(i)) {\n                return MatchStrength.NO_MATCH;\n            }\n        }\n        return fullMatchStrength;\n    }\n    \n    private final static int skipSpace(InputAccessor acc, byte b) throws IOException\n    {\n        while (true) {\n            int ch = (int) b & 0xFF;\n            if (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\n                return ch;\n            }\n            if (!acc.hasMoreBytes()) {\n                return -1;\n            }\n            b = acc.nextByte();\n            ch = (int) b & 0xFF;\n        }\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 45,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/inversoft/prime-jwt/commit/abb0d479389a2509f939452a6767dc424bb5e6ba",
    "cve_id": "CVE-2018-1000531",
    "cwe_id": "CWE-20",
    "filename": "src/main/java/org/primeframework/jwt/JWTDecoder.java",
    "code": "\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  \n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    \n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    \n    if (parts.length == 2 && verifiers.length == 0) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    \n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  \n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  \n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n    Objects.requireNonNull(keyFunction);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    \n    if (parts.length == 2 && verifiers.isEmpty()) {\n      if (header.algorithm == Algorithm.none) {\n        return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n      } else {\n        throw new InvalidJWTSignatureException();\n      }\n    }\n\n    \n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    \n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    \n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    \n    if (parts.length == 2 && verifier != null) {\n      throw new InvalidJWTSignatureException();\n    }\n\n    if (parts.length == 3) {\n      \n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    \n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    \n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    \n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 45,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/inversoft/prime-jwt/commit/abb0d479389a2509f939452a6767dc424bb5e6ba",
    "cve_id": "CVE-2018-1000531",
    "cwe_id": "CWE-20",
    "filename": "src/test/java/org/primeframework/jwt/VulnerabilityTest.java",
    "code": "\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidJWTSignatureException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.hmac.HMACSigner;\nimport org.primeframework.jwt.hmac.HMACVerifier;\nimport org.primeframework.jwt.rsa.RSAVerifier;\nimport org.testng.annotations.Test;\n\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.time.ZoneOffset;\nimport java.time.ZonedDateTime;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\npublic class VulnerabilityTest extends BaseTest {\n\n  @Test\n  public void test_SignedWithoutSignature() throws Exception {\n    JWT inputJwt = new JWT()\n        .setSubject(\"123456789\")\n        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC))\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusHours(2));\n\n    String encodedJWT = JWT.getEncoder().encode(inputJwt, HMACSigner.newSHA256Signer(\"secret\"));\n    String encodedJWTNoSignature = encodedJWT.substring(0, encodedJWT.lastIndexOf('.') + 1);\n\n    expectException(InvalidJWTSignatureException.class, () -> JWT.getDecoder().decode(encodedJWTNoSignature, HMACVerifier.newVerifier(\"secret\")));\n\n    \n    expectException(InvalidJWTSignatureException.class, () -> JWT.getDecoder().decode(encodedJWTNoSignature));\n  }\n\n  @Test\n  public void test_encodedJwtWithSignatureRemoved() throws Exception {\n    \n    JWT jwt = new JWT().setSubject(\"art\");\n    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(\"secret\"));\n\n    String hackedJWT = encodedJWT.substring(0, encodedJWT.lastIndexOf(\".\"));\n\n    expectException(InvalidJWTException.class, ()\n        -> JWT.getDecoder().decode(hackedJWT, HMACVerifier.newVerifier(\"secret\")));\n  }\n\n  @Test\n  public void test_noVerification() throws Exception {\n    \n    JWT jwt = new JWT().setSubject(\"art\");\n    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(\"secret\"));\n\n    expectException(MissingVerifierException.class, ()\n        -> JWT.getDecoder().decode(encodedJWT));\n  }\n\n  @Test\n  public void test_vulnerability_HMAC_forgery() throws Exception {\n    \n\n    \n    \n    \n\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    \n    Signer hackedSigner = HMACSigner.newSHA512Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_2048.pem\"))));\n\n    \n    String hmacSignedJWT = JWTEncoder.getInstance().encode(jwt, hackedSigner, h -> h.set(\"kid\", \"abc\"));\n\n    \n    Verifier rsaVerifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_2048.pem\"))));\n    Verifier hmacVerifier = HMACVerifier.newVerifier(\"secret\");\n\n    \n    \n    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWT, rsaVerifier, hmacVerifier));\n\n    Map<String, Verifier> verifierMap = new HashMap<>();\n    verifierMap.put(\"abc\", rsaVerifier);\n    verifierMap.put(\"def\", hmacVerifier);\n\n    \n    \n    expectException(MissingVerifierException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWT, verifierMap));\n\n    \n    String hmacSignedJWTTakeTwo = JWTEncoder.getInstance().encode(jwt, hackedSigner, h -> h.set(\"kid\", \"def\"));\n\n    \n    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWTTakeTwo, rsaVerifier, hmacVerifier));\n    \n    \n    expectException(InvalidJWTSignatureException.class, () -> JWTDecoder.getInstance().decode(hmacSignedJWTTakeTwo, verifierMap));\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 46,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/inversoft/prime-jwt/commit/0d94dcef0133d699f21d217e922564adbb83a227",
    "cve_id": "CVE-2018-1000125",
    "cwe_id": "CWE-20",
    "filename": "src/main/java/org/primeframework/jwt/JWTDecoder.java",
    "code": "\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.Algorithm;\nimport org.primeframework.jwt.domain.Header;\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.json.Mapper;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.function.Function;\n\n\npublic class JWTDecoder {\n\n  private static JWTDecoder instance;\n\n  public static JWTDecoder getInstance() {\n    if (instance == null) {\n      instance = new JWTDecoder();\n    }\n\n    return instance;\n  }\n\n  \n  public JWT decode(String encodedJWT, Verifier... verifiers) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    \n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n\n    \n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.length == 0) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    \n    Verifier verifier = null;\n    for (Verifier v : verifiers) {\n      if (v.canVerify(header.algorithm)) {\n        verifier = v;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  \n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers) {\n    return decode(encodedJWT, verifiers, h -> h.get(\"kid\"));\n  }\n\n  \n  public JWT decode(String encodedJWT, Map<String, Verifier> verifiers, Function<Header, String> keyFunction) {\n    Objects.requireNonNull(encodedJWT);\n    Objects.requireNonNull(verifiers);\n\n    String[] parts = getParts(encodedJWT);\n    Header header = Mapper.deserialize(base64Decode(parts[0].getBytes(StandardCharsets.UTF_8)), Header.class);\n    \n    if (header.algorithm == Algorithm.none && parts.length == 2 && verifiers.isEmpty()) {\n      return Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n    }\n\n    \n    String key = keyFunction.apply(header);\n    Verifier verifier = verifiers.get(key);\n    if (verifier != null) {\n      if (!verifier.canVerify(header.algorithm)) {\n        verifier = null;\n      }\n    }\n\n    return decode(encodedJWT, header, parts, verifier);\n  }\n\n  private byte[] base64Decode(byte[] bytes) {\n    try {\n      return Base64.getUrlDecoder().decode(bytes);\n    } catch (IllegalArgumentException e) {\n      throw new InvalidJWTException(\"The encoded JWT is not properly Base64 encoded.\", e);\n    }\n  }\n\n  private JWT decode(String encodedJWT, Header header, String[] parts, Verifier verifier) {\n    int index = encodedJWT.lastIndexOf(\".\");\n    \n    byte[] message = encodedJWT.substring(0, index).getBytes(StandardCharsets.UTF_8);\n\n    \n    if (parts.length == 3 && verifier == null) {\n      throw new MissingVerifierException(\"No Verifier has been provided for verify a signature signed using [\" + header.algorithm.getName() + \"]\");\n    }\n\n    if (parts.length == 3) {\n      \n      byte[] signature = base64Decode(parts[2].getBytes(StandardCharsets.UTF_8));\n      verifier.verify(header.algorithm, message, signature);\n    }\n\n    JWT jwt = Mapper.deserialize(base64Decode(parts[1].getBytes(StandardCharsets.UTF_8)), JWT.class);\n\n    \n    if (jwt.isExpired()) {\n      throw new JWTExpiredException();\n    }\n\n    \n    if (jwt.isUnavailableForProcessing()) {\n      throw new JWTUnavailableForProcessingException();\n    }\n\n    return jwt;\n  }\n\n  private String[] getParts(String encodedJWT) {\n    String[] parts = encodedJWT.split(\"\\\\.\");\n    \n    if (parts.length == 3 || (parts.length == 2 && encodedJWT.endsWith(\".\"))) {\n      return parts;\n    }\n\n    throw new InvalidJWTException(\"The encoded JWT is not properly formatted. Expected a three part dot separated string.\");\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 46,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/inversoft/prime-jwt/commit/0d94dcef0133d699f21d217e922564adbb83a227",
    "cve_id": "CVE-2018-1000125",
    "cwe_id": "CWE-20",
    "filename": "src/test/java/org/primeframework/jwt/JWTTest.java",
    "code": "\n\npackage org.primeframework.jwt;\n\nimport org.primeframework.jwt.domain.InvalidJWTException;\nimport org.primeframework.jwt.domain.InvalidKeyLengthException;\nimport org.primeframework.jwt.domain.JWT;\nimport org.primeframework.jwt.domain.JWTExpiredException;\nimport org.primeframework.jwt.domain.JWTUnavailableForProcessingException;\nimport org.primeframework.jwt.domain.MissingVerifierException;\nimport org.primeframework.jwt.hmac.HMACSigner;\nimport org.primeframework.jwt.hmac.HMACVerifier;\nimport org.primeframework.jwt.rsa.RSASigner;\nimport org.primeframework.jwt.rsa.RSAVerifier;\nimport org.testng.annotations.Test;\n\nimport java.math.BigDecimal;\nimport java.math.RoundingMode;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.ZoneOffset;\nimport java.time.ZonedDateTime;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertFalse;\nimport static org.testng.Assert.assertTrue;\nimport static org.testng.Assert.fail;\n\n\npublic class JWTTest {\n\n  \n  @Test(enabled = false)\n  public void decoding_performance() throws Exception {\n    String secret = JWTUtils.generateSHA256HMACSecret();\n    Signer hmacSigner = HMACSigner.newSHA256Signer(secret);\n    Signer rsaSigner = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_2048.pem\"))));\n\n    Verifier hmacVerifier = HMACVerifier.newVerifier(secret);\n    Verifier rsaVerifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_2048.pem\"))));\n\n    JWT jwt = new JWT().setSubject(UUID.randomUUID().toString())\n        .addClaim(\"exp\", ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).toInstant().toEpochMilli())\n        .setAudience(UUID.randomUUID().toString())\n        .addClaim(\"roles\", new ArrayList<>(Arrays.asList(\"admin\", \"user\")))\n        .addClaim(\"iat\", ZonedDateTime.now(ZoneOffset.UTC).toInstant().toEpochMilli())\n        .setIssuer(\"inversoft.com\");\n\n    long iterationCount = 250_000;\n    for (Verifier verifier : Arrays.asList(hmacVerifier, rsaVerifier)) {\n      Instant start = Instant.now();\n      Signer signer = verifier instanceof HMACVerifier ? hmacSigner : rsaSigner;\n\n\n      String encodedJWT = JWT.getEncoder().encode(jwt, signer);\n\n      for (int i = 0; i < iterationCount; i++) {\n        JWT.getDecoder().decode(encodedJWT, verifier);\n\n\n      }\n\n      Duration duration = Duration.between(start, Instant.now());\n      BigDecimal durationInMillis = BigDecimal.valueOf(duration.toMillis());\n      BigDecimal average = durationInMillis.divide(BigDecimal.valueOf(iterationCount), RoundingMode.HALF_DOWN);\n      long perSecond = iterationCount / (duration.toMillis() / 1000);\n\n      System.out.println(\"[\" + signer.getAlgorithm().getName() + \"] \" + duration.toMillis() + \" milliseconds total. [\" + iterationCount + \"] iterations. [\" + average + \"] milliseconds per iteration. Approx. [\" + perSecond + \"] per second.\");\n\n    }\n  }\n\n  @Test(enabled = false)\n  public void encoding_performance() throws Exception {\n    Signer hmacSigner = HMACSigner.newSHA256Signer(JWTUtils.generateSHA256HMACSecret());\n    Signer rsaSigner = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_2048.pem\"))));\n\n    JWT jwt = new JWT().setSubject(UUID.randomUUID().toString())\n        .addClaim(\"exp\", ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).toInstant().toEpochMilli())\n        .setAudience(UUID.randomUUID().toString())\n        .addClaim(\"roles\", new ArrayList<>(Arrays.asList(\"admin\", \"user\")))\n        .addClaim(\"iat\", ZonedDateTime.now(ZoneOffset.UTC).toInstant().toEpochMilli())\n        .setIssuer(\"inversoft.com\");\n\n    long iterationCount = 10_000;\n    for (Signer signer : Arrays.asList(hmacSigner, rsaSigner)) {\n\n\n      Instant start = Instant.now();\n      for (int i = 0; i < iterationCount; i++) {\n        JWT.getEncoder().encode(jwt, signer);\n      }\n      Duration duration = Duration.between(start, Instant.now());\n      BigDecimal durationInMillis = BigDecimal.valueOf(duration.toMillis());\n      BigDecimal average = durationInMillis.divide(BigDecimal.valueOf(iterationCount), RoundingMode.HALF_DOWN);\n      long perSecond = iterationCount / (duration.toMillis() / 1000);\n\n      System.out.println(\"[\" + signer.getAlgorithm().getName() + \"] \" + duration.toMillis() + \" milliseconds total. [\" + iterationCount + \"] iterations. [\" + average + \"] milliseconds per iteration. Approx. [\" + perSecond + \"] per second.\");\n    }\n  }\n\n  @Test\n  public void expired() throws Exception {\n    \n    assertFalse(new JWT()\n        .setSubject(\"123456789\").isExpired());\n\n    assertFalse(new JWT()\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(1))\n        .setSubject(\"123456789\").isExpired());\n\n    assertTrue(new JWT()\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(1))\n        .setSubject(\"123456789\").isExpired());\n  }\n\n  @Test\n  public void test_HS256() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n\n    assertEquals(JWT.getEncoder().encode(jwt, signer), \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.qHdut1UR4-2FSAvh7U3YdeRR5r5boVqjIGQ16Ztp894\");\n  }\n\n  @Test\n  public void test_HS256_manualAddedClaim() throws Exception {\n    JWT jwt = new JWT().addClaim(\"test\", \"123456789\");\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n\n    assertEquals(JWT.getEncoder().encode(jwt, signer), \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0ZXN0IjoiMTIzNDU2Nzg5In0.0qgr4ztqB0mNXA8mtqaBSL6UJT3aqEyjHMrWDZmT4Bc\");\n  }\n\n  @Test\n  public void test_HS384() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = HMACSigner.newSHA384Signer(\"secret\");\n\n    String encodedJWT = JWT.getEncoder().encode(jwt, signer);\n    assertEquals(encodedJWT, \"eyJhbGciOiJIUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.sCHKynlQkBveA063_Z-fwcXmRYp_lKQ0fRqGNzplb14qMUj5CV3CfXwluclTF17P\");\n\n    assertEquals(JWT.getDecoder().decode(encodedJWT, HMACVerifier.newVerifier(\"secret\")).subject, jwt.subject);\n  }\n\n  @Test\n  public void test_HS512() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = HMACSigner.newSHA512Signer(\"secret\");\n\n    assertEquals(JWT.getEncoder().encode(jwt, signer), \"eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.MgAi9gfGkep-IoFYPHMhHz6w2Kxf0u8TZ-wNeQOLPwc8emLNKOMqBU-5dJXeaY5-8wQ1CvZycWHbEilvHgN6Ug\");\n  }\n\n  @Test\n  public void test_RS256() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_4096.pem\"))));\n\n    assertEquals(JWT.getEncoder().encode(jwt, signer), \"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.kRXJkOHC98D0LCT2oPg5fTmQJDFXkMRQJopbt7QM6prmQDHwjJL_xO-_EXRXnbvf5NLORto45By3XNn2ZzWmY3pAOxj46MlQ5elhROx2S-EnHZNLfQhoG8ZXPZ54q-Obz_6K7ZSlkAQ8jmeZUO3Ryi8jRlHQ2PT4LbBtLpaf982SGJfeTyUMw1LbvowZUTZSF-E6JARaokmmx8M2GeLuKcFhU-YsBTXUarKp0IJCy3jpMQ2zW_HGjyVWH8WwSIbSdpBn7ztoQEJYO-R5H3qVaAz2BsTuGLRxoyIu1iy2-QcDp5uTufmX1roXM8ciQMpcfwKGiyNpKVIZm-lF8aROXRL4kk4rqp6KUzJuOPljPXRU--xKSua-DeR0BEerKzI9hbwIMWiblCslAciNminoSc9G7pUyVwV5Z5IT8CGJkVgoyVGELeBmYCDy7LHwXrr0poc0hPbE3mJXhzolga4BB84nCg2Hb9tCNiHU8F-rKgZWCONaSSIdhQ49x8OiPafFh2DJBEBe5Xbm6xdCfh3KVG0qe4XL18R5s98aIP9UIC4i62UEgPy6W7Fr7QgUxpXrjRCERBV3MiNu4L8NNJb3oZleq5lQi72EfdS-Bt8ZUOVInIcAvSmu-3i8jB_2sF38XUXdl8gkW8k_b9dJkzDcivCFehvSqGmm3vBm5X4bNmk\");\n  }\n\n  @Test\n  public void test_badEncoding() throws Exception {\n    Verifier verifier = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_2048.pem\"))));\n    \n    expectException(InvalidJWTException.class, ()\n        -> JWT.getDecoder().decode(\"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9 .foo.bar\", verifier));\n  }\n\n  @Test\n  public void test_RS384() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = RSASigner.newSHA384Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_4096.pem\"))));\n\n    String encodedJWT = JWT.getEncoder().encode(jwt, signer);\n    assertEquals(encodedJWT, \"eyJhbGciOiJSUzM4NCIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.OkmWXzhTm7mtfpeMVNLlFjw3fJvc7yMQ1rgI5BXBPqaLSb_fpLHYAq_q5pQDDaIGg8klg9y2f784smc7-o9czX3JnzEDvO9e_sA10YIEA6Q9qRh17EATNXFG-WzSocpxPgEOQZ8lqSqZ_0waCGaUMwK5J5BB1A_70AcNGPnI7PrX76lWNNHwdK0OjkhkxX7vHR6B-uAIzih0ntQP_afr1UIzXkllmnnb1oU9cgFFD1AGDa3V0XCgitVYZA_ozbGELGMrUl_7fB_uNVEvcreUoZIEI4cfUKI6iZ8Ll4j_iLAdlpH4GRGNiQ7gMLq35AqqxKbEG8r-S-SrlRL6PkKlaJ-viMVLxoHreZow634r8A1fxR1mnrdUnn0vGmOthyjpP_TgfAsER9EJ_UUIamsKC8s6pip2jcPB7G6huHocyKBTxsoxclQgk1jOy4lZq4Js2KKM5sGfcq5SWQTW4B44KlUU1kWWmUg21jtflna38sWFdTk845phi5ITOBZ_ElJ9MdYVAgjvDsRFs_XxFENlwpwKeLD9PsaCiJhdG7EJN5qJvVogYuUMM0wyS-SOGZ1ILsTeYsjc7TtI0JUKndlUXFPubwaaxW_06zrCJR-dvWye99fIDH-u3I74XK5MKhknlgewzsXpsiPdvsMW59WUbdIZqkvok5vdkIlm4XGIqcM\");\n\n    assertEquals(JWT.getDecoder().decode(encodedJWT, RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_4096.pem\"))))).subject, jwt.subject);\n  }\n\n  @Test\n  public void test_RS512() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = RSASigner.newSHA512Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_4096.pem\"))));\n\n    assertEquals(JWT.getEncoder().encode(jwt, signer), \"eyJhbGciOiJSUzUxMiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkifQ.ei28WNoJdUpMlLnHr78HiTnnuKwSRLYcOpgUC3daVInT5RAc0kk2Ipx16Z-bHL_eFLSYgF3TSKdymFpNf8cnEu5T6rH0azYSZLrPmVCetDxjo-ixXK9asPOF3JuIbDjN7ow3K-CMbMCWzWp04ZAh-DNecYEd3HiGgooPVGA4HuVXZFHH8XfQ9TD-64ppBQTWgW32vkna8ILKyIXdwWXSEfCZYfLzLZnilJrz820wZJ5JMXimv2au0OwwRobUMLEBUM4iuEPXLf5wFJU6LcU0XMuovavfIXKDpvP9Yfz6UplMlFvIr9y72xExfaNt32vwneAP-Fpg2x9wYvR0W8LhXKZaFRfcYwhbj17GCAbpx34hjiqnwyFStn5Qx_QHz_Y7ck-ZXB2MGUkiYGj9y_8bQNx-LIaTQUX6sONTNdVVCfnOnMHFqVbupGho24K7885-8BxCRojvA0ggneF6dsKCQvAt2rsVRso0TrCVxwYItb9tRsyhCbWou-zh_08JlYGVXPiGY3RRQDfxCc9RHQUflWRS9CBcPtoaco4mFKZSM-9e_xoYx__DEzM3UjaI4jReLM-IARwlVPoHJa2Vcb5wngZTaxGf2ToMq7R_8KecZymb3OaA2X1e8GS2300ySwsXbOz0sJv2a7_JUncSEBPSsb2vMMurxSJ4E3RTAc4s3aU\");\n  }\n\n  @Test\n  public void test_RSA_1024Key() throws Exception {\n    expectException(InvalidKeyLengthException.class, ()\n        -> RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_1024.pem\")))));\n    expectException(InvalidKeyLengthException.class, ()\n        -> RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_1024.pem\")))));\n  }\n\n  @Test\n  public void test_complexPayload() throws Exception {\n    JWT expectedJWT = new JWT()\n        .setAudience(Arrays.asList(\"www.acme.com\", \"www.vandelayindustries.com\"))\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS))\n        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC).truncatedTo(ChronoUnit.SECONDS))\n        .setIssuer(\"www.inversoft.com\")\n        .setNotBefore(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(5).truncatedTo(ChronoUnit.SECONDS))\n        .setUniqueId(UUID.randomUUID().toString())\n        .setSubject(\"123456789\")\n        .addClaim(\"foo\", \"bar\")\n        .addClaim(\"timestamp\", 1476062602926L)\n        .addClaim(\"meaningOfLife\", 42)\n        .addClaim(\"bar\", Arrays.asList(\"bing\", \"bam\", \"boo\"))\n        .addClaim(\"www.inversoft.com/claims/is_admin\", true);\n\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n    Verifier verifier = HMACVerifier.newVerifier(\"secret\");\n\n    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);\n    JWT actualJwt = JWT.getDecoder().decode(encodedJWT, verifier);\n\n    assertEquals(actualJwt.audience, expectedJWT.audience);\n    assertEquals(actualJwt.expiration, expectedJWT.expiration);\n    assertEquals(actualJwt.issuedAt, expectedJWT.issuedAt);\n    assertEquals(actualJwt.issuer, expectedJWT.issuer);\n    assertEquals(actualJwt.notBefore, expectedJWT.notBefore);\n    assertEquals(actualJwt.uniqueId, expectedJWT.uniqueId);\n    assertEquals(actualJwt.subject, expectedJWT.subject);\n    assertEquals(actualJwt.getString(\"foo\"), expectedJWT.getString(\"foo\"));\n    assertEquals(actualJwt.getLong(\"timestamp\"), expectedJWT.getLong(\"timestamp\"));\n    assertEquals(actualJwt.getInteger(\"meaningOfLife\"), expectedJWT.getInteger(\"meaningOfLife\"));\n    assertEquals(actualJwt.getObject(\"bar\"), expectedJWT.getObject(\"bar\"));\n    assertEquals(actualJwt.getBoolean(\"www.inversoft.com/claims/is_admin\"), expectedJWT.getBoolean(\"www.inversoft.com/claims/is_admin\"));\n\n    \n    Map<String, Object> rawClaims = actualJwt.getRawClaims();\n    assertEquals(rawClaims.get(\"aud\"), expectedJWT.audience);\n    assertEquals(rawClaims.get(\"exp\"), expectedJWT.expiration.toEpochSecond());\n    assertEquals(rawClaims.get(\"iat\"), expectedJWT.issuedAt.toEpochSecond());\n    assertEquals(rawClaims.get(\"iss\"), expectedJWT.issuer);\n    assertEquals(rawClaims.get(\"nbf\"), expectedJWT.notBefore.toEpochSecond());\n    assertEquals(rawClaims.get(\"jti\"), expectedJWT.uniqueId);\n    assertEquals(rawClaims.get(\"sub\"), expectedJWT.subject);\n    assertEquals(rawClaims.get(\"foo\"), expectedJWT.getString(\"foo\"));\n    assertEquals(rawClaims.get(\"timestamp\"), expectedJWT.getLong(\"timestamp\"));\n    assertEquals(rawClaims.get(\"meaningOfLife\"), expectedJWT.getInteger(\"meaningOfLife\"));\n    assertEquals(rawClaims.get(\"bar\"), expectedJWT.getObject(\"bar\"));\n    assertEquals(rawClaims.get(\"www.inversoft.com/claims/is_admin\"), expectedJWT.getBoolean(\"www.inversoft.com/claims/is_admin\"));\n  }\n\n  @Test\n  public void test_encodedJwtWithSignatureRemoved() throws Exception {\n    \n    JWT jwt = new JWT().setSubject(\"art\");\n    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(\"secret\"));\n\n    String hackedJWT = encodedJWT.substring(0, encodedJWT.lastIndexOf(\".\"));\n\n    expectException(InvalidJWTException.class, ()\n        -> JWT.getDecoder().decode(hackedJWT, HMACVerifier.newVerifier(\"secret\")));\n  }\n\n  @Test\n  public void test_expiredThrows() throws Exception {\n    JWT expectedJWT = new JWT()\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).minusMinutes(1).truncatedTo(ChronoUnit.SECONDS));\n\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n    Verifier verifier = HMACVerifier.newVerifier(\"secret\");\n\n    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);\n\n    expectException(JWTExpiredException.class, ()\n        -> JWT.getDecoder().decode(encodedJWT, verifier));\n  }\n\n  @Test\n  public void test_multipleSignersAndVerifiers() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n\n    \n    Signer signer1 = HMACSigner.newSHA512Signer(\"secret1\");\n    Signer signer2 = HMACSigner.newSHA512Signer(\"secret2\");\n    Signer signer3 = RSASigner.newSHA256Signer(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_private_key_2048.pem\"))));\n\n    \n    String encodedJWT1 = JWT.getEncoder().encode(jwt, signer1, h -> h.set(\"kid\", \"verifier1\"));\n    String encodedJWT2 = JWT.getEncoder().encode(jwt, signer2, h -> h.set(\"kid\", \"verifier2\"));\n    String encodedJWT3 = JWT.getEncoder().encode(jwt, signer3, h -> h.set(\"kid\", \"verifier3\"));\n\n    Verifier verifier1 = HMACVerifier.newVerifier(\"secret1\");\n    Verifier verifier2 = HMACVerifier.newVerifier(\"secret2\");\n    Verifier verifier3 = RSAVerifier.newVerifier(new String(Files.readAllBytes(Paths.get(\"src/test/resources/rsa_public_key_2048.pem\"))));\n\n    Map<String, Verifier> verifiers = new HashMap<>();\n    verifiers.put(\"verifier1\", verifier1);\n    verifiers.put(\"verifier2\", verifier2);\n    verifiers.put(\"verifier3\", verifier3);\n\n    \n    JWT jwt1 = JWT.getDecoder().decode(encodedJWT1, verifiers);\n    JWT jwt2 = JWT.getDecoder().decode(encodedJWT2, verifiers);\n    JWT jwt3 = JWT.getDecoder().decode(encodedJWT3, verifiers);\n\n    assertEquals(jwt1.subject, jwt2.subject);\n    assertEquals(jwt2.subject, jwt3.subject);\n  }\n\n  @Test\n  public void test_noVerification() throws Exception {\n    \n    JWT jwt = new JWT().setSubject(\"art\");\n    String encodedJWT = JWT.getEncoder().encode(jwt, HMACSigner.newSHA256Signer(\"secret\"));\n\n    expectException(MissingVerifierException.class, ()\n        -> JWT.getDecoder().decode(encodedJWT));\n  }\n\n  @Test\n  public void test_none() throws Exception {\n    JWT jwt = new JWT().setSubject(\"123456789\");\n    Signer signer = new UnsecuredSigner();\n\n    String encodedJWT = JWT.getEncoder().encode(jwt, signer);\n    assertEquals(encodedJWT, \"eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiIxMjM0NTY3ODkifQ.\");\n\n    JWT actual = JWT.getDecoder().decode(encodedJWT);\n    assertEquals(actual.subject, jwt.subject);\n  }\n\n  @Test\n  public void test_notBeforeThrows() throws Exception {\n    JWT expectedJWT = new JWT()\n        .setExpiration(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS))\n        .setIssuedAt(ZonedDateTime.now(ZoneOffset.UTC).truncatedTo(ChronoUnit.SECONDS))\n        .setIssuer(\"www.inversoft.com\")\n        .setNotBefore(ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(5).truncatedTo(ChronoUnit.SECONDS));\n\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n    Verifier verifier = HMACVerifier.newVerifier(\"secret\");\n\n    String encodedJWT = JWT.getEncoder().encode(expectedJWT, signer);\n\n    expectException(JWTUnavailableForProcessingException.class, ()\n        -> JWT.getDecoder().decode(encodedJWT, verifier));\n  }\n\n  @Test\n  public void test_zonedDateTime() throws Exception {\n    ZonedDateTime expiration = ZonedDateTime.now(ZoneOffset.UTC).plusMinutes(60).truncatedTo(ChronoUnit.SECONDS);\n    JWT expectedJWT = new JWT().setExpiration(expiration);\n\n    Signer signer = HMACSigner.newSHA256Signer(\"secret\");\n    Verifier verifier = HMACVerifier.newVerifier(\"secret\");\n\n    String encodedJWT1 = JWT.getEncoder().encode(expectedJWT, signer);\n    JWT actualJWT1 = JWT.getDecoder().decode(encodedJWT1, verifier);\n\n    assertEquals(actualJWT1.expiration, expectedJWT.expiration);\n  }\n\n  private void expectException(Class<? extends Exception> expected, ThrowingRunnable runnable) {\n    try {\n      runnable.run();\n      fail(\"Expected [\" + expected.getCanonicalName() + \"] to be thrown. No Exception was thrown.\");\n    } catch (Exception e) {\n      if (!e.getClass().isAssignableFrom(expected)) {\n        fail(\"Expected [\" + expected.getCanonicalName() + \"] to be thrown. Caught this instead [\" + e.getClass().getCanonicalName() + \"]\");\n      }\n    }\n  }\n\n  private interface ThrowingRunnable {\n    void run() throws Exception;\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 47,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/javamelody/javamelody/commit/aacbc46151ff4ac1ca34ce0899c2a6113071c66e",
    "cve_id": "CVE-2013-4378",
    "cwe_id": "CWE-79",
    "filename": "javamelody-core/src/main/java/net/bull/javamelody/HtmlSessionInformationsReport.java",
    "code": "\r\npackage net.bull.javamelody;\r\n\r\nimport java.io.IOException;\r\nimport java.io.Writer;\r\nimport java.text.DateFormat;\r\nimport java.text.DecimalFormat;\r\nimport java.util.Collections;\r\nimport java.util.List;\r\n\r\nimport net.bull.javamelody.SessionInformations.SessionAttribute;\r\n\r\n\r\nclass HtmlSessionInformationsReport extends HtmlAbstractReport {\r\n\tprivate static final String A_HREF_PART_SESSIONS = \"<a href='?part=sessions\";\r\n\tprivate final List<SessionInformations> sessionsInformations;\r\n\tprivate final DecimalFormat integerFormat = I18N.createIntegerFormat();\r\n\tprivate final DateFormat durationFormat = I18N.createDurationFormat();\r\n\tprivate final DateFormat expiryFormat = I18N.createDateAndTimeFormat();\r\n\r\n\tHtmlSessionInformationsReport(List<SessionInformations> sessionsInformations, Writer writer) {\r\n\t\tsuper(writer);\r\n\t\tthis.sessionsInformations = sessionsInformations;\r\n\t}\r\n\r\n\t@Override\r\n\tvoid toHtml() throws IOException {\r\n\t\twriteBackAndRefreshLinks();\r\n\t\twriteln(\"<br/>\");\r\n\r\n\t\tassert sessionsInformations != null;\r\n\t\tif (sessionsInformations.isEmpty()) {\r\n\t\t\twriteln(\"#Aucune_session#\");\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twriteTitle(\"system-users.png\", getString(\"Sessions\"));\r\n\t\twriteSessions(sessionsInformations);\r\n\t\tlong totalSerializedSize = 0;\r\n\t\tint nbSerializableSessions = 0;\r\n\t\tfor (final SessionInformations sessionInformations : sessionsInformations) {\r\n\t\t\tfinal int size = sessionInformations.getSerializedSize();\r\n\t\t\tif (size >= 0) {\r\n\t\t\t\ttotalSerializedSize += size;\r\n\t\t\t\tnbSerializableSessions++;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinal long meanSerializedSize;\r\n\t\tif (nbSerializableSessions > 0) {\r\n\t\t\tmeanSerializedSize = totalSerializedSize / nbSerializableSessions;\r\n\t\t} else {\r\n\t\t\tmeanSerializedSize = -1;\r\n\t\t}\r\n\t\twriteln(\"<div align='right'>\"\r\n\t\t\t\t+ getFormattedString(\"nb_sessions\", sessionsInformations.size()) + \"<br/><br/>\"\r\n\t\t\t\t+ getFormattedString(\"taille_moyenne_sessions\", meanSerializedSize) + \"</div>\");\r\n\t}\r\n\r\n\tprivate void writeSessions(List<SessionInformations> sessions) throws IOException {\r\n\t\tboolean displayUser = false;\r\n\t\tfor (final SessionInformations sessionInformations : sessions) {\r\n\t\t\tif (sessionInformations.getRemoteUser() != null) {\r\n\t\t\t\tdisplayUser = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinal HtmlTable table = new HtmlTable();\r\n\t\ttable.beginTable(getString(\"Sessions\"));\r\n\t\twrite(\"<th>#Session_id#</th><th class='sorttable_numeric'>#Dernier_acces#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Age#</th><th class='sorttable_date'>#Expiration#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Nb_attributs#</th><th>#Serialisable#</th><th>#Taille_serialisee#</th>\");\r\n\t\twrite(\"<th class='sorttable_numeric'>#Adresse_IP#</th><th>#Pays#</th>\");\r\n\t\tif (displayUser) {\r\n\t\t\twrite(\"<th>#Utilisateur#</th>\");\r\n\t\t}\r\n\t\twrite(\"<th class='noPrint'>#Invalider#</th>\");\r\n\t\tfor (final SessionInformations session : sessions) {\r\n\t\t\ttable.nextRow();\r\n\t\t\twriteSession(session, displayUser);\r\n\t\t}\r\n\t\ttable.endTable();\r\n\t}\r\n\r\n\tprivate void writeBackAndRefreshLinks() throws IOException {\r\n\t\twriteln(\"<div class='noPrint'>\");\r\n\t\twriteln(\"<a href='javascript:history.back()'>\");\r\n\t\twriteln(\"<img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>\");\r\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS + \"'>\");\r\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\r\n\t\tif (isPdfEnabled()) {\r\n\t\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\t\twrite(A_HREF_PART_SESSIONS + \"&amp;format=pdf' title='#afficher_PDF#'>\");\r\n\t\t\twrite(\"<img src='?resource=pdf.png' alt='#PDF#'/> #PDF#</a>\");\r\n\t\t}\r\n\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS\r\n\t\t\t\t+ \"&amp;action=invalidate_sessions' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_sessions\") + \"');\\\">\");\r\n\t\twriteln(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_sessions#' title='#invalidate_sessions#' /> #invalidate_sessions#</a>\");\r\n\t\twriteln(\"</div>\");\r\n\t}\r\n\r\n\tprivate void writeBackAndRefreshLinksForSession(String sessionId) throws IOException {\r\n\t\twriteln(\"<div class='noPrint'>\");\r\n\t\twriteln(\"<a href='javascript:history.back()'><img src='?resource=action_back.png' alt='#Retour#'/> #Retour#</a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\r\n\t\twriteln(A_HREF_PART_SESSIONS + \"&amp;sessionId=\" + urlEncode(sessionId) + \"'>\");\r\n\t\twriteln(\"<img src='?resource=action_refresh.png' alt='#Actualiser#'/> #Actualiser#</a>\");\r\n\t\twriteln(\"</div>\");\r\n\t}\r\n\r\n\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\r\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\r\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\r\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"'>\");\r\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\r\n\t\twrite(\"</a>\");\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getLastAccess()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(durationFormat.format(session.getAge()));\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\r\n\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getAttributeCount()));\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\tif (session.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(nextColumnAlignRight);\r\n\t\twrite(integerFormat.format(session.getSerializedSize()));\r\n\t\tfinal String nextColumn = \"</td><td>\";\r\n\t\twrite(nextColumn);\r\n\t\tfinal String remoteAddr = session.getRemoteAddr();\r\n\t\tif (remoteAddr == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\twrite(remoteAddr);\r\n\t\t}\r\n\t\twrite(nextColumnAlignCenter);\r\n\t\twriteCountry(session);\r\n\t\tif (displayUser) {\r\n\t\t\twrite(nextColumn);\r\n\t\t\tfinal String remoteUser = session.getRemoteUser();\r\n\t\t\tif (remoteUser == null) {\r\n\t\t\t\twrite(\"&nbsp;\");\r\n\t\t\t} else {\r\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\r\n\t\t\t}\r\n\t\t}\r\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\r\n\t\twrite(A_HREF_PART_SESSIONS);\r\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\r\n\t\twrite(urlEncode(session.getId()));\r\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\r\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\r\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\r\n\t\twrite(\"</a>\");\r\n\t\twrite(\"</td>\");\r\n\t}\r\n\r\n\tprivate void writeCountry(SessionInformations session) throws IOException {\r\n\t\tfinal String country = session.getCountry();\r\n\t\tif (country == null) {\r\n\t\t\twrite(\"&nbsp;\");\r\n\t\t} else {\r\n\t\t\tfinal String fileName = \"flags/\" + country + \".gif\";\r\n\t\t\tif (getClass().getResource(Parameters.getResourcePath(fileName)) == null) {\r\n\t\t\t\twrite(country);\r\n\t\t\t} else {\r\n\t\t\t\twrite(\"<img src='?resource=\");\r\n\t\t\t\twrite(fileName);\r\n\t\t\t\twrite(\"' alt='\");\r\n\t\t\t\twrite(country);\r\n\t\t\t\twrite(\"' title='\");\r\n\t\t\t\twrite(session.getCountryDisplay());\r\n\t\t\t\twrite(\"' />\");\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid writeSessionDetails(String sessionId, SessionInformations sessionInformations)\r\n\t\t\tthrows IOException {\r\n\t\twriteBackAndRefreshLinksForSession(sessionId);\r\n\t\twriteln(\"<br/>\");\r\n\r\n\t\tif (sessionInformations == null) {\r\n\t\t\twriteln(getFormattedString(\"session_invalidee\", htmlEncodeButNotSpace(sessionId)));\r\n\t\t\treturn;\r\n\t\t}\r\n\t\twriteTitle(\"system-users.png\",\r\n\t\t\t\tgetFormattedString(\"Details_session\", htmlEncodeButNotSpace(sessionId)));\r\n\t\twriteSessions(Collections.singletonList(sessionInformations));\r\n\r\n\t\twriteln(\"<br/><b>#Attributs#</b>\");\r\n\t\twriteSessionAttributes(sessionInformations);\r\n\t}\r\n\r\n\tprivate void writeSessionAttributes(SessionInformations sessionInformations) throws IOException {\r\n\t\tfinal HtmlTable table = new HtmlTable();\r\n\t\ttable.beginTable(getString(\"Attributs\"));\r\n\t\twrite(\"<th>#Nom#</th><th>Type</th><th>#Serialisable#</th><th>#Taille_serialisee#</th><th>#Contenu#</th>\");\r\n\t\tfor (final SessionAttribute sessionAttribute : sessionInformations.getAttributes()) {\r\n\t\t\ttable.nextRow();\r\n\t\t\twriteAttribute(sessionAttribute);\r\n\t\t}\r\n\t\ttable.endTable();\r\n\t}\r\n\r\n\tprivate void writeAttribute(SessionAttribute sessionAttribute) throws IOException {\r\n\t\twrite(\"<td>\");\r\n\t\twriteDirectly(htmlEncodeButNotSpace(sessionAttribute.getName()));\r\n\t\twrite(\"</td><td>\");\r\n\t\twrite(String.valueOf(sessionAttribute.getType()));\r\n\t\twrite(\"</td><td align='center'>\");\r\n\t\tif (sessionAttribute.isSerializable()) {\r\n\t\t\twrite(\"#oui#\");\r\n\t\t} else {\r\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\r\n\t\t}\r\n\t\twrite(\"</td><td align='right'>\");\r\n\t\twrite(integerFormat.format(sessionAttribute.getSerializedSize()));\r\n\t\twrite(\"</td><td>\");\r\n\t\twriteDirectly(htmlEncodeButNotSpace(String.valueOf(sessionAttribute.getContent())));\r\n\t\twrite(\"</td>\");\r\n\t}\r\n}\r\n",
    "is_vulnerable": 1
  },
  {
    "id": 48,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/ccm-plugin/commit/066cb43b4413b3490d822ec8b8a32072ebd213ca",
    "cve_id": "CVE-2018-1000054",
    "cwe_id": "CWE-918",
    "filename": "src/main/java/hudson/plugins/ccm/parser/CcmParser.java",
    "code": "\npackage hudson.plugins.ccm.parser;\n\nimport hudson.plugins.analysis.core.AbstractAnnotationParser;\nimport hudson.plugins.analysis.util.model.FileAnnotation;\nimport hudson.plugins.analysis.util.model.Priority;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.apache.commons.digester.Digester;\nimport org.apache.commons.lang.StringUtils;\nimport org.xml.sax.SAXException;\n\n\npublic class CcmParser extends AbstractAnnotationParser {\n\n\tprivate static final long serialVersionUID = -5172155190810975806L;\n\t\n\t\n    public CcmParser() {\n        super(StringUtils.EMPTY);\n    }\n\t\n\t\n\tpublic CcmParser(String defaultEncoding) {\n\t\tsuper(defaultEncoding);\n\t}\n\n\t\n\t@Override\n\tpublic Collection<FileAnnotation> parse(InputStream file, String moduleName)\n\t\t\tthrows InvocationTargetException {\n\t\ttry {\n            Ccm module = parseCCMXmlFile(file);\n\t\t\tif (module == null) {\n                throw new SAXException(\"Input stream is not a CCM file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n\t}\n\n\tprivate Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tDigester digester = new Digester();\n\t\tdigester.setValidating(false);\n\t\tdigester.setClassLoader(CcmParser.class.getClassLoader());\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}\n\n\t\n\tprivate Collection<FileAnnotation> convert(Ccm collection, String moduleName) {\n\t\tArrayList<FileAnnotation> annotations = new ArrayList<FileAnnotation>();\n\t\t\n\t\tfor (Metric metric : collection.getMetrics()) {\n\t\t\tPriority priority = calculateMetricPriority(metric);\n\n\t\t\tString complexity = String.format(\"%s has a complexity of %d\", metric.getUnit(), metric.getComplexity());\n\n\t\t\tBug bug = new Bug(priority, complexity, metric.getClassification(),\n\t\t\t\t\t\"Cyclomatic Complexity\", metric.getStartLineNumber(), metric.getEndLineNumber());\n\t\t\tbug.setPackageName(\"-\");\n\t\t\tbug.setModuleName(moduleName);\n\t\t\tbug.setFileName(metric.getFile());\n\t\t\tbug.setColumnPosition(0, 0);\n\n\t\t\ttry {\n\t\t\t\tbug.setContextHashCode(createContextHashCode(metric.getFile() + metric.getUnit() + metric.getClassification(), 0));\n\t\t\t} catch (IOException exception) {\n\t\t\t\t\n\t\t\t}\n\n\t\t\tannotations.add(bug);\n\t\t}\n\n\t\treturn annotations;\n\t}\n\n\tprivate Priority calculateMetricPriority(Metric metric){\n\t\tPriority priority;\n\t\tif (isMetricHighPriority(metric)) {\n\t\t\tpriority = Priority.HIGH;\n\t\t} else if (isMetricModeratePriority(metric)) {\n\t\t\tpriority = Priority.NORMAL;\n\t\t} else {\n\t\t\tpriority = Priority.LOW;\n\t\t}\n\n\t\treturn priority;\n\t}\n\n\tprivate boolean isMetricHighPriority(Metric metric){\n\t\tString metricClassification = metric.getClassification();\n\t\tif (metricClassification.contains(\"high\")){\n\t\t\treturn true;\n\t\t}\n\t\telse if (metricClassification.contentEquals(\"C\") || metricClassification.contentEquals(\"D\") ||\n\t\t\t\tmetricClassification.contentEquals(\"E\") || metricClassification.contentEquals((\"F\"))){\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate boolean isMetricModeratePriority(Metric metric){\n\t\tString metricClassification = metric.getClassification();\n\t\tif (metricClassification.contains(\"moderate\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (metricClassification.contentEquals(\"B\")) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 49,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/groovy-sandbox/commit/0cd7ec12b7c56cfa3167d99c5f43147ce05449d3",
    "cve_id": "CVE-2018-1000865",
    "cwe_id": "CWE-269",
    "filename": "src/main/java/org/kohsuke/groovy/sandbox/SandboxTransformer.java",
    "code": "package org.kohsuke.groovy.sandbox;\n\nimport groovy.lang.Script;\nimport java.lang.reflect.Modifier;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicReference;\nimport org.codehaus.groovy.GroovyBugError;\nimport org.codehaus.groovy.ast.ASTNode;\nimport org.codehaus.groovy.ast.ClassCodeExpressionTransformer;\nimport org.codehaus.groovy.ast.ClassHelper;\nimport org.codehaus.groovy.ast.ClassNode;\nimport org.codehaus.groovy.ast.ConstructorNode;\nimport org.codehaus.groovy.ast.FieldNode;\nimport org.codehaus.groovy.ast.MethodNode;\nimport org.codehaus.groovy.ast.Parameter;\nimport org.codehaus.groovy.ast.expr.ArgumentListExpression;\nimport org.codehaus.groovy.ast.expr.AttributeExpression;\nimport org.codehaus.groovy.ast.expr.CastExpression;\nimport org.codehaus.groovy.ast.expr.ClassExpression;\nimport org.codehaus.groovy.ast.expr.ClosureExpression;\nimport org.codehaus.groovy.ast.expr.ConstantExpression;\nimport org.codehaus.groovy.ast.expr.DeclarationExpression;\nimport org.codehaus.groovy.ast.expr.EmptyExpression;\nimport org.codehaus.groovy.ast.expr.Expression;\nimport org.codehaus.groovy.ast.expr.ListExpression;\nimport org.codehaus.groovy.ast.expr.MethodCallExpression;\nimport org.codehaus.groovy.ast.expr.MethodPointerExpression;\nimport org.codehaus.groovy.ast.expr.PostfixExpression;\nimport org.codehaus.groovy.ast.expr.PrefixExpression;\nimport org.codehaus.groovy.ast.expr.PropertyExpression;\nimport org.codehaus.groovy.ast.expr.StaticMethodCallExpression;\nimport org.codehaus.groovy.ast.expr.TupleExpression;\nimport org.codehaus.groovy.classgen.GeneratorContext;\nimport org.codehaus.groovy.control.CompilePhase;\nimport org.codehaus.groovy.control.SourceUnit;\nimport org.codehaus.groovy.control.customizers.CompilationCustomizer;\nimport org.codehaus.groovy.ast.expr.ConstructorCallExpression;\nimport org.codehaus.groovy.ast.expr.BinaryExpression;\nimport org.codehaus.groovy.runtime.ScriptBytecodeAdapter;\nimport org.codehaus.groovy.syntax.Token;\nimport org.codehaus.groovy.syntax.Types;\nimport org.codehaus.groovy.ast.expr.FieldExpression;\nimport org.codehaus.groovy.ast.expr.VariableExpression;\nimport org.kohsuke.groovy.sandbox.impl.Checker;\nimport org.kohsuke.groovy.sandbox.impl.Ops;\nimport org.kohsuke.groovy.sandbox.impl.SandboxedMethodClosure;\n\nimport static org.codehaus.groovy.ast.expr.ArgumentListExpression.EMPTY_ARGUMENTS;\nimport org.codehaus.groovy.ast.stmt.BlockStatement;\nimport org.codehaus.groovy.ast.stmt.ExpressionStatement;\nimport org.codehaus.groovy.ast.stmt.Statement;\nimport org.codehaus.groovy.runtime.typehandling.DefaultTypeTransformation;\nimport static org.codehaus.groovy.syntax.Types.*;\n\n\npublic class SandboxTransformer extends CompilationCustomizer {\n    \n    boolean interceptMethodCall=true;\n    \n    boolean interceptConstructor=true;\n    \n    boolean interceptProperty=true;\n    \n    boolean interceptArray=true;\n    \n    boolean interceptAttribute=true;\n\n    public SandboxTransformer() {\n        super(CompilePhase.CANONICALIZATION);\n    }\n\n    @Override\n    public void call(final SourceUnit source, GeneratorContext context, ClassNode classNode) {\n        if (classNode == null) { \n            return;\n        }\n\n        ClassCodeExpressionTransformer visitor = createVisitor(source, classNode);\n\n        processConstructors(visitor, classNode);\n        for (MethodNode m : classNode.getMethods()) {\n            visitor.visitMethod(m);\n        }\n        for (Statement s : classNode.getObjectInitializerStatements()) {\n            s.visit(visitor);\n        }\n        for (FieldNode f : classNode.getFields()) {\n            visitor.visitField(f);\n        }\n    }\n\n    \n    private static final Set<String> TRIVIAL_CONSTRUCTORS = new HashSet<>(Arrays.asList(\n        Object.class.getName(),\n        Script.class.getName(),\n        \"com.cloudbees.groovy.cps.SerializableScript\",\n        \"org.jenkinsci.plugins.workflow.cps.CpsScript\"));\n    \n    public void processConstructors(final ClassCodeExpressionTransformer visitor, ClassNode classNode) {\n        ClassNode superClass = classNode.getSuperClass();\n        List<ConstructorNode> declaredConstructors = classNode.getDeclaredConstructors();\n        if (TRIVIAL_CONSTRUCTORS.contains(superClass.getName())) {\n            for (ConstructorNode c : declaredConstructors) {\n                visitor.visitMethod(c);\n            }\n        } else {\n            if (declaredConstructors.isEmpty()) {\n                ConstructorNode syntheticConstructor = new ConstructorNode(Modifier.PUBLIC, new BlockStatement());\n                declaredConstructors = Collections.singletonList(syntheticConstructor);\n                classNode.addConstructor(syntheticConstructor);\n            } else {\n                declaredConstructors = new ArrayList<>(declaredConstructors);\n            }\n            for (ConstructorNode c : declaredConstructors) {\n                Statement code = c.getCode();\n                List<Statement> body;\n                if (code instanceof BlockStatement) {\n                    body = ((BlockStatement) code).getStatements();\n                } else {\n                    body = Collections.singletonList(code);\n                }\n                TupleExpression superArgs = new TupleExpression();\n                if (!body.isEmpty() && body.get(0) instanceof ExpressionStatement && ((ExpressionStatement) body.get(0)).getExpression() instanceof ConstructorCallExpression) {\n                    ConstructorCallExpression cce = (ConstructorCallExpression) ((ExpressionStatement) body.get(0)).getExpression();\n                    if (cce.isThisCall()) { \n                        visitor.visitMethod(c);\n                        continue;\n                    } else if (cce.isSuperCall()) {\n                        body = body.subList(1, body.size());\n                        superArgs = ((TupleExpression) cce.getArguments());\n                    }\n                }\n                List<Expression> thisArgs = new ArrayList<>();\n                final TupleExpression _superArgs = superArgs;\n                final AtomicReference<Expression> superArgsTransformed = new AtomicReference<>();\n                ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                    @Override\n                    public void run() {\n                        superArgsTransformed.set(((VisitorImpl) visitor).transformArguments(_superArgs));\n                    }\n                });\n                thisArgs.add(((VisitorImpl) visitor).makeCheckedCall(\"checkedSuperConstructor\", new ClassExpression(superClass), superArgsTransformed.get()));\n                Parameter[] origParams = c.getParameters();\n                for (Parameter p : origParams) {\n                    thisArgs.add(new VariableExpression(p));\n                }\n                c.setCode(new BlockStatement(new Statement[] {new ExpressionStatement(new ConstructorCallExpression(ClassNode.THIS, new TupleExpression(thisArgs)))}, c.getVariableScope()));\n                Parameter[] params = new Parameter[origParams.length + 1];\n                params[0] = new Parameter(new ClassNode(Checker.SuperConstructorWrapper.class), \"$scw\");\n                System.arraycopy(origParams, 0, params, 1, origParams.length);\n                List<Expression> scwArgs = new ArrayList<>();\n                int x = 0;\n                for (Expression superArg : superArgs) {\n                    scwArgs.add(new MethodCallExpression(new VariableExpression(\"$scw\"), \"arg\", new ConstantExpression(x++)));\n                }\n                List<Statement> body2 = new ArrayList<>();\n                body2.add(0, new ExpressionStatement(new ConstructorCallExpression(ClassNode.SUPER, new ArgumentListExpression(scwArgs))));\n                for (final Statement s : body) {\n                    ((ScopeTrackingClassCodeExpressionTransformer) visitor).withMethod(c, new Runnable() {\n                        @Override\n                        public void run() {\n                            s.visit(visitor);\n                        }\n                    });\n                    body2.add(s);\n                }\n                ConstructorNode c2 = new ConstructorNode(Modifier.PRIVATE, params, c.getExceptions(), new BlockStatement(body2, c.getVariableScope()));\n                \n                classNode.addConstructor(c2);\n            }\n        }\n    }\n\n    @Deprecated\n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source) {\n        return createVisitor(source, null);\n    }\n    \n    public ClassCodeExpressionTransformer createVisitor(SourceUnit source, ClassNode clazz) {\n        return new VisitorImpl(source, clazz);\n    }\n\n    class VisitorImpl extends ScopeTrackingClassCodeExpressionTransformer {\n        private final SourceUnit sourceUnit;\n        \n        private boolean visitingClosureBody;\n\n        \n        private ClassNode clazz;\n\n        VisitorImpl(SourceUnit sourceUnit, ClassNode clazz) {\n            this.sourceUnit = sourceUnit;\n            this.clazz = clazz;\n        }\n\n        @Override\n        public void visitMethod(MethodNode node) {\n            if (clazz == null) { \n                clazz = node.getDeclaringClass();\n            }\n            super.visitMethod(node);\n        }\n\n        \n        Expression transformArguments(Expression e) {\n            List<Expression> l;\n            if (e instanceof TupleExpression) {\n                List<Expression> expressions = ((TupleExpression) e).getExpressions();\n                l = new ArrayList<>(expressions.size());\n                for (Expression expression : expressions) {\n                    l.add(transform(expression));\n                }\n            } else {\n                l = Collections.singletonList(transform(e));\n            }\n\n            \n            return withLoc(e,new MethodCallExpression(new ListExpression(l),\"toArray\",new ArgumentListExpression()));\n        }\n        \n        Expression makeCheckedCall(String name, Expression... arguments) {\n            return new StaticMethodCallExpression(checkerClass,name,\n                new ArgumentListExpression(arguments));\n        }\n    \n        @Override\n        public Expression transform(Expression exp) {\n            Expression o = innerTransform(exp);\n            if (o!=exp) {\n                o.setSourcePosition(exp);\n            }\n            return o;\n        }\n\n        private Expression innerTransform(Expression exp) {\n            if (exp instanceof ClosureExpression) {\n                \n                ClosureExpression ce = (ClosureExpression)exp;\n                try (StackVariableSet scope = new StackVariableSet(this)) {\n                    Parameter[] parameters = ce.getParameters();\n                    if (parameters != null) {\n                        \n                        if (parameters.length > 0) {\n                            for (Parameter p : parameters) {\n                                declareVariable(p);\n                            }\n                        } else {\n                            \n                            declareVariable(new Parameter(ClassHelper.DYNAMIC_TYPE, \"it\"));\n                        }\n                    }\n                    boolean old = visitingClosureBody;\n                    visitingClosureBody = true;\n                    try {\n                        ce.getCode().visit(this);\n                    } finally {\n                        visitingClosureBody = old;\n                    }\n                }\n            }\n\n            if (exp instanceof MethodCallExpression && interceptMethodCall) {\n                \n                \n                \n                \n                MethodCallExpression call = (MethodCallExpression) exp;\n\n                Expression objExp;\n                if (call.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(call.getObjectExpression()))\n                    objExp = CLOSURE_THIS;\n                else\n                    objExp = transform(call.getObjectExpression());\n\n                Expression arg1 = call.getMethod();\n                Expression arg2 = transformArguments(call.getArguments());\n\n                if (call.getObjectExpression() instanceof VariableExpression && ((VariableExpression) call.getObjectExpression()).getName().equals(\"super\")) {\n                    if (clazz == null) {\n                        throw new IllegalStateException(\"owning class not defined\");\n                    }\n                    return makeCheckedCall(\"checkedSuperCall\", new ClassExpression(clazz), objExp, arg1, arg2);\n                } else {\n                    return makeCheckedCall(\"checkedCall\",\n                            objExp,\n                            boolExp(call.isSafe()),\n                            boolExp(call.isSpreadSafe()),\n                            arg1,\n                            arg2);\n                }\n            }\n            \n            if (exp instanceof StaticMethodCallExpression && interceptMethodCall) {\n                \n                StaticMethodCallExpression call = (StaticMethodCallExpression) exp;\n                return makeCheckedCall(\"checkedStaticCall\",\n                            new ClassExpression(call.getOwnerType()),\n                            new ConstantExpression(call.getMethod()),\n                            transformArguments(call.getArguments())\n                    );\n            }\n\n            if (exp instanceof MethodPointerExpression && interceptMethodCall) {\n                MethodPointerExpression mpe = (MethodPointerExpression) exp;\n                return new ConstructorCallExpression(\n                        new ClassNode(SandboxedMethodClosure.class),\n                        new ArgumentListExpression(mpe.getExpression(), mpe.getMethodName())\n                );\n            }\n\n            if (exp instanceof ConstructorCallExpression && interceptConstructor) {\n                if (!((ConstructorCallExpression) exp).isSpecialCall()) {\n                    \n                    return makeCheckedCall(\"checkedConstructor\",\n                            new ClassExpression(exp.getType()),\n                            transformArguments(((ConstructorCallExpression) exp).getArguments())\n                    );\n                } else {\n                    \n                    \n                    \n                }\n            }\n\n            if (exp instanceof AttributeExpression && interceptAttribute) {\n                AttributeExpression ae = (AttributeExpression) exp;\n                return makeCheckedCall(\"checkedGetAttribute\",\n                    transform(ae.getObjectExpression()),\n                    boolExp(ae.isSafe()),\n                    boolExp(ae.isSpreadSafe()),\n                    transform(ae.getProperty())\n                );\n            }\n\n            if (exp instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) exp;\n                return makeCheckedCall(\"checkedGetProperty\",\n                    transformObjectExpression(pe),\n                    boolExp(pe.isSafe()),\n                    boolExp(pe.isSpreadSafe()),\n                    transform(pe.getProperty())\n                );\n            }\n\n            if (exp instanceof VariableExpression && interceptProperty) {\n                VariableExpression vexp = (VariableExpression) exp;\n                if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                    \n                    return super.transform(exp);\n                } else {\n                    \n                    \n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                    pexp.setImplicitThis(true);\n                    withLoc(exp,pexp);\n                    return transform(pexp);\n                }\n            }\n\n            if (exp instanceof DeclarationExpression) {\n                handleDeclarations((DeclarationExpression) exp);\n            }\n\n            if (exp instanceof BinaryExpression) {\n                BinaryExpression be = (BinaryExpression) exp;\n                \n                if (ofType(be.getOperation().getType(),ASSIGNMENT_OPERATOR)) {\n                    \n\n                    \n                    \n                    \n                    \n\n                    Expression lhs = be.getLeftExpression();\n                    if (lhs instanceof VariableExpression) {\n                        VariableExpression vexp = (VariableExpression) lhs;\n                        if (isLocalVariable(vexp.getName()) || vexp.getName().equals(\"this\") || vexp.getName().equals(\"super\")) {\n                            \n                            return super.transform(exp);\n                        } else {\n                            \n                            \n                            PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, vexp.getName());\n                            pexp.setImplicitThis(true);\n                            pexp.setSourcePosition(vexp);\n\n                            lhs = pexp;\n                        }\n                    } \n                    if (lhs instanceof PropertyExpression) {\n                        PropertyExpression pe = (PropertyExpression) lhs;\n                        String name = null;\n                        if (lhs instanceof AttributeExpression) {\n                            if (interceptAttribute)\n                                name = \"checkedSetAttribute\";\n                        } else {\n                            Expression receiver = pe.getObjectExpression();\n                            if (receiver instanceof VariableExpression && ((VariableExpression) receiver).getName().equals(\"this\")) {\n                                FieldNode field = clazz != null ? clazz.getField(pe.getPropertyAsString()) : null;\n                                if (field != null) { \n                                    \n                                    return new BinaryExpression(lhs, be.getOperation(), transform(be.getRightExpression()));\n                                } \n                            }\n                            if (interceptProperty)\n                                name = \"checkedSetProperty\";\n                        }\n                        if (name==null) \n                            return super.transform(exp);\n\n                        return makeCheckedCall(name,\n                                transformObjectExpression(pe),\n                                pe.getProperty(),\n                                boolExp(pe.isSafe()),\n                                boolExp(pe.isSpreadSafe()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    } else\n                    if (lhs instanceof FieldExpression) {\n                        \n                        \n                        \n                        return super.transform(exp);\n                    } else\n                    if (lhs instanceof BinaryExpression) {\n                        BinaryExpression lbe = (BinaryExpression) lhs;\n                        if (lbe.getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {\n                            return makeCheckedCall(\"checkedSetArray\",\n                                    transform(lbe.getLeftExpression()),\n                                    transform(lbe.getRightExpression()),\n                                    intExp(be.getOperation().getType()),\n                                    transform(be.getRightExpression())\n                            );\n                        }\n                    } else\n                        throw new AssertionError(\"Unexpected LHS of an assignment: \" + lhs.getClass());\n                }\n                if (be.getOperation().getType()==Types.LEFT_SQUARE_BRACKET) {\n                    if (interceptArray)\n                        return makeCheckedCall(\"checkedGetArray\",\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_INSTANCEOF) {\n                    return super.transform(exp);\n                } else\n                if (Ops.isLogicalOperator(be.getOperation().getType())) {\n                    return super.transform(exp);\n                } else\n                if (be.getOperation().getType()==Types.KEYWORD_IN) {\n                    \n                    \n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedCall\",\n                                transform(be.getRightExpression()),\n                                boolExp(false),\n                                boolExp(false),\n                                stringExp(\"isCase\"),\n                                transform(be.getLeftExpression())\n\n                        );\n                } else\n                if (Ops.isRegexpComparisonOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall)\n                        return makeCheckedCall(\"checkedStaticCall\",\n                                classExp(ScriptBytecodeAdapterClass),\n                                stringExp(Ops.binaryOperatorMethods(be.getOperation().getType())),\n                                transform(be.getLeftExpression()),\n                                transform(be.getRightExpression())\n                        );\n                } else\n                if (Ops.isComparisionOperator(be.getOperation().getType())) {\n                    if (interceptMethodCall) {\n                        return makeCheckedCall(\"checkedComparison\",\n                                transform(be.getLeftExpression()),\n                                intExp(be.getOperation().getType()),\n                                transform(be.getRightExpression())\n                        );\n                    }\n                } else\n                if (interceptMethodCall) {\n                    \n                    \n                    return makeCheckedCall(\"checkedBinaryOp\",\n                            transform(be.getLeftExpression()),\n                            intExp(be.getOperation().getType()),\n                            transform(be.getRightExpression())\n                    );\n                }\n            }\n\n            if (exp instanceof PostfixExpression) {\n                PostfixExpression pe = (PostfixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Postfix\");\n            }\n            if (exp instanceof PrefixExpression) {\n                PrefixExpression pe = (PrefixExpression) exp;\n                return prefixPostfixExp(exp, pe.getExpression(), pe.getOperation(), \"Prefix\");\n            }\n\n            if (exp instanceof CastExpression) {\n                CastExpression ce = (CastExpression) exp;\n                return makeCheckedCall(\"checkedCast\",\n                        classExp(exp.getType()),\n                        transform(ce.getExpression()),\n                        boolExp(ce.isIgnoringAutoboxing()),\n                        boolExp(ce.isCoerce()),\n                        boolExp(ce.isStrict())\n                );\n            }\n\n            return super.transform(exp);\n        }\n\n        private Expression prefixPostfixExp(Expression whole, Expression atom, Token opToken, String mode) {\n            String op = opToken.getText().equals(\"++\") ? \"next\" : \"previous\";\n\n            \n            if (atom instanceof BinaryExpression && ((BinaryExpression) atom).getOperation().getType()==Types.LEFT_SQUARE_BRACKET && interceptArray) {\n                return makeCheckedCall(\"checked\" + mode + \"Array\",\n                        transform(((BinaryExpression) atom).getLeftExpression()),\n                        transform(((BinaryExpression) atom).getRightExpression()),\n                        stringExp(op)\n                );\n            }\n\n            \n            if (atom instanceof VariableExpression) {\n                VariableExpression ve = (VariableExpression) atom;\n                if (isLocalVariable(ve.getName())) {\n                    if (mode.equals(\"Postfix\")) {\n                        \n                        \n                        return transform(withLoc(whole,new BinaryExpression(\n                                new ListExpression(Arrays.asList(\n                                    atom,\n                                    new BinaryExpression(atom, ASSIGNMENT_OP,\n                                        withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                                )),\n                                new Token(Types.LEFT_SQUARE_BRACKET, \"[\", -1,-1),\n                                new ConstantExpression(0)\n                        )));\n                    } else {\n                        \n                        return transform(withLoc(whole,new BinaryExpression(atom,ASSIGNMENT_OP,\n                                withLoc(atom,new MethodCallExpression(atom,op,EMPTY_ARGUMENTS)))\n                        ));\n                    }\n                } else {\n                    \n                    \n                    PropertyExpression pexp = new PropertyExpression(VariableExpression.THIS_EXPRESSION, ve.getName());\n                    pexp.setImplicitThis(true);\n                    pexp.setSourcePosition(atom);\n\n                    atom = pexp;\n                    \n                }\n            }\n\n            \n            if (atom instanceof PropertyExpression && interceptProperty) {\n                PropertyExpression pe = (PropertyExpression) atom;\n                return makeCheckedCall(\"checked\" + mode + \"Property\",\n                        transformObjectExpression(pe),\n                        pe.getProperty(),\n                        boolExp(pe.isSafe()),\n                        boolExp(pe.isSpreadSafe()),\n                        stringExp(op)\n                );\n            }\n\n            return whole;\n        }\n\n        \n        private <T extends ASTNode> T withLoc(ASTNode src, T t) {\n            t.setSourcePosition(src);\n            return t;\n        }\n\n        \n        private Expression transformObjectExpression(PropertyExpression exp) {\n            if (exp.isImplicitThis() && visitingClosureBody && !isLocalVariableExpression(exp.getObjectExpression())) {\n                return CLOSURE_THIS;\n            } else {\n                return transform(exp.getObjectExpression());\n            }\n        }\n\n        private boolean isLocalVariableExpression(Expression exp) {\n            if (exp != null && exp instanceof VariableExpression) {\n                return isLocalVariable(((VariableExpression) exp).getName());\n            }\n\n            return false;\n        }\n\n        ConstantExpression boolExp(boolean v) {\n            return v ? ConstantExpression.PRIM_TRUE : ConstantExpression.PRIM_FALSE;\n        }\n\n        ConstantExpression intExp(int v) {\n            return new ConstantExpression(v,true);\n        }\n\n        ClassExpression classExp(ClassNode c) {\n            return new ClassExpression(c);\n        }\n\n        ConstantExpression stringExp(String v) {\n            return new ConstantExpression(v);\n        }\n\n        @Override\n        public void visitExpressionStatement(ExpressionStatement es) {\n            Expression exp = es.getExpression();\n            if (exp instanceof DeclarationExpression) {\n                DeclarationExpression de = (DeclarationExpression) exp;\n                Expression leftExpression = de.getLeftExpression();\n                if (leftExpression instanceof VariableExpression) {\n                    \n                    if (!(de.getRightExpression() instanceof EmptyExpression) &&\n                            mightBePositionalArgumentConstructor((VariableExpression) leftExpression)) {\n                        CastExpression ce = new CastExpression(leftExpression.getType(), de.getRightExpression());\n                        ce.setCoerce(true);\n                        es.setExpression(transform(new DeclarationExpression(leftExpression, de.getOperation(), ce)));\n                        return;\n                    }\n                } else {\n                    throw new UnsupportedOperationException(\"not supporting tuples yet\"); \n                }\n            }\n            super.visitExpressionStatement(es);\n        }\n\n        @Override\n        protected SourceUnit getSourceUnit() {\n            return sourceUnit;\n        }\n    }\n\n    \n    public static boolean mightBePositionalArgumentConstructor(VariableExpression ve) {\n        ClassNode type = ve.getType();\n        if (type.isArray()) {\n            return false; \n        }\n        Class clazz;\n        try {\n            clazz = type.getTypeClass();\n        } catch (GroovyBugError x) {\n            return false; \n        }\n        return clazz != null && clazz != Object.class && !Modifier.isAbstract(clazz.getModifiers());\n    }\n\n    static final Token ASSIGNMENT_OP = new Token(Types.ASSIGN, \"=\", -1, -1);\n\n    static final ClassNode checkerClass = new ClassNode(Checker.class);\n    static final ClassNode ScriptBytecodeAdapterClass = new ClassNode(ScriptBytecodeAdapter.class);\n\n    \n    static final Expression CLOSURE_THIS;\n\n    static {\n        MethodCallExpression aw = new MethodCallExpression(new VariableExpression(\"this\"),\"asWritable\",EMPTY_ARGUMENTS);\n        aw.setImplicitThis(true);\n\n        CLOSURE_THIS = new MethodCallExpression(aw,\"getOwner\",EMPTY_ARGUMENTS);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 50,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/e5046911c57e60a1d6d8aca9b21bd9093b0f3763",
    "cve_id": "CVE-2018-1999044",
    "cwe_id": "CWE-835",
    "filename": "core/src/main/java/hudson/scheduler/CronTab.java",
    "code": "\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n\npublic final class CronTab {\n    \n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    \n    private String spec;\n\n    \n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    \n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    \n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    \n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    \n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; \n            dayOfWeek &= ~(1<<7); \n        }\n    }\n\n\n    \n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        \n        final int field;\n        \n        final CalendarField lowerField;\n        \n        final int offset;\n        \n        final int min;\n        \n        final boolean redoAdjustmentIfModified;\n\n        \n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        \n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,i-offset);\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        \n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        \n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        \n        abstract long bits(CronTab c);\n\n        \n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    \n                    \n                    \n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    \n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    \n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    \n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                \n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   \n\n                \n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    \n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    \n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; \n                }\n            }\n            return cal; \n        }\n    }\n\n    \n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    \n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                \n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   \n\n                \n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    \n                    f.rollUp(cal,-1);\n                    \n                    \n                    \n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    \n                    \n                    CalendarField.MINUTE.addTo(cal,-1);\n                    \n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; \n                }\n            }\n            return cal; \n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    \n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    \n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    \n                    \n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    \n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { \n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    \n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            \n            return null;\n        } else if (spec.startsWith(\"*/\")) {\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { \n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    \n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 50,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/e5046911c57e60a1d6d8aca9b21bd9093b0f3763",
    "cve_id": "CVE-2018-1999044",
    "cwe_id": "CWE-835",
    "filename": "core/src/test/java/hudson/scheduler/CronTabTest.java",
    "code": "\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.Url;\n\nimport static java.util.Calendar.MONDAY;\nimport java.util.List;\n\n\npublic class CronTabTest {\n\n    @Test\n    public void test1() throws ANTLRException {\n        new CronTab(\"@yearly\");\n        new CronTab(\"@weekly\");\n        new CronTab(\"@midnight\");\n        new CronTab(\"@monthly\");\n        new CronTab(\"0 0 * 1-10/3 *\");\n    }\n\n    @Test\n    public void testCeil1() throws Exception {\n        CronTab x = new CronTab(\"0,30 * * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,1,10);\n        compare(new GregorianCalendar(2000,2,1,1,30),x.ceil(c));\n\n        \n        c =     new GregorianCalendar(2000,2,1,1,40);\n        compare(new GregorianCalendar(2000,2,1,2, 0),x.ceil(c));\n    }\n\n    @Test\n    public void testCeil2() throws Exception {\n        \n        CronTab x = new CronTab(\"15,45 3 * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,2,30);\n        compare(new GregorianCalendar(2000,2,1,3,15),x.ceil(c));\n    }\n\n    @Test\n    public void testCeil3() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2010,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010,7,1,0,0),x.ceil(c));\n    }\n\n    @Test(timeout = 1000)\n    @Issue(\"JENKINS-12357\")\n    public void testCeil3_DoW7() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 7\");\n        Calendar c = new GregorianCalendar(2010,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010, 7, 1, 0, 0), x.ceil(c));\n    }\n\n    \n    @Url(\"http://issues.hudson-ci.org/browse/HUDSON-8656\")\n    @Test\n    public void testCeil4() throws ANTLRException {\n        final Calendar cal = Calendar.getInstance(new Locale(\"de\", \"de\"));\n        cal.set(2011, 0, 16, 0, 0, 0); \n        final String cronStr = \"0 23 * * 1-5\"; \n\n        final CronTab cron = new CronTab(cronStr);\n        final Calendar next = cron.ceil(cal);\n\n        final Calendar expectedDate = Calendar.getInstance();\n        expectedDate.set(2011, 0, 17, 23, 0, 0); \n        assertEquals(expectedDate.get(Calendar.HOUR), next.get(Calendar.HOUR));\n        assertEquals(expectedDate.get(Calendar.MINUTE), next.get(Calendar.MINUTE));\n        assertEquals(expectedDate.get(Calendar.YEAR), next.get(Calendar.YEAR));\n        assertEquals(expectedDate.get(Calendar.MONTH), next.get(Calendar.MONTH));\n        assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), next.get(Calendar.DAY_OF_MONTH)); \n    }\n\n    \n    @Url(\"http://issues.hudson-ci.org/browse/HUDSON-8656\")\n    @Test\n    public void testCeil5() throws ANTLRException {\n        final Calendar cal = Calendar.getInstance(new Locale(\"de\", \"at\"));\n        cal.set(2011, 0, 16, 0, 0, 0); \n        final String cronStr = \"0 23 * * 1-5\"; \n\n        final CronTab cron = new CronTab(cronStr);\n        final Calendar next = cron.ceil(cal);\n\n        final Calendar expectedDate = Calendar.getInstance();\n        expectedDate.set(2011, 0, 17, 23, 0, 0); \n        assertEquals(expectedDate.get(Calendar.HOUR), next.get(Calendar.HOUR));\n        assertEquals(expectedDate.get(Calendar.MINUTE), next.get(Calendar.MINUTE));\n        assertEquals(expectedDate.get(Calendar.YEAR), next.get(Calendar.YEAR));\n        assertEquals(expectedDate.get(Calendar.MONTH), next.get(Calendar.MONTH));\n        assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), next.get(Calendar.DAY_OF_MONTH)); \n    }\n\n    @Test\n    public void testFloor1() throws Exception {\n        CronTab x = new CronTab(\"30 * * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,1,40);\n        compare(new GregorianCalendar(2000,2,1,1,30),x.floor(c));\n\n        \n        c =     new GregorianCalendar(2000,2,1,1,10);\n        compare(new GregorianCalendar(2000,2,1,0,30),x.floor(c));\n    }\n\n    @Test\n    public void testFloor2() throws Exception {\n        \n        CronTab x = new CronTab(\"15,45 3 * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,4,30);\n        compare(new GregorianCalendar(2000,2,1,3,45),x.floor(c));\n    }\n\n    @Test\n    public void testFloor3() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2011,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010,7,1,0,0),x.floor(c));\n    }\n\n    @Issue(\"JENKINS-8401\")\n    @Test\n    public void testFloor4() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2011,0,1,15,55);\n        c.setFirstDayOfWeek(MONDAY);\n        \n        GregorianCalendar answer = new GregorianCalendar(2010, 7, 1, 0, 0);\n        answer.setFirstDayOfWeek(MONDAY);\n        compare(answer,x.floor(c));\n    }\n\n    @Test public void checkSanity() throws Exception {\n        assertEquals(null, new CronTab(\"@hourly\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* * * * *\", \"H * * * *\"), new CronTab(\"* * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"*/1 * * * *\", \"H * * * *\"), new CronTab(\"*/1 * * * *\").checkSanity());\n        assertEquals(null, new CronTab(\"H H(0-2) * * *\", Hash.from(\"stuff\")).checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* 0 * * *\", \"H 0 * * *\"), new CronTab(\"* 0 * * *\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* 6,18 * * *\", \"H 6,18 * * *\"), new CronTab(\"* 6,18 * * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* * 3 * *\", \"H * 3 * *\"), new CronTab(\"* * 3 * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H/15 * * * *\", \"*/15 * * * *\"), new CronTab(\"*/15 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H/15 * * * *\", \"0,15,30,45 * * * *\"), new CronTab(\"0,15,30,45 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H * * * *\", \"0 * * * *\"), new CronTab(\"0 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H * * * *\", \"5 * * * *\"), new CronTab(\"5 * * * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H 3 * * *\", \"0 3 * * *\"), new CronTab(\"0 3 * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H 22 * * 6\", \"00 22 * * 6\"), new CronTab(\"00 22 * * 6\").checkSanity());\n        assertEquals(null, new CronTab(\"H/15 * 1 1 *\").checkSanity());\n        assertEquals(null, new CronTab(\"0 3 H/15 * *\").checkSanity());\n        assertEquals(Messages.CronTab_short_cycles_in_the_day_of_month_field_w(), new CronTab(\"0 3 H/3 * *\").checkSanity());\n        assertEquals(Messages.CronTab_short_cycles_in_the_day_of_month_field_w(), new CronTab(\"0 3 */5 * *\").checkSanity());\n    }\n\n    \n    private void compare(Calendar expected, Calendar actual) {\n        DateFormat f = DateFormat.getDateTimeInstance();\n        assertEquals(f.format(expected.getTime()), f.format(actual.getTime()));\n    }\n\n    @Test\n    public void testHash1() throws Exception {\n        CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() {\n            public int next(int n) {\n                return n-1;\n            }\n        });\n\n        assertEquals(\"59;\", bitset(x.bits[0]));\n        assertEquals(\"8;\", bitset(x.bits[1]));\n        assertEquals(\"3;6;9;12;15;18;21;24;27;\", bitset(x.bits[2]));\n        assertEquals(\"4;8;\", bitset(x.bits[3]));\n    }\n\n    private static String bitset(long bits) {\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < 64; i++) {\n            if ((bits & 1L << i) != 0) {\n                b.append(i).append(';');\n            }\n        }\n        return b.toString();\n    }\n\n    @Test\n    public void testHash2() throws Exception {\n        CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() {\n            public int next(int n) {\n                return 1;\n            }\n        });\n\n        assertEquals(\"1;\", bitset(x.bits[0]));\n        assertEquals(\"6;\", bitset(x.bits[1]));\n        assertEquals(\"2;5;8;11;14;17;20;23;26;\", bitset(x.bits[2]));\n        assertEquals(\"2;6;10;\", bitset(x.bits[3]));\n    }\n\n    @Test public void hashedMinute() throws Exception {\n        long t = new GregorianCalendar(2013, 2, 21, 16, 21).getTimeInMillis();\n        compare(new GregorianCalendar(2013, 2, 21, 17, 56), new CronTab(\"H 17 * * *\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"H * * * *\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"@hourly\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 17, 20), new CronTab(\"@hourly\", Hash.from(\"junk\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 22, 13, 56), new CronTab(\"H H(12-13) * * *\", Hash.from(\"stuff\")).ceil(t));\n    }\n\n    @Test public void hashSkips() throws Exception {\n        compare(new GregorianCalendar(2013, 2, 21, 16, 26), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 21)));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 41), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 31)));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 42)));\n        compare(new GregorianCalendar(2013, 2, 21, 17, 11), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 59)));\n        compare(new GregorianCalendar(2013, 2, 21, 0, 2), new CronTab(\"H(0-15)/3 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n        compare(new GregorianCalendar(2013, 2, 21, 0, 2), new CronTab(\"H(0-3)/4 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n        compare(new GregorianCalendar(2013, 2, 21, 1, 2), new CronTab(\"H(0-3)/4 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 5)));\n        try {\n            compare(new GregorianCalendar(2013, 2, 21, 0, 0), new CronTab(\"H(0-3)/15 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n            fail();\n        } catch (ANTLRException x) {\n            \n        }\n    }\n\n    @Test public void repeatedHash() throws Exception {\n        CronTabList tabs = CronTabList.create(\"H * * * *\\nH * * * *\", Hash.from(\"seed\"));\n        List<Integer> times = new ArrayList<Integer>();\n        for (int i = 0; i < 60; i++) {\n            if (tabs.check(new GregorianCalendar(2013, 3, 3, 11, i, 0))) {\n                times.add(i);\n            }\n        }\n        assertEquals(\"[35, 56]\", times.toString());\n    }\n\n    @Test public void rangeBoundsCheckOK() throws Exception {\n        new CronTab(\"H(0-59) H(0-23) H(1-31) H(1-12) H(0-7)\");\n    }\n\n    @Test public void rangeBoundsCheckFailHour() throws Exception {\n        try {\n            new CronTab(\"H H(12-24) * * *\");\n            fail();\n        } catch (ANTLRException e) {\n            \n        }\n    }\n\n    @Test public void rangeBoundsCheckFailMinute() throws Exception {\n        try {\n            new CronTab(\"H(33-66) * * * *\");\n            fail();\n        } catch (ANTLRException e) {\n            \n        }\n    }\n\n    @Issue(\"JENKINS-9283\")\n    @Test public void testTimezone() throws Exception {\n        CronTabList tabs = CronTabList.create(\"TZ=Australia/Sydney\\nH * * * *\\nH * * * *\", Hash.from(\"seed\"));\n        List<Integer> times = new ArrayList<Integer>();\n        for (int i = 0; i < 60; i++) {\n            if (tabs.check(new GregorianCalendar(2013, 3, 3, 11, i, 0))) {\n                times.add(i);\n            }\n        }\n        assertEquals(\"[35, 56]\", times.toString());\n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 51,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/701ea95a52afe53bee28f76a3f96eb0e578852e9",
    "cve_id": "CVE-2017-1000355",
    "cwe_id": "CWE-502",
    "filename": "core/src/main/java/hudson/util/XStream2.java",
    "code": "\npackage hudson.util;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.thoughtworks.xstream.XStream;\nimport com.thoughtworks.xstream.mapper.AnnotationMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterMatcher;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.mapper.CannotResolveClassException;\nimport edu.umd.cs.findbugs.annotations.SuppressWarnings;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.diagnosis.OldDataMonitor;\nimport hudson.remoting.ClassFilter;\nimport hudson.util.xstream.ImmutableSetConverter;\nimport hudson.util.xstream.ImmutableSortedSetConverter;\nimport jenkins.model.Jenkins;\nimport hudson.model.Label;\nimport hudson.model.Result;\nimport hudson.model.Saveable;\nimport hudson.util.xstream.ImmutableListConverter;\nimport hudson.util.xstream.ImmutableMapConverter;\nimport hudson.util.xstream.MapperDelegate;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.Writer;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\nimport java.nio.charset.Charset;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport javax.annotation.CheckForNull;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\n\n\npublic class XStream2 extends XStream {\n    private RobustReflectionConverter reflectionConverter;\n    private final ThreadLocal<Boolean> oldData = new ThreadLocal<Boolean>();\n    private final @CheckForNull ClassOwnership classOwnership;\n    private final Map<String,Class<?>> compatibilityAliases = new ConcurrentHashMap<String, Class<?>>();\n\n    \n    private MapperInjectionPoint mapperInjectionPoint;\n\n    public XStream2() {\n        init();\n        classOwnership = null;\n    }\n\n    public XStream2(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        super(hierarchicalStreamDriver);\n        init();\n        classOwnership = null;\n    }\n\n    XStream2(ClassOwnership classOwnership) {\n        init();\n        this.classOwnership = classOwnership;\n    }\n\n    @Override\n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        \n        \n        Jenkins h = Jenkins.getInstance();\n        if(h!=null && h.pluginManager!=null && h.pluginManager.uberClassLoader!=null) {\n            setClassLoader(h.pluginManager.uberClassLoader);\n        }\n\n        Object o = super.unmarshal(reader,root,dataHolder);\n        if (oldData.get()!=null) {\n            oldData.remove();\n            if (o instanceof Saveable) OldDataMonitor.report((Saveable)o, \"1.106\");\n        }\n        return o;\n    }\n\n    @Override\n    protected Converter createDefaultConverter() {\n        \n        reflectionConverter = new RobustReflectionConverter(getMapper(),new JVM().bestReflectionProvider(), new PluginClassOwnership());\n        return reflectionConverter;\n    }\n\n    \n    @Restricted(NoExternalUse.class) \n    public void addCriticalField(Class<?> clazz, String field) {\n        reflectionConverter.addCriticalField(clazz, field);\n    }\n\n    static String trimVersion(String version) {\n        \n        return version.replaceFirst(\" .+$\", \"\");\n    }\n\n    private void init() {\n        \n        addImmutableType(Result.class);\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); \n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); \n        registerConverter(new Label.ConverterImpl(),10);\n\n        \n        \n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); \n\n        registerConverter(new DynamicProxyConverter(getMapper()) { \n            @Override public boolean canConvert(Class type) {\n                return  type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }\n\n    @Override\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        Mapper m = new CompatibilityMapper(new MapperWrapper(next) {\n            @Override\n            public String serializedClass(Class type) {\n                if (type != null && ImmutableMap.class.isAssignableFrom(type))\n                    return super.serializedClass(ImmutableMap.class);\n                else if (type != null && ImmutableList.class.isAssignableFrom(type))\n                    return super.serializedClass(ImmutableList.class);\n                else\n                    return super.serializedClass(type);\n            }\n        });\n        AnnotationMapper a = new AnnotationMapper(m, getConverterRegistry(), getConverterLookup(), getClassLoader(), getReflectionProvider(), getJvm());\n        \n        a.autodetectAnnotations(true);\n\n        mapperInjectionPoint = new MapperInjectionPoint(a);\n\n        return mapperInjectionPoint;\n    }\n\n    public Mapper getMapperInjectionPoint() {\n        return mapperInjectionPoint.getDelegate();\n    }\n\n    \n    @Deprecated\n    @Override public void toXML(Object obj, OutputStream out) {\n        super.toXML(obj, out);\n    }\n\n    \n    public void toXMLUTF8(Object obj, OutputStream out) throws IOException {\n        Writer w = new OutputStreamWriter(out, Charset.forName(\"UTF-8\"));\n        w.write(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        toXML(obj, w);\n    }\n\n    \n    public void setMapper(Mapper m) {\n        mapperInjectionPoint.setDelegate(m);\n    }\n\n    final class MapperInjectionPoint extends MapperDelegate {\n        public MapperInjectionPoint(Mapper wrapped) {\n            super(wrapped);\n        }\n\n        public Mapper getDelegate() {\n            return delegate;\n        }\n\n        public void setDelegate(Mapper m) {\n            delegate = m;\n        }\n    }\n\n    \n    public void addCompatibilityAlias(String oldClassName, Class newClass) {\n        compatibilityAliases.put(oldClassName,newClass);\n    }\n\n    \n    private class CompatibilityMapper extends MapperWrapper {\n        private CompatibilityMapper(Mapper wrapped) {\n            super(wrapped);\n        }\n\n        @Override\n        public Class realClass(String elementName) {\n            Class s = compatibilityAliases.get(elementName);\n            if (s!=null)    return s;\n\n            try {\n                return super.realClass(elementName);\n            } catch (CannotResolveClassException e) {\n                \n                if (elementName.indexOf('-') >= 0) try {\n                    Class c = super.realClass(elementName.replace('-', '$'));\n                    oldData.set(Boolean.TRUE);\n                    return c;\n                } catch (CannotResolveClassException e2) { }\n                \n                throw e;\n            }\n        }\n    }\n\n    \n    private static final class AssociatedConverterImpl implements Converter {\n        private final XStream xstream;\n        private final ConcurrentHashMap<Class<?>,Converter> cache =\n                new ConcurrentHashMap<Class<?>,Converter>();\n\n        private AssociatedConverterImpl(XStream xstream) {\n            this.xstream = xstream;\n        }\n\n        private Converter findConverter(Class<?> t) {\n            Converter result = cache.get(t);\n            if (result != null)\n                \n                return result == this ? null : result;\n            try {\n                if(t==null || t.getClassLoader()==null)\n                    return null;\n                Class<?> cl = t.getClassLoader().loadClass(t.getName() + \"$ConverterImpl\");\n                Constructor<?> c = cl.getConstructors()[0];\n\n                Class<?>[] p = c.getParameterTypes();\n                Object[] args = new Object[p.length];\n                for (int i = 0; i < p.length; i++) {\n                    if(p[i]==XStream.class || p[i]==XStream2.class)\n                        args[i] = xstream;\n                    else if(p[i]== Mapper.class)\n                        args[i] = xstream.getMapper();\n                    else\n                        throw new InstantiationError(\"Unrecognized constructor parameter: \"+p[i]);\n\n                }\n                ConverterMatcher cm = (ConverterMatcher)c.newInstance(args);\n                result = cm instanceof SingleValueConverter\n                        ? new SingleValueConverterWrapper((SingleValueConverter)cm)\n                        : (Converter)cm;\n                cache.put(t, result);\n                return result;\n            } catch (ClassNotFoundException e) {\n                cache.put(t, this);  \n                return null;\n            } catch (IllegalAccessException e) {\n                IllegalAccessError x = new IllegalAccessError();\n                x.initCause(e);\n                throw x;\n            } catch (InstantiationException e) {\n                InstantiationError x = new InstantiationError();\n                x.initCause(e);\n                throw x;\n            } catch (InvocationTargetException e) {\n                InstantiationError x = new InstantiationError();\n                x.initCause(e);\n                throw x;\n            }\n        }\n\n        public boolean canConvert(Class type) {\n            return findConverter(type)!=null;\n        }\n\n        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            findConverter(source.getClass()).marshal(source,writer,context);\n        }\n\n        public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n            return findConverter(context.getRequiredType()).unmarshal(reader,context);\n        }\n    }\n\n    \n    public static abstract class PassthruConverter<T> implements Converter {\n        private Converter converter;\n\n        public PassthruConverter(XStream2 xstream) {\n            converter = xstream.reflectionConverter;\n        }\n\n        public boolean canConvert(Class type) {\n            \n            return false;\n        }\n\n        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            converter.marshal(source, writer, context);\n        }\n\n        public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n            Object obj = converter.unmarshal(reader, context);\n            callback((T)obj, context);\n            return obj;\n        }\n\n        protected abstract void callback(T obj, UnmarshallingContext context);\n    }\n\n    \n    interface ClassOwnership {\n        \n        @CheckForNull String ownerOf(Class<?> clazz);\n    }\n    \n    class PluginClassOwnership implements ClassOwnership {\n\n        private PluginManager pm;\n\n        @SuppressWarnings(\"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\") \n        @Override public String ownerOf(Class<?> clazz) {\n            if (classOwnership != null) {\n                return classOwnership.ownerOf(clazz);\n            }\n            if (pm == null) {\n                Jenkins j = Jenkins.getInstance();\n                if (j != null) {\n                    pm = j.getPluginManager();\n                }\n            }\n            if (pm == null) {\n                return null;\n            }\n            \n            PluginWrapper p = pm.whichPlugin(clazz);\n            return p != null ? p.getShortName() + '@' + trimVersion(p.getVersion()) : null;\n        }\n\n    }\n\n    private static class BlacklistedTypesConverter implements Converter {\n        @Override\n        public void marshal(Object source, HierarchicalStreamWriter writer, MarshallingContext context) {\n            throw new UnsupportedOperationException(\"Refusing to marshal \" + source.getClass().getName() + \" for security reasons\");\n        }\n\n        @Override\n        public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n            throw new ConversionException(\"Refusing to unmarshal \" + reader.getNodeName() + \" for security reasons\");\n        }\n\n        @Override\n        public boolean canConvert(Class type) {\n            if (type == null) {\n                return false;\n            }\n            try {\n                ClassFilter.DEFAULT.check(type);\n                ClassFilter.DEFAULT.check(type.getName());\n            } catch (SecurityException se) {\n                \n                return true;\n            }\n            return false;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 51,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/701ea95a52afe53bee28f76a3f96eb0e578852e9",
    "cve_id": "CVE-2017-1000355",
    "cwe_id": "CWE-502",
    "filename": "core/src/test/java/hudson/util/XStream2Test.java",
    "code": "\npackage hudson.util;\n\nimport static org.junit.Assert.*;\n\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableMap;\nimport com.thoughtworks.xstream.XStreamException;\nimport hudson.XmlFile;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport java.io.File;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.apache.commons.io.FileUtils;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.Issue;\n\n\npublic class XStream2Test {\n\n    public static final class Foo {\n        Result r1,r2;\n    }\n\n    @Test\n    public void marshalValue() {\n        Foo f = new Foo();\n        f.r1 = f.r2 = Result.FAILURE;\n        String xml = Run.XSTREAM.toXML(f);\n        \n        assertEquals(xml, 3, xml.split(\"FAILURE\").length);\n    }\n\n    private static class Bar {\n        String s;\n    }\n\n    \n    @Test\n    public void xStream11Compatibility() {\n        Bar b = (Bar)new XStream2().fromXML(\n                \"<hudson.util.XStream2Test-Bar><s>foo</s></hudson.util.XStream2Test-Bar>\");\n        assertEquals(\"foo\", b.s);\n    }\n\n    public static final class __Foo_Bar$Class {\n        String under_1 = \"1\", under__2 = \"2\",\n               _leadUnder1 = \"L1\", __leadUnder2 = \"L2\",\n               $dollar = \"D1\", dollar$2 = \"D2\";\n    }\n\n    \n    @Issue(\"HUDSON-5768\")\n    @Test\n    public void xmlRoundTrip() {\n        XStream2 xs = new XStream2();\n        __Foo_Bar$Class b = new __Foo_Bar$Class();\n\n        String xml = xs.toXML(b);\n        __Foo_Bar$Class b2 = (__Foo_Bar$Class)xs.fromXML(xml);\n\n        assertEquals(xml, b.under_1, b2.under_1);\n        assertEquals(xml, b.under__2, b2.under__2);\n        assertEquals(xml, b._leadUnder1, b2._leadUnder1);\n        assertEquals(xml, b.__leadUnder2, b2.__leadUnder2);\n        assertEquals(xml, b.$dollar, b2.$dollar);\n        assertEquals(xml, b.dollar$2, b2.dollar$2);\n    }\n\n    private static class Baz {\n        private Exception myFailure;\n    }\n\n    \n    @Issue(\"HUDSON-5769\")\n    @Test\n    public void unmarshalThrowableMissingField() {\n        Level oldLevel = disableLogging();\n\n        Baz baz = new Baz();\n        baz.myFailure = new Exception(\"foo\");\n\n        XStream2 xs = new XStream2();\n        String xml = xs.toXML(baz);\n        baz = (Baz)xs.fromXML(xml);\n        assertEquals(\"foo\", baz.myFailure.getMessage());\n\n        baz = (Baz)xs.fromXML(\"<hudson.util.XStream2Test_-Baz><myFailure>\"\n                + \"<missingField>true</missingField>\"\n                + \"<detailMessage>hoho</detailMessage>\"\n                + \"<stackTrace><trace>\"\n                + \"hudson.util.XStream2Test.testUnmarshalThrowableMissingField(XStream2Test.java:97)\"\n                + \"</trace></stackTrace>\"\n                + \"</myFailure></hudson.util.XStream2Test_-Baz>\");\n        \n        assertEquals(\"hoho\", baz.myFailure.getMessage());\n\n        enableLogging(oldLevel);\n    }\n\n    private Level disableLogging() {\n        Level oldLevel = Logger.getLogger(RobustReflectionConverter.class.getName()).getLevel();\n        Logger.getLogger(RobustReflectionConverter.class.getName()).setLevel(Level.OFF);\n        return oldLevel;\n    }\n\n    private void enableLogging(Level oldLevel) {\n        Logger.getLogger(RobustReflectionConverter.class.getName()).setLevel(oldLevel);\n    }\n\n    private static class ImmutableMapHolder {\n        ImmutableMap<?,?> m;\n    }\n\n    private static class MapHolder {\n        Map<?,?> m;\n    }\n\n    @Test\n    public void immutableMap() {\n        XStream2 xs = new XStream2();\n\n        roundtripImmutableMap(xs, ImmutableMap.of());\n        roundtripImmutableMap(xs, ImmutableMap.of(\"abc\", \"xyz\"));\n        roundtripImmutableMap(xs, ImmutableMap.of(\"abc\", \"xyz\", \"def\",\"ghi\"));\n\n        roundtripImmutableMapAsPlainMap(xs, ImmutableMap.of());\n        roundtripImmutableMapAsPlainMap(xs, ImmutableMap.of(\"abc\", \"xyz\"));\n        roundtripImmutableMapAsPlainMap(xs, ImmutableMap.of(\"abc\", \"xyz\", \"def\",\"ghi\"));\n    }\n\n    \n    private void roundtripImmutableMap(XStream2 xs, ImmutableMap<?,?> m) {\n        ImmutableMapHolder a = new ImmutableMapHolder();\n        a.m = m;\n        String xml = xs.toXML(a);\n        \n        assertFalse(\"shouldn't contain the class name\",xml.contains(\"google\"));\n        assertFalse(\"shouldn't contain the class name\",xml.contains(\"class\"));\n        a = (ImmutableMapHolder)xs.fromXML(xml);\n\n        assertSame(m.getClass(),a.m.getClass());    \n        assertEquals(m,a.m);\n    }\n\n    private void roundtripImmutableMapAsPlainMap(XStream2 xs, ImmutableMap<?,?> m) {\n        MapHolder a = new MapHolder();\n        a.m = m;\n        String xml = xs.toXML(a);\n        \n        assertTrue(\"XML should mention the class name\",xml.contains('\\\"'+ImmutableMap.class.getName()+'\\\"'));\n        a = (MapHolder)xs.fromXML(xml);\n\n        assertSame(m.getClass(),a.m.getClass());    \n        assertEquals(m,a.m);\n    }\n\n    private static class ImmutableListHolder {\n        ImmutableList<?> l;\n    }\n\n    private static class ListHolder {\n        List<?> l;\n    }\n\n    @Test\n    public void immutableList() {\n        XStream2 xs = new XStream2();\n\n        roundtripImmutableList(xs, ImmutableList.of());\n        roundtripImmutableList(xs, ImmutableList.of(\"abc\"));\n        roundtripImmutableList(xs, ImmutableList.of(\"abc\", \"def\"));\n\n        roundtripImmutableListAsPlainList(xs, ImmutableList.of());\n        roundtripImmutableListAsPlainList(xs, ImmutableList.of(\"abc\"));\n        roundtripImmutableListAsPlainList(xs, ImmutableList.of(\"abc\", \"def\"));\n    }\n\n    \n    private void roundtripImmutableList(XStream2 xs, ImmutableList<?> l) {\n        ImmutableListHolder a = new ImmutableListHolder();\n        a.l = l;\n        String xml = xs.toXML(a);\n        \n        assertFalse(\"shouldn't contain the class name\",xml.contains(\"google\"));\n        assertFalse(\"shouldn't contain the class name\",xml.contains(\"class\"));\n        a = (ImmutableListHolder)xs.fromXML(xml);\n\n        assertSame(l.getClass(),a.l.getClass());    \n        assertEquals(l,a.l);\n    }\n\n    private void roundtripImmutableListAsPlainList(XStream2 xs, ImmutableList<?> l) {\n        ListHolder a = new ListHolder();\n        a.l = l;\n        String xml = xs.toXML(a);\n        \n        assertTrue(\"XML should mention the class name\",xml.contains('\\\"'+ImmutableList.class.getName()+'\\\"'));\n        a = (ListHolder)xs.fromXML(xml);\n\n        assertSame(l.getClass(),a.l.getClass());    \n        assertEquals(l,a.l);\n    }\n\n    @Issue(\"JENKINS-8006\") \n    @Test\n    public void emptyStack() {\n        assertEquals(\"<object-array><null/><null/></object-array>\",\n                     Run.XSTREAM.toXML(new Object[2]).replaceAll(\"[ \\n\\r\\t]+\", \"\"));\n    }\n\n    @Issue(\"JENKINS-9843\")\n    @Test\n    public void compatibilityAlias() {\n        XStream2 xs = new XStream2();\n        xs.addCompatibilityAlias(\"legacy.Point\",Point.class);\n        Point pt = (Point)xs.fromXML(\"<legacy.Point><x>1</x><y>2</y></legacy.Point>\");\n        assertEquals(1,pt.x);\n        assertEquals(2,pt.y);\n        String xml = xs.toXML(pt);\n        \n        assertFalse(\"Shouldn't use the alias when writing back\",xml.contains(\"legacy\"));\n    }\n\n    public static class Point {\n        public int x,y;\n    }\n\n    public static class Foo2 {\n        ConcurrentHashMap<String,String> m = new ConcurrentHashMap<String,String>();\n    }\n\n    @Issue(\"SECURITY-105\")\n    @Test\n    public void dynamicProxyBlocked() {\n        try {\n            ((Runnable) new XStream2().fromXML(\"<dynamic-proxy><interface>java.lang.Runnable</interface><handler class='java.beans.EventHandler'><target class='\" + Hacked.class.getName() + \"'/><action>oops</action></handler></dynamic-proxy>\")).run();\n        } catch (XStreamException x) {\n            \n        }\n        assertFalse(\"should never have run that\", Hacked.tripped);\n    }\n\n    public static final class Hacked {\n        static boolean tripped;\n        public void oops() {\n            tripped = true;\n        }\n    }\n\n    @Test\n    public void trimVersion() {\n        assertEquals(\"3.2\", XStream2.trimVersion(\"3.2\"));\n        assertEquals(\"3.2.1\", XStream2.trimVersion(\"3.2.1\"));\n        assertEquals(\"3.2-SNAPSHOT\", XStream2.trimVersion(\"3.2-SNAPSHOT (private-09/23/2012 12:26-jhacker)\"));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 52,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/73afa0ca786a87f05b5433e2e38f863826fcad17",
    "cve_id": "CVE-2018-1000864",
    "cwe_id": "CWE-835",
    "filename": "core/src/main/java/hudson/scheduler/CronTab.java",
    "code": "\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\n\nimport java.io.StringReader;\nimport java.util.Calendar;\nimport java.util.TimeZone;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.util.Calendar.*;\nimport javax.annotation.CheckForNull;\n\n\npublic final class CronTab {\n    \n    final long[] bits = new long[4];\n\n    int dayOfWeek;\n\n    \n    private String spec;\n\n    \n    private @CheckForNull String specTimezone;\n\n    public CronTab(String format) throws ANTLRException {\n        this(format,null);\n    }\n\n    public CronTab(String format, Hash hash) throws ANTLRException {\n        this(format,1,hash);\n    }\n    \n    \n    @Deprecated\n    public CronTab(String format, int line) throws ANTLRException {\n        set(format, line, null);\n    }\n\n    \n    public CronTab(String format, int line, Hash hash) throws ANTLRException {\n        this(format, line, hash, null);\n    }\n\n    \n    public CronTab(String format, int line, Hash hash, @CheckForNull String timezone) throws ANTLRException {\n        set(format, line, hash, timezone);\n    }\n    \n    private void set(String format, int line, Hash hash) throws ANTLRException {\n        set(format, line, hash, null);\n    }\n\n    \n    private void set(String format, int line, Hash hash, String timezone) throws ANTLRException {\n        CrontabLexer lexer = new CrontabLexer(new StringReader(format));\n        lexer.setLine(line);\n        CrontabParser parser = new CrontabParser(lexer);\n        parser.setHash(hash);\n        spec = format;\n        specTimezone = timezone;\n\n        parser.startRule(this);\n        if((dayOfWeek&(1<<7))!=0) {\n            dayOfWeek |= 1; \n            dayOfWeek &= ~(1<<7); \n        }\n    }\n\n\n    \n    boolean check(Calendar cal) {\n\n        Calendar checkCal = cal;\n\n        if(specTimezone != null && !specTimezone.isEmpty()) {\n            Calendar tzCal = Calendar.getInstance(TimeZone.getTimeZone(specTimezone));\n            tzCal.setTime(cal.getTime());\n            checkCal = tzCal;\n        }\n\n        if(!checkBits(bits[0],checkCal.get(MINUTE)))\n            return false;\n        if(!checkBits(bits[1],checkCal.get(HOUR_OF_DAY)))\n            return false;\n        if(!checkBits(bits[2],checkCal.get(DAY_OF_MONTH)))\n            return false;\n        if(!checkBits(bits[3],checkCal.get(MONTH)+1))\n            return false;\n        if(!checkBits(dayOfWeek,checkCal.get(Calendar.DAY_OF_WEEK)-1))\n            return false;\n\n        return true;\n    }\n\n    private static abstract class CalendarField {\n        \n        final int field;\n        \n        final CalendarField lowerField;\n        \n        final int offset;\n        \n        final int min;\n        \n        final boolean redoAdjustmentIfModified;\n\n        \n        @SuppressWarnings(\"unused\")\n        private final String displayName;\n\n        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        \n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }\n\n        void clear(Calendar c) {\n            setTo(c, min);\n        }\n\n        \n        private int ceil(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n>60)   return -1;\n                n++;\n            }\n            return n;\n        }\n\n        \n        private int first(CronTab c) {\n            return ceil(c,0);\n        }\n\n        private int floor(CronTab c, int n) {\n            long bits = bits(c);\n            while ((bits|(1L<<n))!=bits) {\n                if (n==0)   return -1;\n                n--;\n            }\n            return n;\n        }\n\n        private int last(CronTab c) {\n            return floor(c,63);\n        }\n\n        \n        abstract long bits(CronTab c);\n\n        \n        abstract void rollUp(Calendar cal, int i);\n\n        private static final CalendarField MINUTE       = new CalendarField(\"minute\", Calendar.MINUTE,        0, 0, false, null) {\n            long bits(CronTab c) { return c.bits[0]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.HOUR_OF_DAY,i); }\n        };\n        private static final CalendarField HOUR         = new CalendarField(\"hour\", Calendar.HOUR_OF_DAY,   0, 0, false, MINUTE) {\n            long bits(CronTab c) { return c.bits[1]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.DAY_OF_MONTH,i); }\n        };\n        private static final CalendarField DAY_OF_MONTH = new CalendarField(\"day\", Calendar.DAY_OF_MONTH,  1, 0, true,  HOUR) {\n            long bits(CronTab c) { return c.bits[2]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.MONTH,i); }\n        };\n        private static final CalendarField MONTH        = new CalendarField(\"month\", Calendar.MONTH,         1, 1, false, DAY_OF_MONTH) {\n            long bits(CronTab c) { return c.bits[3]; }\n            void rollUp(Calendar cal, int i) { cal.add(Calendar.YEAR,i); }\n        };\n        private static final CalendarField DAY_OF_WEEK  = new CalendarField(\"dow\", Calendar.DAY_OF_WEEK,   1,-1, true,  HOUR) {\n            long bits(CronTab c) { return c.dayOfWeek; }\n            void rollUp(Calendar cal, int i) {\n                cal.add(Calendar.DAY_OF_WEEK, 7 * i);\n            }\n\n            @Override\n            void setTo(Calendar c, int i) {\n                int v = i-offset;\n                int was = c.get(field);\n                c.set(field,v);\n                final int firstDayOfWeek = c.getFirstDayOfWeek();\n                if (v < firstDayOfWeek && was >= firstDayOfWeek) {\n                    \n                    \n                    \n                    addTo(c,-7);\n                } else if (was < firstDayOfWeek && firstDayOfWeek <= v) {\n                    \n                    addTo(c, 7);\n                }\n            }\n        };\n\n        private static final CalendarField[] ADJUST_ORDER = {\n            MONTH, DAY_OF_MONTH, DAY_OF_WEEK, HOUR, MINUTE\n        };\n    }\n\n\n    \n    public Calendar ceil(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return ceil(cal);\n    }\n\n    \n    public Calendar ceil(Calendar cal) {\n        Calendar twoYearsFuture = (Calendar) cal.clone();\n        twoYearsFuture.add(Calendar.YEAR, 2);\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsFuture) > 0) {\n                \n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.ceil(this,cur);\n                if (cur==next)  continue;   \n\n                \n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    \n                    f.rollUp(cal, 1);\n                    f.setTo(cal,f.first(this));\n                    \n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; \n                }\n            }\n            return cal; \n        }\n    }\n\n    \n    public Calendar floor(long t) {\n        Calendar cal = new GregorianCalendar(Locale.US);\n        cal.setTimeInMillis(t);\n        return floor(cal);\n    }\n\n    \n    public Calendar floor(Calendar cal) {\n        Calendar twoYearsAgo = (Calendar) cal.clone();\n        twoYearsAgo.add(Calendar.YEAR, -2);\n\n        OUTER:\n        while (true) {\n            if (cal.compareTo(twoYearsAgo) < 0) {\n                \n                throw new RareOrImpossibleDateException();\n            }\n            for (CalendarField f : CalendarField.ADJUST_ORDER) {\n                int cur = f.valueOf(cal);\n                int next = f.floor(this,cur);\n                if (cur==next)  continue;   \n\n                \n                for (CalendarField l=f.lowerField; l!=null; l=l.lowerField)\n                    l.clear(cal);\n\n                if (next<0) {\n                    \n                    f.rollUp(cal,-1);\n                    \n                    \n                    \n                    f.setTo(cal,f.last(this));\n                    f.addTo(cal,1);\n                    \n                    \n                    CalendarField.MINUTE.addTo(cal,-1);\n                    \n                    continue OUTER;\n                } else {\n                    f.setTo(cal,next);\n                    f.addTo(cal,1);\n                    CalendarField.MINUTE.addTo(cal,-1);\n                    if (f.redoAdjustmentIfModified)\n                        continue OUTER; \n                }\n            }\n            return cal; \n        }\n    }\n\n    void set(String format, Hash hash) throws ANTLRException {\n        set(format,1,hash);\n    }\n\n    \n    private boolean checkBits(long bitMask, int n) {\n        return (bitMask|(1L<<n))==bitMask;\n    }\n\n    public String toString() {\n        return super.toString()+\"[\"+\n            toString(\"minute\",bits[0])+','+\n            toString(\"hour\",bits[1])+','+\n            toString(\"dayOfMonth\",bits[2])+','+\n            toString(\"month\",bits[3])+','+\n            toString(\"dayOfWeek\",dayOfWeek)+']';\n    }\n\n    private String toString(String key, long bit) {\n        return key+'='+Long.toHexString(bit);\n    }\n\n    \n    public @CheckForNull String checkSanity() {\n        OUTER: for (int i = 0; i < 5; i++) {\n            long bitMask = (i<4)?bits[i]:(long)dayOfWeek;\n            for( int j=BaseParser.LOWER_BOUNDS[i]; j<=BaseParser.UPPER_BOUNDS[i]; j++ ) {\n                if(!checkBits(bitMask,j)) {\n                    \n                    \n                    if(i>0)\n                        return Messages.CronTab_do_you_really_mean_every_minute_when_you(spec, \"H \" + spec.substring(spec.indexOf(' ') + 1));\n                    \n                    break OUTER;\n                }\n            }\n        }\n\n        int daysOfMonth = 0;\n        for (int i = 1; i < 31; i++) {\n            if (checkBits(bits[2], i)) {\n                daysOfMonth++;\n            }\n        }\n        if (daysOfMonth > 5 && daysOfMonth < 28) { \n            return Messages.CronTab_short_cycles_in_the_day_of_month_field_w();\n        }\n\n        String hashified = hashify(spec);\n        if (hashified != null) {\n            return Messages.CronTab_spread_load_evenly_by_using_rather_than_(hashified, spec);\n        }\n\n        return null;\n    }\n\n    \n    public static @CheckForNull String hashify(String spec) {\n        if (spec.contains(\"H\")) {\n            \n            return null;\n        } else if (spec.startsWith(\"*/\")) {\n            return \"H\" + spec.substring(1);\n        } else if (spec.matches(\"\\\\d+ .+\")) {\n            return \"H \" + spec.substring(spec.indexOf(' ') + 1);\n        } else {\n            Matcher m = Pattern.compile(\"0(,(\\\\d+)(,\\\\d+)*)( .+)\").matcher(spec);\n            if (m.matches()) { \n                int period = Integer.parseInt(m.group(2));\n                if (period > 0) {\n                    StringBuilder b = new StringBuilder();\n                    for (int i = period; i < 60; i += period) {\n                        b.append(',').append(i);\n                    }\n                    if (b.toString().equals(m.group(1))) {\n                        return \"H/\" + period + m.group(4);\n                    }\n                }\n            }\n            return null;\n        }\n    }\n\n    \n    @CheckForNull public TimeZone getTimeZone() {\n        if (this.specTimezone == null) {\n            return null;\n        }\n        return TimeZone.getTimeZone(this.specTimezone);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 52,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/jenkins/commit/73afa0ca786a87f05b5433e2e38f863826fcad17",
    "cve_id": "CVE-2018-1000864",
    "cwe_id": "CWE-835",
    "filename": "core/src/test/java/hudson/scheduler/CronTabTest.java",
    "code": "\npackage hudson.scheduler;\n\nimport antlr.ANTLRException;\nimport java.text.DateFormat;\nimport java.util.ArrayList;\nimport java.util.Calendar;\nimport java.util.GregorianCalendar;\nimport java.util.Locale;\n\nimport static org.junit.Assert.*;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.Url;\n\nimport static java.util.Calendar.MONDAY;\nimport java.util.List;\n\n\npublic class CronTabTest {\n\n    @Test\n    public void test1() throws ANTLRException {\n        new CronTab(\"@yearly\");\n        new CronTab(\"@weekly\");\n        new CronTab(\"@midnight\");\n        new CronTab(\"@monthly\");\n        new CronTab(\"0 0 * 1-10/3 *\");\n    }\n\n    @Test\n    public void testCeil1() throws Exception {\n        CronTab x = new CronTab(\"0,30 * * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,1,10);\n        compare(new GregorianCalendar(2000,2,1,1,30),x.ceil(c));\n\n        \n        c =     new GregorianCalendar(2000,2,1,1,40);\n        compare(new GregorianCalendar(2000,2,1,2, 0),x.ceil(c));\n    }\n\n    @Test\n    public void testCeil2() throws Exception {\n        \n        CronTab x = new CronTab(\"15,45 3 * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,2,30);\n        compare(new GregorianCalendar(2000,2,1,3,15),x.ceil(c));\n    }\n\n    @Test\n    public void testCeil3() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2010,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010,7,1,0,0),x.ceil(c));\n    }\n\n    @Test(timeout = 1000)\n    @Issue(\"JENKINS-12357\")\n    public void testCeil3_DoW7() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 7\");\n        Calendar c = new GregorianCalendar(2010,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010, 7, 1, 0, 0), x.ceil(c));\n    }\n\n    \n    @Url(\"http://issues.hudson-ci.org/browse/HUDSON-8656\")\n    @Test\n    public void testCeil4() throws ANTLRException {\n        final Calendar cal = Calendar.getInstance(new Locale(\"de\", \"de\"));\n        cal.set(2011, 0, 16, 0, 0, 0); \n        final String cronStr = \"0 23 * * 1-5\"; \n\n        final CronTab cron = new CronTab(cronStr);\n        final Calendar next = cron.ceil(cal);\n\n        final Calendar expectedDate = Calendar.getInstance();\n        expectedDate.set(2011, 0, 17, 23, 0, 0); \n        assertEquals(expectedDate.get(Calendar.HOUR), next.get(Calendar.HOUR));\n        assertEquals(expectedDate.get(Calendar.MINUTE), next.get(Calendar.MINUTE));\n        assertEquals(expectedDate.get(Calendar.YEAR), next.get(Calendar.YEAR));\n        assertEquals(expectedDate.get(Calendar.MONTH), next.get(Calendar.MONTH));\n        assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), next.get(Calendar.DAY_OF_MONTH)); \n    }\n\n    \n    @Url(\"http://issues.hudson-ci.org/browse/HUDSON-8656\")\n    @Test\n    public void testCeil5() throws ANTLRException {\n        final Calendar cal = Calendar.getInstance(new Locale(\"de\", \"at\"));\n        cal.set(2011, 0, 16, 0, 0, 0); \n        final String cronStr = \"0 23 * * 1-5\"; \n\n        final CronTab cron = new CronTab(cronStr);\n        final Calendar next = cron.ceil(cal);\n\n        final Calendar expectedDate = Calendar.getInstance();\n        expectedDate.set(2011, 0, 17, 23, 0, 0); \n        assertEquals(expectedDate.get(Calendar.HOUR), next.get(Calendar.HOUR));\n        assertEquals(expectedDate.get(Calendar.MINUTE), next.get(Calendar.MINUTE));\n        assertEquals(expectedDate.get(Calendar.YEAR), next.get(Calendar.YEAR));\n        assertEquals(expectedDate.get(Calendar.MONTH), next.get(Calendar.MONTH));\n        assertEquals(expectedDate.get(Calendar.DAY_OF_MONTH), next.get(Calendar.DAY_OF_MONTH)); \n    }\n\n    @Test\n    public void testFloor1() throws Exception {\n        CronTab x = new CronTab(\"30 * * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,1,40);\n        compare(new GregorianCalendar(2000,2,1,1,30),x.floor(c));\n\n        \n        c =     new GregorianCalendar(2000,2,1,1,10);\n        compare(new GregorianCalendar(2000,2,1,0,30),x.floor(c));\n    }\n\n    @Test\n    public void testFloor2() throws Exception {\n        \n        CronTab x = new CronTab(\"15,45 3 * * *\");\n        Calendar c = new GregorianCalendar(2000,2,1,4,30);\n        compare(new GregorianCalendar(2000,2,1,3,45),x.floor(c));\n    }\n\n    @Test\n    public void testFloor3() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2011,0,1,15,55);\n        \n        compare(new GregorianCalendar(2010,7,1,0,0),x.floor(c));\n    }\n\n    @Issue(\"JENKINS-8401\")\n    @Test\n    public void testFloor4() throws Exception {\n        \n        CronTab x = new CronTab(\"0 0 1 * 0\");\n        Calendar c = new GregorianCalendar(2011,0,1,15,55);\n        c.setFirstDayOfWeek(MONDAY);\n        \n        GregorianCalendar answer = new GregorianCalendar(2010, 7, 1, 0, 0);\n        answer.setFirstDayOfWeek(MONDAY);\n        compare(answer,x.floor(c));\n    }\n\n    @Test public void checkSanity() throws Exception {\n        assertEquals(null, new CronTab(\"@hourly\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* * * * *\", \"H * * * *\"), new CronTab(\"* * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"*/1 * * * *\", \"H * * * *\"), new CronTab(\"*/1 * * * *\").checkSanity());\n        assertEquals(null, new CronTab(\"H H(0-2) * * *\", Hash.from(\"stuff\")).checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* 0 * * *\", \"H 0 * * *\"), new CronTab(\"* 0 * * *\").checkSanity());\n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* 6,18 * * *\", \"H 6,18 * * *\"), new CronTab(\"* 6,18 * * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_do_you_really_mean_every_minute_when_you(\"* * 3 * *\", \"H * 3 * *\"), new CronTab(\"* * 3 * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H/15 * * * *\", \"*/15 * * * *\"), new CronTab(\"*/15 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H/15 * * * *\", \"0,15,30,45 * * * *\"), new CronTab(\"0,15,30,45 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H * * * *\", \"0 * * * *\"), new CronTab(\"0 * * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H * * * *\", \"5 * * * *\"), new CronTab(\"5 * * * *\").checkSanity());\n        \n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H 3 * * *\", \"0 3 * * *\"), new CronTab(\"0 3 * * *\").checkSanity());\n        assertEquals(Messages.CronTab_spread_load_evenly_by_using_rather_than_(\"H 22 * * 6\", \"00 22 * * 6\"), new CronTab(\"00 22 * * 6\").checkSanity());\n        assertEquals(null, new CronTab(\"H/15 * 1 1 *\").checkSanity());\n        assertEquals(null, new CronTab(\"0 3 H/15 * *\").checkSanity());\n        assertEquals(Messages.CronTab_short_cycles_in_the_day_of_month_field_w(), new CronTab(\"0 3 H/3 * *\").checkSanity());\n        assertEquals(Messages.CronTab_short_cycles_in_the_day_of_month_field_w(), new CronTab(\"0 3 */5 * *\").checkSanity());\n    }\n\n    \n    private void compare(Calendar expected, Calendar actual) {\n        DateFormat f = DateFormat.getDateTimeInstance();\n        assertEquals(f.format(expected.getTime()), f.format(actual.getTime()));\n    }\n\n    @Test\n    public void testHash1() throws Exception {\n        CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() {\n            public int next(int n) {\n                return n-1;\n            }\n        });\n\n        assertEquals(\"59;\", bitset(x.bits[0]));\n        assertEquals(\"8;\", bitset(x.bits[1]));\n        assertEquals(\"3;6;9;12;15;18;21;24;27;\", bitset(x.bits[2]));\n        assertEquals(\"4;8;\", bitset(x.bits[3]));\n    }\n\n    private static String bitset(long bits) {\n        StringBuilder b = new StringBuilder();\n        for (int i = 0; i < 64; i++) {\n            if ((bits & 1L << i) != 0) {\n                b.append(i).append(';');\n            }\n        }\n        return b.toString();\n    }\n\n    @Test\n    public void testHash2() throws Exception {\n        CronTab x = new CronTab(\"H H(5-8) H/3 H(1-10)/4 *\",new Hash() {\n            public int next(int n) {\n                return 1;\n            }\n        });\n\n        assertEquals(\"1;\", bitset(x.bits[0]));\n        assertEquals(\"6;\", bitset(x.bits[1]));\n        assertEquals(\"2;5;8;11;14;17;20;23;26;\", bitset(x.bits[2]));\n        assertEquals(\"2;6;10;\", bitset(x.bits[3]));\n    }\n\n    @Test public void hashedMinute() throws Exception {\n        long t = new GregorianCalendar(2013, 2, 21, 16, 21).getTimeInMillis();\n        compare(new GregorianCalendar(2013, 2, 21, 17, 56), new CronTab(\"H 17 * * *\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"H * * * *\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"@hourly\", Hash.from(\"stuff\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 21, 17, 20), new CronTab(\"@hourly\", Hash.from(\"junk\")).ceil(t));\n        compare(new GregorianCalendar(2013, 2, 22, 13, 56), new CronTab(\"H H(12-13) * * *\", Hash.from(\"stuff\")).ceil(t));\n    }\n\n    @Test public void hashSkips() throws Exception {\n        compare(new GregorianCalendar(2013, 2, 21, 16, 26), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 21)));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 41), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 31)));\n        compare(new GregorianCalendar(2013, 2, 21, 16, 56), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 42)));\n        compare(new GregorianCalendar(2013, 2, 21, 17, 11), new CronTab(\"H/15 * * * *\", Hash.from(\"stuff\")).ceil(new GregorianCalendar(2013, 2, 21, 16, 59)));\n        compare(new GregorianCalendar(2013, 2, 21, 0, 2), new CronTab(\"H(0-15)/3 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n        compare(new GregorianCalendar(2013, 2, 21, 0, 2), new CronTab(\"H(0-3)/4 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n        compare(new GregorianCalendar(2013, 2, 21, 1, 2), new CronTab(\"H(0-3)/4 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 5)));\n        try {\n            compare(new GregorianCalendar(2013, 2, 21, 0, 0), new CronTab(\"H(0-3)/15 * * * *\", Hash.from(\"junk\")).ceil(new GregorianCalendar(2013, 2, 21, 0, 0)));\n            fail();\n        } catch (ANTLRException x) {\n            \n        }\n    }\n\n    @Test public void repeatedHash() throws Exception {\n        CronTabList tabs = CronTabList.create(\"H * * * *\\nH * * * *\", Hash.from(\"seed\"));\n        List<Integer> times = new ArrayList<Integer>();\n        for (int i = 0; i < 60; i++) {\n            if (tabs.check(new GregorianCalendar(2013, 3, 3, 11, i, 0))) {\n                times.add(i);\n            }\n        }\n        assertEquals(\"[35, 56]\", times.toString());\n    }\n\n    @Test public void rangeBoundsCheckOK() throws Exception {\n        new CronTab(\"H(0-59) H(0-23) H(1-31) H(1-12) H(0-7)\");\n    }\n\n    @Test public void rangeBoundsCheckFailHour() throws Exception {\n        try {\n            new CronTab(\"H H(12-24) * * *\");\n            fail();\n        } catch (ANTLRException e) {\n            \n        }\n    }\n\n    @Test public void rangeBoundsCheckFailMinute() throws Exception {\n        try {\n            new CronTab(\"H(33-66) * * * *\");\n            fail();\n        } catch (ANTLRException e) {\n            \n        }\n    }\n\n    @Issue(\"JENKINS-9283\")\n    @Test public void testTimezone() throws Exception {\n        CronTabList tabs = CronTabList.create(\"TZ=Australia/Sydney\\nH * * * *\\nH * * * *\", Hash.from(\"seed\"));\n        List<Integer> times = new ArrayList<Integer>();\n        for (int i = 0; i < 60; i++) {\n            if (tabs.check(new GregorianCalendar(2013, 3, 3, 11, i, 0))) {\n                times.add(i);\n            }\n        }\n        assertEquals(\"[35, 56]\", times.toString());\n    }\n\n    @Issue(\"SECURITY-790\")\n    @Test(timeout = 1000L) public void testLongMonths() throws Exception {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.MONTH, Calendar.JULY);\n        new CronTab(\"0 0 31 7 *\").floor(cal); \n    }\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 53,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/junit-plugin/commit/15f39fc49d9f25bca872badb48e708a8bb815ea7",
    "cve_id": "CVE-2018-1000056",
    "cwe_id": "CWE-918",
    "filename": "src/main/java/hudson/tasks/junit/SuiteResult.java",
    "code": "\npackage hudson.tasks.junit;\n\nimport hudson.tasks.test.PipelineTestDetails;\nimport hudson.tasks.test.TestObject;\nimport hudson.util.io.ParserConfigurator;\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n\n@ExportedBean\npublic final class SuiteResult implements Serializable {\n    private static final Logger LOGGER = Logger.getLogger(SuiteResult.class.getName());\n    private final String file;\n    private final String name;\n    private final String stdout;\n    private final String stderr;\n    private float duration;\n    \n    private String timestamp;\n    \n    private String id;\n\n    \n    private String time;\n\n    \n    private String nodeId;\n\n    private final List<String> enclosingBlocks = new ArrayList<>();\n\n    private final List<String> enclosingBlockNames = new ArrayList<>();\n\n    \n    private final List<CaseResult> cases = new ArrayList<CaseResult>();\n    private transient Map<String, CaseResult> casesByName;\n    private transient hudson.tasks.junit.TestResult parent;\n\n    @Deprecated\n    SuiteResult(String name, String stdout, String stderr) {\n        this(name, stdout, stderr, null);\n    }\n\n    \n    SuiteResult(String name, String stdout, String stderr, @CheckForNull PipelineTestDetails pipelineTestDetails) {\n        this.name = name;\n        this.stderr = stderr;\n        this.stdout = stdout;\n        \n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        } else {\n            this.nodeId = null;\n        }\n        this.file = null;\n    }\n\n    private synchronized Map<String, CaseResult> casesByName() {\n        if (casesByName == null) {\n            casesByName = new HashMap<>();\n            for (CaseResult c : cases) {\n                casesByName.put(c.getTransformedTestName(), c);\n            }\n        }\n        return casesByName;\n    }\n\n    \n    @Deprecated\n    public static class SuiteResultParserConfigurationContext {\n        public final File xmlReport;\n\n        SuiteResultParserConfigurationContext(File xmlReport) {\n            this.xmlReport = xmlReport;\n        }\n    }\n\n    \n    static List<SuiteResult> parse(File xmlReport, boolean keepLongStdio, PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException, InterruptedException {\n        List<SuiteResult> r = new ArrayList<SuiteResult>();\n\n        \n        SAXReader saxReader = new SAXReader();\n        saxReader.setEntityResolver(new XMLEntityResolver());\n\n        FileInputStream xmlReportStream = new FileInputStream(xmlReport);\n        try {\n            Document result = saxReader.read(xmlReportStream);\n            Element root = result.getRootElement();\n\n            parseSuite(xmlReport, keepLongStdio, r, root, pipelineTestDetails);\n        } finally {\n            xmlReportStream.close();\n        }\n\n        return r;\n    }\n\n    private static void parseSuite(File xmlReport, boolean keepLongStdio, List<SuiteResult> r, Element root,\n                                   PipelineTestDetails pipelineTestDetails) throws DocumentException, IOException {\n        \n        @SuppressWarnings(\"unchecked\")\n        List<Element> testSuites = (List<Element>) root.elements(\"testsuite\");\n        for (Element suite : testSuites)\n            parseSuite(xmlReport, keepLongStdio, r, suite, pipelineTestDetails);\n\n        \n        \n        if (root.element(\"testcase\") != null || root.element(\"error\") != null)\n            r.add(new SuiteResult(xmlReport, root, keepLongStdio, pipelineTestDetails));\n    }\n\n    \n    private SuiteResult(File xmlReport, Element suite, boolean keepLongStdio, @CheckForNull PipelineTestDetails pipelineTestDetails)\n            throws DocumentException, IOException {\n        this.file = xmlReport.getAbsolutePath();\n        String name = suite.attributeValue(\"name\");\n        if (name == null)\n            \n            \n            name = '(' + xmlReport.getName() + ')';\n        else {\n            String pkg = suite.attributeValue(\"package\");\n            if (pkg != null && pkg.length() > 0) name = pkg + '.' + name;\n        }\n        this.name = TestObject.safe(name);\n        this.timestamp = suite.attributeValue(\"timestamp\");\n        this.id = suite.attributeValue(\"id\");\n        if (pipelineTestDetails != null && pipelineTestDetails.getNodeId() != null) {\n            this.nodeId = pipelineTestDetails.getNodeId();\n            this.enclosingBlocks.addAll(pipelineTestDetails.getEnclosingBlocks());\n            this.enclosingBlockNames.addAll(pipelineTestDetails.getEnclosingBlockNames());\n        }\n\n        \n        if ((this.time = suite.attributeValue(\"time\")) != null) {\n            duration = new TimeToFloat(this.time).parse();\n        }\n\n        Element ex = suite.element(\"error\");\n        if (ex != null) {\n            \n            addCase(new CaseResult(this, suite, \"<init>\", keepLongStdio));\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        List<Element> testCases = (List<Element>) suite.elements(\"testcase\");\n        for (Element e : testCases) {\n            \n            \n            \n\n            \n            \n            \n            \n            String classname = e.attributeValue(\"classname\");\n            if (classname == null) {\n                classname = suite.attributeValue(\"name\");\n            }\n\n            \n            \n            \n            \n            \n\n            addCase(new CaseResult(this, e, classname, keepLongStdio));\n        }\n\n        String stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-out\"));\n        String stderr = CaseResult.possiblyTrimStdio(cases, keepLongStdio, suite.elementText(\"system-err\"));\n        if (stdout == null && stderr == null) {\n            \n            Matcher m = SUREFIRE_FILENAME.matcher(xmlReport.getName());\n            if (m.matches()) {\n                \n                File mavenOutputFile = new File(xmlReport.getParentFile(), m.group(1) + \"-output.txt\");\n                if (mavenOutputFile.exists()) {\n                    try {\n                        stdout = CaseResult.possiblyTrimStdio(cases, keepLongStdio, mavenOutputFile);\n                    } catch (IOException e) {\n                        throw new IOException(\"Failed to read \" + mavenOutputFile, e);\n                    }\n                }\n            }\n        }\n\n        this.stdout = stdout;\n        this.stderr = stderr;\n    }\n\n     void addCase(CaseResult cr) {\n        cases.add(cr);\n        casesByName().put(cr.getTransformedTestName(), cr);\n\n        \n        if( !hasTimeAttr() ){\n            duration += cr.getDuration();\n        }\n    }\n\n    \n    private boolean hasTimeAttr() {\n        return time != null;\n    }\n\n    @Exported(visibility=9)\n    public String getName() {\n        return name;\n    }\n\n    @Exported(visibility=9)\n    public float getDuration() {\n        return duration;\n    }\n\n    \n    @Exported(visibility=9)\n    @CheckForNull\n    public String getNodeId() {\n        return nodeId;\n    }\n\n    \n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlocks() {\n        if (enclosingBlocks != null) {\n            return Collections.unmodifiableList(enclosingBlocks);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    \n    @Exported(visibility=9)\n    @Nonnull\n    public List<String> getEnclosingBlockNames() {\n        if (enclosingBlockNames != null) {\n            return Collections.unmodifiableList(enclosingBlockNames);\n        } else {\n            return Collections.emptyList();\n        }\n    }\n\n    \n    @Exported\n    public String getStdout() {\n        return stdout;\n    }\n\n    \n    @Exported\n    public String getStderr() {\n        return stderr;\n    }\n\n    \n    public String getFile() {\n\t\treturn file;\n\t}\n\n\tpublic hudson.tasks.junit.TestResult getParent() {\n        return parent;\n    }\n\n    @Exported(visibility=9)\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    @Exported(visibility=9)\n    public String getId() {\n        return id;\n    }\n\n    @Exported(inline=true,visibility=9)\n    public List<CaseResult> getCases() {\n        return cases;\n    }\n\n    public SuiteResult getPreviousResult() {\n        hudson.tasks.test.TestResult pr = parent.getPreviousResult();\n        if(pr==null)    return null;\n        if(pr instanceof hudson.tasks.junit.TestResult)\n            return ((hudson.tasks.junit.TestResult)pr).getSuite(name);\n        return null;\n    }\n\n    \n    public CaseResult getCase(String name) {\n        return casesByName().get(name);\n    }\n\n\tpublic Set<String> getClassNames() {\n\t\tSet<String> result = new HashSet<String>();\n\t\tfor (CaseResult c : cases) {\n\t\t\tresult.add(c.getClassName());\n\t\t}\n\t\treturn result;\n\t}\n\n    \n    void setParent(hudson.tasks.junit.TestResult parent) {\n        this.parent = parent;\n    }\n\n     boolean freeze(hudson.tasks.junit.TestResult owner) {\n        if(this.parent!=null)\n            return false;   \n\n        this.parent = owner;\n        for (CaseResult c : cases)\n            c.freeze(this);\n        return true;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Pattern SUREFIRE_FILENAME = Pattern.compile(\"TEST-(.+)\\\\.xml\");\n\n    \n    public void merge(SuiteResult sr) {\n        if (sr.hasTimeAttr() ^ hasTimeAttr()){\n            LOGGER.warning(\"Merging of suiteresults with incompatible time attribute may lead to incorrect durations in reports.( \"+getFile()+\", \"+sr.getFile()+\")\");\n        }\n        if (hasTimeAttr()) {\n            duration += sr.getDuration();\n        }\n        for (CaseResult cr : sr.getCases()) {\n            addCase(cr);\n            cr.replaceParent(this);\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 53,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/junit-plugin/commit/15f39fc49d9f25bca872badb48e708a8bb815ea7",
    "cve_id": "CVE-2018-1000056",
    "cwe_id": "CWE-918",
    "filename": "src/main/java/hudson/tasks/junit/XMLEntityResolver.java",
    "code": "\npackage hudson.tasks.junit;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n\npublic class XMLEntityResolver implements EntityResolver {\n\n    private static final String TESTNG_NAMESPACE = \"http://testng.org/\";\n\n    \n    public InputSource resolveEntity(String publicId, String systemId) throws SAXException, IOException {\n        if (systemId != null) {\n            if (LOGGER.isLoggable(Level.FINE)) {\n                LOGGER.fine(\"Will try to resolve systemId [\" + systemId + \"]\");\n            }\n            \n            if (systemId.startsWith(TESTNG_NAMESPACE)) {\n                LOGGER.fine(\"It's a TestNG document, will try to lookup DTD in classpath\");\n                String dtdFileName = systemId.substring(TESTNG_NAMESPACE.length());\n\n                URL url = getClass().getClassLoader().getResource(dtdFileName);\n                if (url != null)\n                    return new InputSource(url.toString());\n            }\n        }\n        \n        return null;\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(XMLEntityResolver.class.getName());\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 53,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/junit-plugin/commit/15f39fc49d9f25bca872badb48e708a8bb815ea7",
    "cve_id": "CVE-2018-1000056",
    "cwe_id": "CWE-918",
    "filename": "src/test/java/hudson/tasks/junit/JUnitResultArchiverTest.java",
    "code": "\npackage hudson.tasks.junit;\n\nimport hudson.FilePath;\nimport hudson.matrix.AxisList;\nimport hudson.matrix.MatrixBuild;\nimport hudson.matrix.MatrixProject;\nimport hudson.matrix.TextAxis;\nimport hudson.model.FreeStyleBuild;\nimport hudson.model.FreeStyleProject;\nimport hudson.slaves.DumbSlave;\nimport hudson.tasks.test.TestObject;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.TreeMap;\nimport java.util.concurrent.TimeUnit;\n\nimport org.jenkinsci.plugins.structs.describable.DescribableModel;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.TouchBuilder;\nimport org.jvnet.hudson.test.recipes.LocalData;\n\nimport com.gargoylesoftware.htmlunit.html.HtmlAnchor;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\n\nimport hudson.Launcher;\nimport hudson.model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.BuildListener;\nimport hudson.model.Descriptor;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.Builder;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.List;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.not;\nimport static org.junit.Assert.*;\n\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\nimport org.jvnet.hudson.test.RandomlyFails;\nimport org.jvnet.hudson.test.SingleFileSCM;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.kohsuke.stapler.DataBoundConstructor;\n\npublic class JUnitResultArchiverTest {\n\n    @Rule public JenkinsRule j = new JenkinsRule();\n    private FreeStyleProject project;\n    private JUnitResultArchiver archiver;\n\n    @Before public void setUp() throws Exception {\n        project = j.createFreeStyleProject(\"junit\");\n        archiver = new JUnitResultArchiver(\"*.xml\");\n        project.getPublishersList().add(archiver);\n\n        project.getBuildersList().add(new TouchBuilder());\n    }\n\n    @LocalData(\"All\")\n    @Test public void basic() throws Exception {\n        FreeStyleBuild build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\n\n        assertTestResults(build);\n\n        WebClient wc = j.new WebClient();\n        wc.getPage(project); \n        wc.getPage(build); \n        wc.getPage(build, \"testReport\");  \n        wc.getPage(build, \"testReport/hudson.security\"); \n        wc.getPage(build, \"testReport/hudson.security/HudsonPrivateSecurityRealmTest/\"); \n        wc.getPage(build, \"testReport/hudson.security/HudsonPrivateSecurityRealmTest/testDataCompatibilityWith1_282/\"); \n\n\n    }\n\n   @RandomlyFails(\"TimeoutException from basic\")\n   @LocalData(\"All\")\n   @Test public void slave() throws Exception {\n        DumbSlave s = j.createOnlineSlave();\n        project.setAssignedLabel(s.getSelfLabel());\n\n        FilePath src = new FilePath(j.jenkins.getRootPath(), \"jobs/junit/workspace/\");\n        assertNotNull(src);\n        FilePath dest = s.getWorkspaceFor(project);\n        assertNotNull(dest);\n        src.copyRecursiveTo(\"*.xml\", dest);\n\n        basic();\n    }\n\n    private void assertTestResults(FreeStyleBuild build) {\n        TestResultAction testResultAction = build.getAction(TestResultAction.class);\n        assertNotNull(\"no TestResultAction\", testResultAction);\n\n        TestResult result = testResultAction.getResult();\n        assertNotNull(\"no TestResult\", result);\n\n        assertEquals(\"should have 1 failing test\", 1, testResultAction.getFailCount());\n        assertEquals(\"should have 1 failing test\", 1, result.getFailCount());\n\n        assertEquals(\"should have 132 total tests\", 132, testResultAction.getTotalCount());\n        assertEquals(\"should have 132 total tests\", 132, result.getTotalCount());\n\n        for (SuiteResult suite : result.getSuites()) {\n            assertNull(\"No nodeId should be present on the SuiteResult\", suite.getNodeId());\n        }\n    }\n\n    @LocalData(\"All\")\n    @Test public void persistence() throws Exception {\n        project.scheduleBuild2(0).get(60, TimeUnit.SECONDS);\n\n        reloadJenkins();\n\n        FreeStyleBuild build = project.getBuildByNumber(1);\n\n        assertTestResults(build);\n    }\n\n    private void reloadJenkins() throws Exception {\n        j.jenkins.reload();\n        project = (FreeStyleProject) j.jenkins.getItem(\"junit\");\n    }\n\n    @LocalData(\"All\")\n    @Test public void setDescription() throws Exception {\n        FreeStyleBuild build = project.scheduleBuild2(0).get(10, TimeUnit.SECONDS);\n\n        CaseResult caseResult = build.getAction(TestResultAction.class).getFailedTests().get(0);\n        String url = build.getUrl() + \"/testReport/\" + caseResult.getRelativePathFrom(caseResult.getTestResult());\n\n        testSetDescription(url, caseResult);\n\n        ClassResult classResult = caseResult.getParent();\n        url = build.getUrl() + \"/testReport/\" + classResult.getParent().getSafeName() + \"/\" + classResult.getSafeName();\n        testSetDescription(url, classResult);\n\n        PackageResult packageResult = classResult.getParent();\n        url = build.getUrl() + \"/testReport/\" + classResult.getParent().getSafeName();\n        testSetDescription(url, packageResult);\n\n    }\n\n    private void testSetDescription(String url, TestObject object) throws Exception {\n        object.doSubmitDescription(\"description\");\n\n        \n        final WebClient wc = j.createWebClient();\n        HtmlPage page = wc.goTo(url);\n        page.getAnchorByHref(\"editDescription\").click();\n        wc.waitForBackgroundJavaScript(10000L);\n        HtmlForm form = findForm(page, \"submitDescription\");\n        j.submit(form);\n\n        assertEquals(\"description\", object.getDescription());\n    }\n\n    private HtmlForm findForm(HtmlPage page, String action) {\n        for (HtmlForm form: page.getForms()) {\n            if (action.equals(form.getActionAttribute())) {\n                return form;\n            }\n        }\n        fail(\"no form found\");\n        return null;\n    }\n\n    @Test public void repeatedArchiving() throws Exception {\n        doRepeatedArchiving(false);\n    }\n    @Test public void repeatedArchivingSlave() throws Exception {\n        doRepeatedArchiving(true);\n    }\n    private void doRepeatedArchiving(boolean slave) throws Exception {\n        if (slave) {\n            DumbSlave s = j.createOnlineSlave();\n            project.setAssignedLabel(s.getSelfLabel());\n        }\n        project.getPublishersList().removeAll(JUnitResultArchiver.class);\n        project.getBuildersList().add(new SimpleArchive(\"A\", 7, 0));\n        project.getBuildersList().add(new SimpleArchive(\"B\", 0, 1));\n        FreeStyleBuild build = j.assertBuildStatus(Result.UNSTABLE, project.scheduleBuild2(0).get());\n        List<TestResultAction> actions = build.getActions(TestResultAction.class);\n        assertEquals(1, actions.size());\n        TestResultAction testResultAction = actions.get(0);\n        TestResult result = testResultAction.getResult();\n        assertNotNull(\"no TestResult\", result);\n        assertEquals(\"should have 1 failing test\", 1, testResultAction.getFailCount());\n        assertEquals(\"should have 1 failing test\", 1, result.getFailCount());\n        assertEquals(\"should have 8 total tests\", 8, testResultAction.getTotalCount());\n        assertEquals(\"should have 8 total tests\", 8, result.getTotalCount());\n        assertEquals(87, testResultAction.getBuildHealth().getScore());\n    }\n    public static final class SimpleArchive extends Builder {\n        private final String name;\n        private final int pass;\n        private final int fail;\n        public SimpleArchive(String name, int pass, int fail) {\n            this.name = name;\n            this.pass = pass;\n            this.fail = fail;\n        }\n        @Override public boolean perform(AbstractBuild<?, ?> build, Launcher launcher, BuildListener listener) throws InterruptedException, IOException {\n            FilePath ws = build.getWorkspace();\n            OutputStream os = ws.child(name + \".xml\").write();\n            try {\n                PrintWriter pw = new PrintWriter(os);\n                pw.println(\"<testsuite failures=\\\"\" + fail + \"\\\" errors=\\\"0\\\" skipped=\\\"0\\\" tests=\\\"\" + (pass + fail) + \"\\\" name=\\\"\" + name + \"\\\">\");\n                for (int i = 0; i < pass; i++) {\n                    pw.println(\"<testcase classname=\\\"\" + name + \"\\\" name=\\\"passing\" + i + \"\\\"/>\");\n                }\n                for (int i = 0; i < fail; i++) {\n                    pw.println(\"<testcase classname=\\\"\" + name + \"\\\" name=\\\"failing\" + i + \"\\\"><error message=\\\"failure\\\"/></testcase>\");\n                }\n                pw.println(\"</testsuite>\");\n                pw.flush();\n            } finally {\n                os.close();\n            }\n            new JUnitResultArchiver(name + \".xml\").perform(build, ws, launcher, listener);\n            return true;\n        }\n        @TestExtension public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {\n            @Override public boolean isApplicable(Class<? extends AbstractProject> jobType) {\n                return true;\n            }\n            @Override public String getDisplayName() {\n                return \"Incremental JUnit result publishing\";\n            }\n        }\n    }\n\n    @Test public void configRoundTrip() throws Exception {\n        JUnitResultArchiver a = new JUnitResultArchiver(\"TEST-*.xml\");\n        a.setKeepLongStdio(true);\n        a.setTestDataPublishers(Collections.<TestDataPublisher>singletonList(new MockTestDataPublisher(\"testing\")));\n        a.setHealthScaleFactor(0.77);\n        a = j.configRoundtrip(a);\n        assertEquals(\"TEST-*.xml\", a.getTestResults());\n        assertTrue(a.isKeepLongStdio());\n        List<? extends TestDataPublisher> testDataPublishers = a.getTestDataPublishers();\n        assertEquals(1, testDataPublishers.size());\n        assertEquals(MockTestDataPublisher.class, testDataPublishers.get(0).getClass());\n        assertEquals(\"testing\", ((MockTestDataPublisher) testDataPublishers.get(0)).getName());\n        assertEquals(0.77, a.getHealthScaleFactor(), 0.01);\n    }\n\n    public static class MockTestDataPublisher extends TestDataPublisher {\n        private final String name;\n        @DataBoundConstructor public MockTestDataPublisher(String name) {\n            this.name = name;\n        }\n        public String getName() {\n            return name;\n        }\n        @Override public TestResultAction.Data contributeTestData(Run<?,?> run, FilePath workspace, Launcher launcher, TaskListener listener, TestResult testResult) throws IOException, InterruptedException {\n            return null;\n        }\n\n        \n        @TestExtension public static class DescriptorImpl extends Descriptor<TestDataPublisher> {\n            @Override public String getDisplayName() {\n                return \"MockTestDataPublisher\";\n            }\n        }\n    }\n\n    @Test public void emptyDirectoryAllowEmptyResult() throws Exception {\n        JUnitResultArchiver a = new JUnitResultArchiver(\"TEST-*.xml\");\n        a.setAllowEmptyResults(true);\n        FreeStyleProject freeStyleProject = j.createFreeStyleProject();\n        freeStyleProject.getPublishersList().add(a);\n        j.assertBuildStatus(Result.SUCCESS, freeStyleProject.scheduleBuild2(0).get());\n    }\n\n    @Test public void emptyDirectory() throws Exception {\n        JUnitResultArchiver a = new JUnitResultArchiver(\"TEST-*.xml\");\n        a.setAllowEmptyResults(false);\n        FreeStyleProject freeStyleProject = j.createFreeStyleProject();\n        freeStyleProject.getPublishersList().add(a);\n        j.assertBuildStatus(Result.FAILURE, freeStyleProject.scheduleBuild2(0).get());\n    }\n\n    @Test public void specialCharsInRelativePath() throws Exception {\n        final String ID_PREFIX = \"test-../a=%3C%7C%23)/testReport/org.twia.vendor/VendorManagerTest/testCreateAdjustingFirm/\";\n        final String EXPECTED = \"org.twia.dao.DAOException: [S2001] Hibernate encountered an error updating Claim [null]\";\n\n        MatrixProject p = j.jenkins.createProject(MatrixProject.class, \"test-\" + j.jenkins.getItems().size());\n        p.setAxes(new AxisList(new TextAxis(\"a\", \"<|#)\")));\n        p.setScm(new SingleFileSCM(\"report.xml\", getClass().getResource(\"junit-report-20090516.xml\")));\n        p.getPublishersList().add(new JUnitResultArchiver(\"report.xml\"));\n\n        MatrixBuild b = p.scheduleBuild2(0).get();\n        j.assertBuildStatus(Result.UNSTABLE, b);\n\n        WebClient wc = j.createWebClient();\n        HtmlPage page = wc.getPage(b, \"testReport\");\n\n        assertThat(page.asText(), not(containsString(EXPECTED)));\n\n        ((HtmlAnchor) page.getElementById(ID_PREFIX + \"-showlink\")).click();\n        wc.waitForBackgroundJavaScript(10000L);\n        assertThat(page.asText(), containsString(EXPECTED));\n\n        ((HtmlAnchor) page.getElementById(ID_PREFIX + \"-hidelink\")).click();\n        wc.waitForBackgroundJavaScript(10000L);\n        assertThat(page.asText(), not(containsString(EXPECTED)));\n    }\n\n    @Issue(\"JENKINS-26535\")\n    @Test\n    public void testDescribableRoundTrip() throws Exception {\n        DescribableModel<JUnitResultArchiver> model = new DescribableModel<JUnitResultArchiver>(JUnitResultArchiver.class);\n        Map<String,Object> args = new TreeMap<String,Object>();\n\n        args.put(\"testResults\", \"**/TEST-*.xml\");\n        JUnitResultArchiver j = model.instantiate(args);\n        assertEquals(\"**/TEST-*.xml\", j.getTestResults());\n        assertFalse(j.isAllowEmptyResults());\n        assertFalse(j.isKeepLongStdio());\n        assertEquals(1.0, j.getHealthScaleFactor(), 0);\n        assertTrue(j.getTestDataPublishers().isEmpty());\n        assertEquals(args, model.uninstantiate(model.instantiate(args)));\n\n        \n        Map<String,Object> describedPublisher = new HashMap<String, Object>();\n        describedPublisher.put(\"$class\", \"MockTestDataPublisher\");\n        describedPublisher.put(\"name\", \"test\");\n        args.put(\"testDataPublishers\", Collections.singletonList(describedPublisher));\n\n        Map<String,Object> described = model.uninstantiate(model.instantiate(args));\n        JUnitResultArchiver j2 = model.instantiate(described);\n        List<TestDataPublisher> testDataPublishers = j2.getTestDataPublishers();\n        assertFalse(testDataPublishers.isEmpty());\n        assertEquals(1, testDataPublishers.size());\n        assertEquals(MockTestDataPublisher.class, testDataPublishers.get(0).getClass());\n        assertEquals(\"test\", ((MockTestDataPublisher)testDataPublishers.get(0)).getName());\n\n        assertEquals(described, model.uninstantiate(model.instantiate(described)));\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 54,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/pipeline-build-step-plugin/commit/3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3",
    "cve_id": "CVE-2018-1000089",
    "cwe_id": "CWE-532",
    "filename": "src/main/java/org/jenkinsci/plugins/workflow/support/steps/build/BuildTriggerStepExecution.java",
    "code": "package org.jenkinsci.plugins.workflow.support.steps.build;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Inject;\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport hudson.AbortException;\nimport hudson.console.ModelHyperlinkNote;\nimport hudson.model.Action;\nimport hudson.model.Cause;\nimport hudson.model.CauseAction;\nimport hudson.model.Computer;\nimport hudson.model.Describable;\nimport hudson.model.Executor;\nimport hudson.model.Item;\nimport hudson.model.Job;\nimport hudson.model.ParameterDefinition;\nimport hudson.model.ParameterValue;\nimport hudson.model.ParametersAction;\nimport hudson.model.ParametersDefinitionProperty;\nimport hudson.model.Queue;\nimport hudson.model.Result;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.queue.QueueTaskFuture;\nimport hudson.model.queue.ScheduleResult;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ParameterizedJobMixIn;\nimport org.jenkinsci.plugins.workflow.actions.LabelAction;\nimport org.jenkinsci.plugins.workflow.graph.FlowNode;\nimport org.jenkinsci.plugins.workflow.steps.AbstractStepExecutionImpl;\nimport org.jenkinsci.plugins.workflow.steps.StepContext;\nimport org.jenkinsci.plugins.workflow.steps.StepContextParameter;\n\n\npublic class BuildTriggerStepExecution extends AbstractStepExecutionImpl {\n\n    private static final Logger LOGGER = Logger.getLogger(BuildTriggerStepExecution.class.getName());\n\n    @StepContextParameter\n    private transient TaskListener listener;\n    @StepContextParameter private transient Run<?,?> invokingRun;\n    @StepContextParameter private transient FlowNode node;\n\n    @Inject(optional=true) transient BuildTriggerStep step;\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n    @Override\n    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        if (step.getWait() && !(item instanceof Job)) {\n            \n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            \n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    \n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }\n\n    private List<ParameterValue> completeDefaultParameters(List<ParameterValue> parameters, Job<?,?> project) {\n        List<ParameterValue> completeListOfParameters = Lists.newArrayList(parameters);\n        List<String> names = Lists.transform(parameters, new Function<ParameterValue, String>() {\n            @Override public String apply(ParameterValue input) {\n                return input.getName();\n            }\n        });\n        if (project != null) {\n            ParametersDefinitionProperty pdp = project.getProperty(ParametersDefinitionProperty.class);\n            if (pdp != null) {\n                for (ParameterDefinition pDef : pdp.getParameterDefinitions()) {\n                    if (!names.contains(pDef.getName())) {\n                        ParameterValue defaultP = pDef.getDefaultParameterValue();\n                        if (defaultP != null) {\n                            completeListOfParameters.add(defaultP);\n                        }\n                    }\n                }\n            }\n        }\n        return completeListOfParameters;\n    }\n\n    @SuppressFBWarnings(value=\"RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE\", justification=\"TODO 1.653+ switch to Jenkins.getInstanceOrNull\")\n    @Override\n    public void stop(Throwable cause) {\n        StepContext context = getContext();\n        Jenkins jenkins = Jenkins.getInstance();\n        if (jenkins == null) {\n            context.onFailure(cause);\n            return;\n        }\n\n        boolean interrupted = false;\n\n        Queue q = jenkins.getQueue();\n        \n        \n        for (Queue.Item i : q.getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(context)) {\n                    \n                    \n                    \n                    q.cancel(i);\n                    interrupted = true;\n                }\n            }\n        }\n\n        \n        \n        \n        for (Computer c : jenkins.getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                interrupted |= maybeInterrupt(e, cause, context);\n            }\n        }\n\n        if (!interrupted) {\n            context.onFailure(cause);\n        }\n    }\n    private static boolean maybeInterrupt(Executor e, Throwable cause, StepContext context) {\n        boolean interrupted = false;\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor((Run) exec)) {\n                if (trigger.context.equals(context)) {\n                    e.interrupt(Result.ABORTED, new BuildTriggerCancelledCause(cause));\n                    trigger.interruption = cause;\n                    try {\n                        ((Run) exec).save();\n                    } catch (IOException x) {\n                        LOGGER.log(Level.WARNING, \"failed to save interrupt cause on \" + exec, x);\n                    }\n                    interrupted = true;\n                }\n            }\n        }\n        return interrupted;\n    }\n\n    @Override public String getStatus() {\n        for (Queue.Item i : Queue.getInstance().getItems()) {\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(i)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"waiting to schedule \" + i.task.getFullDisplayName() + \"; blocked: \" + i.getWhy();\n                }\n            }\n        }\n        for (Computer c : Jenkins.getActiveInstance().getComputers()) {\n            for (Executor e : c.getExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n            for (Executor e : c.getOneOffExecutors()) {\n                String r = running(e);\n                if (r != null) {\n                    return r;\n                }\n            }\n        }\n        \n        return \"unsure what happened to downstream build\";\n    }\n    private @CheckForNull String running(@Nonnull Executor e) {\n        Queue.Executable exec = e.getCurrentExecutable();\n        if (exec instanceof Run) {\n            Run<?,?> run = (Run) exec;\n            for (BuildTriggerAction.Trigger trigger : BuildTriggerAction.triggersFor(run)) {\n                if (trigger.context.equals(getContext())) {\n                    return \"running \" + run;\n                }\n            }\n        }\n        return null;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 54,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/pipeline-build-step-plugin/commit/3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3",
    "cve_id": "CVE-2018-1000089",
    "cwe_id": "CWE-532",
    "filename": "src/test/java/org/jenkinsci/plugins/workflow/support/steps/build/BuildTriggerStepTest.java",
    "code": "package org.jenkinsci.plugins.workflow.support.steps.build;\n\nimport edu.umd.cs.findbugs.annotations.CheckForNull;\nimport edu.umd.cs.findbugs.annotations.NonNull;\nimport hudson.model.Action;\nimport hudson.model.BooleanParameterDefinition;\nimport hudson.model.Cause;\nimport hudson.model.Executor;\nimport hudson.model.FreeStyleBuild;\nimport hudson.model.FreeStyleProject;\nimport hudson.model.ItemGroup;\nimport hudson.model.Label;\nimport hudson.model.ParametersDefinitionProperty;\nimport hudson.model.Queue;\nimport hudson.model.Result;\nimport hudson.model.StringParameterDefinition;\nimport hudson.model.TaskListener;\nimport hudson.model.queue.QueueTaskFuture;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.logging.Level;\nimport jenkins.branch.MultiBranchProjectFactory;\nimport jenkins.branch.MultiBranchProjectFactoryDescriptor;\nimport jenkins.branch.OrganizationFolder;\nimport jenkins.scm.api.SCMHeadEvent;\nimport jenkins.scm.api.SCMSource;\nimport jenkins.scm.impl.mock.MockSCMController;\nimport jenkins.scm.impl.mock.MockSCMNavigator;\nimport org.apache.commons.lang.StringUtils;\nimport static org.hamcrest.Matchers.notNullValue;\nimport static org.hamcrest.Matchers.nullValue;\nimport org.jenkinsci.plugins.workflow.cps.CpsFlowDefinition;\nimport org.jenkinsci.plugins.workflow.cps.CpsFlowExecution;\nimport org.jenkinsci.plugins.workflow.job.WorkflowJob;\nimport org.jenkinsci.plugins.workflow.job.WorkflowRun;\nimport org.jenkinsci.plugins.workflow.test.steps.SemaphoreStep;\nimport static org.junit.Assert.*;\nimport org.junit.Before;\nimport org.junit.ClassRule;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.BuildWatcher;\nimport org.jvnet.hudson.test.CaptureEnvironmentBuilder;\nimport org.jvnet.hudson.test.FailureBuilder;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.LoggerRule;\nimport org.jvnet.hudson.test.MockFolder;\nimport org.jvnet.hudson.test.SleepBuilder;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.jvnet.hudson.test.recipes.LocalData;\n\npublic class BuildTriggerStepTest {\n    \n    @ClassRule public static BuildWatcher buildWatcher = new BuildWatcher();\n    @Rule public JenkinsRule j = new JenkinsRule();\n    @Rule public LoggerRule logging = new LoggerRule();\n\n    @Before public void runQuickly() throws IOException {\n        j.jenkins.setQuietPeriod(0);\n    }\n\n    @Issue(\"JENKINS-25851\")\n    @Test public void buildTopLevelProject() throws Exception {\n        FreeStyleProject ds = j.createFreeStyleProject(\"ds\");\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\n            \"def ds = build 'ds'\\n\" +\n            \"echo \\\"ds.result=${ds.result} ds.number=${ds.number}\\\"\", true));\n        j.assertLogContains(\"ds.result=SUCCESS ds.number=1\", j.buildAndAssertSuccess(us));\n        \n        \n        ds.getBuildByNumber(1).delete();\n    }\n\n    @Issue(\"JENKINS-25851\")\n    @Test public void failingBuild() throws Exception {\n        j.createFreeStyleProject(\"ds\").getBuildersList().add(new FailureBuilder());\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"build 'ds'\", true));\n        j.assertBuildStatus(Result.FAILURE, us.scheduleBuild2(0));\n        us.setDefinition(new CpsFlowDefinition(\"echo \\\"ds.result=${build(job: 'ds', propagate: false).result}\\\"\", true));\n        j.assertLogContains(\"ds.result=FAILURE\", j.buildAndAssertSuccess(us));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    public void buildFolderProject() throws Exception {\n        MockFolder dir1 = j.createFolder(\"dir1\");\n        FreeStyleProject downstream = dir1.createProject(FreeStyleProject.class, \"downstream\");\n        downstream.getBuildersList().add(new SleepBuilder(1));\n\n        MockFolder dir2 = j.createFolder(\"dir2\");\n        WorkflowJob upstream = dir2.createProject(WorkflowJob.class, \"upstream\");\n        upstream.setDefinition(new CpsFlowDefinition(\"build '../dir1/downstream'\"));\n\n        j.buildAndAssertSuccess(upstream);\n        assertEquals(1, downstream.getBuilds().size());\n    }\n\n    @Test\n    public void buildParallelTests() throws Exception {\n        FreeStyleProject p1 = j.createFreeStyleProject(\"test1\");\n        p1.getBuildersList().add(new SleepBuilder(1));\n\n        FreeStyleProject p2 = j.createFreeStyleProject(\"test2\");\n        p2.getBuildersList().add(new SleepBuilder(1));\n\n        WorkflowJob foo = j.jenkins.createProject(WorkflowJob.class, \"foo\");\n        foo.setDefinition(new CpsFlowDefinition(StringUtils.join(Arrays.asList(\"parallel(test1: {\\n\" +\n                \"          build('test1');\\n\" +\n                \"        }, test2: {\\n\" +\n                \"          build('test2');\\n\" +\n                \"        })\"), \"\\n\"), true));\n\n        j.buildAndAssertSuccess(foo);\n    }\n\n\n    @Test\n    public void abortBuild() throws Exception {\n        FreeStyleProject p = j.createFreeStyleProject(\"test1\");\n        p.getBuildersList().add(new SleepBuilder(Long.MAX_VALUE));\n\n        WorkflowJob foo = j.jenkins.createProject(WorkflowJob.class, \"foo\");\n        foo.setDefinition(new CpsFlowDefinition(StringUtils.join(Arrays.asList(\"build('test1');\"), \"\\n\")));\n\n        QueueTaskFuture<WorkflowRun> q = foo.scheduleBuild2(0);\n        WorkflowRun b = q.getStartCondition().get();\n\n        CpsFlowExecution e = (CpsFlowExecution) b.getExecutionPromise().get();\n        e.waitForSuspension();\n\n        FreeStyleBuild fb=null;\n        while (fb==null) {\n            fb = p.getBuildByNumber(1);\n            Thread.sleep(10);\n        }\n        fb.getExecutor().interrupt();\n\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(fb));\n        j.assertBuildStatus(Result.FAILURE,q.get());\n    }\n\n    @Test\n    public void cancelBuildQueue() throws Exception {\n        FreeStyleProject p = j.createFreeStyleProject(\"test1\");\n        p.getBuildersList().add(new SleepBuilder(Long.MAX_VALUE));\n\n        WorkflowJob foo = j.jenkins.createProject(WorkflowJob.class, \"foo\");\n        foo.setDefinition(new CpsFlowDefinition(StringUtils.join(Arrays.asList(\"build('test1');\"), \"\\n\")));\n\n        j.jenkins.setNumExecutors(0); \n\n        QueueTaskFuture<WorkflowRun> q = foo.scheduleBuild2(0);\n\n        WorkflowRun b = q.getStartCondition().get();\n        CpsFlowExecution e = (CpsFlowExecution) b.getExecutionPromise().get();\n        e.waitForSuspension();\n\n        Queue.Item[] items = j.jenkins.getQueue().getItems();\n        assertEquals(1, items.length);\n        j.jenkins.getQueue().cancel(items[0]);\n\n        j.assertBuildStatus(Result.FAILURE,q.get());\n    }\n\n    \n    @Test public void interruptFlow() throws Exception {\n        FreeStyleProject ds1 = j.createFreeStyleProject(\"ds1\");\n        ds1.getBuildersList().add(new SleepBuilder(Long.MAX_VALUE));\n        FreeStyleProject ds2 = j.createFreeStyleProject(\"ds2\");\n        ds2.getBuildersList().add(new SleepBuilder(Long.MAX_VALUE));\n        FreeStyleProject ds3 = j.createFreeStyleProject(\"ds3\");\n        ds3.getBuildersList().add(new SleepBuilder(Long.MAX_VALUE));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"parallel ds1: {build 'ds1'}, ds23: {parallel ds2: {build 'ds2'}, ds3: {build 'ds3'}}\", true));\n        j.jenkins.setNumExecutors(3);\n        j.jenkins.setNodes(j.jenkins.getNodes()); \n        WorkflowRun usb = us.scheduleBuild2(0).getStartCondition().get();\n        assertEquals(1, usb.getNumber());\n        FreeStyleBuild ds1b, ds2b, ds3b;\n        while ((ds1b = ds1.getLastBuild()) == null || (ds2b = ds2.getLastBuild()) == null || (ds3b = ds3.getLastBuild()) == null) {\n            Thread.sleep(100);\n        }\n        assertEquals(1, ds1b.getNumber());\n        assertEquals(1, ds2b.getNumber());\n        assertEquals(1, ds3b.getNumber());\n        \n        \n        \n        usb.doStop();\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(usb));\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(ds1b));\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(ds2b));\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(ds3b));\n    }\n\n    @Issue(\"JENKINS-31902\")\n    @Test public void interruptFlowDownstreamFlow() throws Exception {\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.setDefinition(new CpsFlowDefinition(\"semaphore 'ds'\", true));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"build 'ds'\", true));\n        WorkflowRun usb = us.scheduleBuild2(0).getStartCondition().get();\n        assertEquals(1, usb.getNumber());\n        SemaphoreStep.waitForStart(\"ds/1\", null);\n        WorkflowRun dsb = ds.getLastBuild();\n        assertEquals(1, dsb.getNumber());\n        usb.doStop();\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(usb));\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(dsb));\n    }\n\n    @Test public void interruptFlowNonPropagate() throws Exception {\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.setDefinition(new CpsFlowDefinition(\"semaphore 'ds'\", true));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"while (true) {build job: 'ds', propagate: false}\", true));\n        WorkflowRun usb = us.scheduleBuild2(0).getStartCondition().get();\n        assertEquals(1, usb.getNumber());\n        SemaphoreStep.waitForStart(\"ds/1\", null);\n        WorkflowRun dsb = ds.getLastBuild();\n        assertEquals(1, dsb.getNumber());\n        usb.doStop();\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(usb));\n        j.assertBuildStatus(Result.ABORTED, j.waitForCompletion(dsb));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test public void triggerWorkflow() throws Exception {\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"build 'ds'\"));\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.setDefinition(new CpsFlowDefinition(\"echo 'OK'\"));\n        j.buildAndAssertSuccess(us);\n        assertEquals(1, ds.getBuilds().size());\n    }\n\n    @Issue(\"JENKINS-31897\")\n    @Test public void parameters() throws Exception {\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        FreeStyleProject ds = j.jenkins.createProject(FreeStyleProject.class, \"ds\");\n        ds.addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(\"branch\", \"master\"), new BooleanParameterDefinition(\"extra\", false, null)));\n        CaptureEnvironmentBuilder env = new CaptureEnvironmentBuilder();\n        ds.getBuildersList().add(env);\n        us.setDefinition(new CpsFlowDefinition(\"build 'ds'\"));\n        WorkflowRun us1 = j.buildAndAssertSuccess(us);\n        assertEquals(\"1\", env.getEnvVars().get(\"BUILD_NUMBER\"));\n        assertEquals(\"master\", env.getEnvVars().get(\"branch\"));\n        assertEquals(\"false\", env.getEnvVars().get(\"extra\"));\n        Cause.UpstreamCause cause = ds.getBuildByNumber(1).getCause(Cause.UpstreamCause.class);\n        assertNotNull(cause);\n        assertEquals(us1, cause.getUpstreamRun());\n        us.setDefinition(new CpsFlowDefinition(\"build job: 'ds', parameters: [[$class: 'StringParameterValue', name: 'branch', value: 'release']]\", true));\n        j.buildAndAssertSuccess(us);\n        assertEquals(\"2\", env.getEnvVars().get(\"BUILD_NUMBER\"));\n        assertEquals(\"release\", env.getEnvVars().get(\"branch\"));\n        assertEquals(\"false\", env.getEnvVars().get(\"extra\")); \n        us.setDefinition(new CpsFlowDefinition(\"build job: 'ds', parameters: [[$class: 'StringParameterValue', name: 'branch', value: 'release'], [$class: 'BooleanParameterValue', name: 'extra', value: true]]\", true));\n        j.buildAndAssertSuccess(us);\n        assertEquals(\"3\", env.getEnvVars().get(\"BUILD_NUMBER\"));\n        assertEquals(\"release\", env.getEnvVars().get(\"branch\"));\n        assertEquals(\"true\", env.getEnvVars().get(\"extra\"));\n    }\n\n    @Issue(\"JENKINS-26123\")\n    @Test public void noWait() throws Exception {\n        j.createFreeStyleProject(\"ds\").setAssignedLabel(Label.get(\"nonexistent\"));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"build job: 'ds', wait: false\"));\n        j.buildAndAssertSuccess(us);\n    }\n\n    @Test public void rejectedStart() throws Exception {\n        j.createFreeStyleProject(\"ds\");\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        \n        us.setDefinition(new CpsFlowDefinition(\"build job: 'ds', wait: false\"));\n        j.assertLogContains(\"Failed to trigger build of ds\", j.assertBuildStatus(Result.FAILURE, us.scheduleBuild2(0)));\n    }\n    @TestExtension(\"rejectedStart\") public static final class QDH extends Queue.QueueDecisionHandler {\n        @Override public boolean shouldSchedule(Queue.Task p, List<Action> actions) {\n            return p instanceof WorkflowJob; \n        }\n    }\n\n    @Issue(\"JENKINS-25851\")\n    @Test public void buildVariables() throws Exception {\n        j.createFreeStyleProject(\"ds\").addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(\"param\", \"default\")));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"echo \\\"build var: ${build(job: 'ds', parameters: [[$class: 'StringParameterValue', name: 'param', value: 'override']]).buildVariables.param}\\\"\", true));\n        j.assertLogContains(\"build var: override\", j.buildAndAssertSuccess(us));\n    }\n\n    @Issue(\"JENKINS-29169\")\n    @Test public void buildVariablesWorkflow() throws Exception {\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.setDefinition(new CpsFlowDefinition(\"env.RESULT = \\\"ds-${env.BUILD_NUMBER}\\\"\", true));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"def vars = build('ds').buildVariables; echo \\\"received RESULT=${vars.RESULT} vs. BUILD_NUMBER=${vars.BUILD_NUMBER}\\\"\", true));\n        j.assertLogContains(\"received RESULT=ds-1 vs. BUILD_NUMBER=null\", j.buildAndAssertSuccess(us));\n        ds.getBuildByNumber(1).delete();\n    }\n\n    @Issue(\"JENKINS-28063\")\n    @Test public void coalescedQueue() throws Exception {\n        FreeStyleProject ds = j.createFreeStyleProject(\"ds\");\n        ds.setConcurrentBuild(true);\n        ds.getBuildersList().add(new SleepBuilder(3000));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"echo \\\"triggered #${build('ds').number}\\\"\", true));\n        QueueTaskFuture<WorkflowRun> us1F = us.scheduleBuild2(0);\n        us1F.waitForStart(); \n        QueueTaskFuture<WorkflowRun> us2F = us.scheduleBuild2(0);\n        WorkflowRun us1 = us1F.get();\n        assertEquals(1, us1.getNumber());\n        j.assertLogContains(\"triggered #1\", us1);\n        WorkflowRun us2 = us2F.get();\n        assertEquals(2, us2.getNumber());\n        j.assertLogContains(\"triggered #1\", us2);\n        FreeStyleBuild ds1 = ds.getLastBuild();\n        assertEquals(1, ds1.getNumber());\n        assertEquals(2, ds1.getCauses().size()); \n    }\n\n    @Issue(\"http://stackoverflow.com/q/32228590/12916\")\n    @Test public void nonCoalescedQueueParallel() throws Exception {\n        j.jenkins.setNumExecutors(5);\n        FreeStyleProject ds = j.createFreeStyleProject(\"ds\");\n        ds.setConcurrentBuild(true);\n        ds.addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(\"which\", null)));\n        ds.getBuildersList().add(new SleepBuilder(3000));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\n            \"def branches = [:]\\n\" +\n            \"for (int i = 0; i < 5; i++) {\\n\" +\n            \"  def which = \\\"${i}\\\"\\n\" +\n            \"  branches[\\\"branch${i}\\\"] = {\\n\" +\n            \"    build job: 'ds', parameters: [[$class: 'StringParameterValue', name: 'which', value: which]]\\n\" +\n            \"  }\\n\" +\n            \"}\\n\" +\n            \"parallel branches\", true));\n        j.buildAndAssertSuccess(us);\n        FreeStyleBuild ds1 = ds.getLastBuild();\n        assertEquals(5, ds1.getNumber());\n    }\n\n    @Issue(\"JENKINS-39454\")\n    @Test public void raceCondition() throws Exception {\n        logging.record(BuildTriggerStepExecution.class.getPackage().getName(), Level.FINE).record(Queue.class, Level.FINE).record(Executor.class, Level.FINE);\n        j.jenkins.setQuietPeriod(0);\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.setDefinition(new CpsFlowDefinition(\"sleep 1\", true));\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"def rebuild() {for (int i = 0; i < 20; i++) {build 'ds'}}; parallel A: {rebuild()}, B: {rebuild()}, C: {rebuild()}\", true));\n        j.buildAndAssertSuccess(us);\n    }\n\n    @Issue(\"JENKINS-31897\")\n    @Test public void defaultParameters() throws Exception {\n        WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n        us.setDefinition(new CpsFlowDefinition(\"build job: 'ds', parameters: [[$class: 'StringParameterValue', name: 'PARAM1', value: 'first']] \"));\n        WorkflowJob ds = j.jenkins.createProject(WorkflowJob.class, \"ds\");\n        ds.addProperty(new ParametersDefinitionProperty(new StringParameterDefinition(\"PARAM1\", \"p1\"), new StringParameterDefinition(\"PARAM2\", \"p2\")));\n        \n        ds.setDefinition(new CpsFlowDefinition(\"echo \\\"${PARAM1} - ${PARAM2}\\\"\"));\n        j.buildAndAssertSuccess(us);\n        j.assertLogContains(\"first - p2\", ds.getLastBuild());\n    }\n\n    @LocalData\n    @Test public void storedForm() throws Exception {\n        WorkflowJob us = j.jenkins.getItemByFullName(\"us\", WorkflowJob.class);\n        WorkflowRun us1 = us.getBuildByNumber(1);\n        WorkflowJob ds = j.jenkins.getItemByFullName(\"ds\", WorkflowJob.class);\n        WorkflowRun ds1 = ds.getBuildByNumber(1);\n        ds1.setDescription(\"something\");\n        j.assertBuildStatusSuccess(j.waitForCompletion(ds1));\n        j.assertBuildStatusSuccess(j.waitForCompletion(us1));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    @Test\n    @Issue(\"JENKINS-38887\")\n    public void triggerOrgFolder() throws Exception {\n        try (MockSCMController c = MockSCMController.create()) {\n            c.createRepository(\"foo\");\n            WorkflowJob us = j.jenkins.createProject(WorkflowJob.class, \"us\");\n            us.setDefinition(new CpsFlowDefinition(\"build job:'ds', wait:false\"));\n            OrganizationFolder ds = j.jenkins.createProject(OrganizationFolder.class, \"ds\");\n            ds.getSCMNavigators().add(new MockSCMNavigator(c, true, false, false));\n            ds.getProjectFactories().add(new DummyMultiBranchProjectFactory());\n            j.waitUntilNoActivity();\n            assertThat(ds.getComputation().getResult(), nullValue());\n            j.buildAndAssertSuccess(us);\n            j.waitUntilNoActivity();\n            assertThat(ds.getComputation().getResult(), notNullValue());\n        }\n    }\n\n    public static class DummyMultiBranchProjectFactory extends MultiBranchProjectFactory {\n        @Override\n        public boolean recognizes(@NonNull ItemGroup<?> parent, @NonNull String name,\n                                  @NonNull List<? extends SCMSource> scmSources,\n                                  @NonNull Map<String, Object> attributes,\n                                  @CheckForNull SCMHeadEvent<?> event, @NonNull TaskListener listener)\n                throws IOException, InterruptedException {\n            return false;\n        }\n\n        @TestExtension(\"triggerOrgFolder\")\n        public static class DescriptorImpl extends MultiBranchProjectFactoryDescriptor {\n\n            @Override\n            public MultiBranchProjectFactory newInstance() {\n                return new DummyMultiBranchProjectFactory();\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 55,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/subversion-plugin/commit/25f6afbb02a5863f363b0a2f664ac717ace743b4",
    "cve_id": "CVE-2018-1000111",
    "cwe_id": "CWE-863",
    "filename": "src/main/java/hudson/scm/SubversionRepositoryStatus.java",
    "code": "package hudson.scm;\n\nimport static java.util.logging.Level.FINE;\nimport static java.util.logging.Level.FINER;\nimport static java.util.logging.Level.WARNING;\nimport static javax.servlet.http.HttpServletResponse.SC_OK;\n\nimport hudson.Extension;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.model.AbstractModelObject;\nimport hudson.model.AbstractProject;\nimport hudson.model.Job;\nimport hudson.scm.SubversionSCM.ModuleLocation;\nimport hudson.scm.SubversionSCM.SvnInfo;\nimport hudson.triggers.SCMTrigger;\nimport hudson.util.QueryParameterMap;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.UUID;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport javax.servlet.ServletException;\n\nimport jenkins.model.Jenkins;\nimport jenkins.triggers.SCMTriggerItem;\nimport org.apache.commons.io.IOUtils;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport org.tmatesoft.svn.core.SVNCancelException;\nimport org.tmatesoft.svn.core.SVNURL;\nimport org.tmatesoft.svn.core.SVNException;\n\n\npublic class SubversionRepositoryStatus extends AbstractModelObject {\n    public final UUID uuid;\n\n    public SubversionRepositoryStatus(UUID uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getDisplayName() {\n        return uuid.toString();\n    }\n\n    public String getSearchUrl() {\n        return uuid.toString();\n    }\n    \n    static interface JobProvider {\n        @SuppressWarnings(\"rawtypes\")\n        List<Job> getAllJobs();\n    }\n\n    \n    public static abstract class Listener implements ExtensionPoint {\n\n        \n        public abstract boolean onNotify(UUID uuid, long revision, Set<String> affectedPaths);\n    }\n    \n    private static Method IS_IGNORE_POST_COMMIT_HOOKS_METHOD;\n    \n    \n    public void doNotifyCommit(StaplerRequest req, StaplerResponse rsp) throws ServletException, IOException {\n        requirePOST();\n\n        \n        Set<String> affectedPath = new HashSet<String>();\n        String line;\n        BufferedReader r = new BufferedReader(req.getReader());\n        \n        try {\n\t        while((line=r.readLine())!=null) {\n\t        \tif (LOGGER.isLoggable(FINER)) {\n\t        \t\tLOGGER.finer(\"Reading line: \"+line);\n\t        \t}\n\t            affectedPath.add(line.substring(4));\n\t            if (line.startsWith(\"svnlook changed --revision \")) {\n\t                String msg = \"Expecting the output from the svnlook command but instead you just sent me the svnlook invocation command line: \" + line;\n\t                LOGGER.warning(msg);\n\t                throw new IllegalArgumentException(msg);\n\t            }\n\t        }\n        } finally {\n        \tIOUtils.closeQuietly(r);\n        }\n\n        if(LOGGER.isLoggable(FINE))\n            LOGGER.fine(\"Change reported to Subversion repository \"+uuid+\" on \"+affectedPath);\n\n        \n        \n        \n        QueryParameterMap query = new QueryParameterMap(req);\n        String revParam = query.get(\"rev\");\n        if (revParam == null) {\n            revParam = req.getHeader(\"X-Hudson-Subversion-Revision\");\n        }\n\n        long rev = -1;\n        if (revParam != null) {\n            rev = Long.parseLong(revParam);\n        }\n\n        boolean listenerDidSomething = false;\n        for (Listener listener : ExtensionList.lookup(Listener.class)) {\n            try {\n                if (listener.onNotify(uuid, rev, affectedPath)) {\n                    listenerDidSomething = true;\n                }\n            } catch (Throwable t) {\n                LOGGER.log(WARNING, \"Listener \" + listener.getClass().getName() + \" threw an uncaught exception\", t);\n            }\n        }\n\n        if (!listenerDidSomething) LOGGER.log(Level.WARNING, \"No interest in change to repository UUID {0} found\", uuid);\n\n        rsp.setStatus(SC_OK);\n    }\n\n    private static class SubversionRepoUUIDAndRootPath {\n        public final UUID uuid;\n        public final String rootPath;\n\n        public SubversionRepoUUIDAndRootPath(UUID uuid, String rootPath) {\n            this.uuid = uuid;\n            this.rootPath = rootPath;\n        }\n    }\n\n    @Extension\n    public static class JobTriggerListenerImpl extends Listener {\n\n        private Map<String, UUID> remoteUUIDCache = new HashMap<String, UUID>();\n\n        private JobProvider jobProvider = new JobProvider() {\n            @SuppressWarnings(\"rawtypes\")\n            public List<Job> getAllJobs() {\n                return Jenkins.getInstance().getAllItems(Job.class);\n            }\n        };\n\n        \n        void setJobProvider(JobProvider jobProvider) {\n            this.jobProvider = jobProvider;\n        }\n\n        private SubversionRepoUUIDAndRootPath remoteUUIDAndRootPathFromCacheOrFromSVN(Job job, SCM scm, ModuleLocation moduleLocation, String urlFromConfiguration) throws SVNException {\n            SubversionRepoUUIDAndRootPath uuidAndRootPath = null;\n            for (Map.Entry<String, UUID> e : remoteUUIDCache.entrySet()) {\n                String remoteRepoRootURL = e.getKey();\n                String remoteRepoRootURLWithSlash = remoteRepoRootURL + \"/\";\n                if (urlFromConfiguration.startsWith(remoteRepoRootURLWithSlash) || urlFromConfiguration.equals(remoteRepoRootURL)) {\n                    UUID uuid = e.getValue();\n                    String rootPath = SVNURL.parseURIDecoded(e.getKey()).getPath();\n                    uuidAndRootPath = new SubversionRepoUUIDAndRootPath(uuid, rootPath);\n\n                    LOGGER.finer(\"Using cached uuid for module location \" + urlFromConfiguration + \" of job \"+ job);\n                    break;\n                }\n            }\n\n            if (uuidAndRootPath == null) {\n                if (LOGGER.isLoggable(FINER)) {\n                    LOGGER.finer(\"Could not find \" + urlFromConfiguration + \" in \" + remoteUUIDCache.keySet());\n                }\n                UUID remoteUUID = moduleLocation.getUUID(job, scm);\n                SVNURL repositoryRoot = moduleLocation.getRepositoryRoot(job, scm);\n                remoteUUIDCache.put(repositoryRoot.toString(), remoteUUID);\n                uuidAndRootPath = new SubversionRepoUUIDAndRootPath(remoteUUID, repositoryRoot.getPath());\n            }\n            return uuidAndRootPath;\n        }\n\n        boolean doModuleLocationHasAPathFromAffectedPath(String configuredRepoFullPath, String rootRepoPath, Set<String> affectedPath) {\n            boolean containsAnAffectedPath = false;\n            if (configuredRepoFullPath.startsWith(rootRepoPath)) {\n                String remainingRepoPath = configuredRepoFullPath.substring(rootRepoPath.length());\n                if (remainingRepoPath.startsWith(\"/\")) remainingRepoPath=remainingRepoPath.substring(1);\n                String remainingRepoPathSlash = remainingRepoPath + '/';\n\n                for (String path : affectedPath) {\n                    if (path.equals(remainingRepoPath)  || \n                            path.startsWith(remainingRepoPathSlash)  ||\n                            remainingRepoPath.length() == 0 ) {\n                        \n                        \n                        containsAnAffectedPath = true;\n                        break;\n                    }\n                }\n            }\n            return containsAnAffectedPath;\n        }\n\n        private void scheduleImediatePollingOfJob(Job job, SCMTrigger trigger, List<SvnInfo> infos) {\n            LOGGER.fine(\"Scheduling the immediate polling of \" + job);\n\n            final RevisionParameterAction[] actions;\n            if (infos.isEmpty()) {\n                actions = new RevisionParameterAction[0];\n            } else {\n                actions = new RevisionParameterAction[] { new RevisionParameterAction(infos) };\n            }\n\n            trigger.run(actions);\n        }\n\n        @Override\n        public boolean onNotify(UUID uuid, long rev, Set<String> affectedPath) {\n            boolean scmFound = false, triggerFound = false, uuidFound = false, pathFound = false;\n            LOGGER.fine(\"Starting subversion locations checks for all jobs\");\n            for (Job p : this.jobProvider.getAllJobs()) {\n                SCMTriggerItem scmTriggerItem = SCMTriggerItem.SCMTriggerItems.asSCMTriggerItem(p);\n                if (scmTriggerItem == null) {\n                    continue;\n                }\n                if (p instanceof AbstractProject && ((AbstractProject) p).isDisabled()) {\n                    continue;\n                }\n                String jobName = p.getName();\n                SCMS: for (SCM scm : scmTriggerItem.getSCMs()) {\n                    if (scm instanceof SubversionSCM) scmFound = true; else continue;\n\n                    SCMTrigger trigger = scmTriggerItem.getSCMTrigger();\n                    if (trigger!=null && !doesIgnorePostCommitHooks(trigger)) triggerFound = true; else continue;\n\n                    SubversionSCM sscm = (SubversionSCM) scm;\n\n                    List<SvnInfo> infos = new ArrayList<SvnInfo>();\n\n                    try {\n                        boolean projectMatches = false;\n                        for (ModuleLocation loc : sscm.getProjectLocations(p)) {\n                            String urlFromConfiguration = loc.getURL();\n                            \n                        \n                            try {\n                                SubversionRepoUUIDAndRootPath uuidAndRootPath = this.remoteUUIDAndRootPathFromCacheOrFromSVN(p, sscm, loc, urlFromConfiguration);\n                                UUID remoteUUID = uuidAndRootPath.uuid;\n                                if (remoteUUID.equals(uuid)) uuidFound = true; else continue;\n\n                                String configuredRepoFullPath = loc.getSVNURL().getPath();\n                                String rootRepoPath = uuidAndRootPath.rootPath;\n                                if (this.doModuleLocationHasAPathFromAffectedPath(configuredRepoFullPath, rootRepoPath, affectedPath)) {\n                                    projectMatches = true;\n                                    pathFound = true;\n                                }\n\n                                if ( rev != -1 ) {\n                                    infos.add(new SvnInfo(loc.getURL(), rev));\n                                }\n                            } catch (SVNCancelException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \"). If you are using svn:externals feature ensure that the credentials of the externals are added on the Additional Credentials field\", e);\n                            } catch (SVNException e) {\n                                LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (was trying to access \" + urlFromConfiguration + \" of job \" + jobName + \")\", e);\n                            }\n                            \n                            if (projectMatches) {\n                                this.scheduleImediatePollingOfJob(p, trigger, infos);\n                                break SCMS;\n                            }\n                        }\n                    } catch(IOException e) {\n                        LOGGER.log(WARNING, \"Failed to handle Subversion commit notification (getting module locations failed for job \" + jobName + \")\", e);\n                    }\n                }\n            }\n            LOGGER.fine(\"Ended subversion locations checks for all jobs\");\n\n            if (!scmFound)          LOGGER.warning(\"No subversion jobs found\");\n            else if (!triggerFound) LOGGER.warning(\"No subversion jobs using SCM polling or all jobs using SCM polling are ignoring post-commit hooks\");\n            else if (!uuidFound)    LOGGER.warning(\"No subversion jobs using repository: \" + uuid);\n            else if (!pathFound)    LOGGER.fine(\"No jobs found matching the modified files\");\n\n            return scmFound;\n        }\n    }\n    \n    private static boolean doesIgnorePostCommitHooks(SCMTrigger trigger) {\n        if (IS_IGNORE_POST_COMMIT_HOOKS_METHOD == null)\n            return false;\n        \n        try {\n            return (Boolean)IS_IGNORE_POST_COMMIT_HOOKS_METHOD.invoke(trigger, (Object[])null);\n        } catch (Exception e) {\n            LOGGER.log(WARNING,\"Failure when calling isIgnorePostCommitHooks\",e);\n            return false;\n        }\n    }\n\n    static {\n        try {\n            IS_IGNORE_POST_COMMIT_HOOKS_METHOD = SCMTrigger.class.getMethod(\"isIgnorePostCommitHooks\", (Class[])null);\n        } catch (Exception e) {\n            \n        }\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(SubversionRepositoryStatus.class.getName());\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 55,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jenkinsci/subversion-plugin/commit/25f6afbb02a5863f363b0a2f664ac717ace743b4",
    "cve_id": "CVE-2018-1000111",
    "cwe_id": "CWE-863",
    "filename": "src/main/java/hudson/scm/SubversionStatus.java",
    "code": "\npackage hudson.scm;\n\nimport hudson.Extension;\nimport hudson.model.AbstractModelObject;\nimport hudson.model.UnprotectedRootAction;\n\nimport java.util.regex.Pattern;\nimport java.util.UUID;\n\n\n@Extension\npublic class SubversionStatus extends AbstractModelObject implements UnprotectedRootAction {\n    public String getDisplayName() {\n        return \"Subversion\";\n    }\n\n    public String getSearchUrl() {\n        return getUrlName();\n    }\n\n    public String getIconFileName() {\n        \n        return null;\n    }\n\n    public String getUrlName() {\n        return \"subversion\";\n    }\n\n    public SubversionRepositoryStatus getDynamic(String uuid) {\n        if(UUID_PATTERN.matcher(uuid).matches())\n            return new SubversionRepositoryStatus(UUID.fromString(uuid));\n        return null;\n    }\n\n    private static final Pattern UUID_PATTERN = Pattern.compile(\"\\\\p{XDigit}{8}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{4}-\\\\p{XDigit}{12}\");\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 56,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/jhy/jsoup/commit/4edb78991f8d0bf87dafde5e01ccd8922065c9b2",
    "cve_id": "CVE-2015-6748",
    "cwe_id": "CWE-79",
    "filename": "src/main/java/org/jsoup/parser/TokeniserState.java",
    "code": "package org.jsoup.parser;\n\nimport java.util.Arrays;\n\n\nenum TokeniserState {\n    Data {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInData);\n                    break;\n                case '<':\n                    t.advanceTransition(TagOpen);\n                    break;\n                case nullChar:\n                    t.error(this); \n                    t.emit(r.consume());\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeData();\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInData {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Data);\n        }\n    },\n    Rcdata {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '&':\n                    t.advanceTransition(CharacterReferenceInRcdata);\n                    break;\n                case '<':\n                    t.advanceTransition(RcdataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('&', '<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    CharacterReferenceInRcdata {\n        void read(Tokeniser t, CharacterReader r) {\n            char[] c = t.consumeCharacterReference(null, false);\n            if (c == null)\n                t.emit('&');\n            else\n                t.emit(c);\n            t.transition(Rcdata);\n        }\n    },\n    Rawtext {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(RawtextLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    ScriptData {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '<':\n                    t.advanceTransition(ScriptDataLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeToAny('<', nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    PLAINTEXT {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.emit(new Token.EOF());\n                    break;\n                default:\n                    String data = r.consumeTo(nullChar);\n                    t.emit(data);\n                    break;\n            }\n        }\n    },\n    TagOpen {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.current()) {\n                case '!':\n                    t.advanceTransition(MarkupDeclarationOpen);\n                    break;\n                case '/':\n                    t.advanceTransition(EndTagOpen);\n                    break;\n                case '?':\n                    t.advanceTransition(BogusComment);\n                    break;\n                default:\n                    if (r.matchesLetter()) {\n                        t.createTagPending(true);\n                        t.transition(TagName);\n                    } else {\n                        t.error(this);\n                        t.emit('<'); \n                        t.transition(Data);\n                    }\n                    break;\n            }\n        }\n    },\n    EndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.emit(\"</\");\n                t.transition(Data);\n            } else if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(TagName);\n            } else if (r.matches('>')) {\n                t.error(this);\n                t.advanceTransition(Data);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment);\n            }\n        }\n    },\n    TagName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            String tagName = r.consumeTagName().toLowerCase();\n            t.tagPending.appendTagName(tagName);\n\n            switch (r.consume()) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar: \n                    t.tagPending.appendTagName(replacementStr);\n                    break;\n                case eof: \n                    t.eofError(this);\n                    t.transition(Data);\n                \n            }\n        }\n    },\n    RcdataLessthanSign {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RCDATAEndTagOpen);\n            } else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n                \n                \n                t.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\n                t.emitTagPending();\n                r.unconsume(); \n                t.transition(Data);\n            } else {\n                t.emit(\"<\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.advanceTransition(RCDATAEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rcdata);\n            }\n        }\n    },\n    RCDATAEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.tagPending.appendTagName(name.toLowerCase());\n                t.dataBuffer.append(name);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(BeforeAttributeName);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '/':\n                    if (t.isAppropriateEndTagToken())\n                        t.transition(SelfClosingStartTag);\n                    else\n                        anythingElse(t, r);\n                    break;\n                case '>':\n                    if (t.isAppropriateEndTagToken()) {\n                        t.emitTagPending();\n                        t.transition(Data);\n                    }\n                    else\n                        anythingElse(t, r);\n                    break;\n                default:\n                    anythingElse(t, r);\n            }\n        }\n\n        private void anythingElse(Tokeniser t, CharacterReader r) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            r.unconsume();\n            t.transition(Rcdata);\n        }\n    },\n    RawtextLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(RawtextEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(RawtextEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(Rawtext);\n            }\n        }\n    },\n    RawtextEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, Rawtext);\n        }\n    },\n    ScriptDataLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            switch (r.consume()) {\n                case '/':\n                    t.createTempBuffer();\n                    t.transition(ScriptDataEndTagOpen);\n                    break;\n                case '!':\n                    t.emit(\"<!\");\n                    t.transition(ScriptDataEscapeStart);\n                    break;\n                default:\n                    t.emit(\"<\");\n                    r.unconsume();\n                    t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.transition(ScriptDataEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptData);\n            }\n\n        }\n    },\n    ScriptDataEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptData);\n        }\n    },\n    ScriptDataEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapeStartDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscapeStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('-')) {\n                t.emit('-');\n                t.advanceTransition(ScriptDataEscapedDashDash);\n            } else {\n                t.transition(ScriptData);\n            }\n        }\n    },\n    ScriptDataEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            switch (r.current()) {\n                case '-':\n                    t.emit('-');\n                    t.advanceTransition(ScriptDataEscapedDash);\n                    break;\n                case '<':\n                    t.advanceTransition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataEscapedDashDash);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.transition(Data);\n                return;\n            }\n\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.transition(ScriptDataEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataEscaped);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTempBuffer();\n                t.dataBuffer.append(Character.toLowerCase(r.current()));\n                t.emit(\"<\" + r.current());\n                t.advanceTransition(ScriptDataDoubleEscapeStart);\n            } else if (r.matches('/')) {\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataEscapedEndTagOpen);\n            } else {\n                t.emit('<');\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createTagPending(false);\n                t.tagPending.appendTagName(Character.toLowerCase(r.current()));\n                t.dataBuffer.append(r.current());\n                t.advanceTransition(ScriptDataEscapedEndTagName);\n            } else {\n                t.emit(\"</\");\n                t.transition(ScriptDataEscaped);\n            }\n        }\n    },\n    ScriptDataEscapedEndTagName {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataEndTag(t, r, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscapeStart {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t, r, ScriptDataDoubleEscaped, ScriptDataEscaped);\n        }\n    },\n    ScriptDataDoubleEscaped {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.advanceTransition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.emit(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    String data = r.consumeToAny('-', '<', nullChar);\n                    t.emit(data);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedDashDash);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedDashDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.emit(c);\n                    break;\n                case '<':\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscapedLessthanSign);\n                    break;\n                case '>':\n                    t.emit(c);\n                    t.transition(ScriptData);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.emit(replacementChar);\n                    t.transition(ScriptDataDoubleEscaped);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.emit(c);\n                    t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapedLessthanSign {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matches('/')) {\n                t.emit('/');\n                t.createTempBuffer();\n                t.advanceTransition(ScriptDataDoubleEscapeEnd);\n            } else {\n                t.transition(ScriptDataDoubleEscaped);\n            }\n        }\n    },\n    ScriptDataDoubleEscapeEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            handleDataDoubleEscapeTag(t,r, ScriptDataEscaped, ScriptDataDoubleEscaped);\n        }\n    },\n    BeforeAttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    AttributeName {\n        \n        void read(Tokeniser t, CharacterReader r) {\n            String name = r.consumeToAnySorted(attributeNameCharsSorted);\n            t.tagPending.appendAttributeName(name.toLowerCase());\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.appendAttributeName(c);\n                \n            }\n        }\n    },\n    AfterAttributeName {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '=':\n                    t.transition(BeforeAttributeValue);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeName(replacementChar);\n                    t.transition(AttributeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                    t.error(this);\n                    t.tagPending.newAttribute();\n                    t.tagPending.appendAttributeName(c);\n                    t.transition(AttributeName);\n                    break;\n                default: \n                    t.tagPending.newAttribute();\n                    r.unconsume();\n                    t.transition(AttributeName);\n            }\n        }\n    },\n    BeforeAttributeValue {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    \n                    break;\n                case '\"':\n                    t.transition(AttributeValue_doubleQuoted);\n                    break;\n                case '&':\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case '\\'':\n                    t.transition(AttributeValue_singleQuoted);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    t.transition(AttributeValue_unquoted);\n                    break;\n                default:\n                    r.unconsume();\n                    t.transition(AttributeValue_unquoted);\n            }\n        }\n    },\n    AttributeValue_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeDoubleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\"', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAnySorted(attributeSingleValueCharsSorted);\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterAttributeValue_quoted);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('\\'', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                \n            }\n        }\n    },\n    AttributeValue_unquoted {\n        void read(Tokeniser t, CharacterReader r) {\n            String value = r.consumeToAny('\\t', '\\n', '\\r', '\\f', ' ', '&', '>', nullChar, '\"', '\\'', '<', '=', '`');\n            if (value.length() > 0)\n                t.tagPending.appendAttributeValue(value);\n\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '&':\n                    char[] ref = t.consumeCharacterReference('>', true);\n                    if (ref != null)\n                        t.tagPending.appendAttributeValue(ref);\n                    else\n                        t.tagPending.appendAttributeValue('&');\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                case '\"':\n                case '\\'':\n                case '<':\n                case '=':\n                case '`':\n                    t.error(this);\n                    t.tagPending.appendAttributeValue(c);\n                    break;\n                \n            }\n\n        }\n    },\n    \n    AfterAttributeValue_quoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    r.unconsume();\n                    t.transition(BeforeAttributeName);\n            }\n\n        }\n    },\n    SelfClosingStartTag {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.tagPending.selfClosing = true;\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeAttributeName);\n            }\n        }\n    },\n    BogusComment {\n        void read(Tokeniser t, CharacterReader r) {\n            \n            \n            r.unconsume();\n            Token.Comment comment = new Token.Comment();\n            comment.bogus = true;\n            comment.data.append(r.consumeTo('>'));\n            \n            t.emit(comment);\n            t.advanceTransition(Data);\n        }\n    },\n    MarkupDeclarationOpen {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchConsume(\"--\")) {\n                t.createCommentPending();\n                t.transition(CommentStart);\n            } else if (r.matchConsumeIgnoreCase(\"DOCTYPE\")) {\n                t.transition(Doctype);\n            } else if (r.matchConsume(\"[CDATA[\")) {\n                \n                \n                \n                t.transition(CdataSection);\n            } else {\n                t.error(this);\n                t.advanceTransition(BogusComment); \n            }\n        }\n    },\n    CommentStart {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentStartDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentStartDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Comment {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.current();\n            switch (c) {\n                case '-':\n                    t.advanceTransition(CommentEndDash);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    r.advance();\n                    t.commentPending.data.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(r.consumeToAny('-', nullChar));\n            }\n        }\n    },\n    CommentEndDash {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.transition(CommentEnd);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append('-').append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append('-').append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEnd {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case '!':\n                    t.error(this);\n                    t.transition(CommentEndBang);\n                    break;\n                case '-':\n                    t.error(this);\n                    t.commentPending.data.append('-');\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.commentPending.data.append(\"--\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    CommentEndBang {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '-':\n                    t.commentPending.data.append(\"--!\");\n                    t.transition(CommentEndDash);\n                    break;\n                case '>':\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.commentPending.data.append(\"--!\").append(replacementChar);\n                    t.transition(Comment);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.emitCommentPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.commentPending.data.append(\"--!\").append(c);\n                    t.transition(Comment);\n            }\n        }\n    },\n    Doctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    \n                case '>': \n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BeforeDoctypeName);\n            }\n        }\n    },\n    BeforeDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                t.createDoctypePending();\n                t.transition(DoctypeName);\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break; \n                case nullChar:\n                    t.error(this);\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(replacementChar);\n                    t.transition(DoctypeName);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.createDoctypePending();\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.createDoctypePending();\n                    t.doctypePending.name.append(c);\n                    t.transition(DoctypeName);\n            }\n        }\n    },\n    DoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.matchesLetter()) {\n                String name = r.consumeLetterSequence();\n                t.doctypePending.name.append(name.toLowerCase());\n                return;\n            }\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(AfterDoctypeName);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.name.append(replacementChar);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.name.append(c);\n            }\n        }\n    },\n    AfterDoctypeName {\n        void read(Tokeniser t, CharacterReader r) {\n            if (r.isEmpty()) {\n                t.eofError(this);\n                t.doctypePending.forceQuirks = true;\n                t.emitDoctypePending();\n                t.transition(Data);\n                return;\n            }\n            if (r.matchesAny('\\t', '\\n', '\\r', '\\f', ' '))\n                r.advance(); \n            else if (r.matches('>')) {\n                t.emitDoctypePending();\n                t.advanceTransition(Data);\n            } else if (r.matchConsumeIgnoreCase(\"PUBLIC\")) {\n                t.transition(AfterDoctypePublicKeyword);\n            } else if (r.matchConsumeIgnoreCase(\"SYSTEM\")) {\n                t.transition(AfterDoctypeSystemKeyword);\n            } else {\n                t.error(this);\n                t.doctypePending.forceQuirks = true;\n                t.advanceTransition(BogusDoctype);\n            }\n\n        }\n    },\n    AfterDoctypePublicKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypePublicIdentifier);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BeforeDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypePublicIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypePublicIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypePublicIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    DoctypePublicIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypePublicIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.publicIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.publicIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypePublicIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BetweenDoctypePublicAndSystemIdentifiers);\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    BetweenDoctypePublicAndSystemIdentifiers {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    AfterDoctypeSystemKeyword {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeDoctypeSystemIdentifier);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case '\"':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    t.error(this);\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n            }\n        }\n    },\n    BeforeDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '\"':\n                    \n                    t.transition(DoctypeSystemIdentifier_doubleQuoted);\n                    break;\n                case '\\'':\n                    \n                    t.transition(DoctypeSystemIdentifier_singleQuoted);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.transition(BogusDoctype);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_doubleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\"':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    DoctypeSystemIdentifier_singleQuoted {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\'':\n                    t.transition(AfterDoctypeSystemIdentifier);\n                    break;\n                case nullChar:\n                    t.error(this);\n                    t.doctypePending.systemIdentifier.append(replacementChar);\n                    break;\n                case '>':\n                    t.error(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.doctypePending.systemIdentifier.append(c);\n            }\n        }\n    },\n    AfterDoctypeSystemIdentifier {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    break;\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.eofError(this);\n                    t.doctypePending.forceQuirks = true;\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.error(this);\n                    t.transition(BogusDoctype);\n                    \n            }\n        }\n    },\n    BogusDoctype {\n        void read(Tokeniser t, CharacterReader r) {\n            char c = r.consume();\n            switch (c) {\n                case '>':\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                case eof:\n                    t.emitDoctypePending();\n                    t.transition(Data);\n                    break;\n                default:\n                    \n                    break;\n            }\n        }\n    },\n    CdataSection {\n        void read(Tokeniser t, CharacterReader r) {\n            String data = r.consumeTo(\"]]>\");\n            t.emit(data);\n            r.matchConsume(\"]]>\");\n            t.transition(Data);\n        }\n    };\n\n\n    abstract void read(Tokeniser t, CharacterReader r);\n\n    static final char nullChar = '\\u0000';\n    private static final char[] attributeSingleValueCharsSorted = new char[]{'\\'', '&', nullChar};\n    private static final char[] attributeDoubleValueCharsSorted = new char[]{'\"', '&', nullChar};\n    private static final char[] attributeNameCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '/', '=', '>', nullChar, '\"', '\\'', '<'};\n\n    private static final char replacementChar = Tokeniser.replacementChar;\n    private static final String replacementStr = String.valueOf(Tokeniser.replacementChar);\n    private static final char eof = CharacterReader.EOF;\n\n    static {\n        Arrays.sort(attributeSingleValueCharsSorted);\n        Arrays.sort(attributeDoubleValueCharsSorted);\n        Arrays.sort(attributeNameCharsSorted);\n    }\n\n    \n    private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.tagPending.appendTagName(name.toLowerCase());\n            t.dataBuffer.append(name);\n            return;\n        }\n\n        boolean needsExitTransition = false;\n        if (t.isAppropriateEndTagToken() && !r.isEmpty()) {\n            char c = r.consume();\n            switch (c) {\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                case '\\f':\n                case ' ':\n                    t.transition(BeforeAttributeName);\n                    break;\n                case '/':\n                    t.transition(SelfClosingStartTag);\n                    break;\n                case '>':\n                    t.emitTagPending();\n                    t.transition(Data);\n                    break;\n                default:\n                    t.dataBuffer.append(c);\n                    needsExitTransition = true;\n            }\n        } else {\n            needsExitTransition = true;\n        }\n\n        if (needsExitTransition) {\n            t.emit(\"</\" + t.dataBuffer.toString());\n            t.transition(elseTransition);\n        }\n    }\n\n    private static void handleDataDoubleEscapeTag(Tokeniser t, CharacterReader r, TokeniserState primary, TokeniserState fallback) {\n        if (r.matchesLetter()) {\n            String name = r.consumeLetterSequence();\n            t.dataBuffer.append(name.toLowerCase());\n            t.emit(name);\n            return;\n        }\n\n        char c = r.consume();\n        switch (c) {\n            case '\\t':\n            case '\\n':\n            case '\\r':\n            case '\\f':\n            case ' ':\n            case '/':\n            case '>':\n                if (t.dataBuffer.toString().equals(\"script\"))\n                    t.transition(primary);\n                else\n                    t.transition(fallback);\n                t.emit(c);\n                break;\n            default:\n                r.unconsume();\n                t.transition(fallback);\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 56,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/jhy/jsoup/commit/4edb78991f8d0bf87dafde5e01ccd8922065c9b2",
    "cve_id": "CVE-2015-6748",
    "cwe_id": "CWE-79",
    "filename": "src/test/java/org/jsoup/parser/XmlTreeBuilderTest.java",
    "code": "package org.jsoup.parser;\n\nimport org.jsoup.Jsoup;\nimport org.jsoup.TextUtil;\nimport org.jsoup.helper.StringUtil;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Node;\nimport org.jsoup.nodes.TextNode;\nimport org.junit.Ignore;\nimport org.junit.Test;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URISyntaxException;\nimport java.util.List;\n\nimport static org.jsoup.nodes.Document.OutputSettings.Syntax;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotSame;\n\n\npublic class XmlTreeBuilderTest {\n    @Test\n    public void testSimpleXmlParse() {\n        String xml = \"<doc id=2 href='/bar'>Foo <br /><link>One</link><link>Two</link></doc>\";\n        XmlTreeBuilder tb = new XmlTreeBuilder();\n        Document doc = tb.parse(xml, \"http://foo.com/\");\n        assertEquals(\"<doc id=\\\"2\\\" href=\\\"/bar\\\">Foo <br /><link>One</link><link>Two</link></doc>\",\n                TextUtil.stripNewlines(doc.html()));\n        assertEquals(doc.getElementById(\"2\").absUrl(\"href\"), \"http://foo.com/bar\");\n    }\n\n    @Test\n    public void testPopToClose() {\n        \n        String xml = \"<doc><val>One<val>Two</val></bar>Three</doc>\";\n        XmlTreeBuilder tb = new XmlTreeBuilder();\n        Document doc = tb.parse(xml, \"http://foo.com/\");\n        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                TextUtil.stripNewlines(doc.html()));\n    }\n\n    @Test\n    public void testCommentAndDocType() {\n        String xml = \"<!DOCTYPE html><!-- a comment -->One <qux />Two\";\n        XmlTreeBuilder tb = new XmlTreeBuilder();\n        Document doc = tb.parse(xml, \"http://foo.com/\");\n        assertEquals(\"<!DOCTYPE html><!-- a comment -->One <qux />Two\",\n                TextUtil.stripNewlines(doc.html()));\n    }\n\n    @Test\n    public void testSupplyParserToJsoupClass() {\n        String xml = \"<doc><val>One<val>Two</val></bar>Three</doc>\";\n        Document doc = Jsoup.parse(xml, \"http://foo.com/\", Parser.xmlParser());\n        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                TextUtil.stripNewlines(doc.html()));\n    }\n\n    @Ignore\n    @Test\n    public void testSupplyParserToConnection() throws IOException {\n        String xmlUrl = \"http://direct.infohound.net/tools/jsoup-xml-test.xml\";\n\n        \n        Document xmlDoc = Jsoup.connect(xmlUrl).parser(Parser.xmlParser()).get();\n        Document htmlDoc = Jsoup.connect(xmlUrl).get();\n\n        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                TextUtil.stripNewlines(xmlDoc.html()));\n        assertNotSame(htmlDoc, xmlDoc);\n        assertEquals(1, htmlDoc.select(\"head\").size()); \n        assertEquals(0, xmlDoc.select(\"head\").size()); \n    }\n\n    @Test\n    public void testSupplyParserToDataStream() throws IOException, URISyntaxException {\n        File xmlFile = new File(XmlTreeBuilder.class.getResource(\"/htmltests/xml-test.xml\").toURI());\n        InputStream inStream = new FileInputStream(xmlFile);\n        Document doc = Jsoup.parse(inStream, null, \"http://foo.com\", Parser.xmlParser());\n        assertEquals(\"<doc><val>One<val>Two</val>Three</val></doc>\",\n                TextUtil.stripNewlines(doc.html()));\n    }\n\n    @Test\n    public void testDoesNotForceSelfClosingKnownTags() {\n        \n        Document htmlDoc = Jsoup.parse(\"<br>one</br>\");\n        assertEquals(\"<br>one\\n<br>\", htmlDoc.body().html());\n\n        Document xmlDoc = Jsoup.parse(\"<br>one</br>\", \"\", Parser.xmlParser());\n        assertEquals(\"<br>one</br>\", xmlDoc.html());\n    }\n\n    @Test public void handlesXmlDeclarationAsDeclaration() {\n        String html = \"<?xml encoding='UTF-8' ?><body>One</body><!-- comment -->\";\n        Document doc = Jsoup.parse(html, \"\", Parser.xmlParser());\n        assertEquals(\"<?xml encoding='UTF-8' ?> <body> One </body> <!-- comment -->\",\n                StringUtil.normaliseWhitespace(doc.outerHtml()));\n        assertEquals(\"#declaration\", doc.childNode(0).nodeName());\n        assertEquals(\"#comment\", doc.childNode(2).nodeName());\n    }\n\n    @Test public void xmlFragment() {\n        String xml = \"<one src='/foo/' />Two<three><four /></three>\";\n        List<Node> nodes = Parser.parseXmlFragment(xml, \"http://example.com/\");\n        assertEquals(3, nodes.size());\n\n        assertEquals(\"http://example.com/foo/\", nodes.get(0).absUrl(\"src\"));\n        assertEquals(\"one\", nodes.get(0).nodeName());\n        assertEquals(\"Two\", ((TextNode)nodes.get(1)).text());\n    }\n\n    @Test public void xmlParseDefaultsToHtmlOutputSyntax() {\n        Document doc = Jsoup.parse(\"x\", \"\", Parser.xmlParser());\n        assertEquals(Syntax.xml, doc.outputSettings().syntax());\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 57,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/nahsra/antisamy/commit/7313931dc3c0d1377b010f07faef2063dd359a36",
    "cve_id": "CVE-2016-10006",
    "cwe_id": "CWE-79",
    "filename": "src/main/java/org/owasp/validator/html/scan/MagicSAXFilter.java",
    "code": "\n\npackage org.owasp.validator.html.scan;\n\nimport java.util.*;\nimport java.util.regex.Pattern;\n\nimport org.apache.xerces.util.AugmentationsImpl;\nimport org.apache.xerces.util.XMLAttributesImpl;\nimport org.apache.xerces.util.XMLStringBuffer;\nimport org.apache.xerces.xni.Augmentations;\nimport org.apache.xerces.xni.QName;\nimport org.apache.xerces.xni.XMLAttributes;\nimport org.apache.xerces.xni.XMLString;\nimport org.apache.xerces.xni.XNIException;\nimport org.apache.xerces.xni.parser.XMLDocumentFilter;\nimport org.cyberneko.html.filters.DefaultFilter;\nimport org.owasp.validator.css.CssScanner;\nimport org.owasp.validator.css.ExternalCssScanner;\nimport org.owasp.validator.html.CleanResults;\nimport org.owasp.validator.html.InternalPolicy;\nimport org.owasp.validator.html.Policy;\nimport org.owasp.validator.html.ScanException;\nimport org.owasp.validator.html.model.Attribute;\nimport org.owasp.validator.html.model.Tag;\nimport org.owasp.validator.html.util.ErrorMessageUtil;\nimport org.owasp.validator.html.util.HTMLEntityEncoder;\n\n\npublic class MagicSAXFilter extends DefaultFilter implements XMLDocumentFilter {\n\n    private static enum Ops {\n        CSS, FILTER, REMOVE, TRUNCATE, KEEP\n    }\n\tprivate final Stack<Ops> operations = new Stack<Ops>();\n\tprivate List<String> errorMessages = new ArrayList<String>();\n\tprivate StringBuffer cssContent = null;\n\tprivate XMLAttributes cssAttributes = null;\n\tprivate CssScanner cssScanner = null;\n\tprivate InternalPolicy policy;\n\tprivate ResourceBundle messages;\n\n\tprivate boolean isNofollowAnchors;\n\tprivate boolean isValidateParamAsEmbed;\n\tprivate boolean inCdata = false;\n    \n    private boolean preserveComments;\n    private int maxInputSize;\n    private boolean externalCssScanner;\n\n    public MagicSAXFilter(ResourceBundle messages) {\n\t\tthis.messages = messages;\n    }\n\n    public void reset(InternalPolicy instance){\n        this.policy = instance;\n        isNofollowAnchors = policy.isNofollowAnchors();\n        isValidateParamAsEmbed = policy.isValidateParamAsEmbed();\n        preserveComments = policy.isPreserveComments();\n        maxInputSize = policy.getMaxInputSize();\n        externalCssScanner = policy.isEmbedStyleSheets();\n        operations.clear();\n        errorMessages.clear();\n        cssContent = null;\n        cssAttributes = null;\n        cssScanner = null;\n        inCdata = false;\n\n    }\n\n\tpublic void characters(XMLString text, Augmentations augs) throws XNIException {\n        \n        Ops topOp = peekTop();\n        \n        if (topOp ==  Ops.REMOVE) {\n\t\t\t\n\t\t} else if (topOp == Ops.CSS) {\n\t\t\t\n\t\t\t\n\t\t\tcssContent.append(text.ch, text.offset, text.length);\n\t\t} else {\n\t\t\t\n\t\t\tif ( inCdata ) {\n\t\t\t\tString encoded = HTMLEntityEncoder.htmlEntityEncode(text.toString());\n                addError(ErrorMessageUtil.ERROR_CDATA_FOUND, new Object[]{encoded});\n\t\t\t}\n\t\t\tsuper.characters(text, augs);\n\t\t}\n\t}\n\n    private static final Pattern conditionalDirectives =\n            Pattern.compile(\"<?!?\\\\[\\\\s*(?:end)?if[^]]*\\\\]>?\");\n\n    public void comment(XMLString text, Augmentations augs) throws XNIException {\n\n\t\tif (preserveComments) {\n\t\t\tString value = text.toString();\n\t\t\t\n\t\t\t\n\t\t\tif (value != null) {\n                value = conditionalDirectives.matcher(value).replaceAll(\"\");\n\t\t\t\tsuper.comment(new XMLString(value.toCharArray(), 0, value.length()), augs);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void doctypeDecl(String root, String publicId, String systemId, Augmentations augs) throws XNIException {\n\t\t\n\t}\n\n\tpublic void emptyElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\tthis.startElement(element, attributes, augs);\n\t\tthis.endElement(element, augs);\n\t}\n\n    private Ops peekTop(){\n         return operations.empty() ? null : operations.peek();\n    }\n\n\tpublic void endElement(QName element, Augmentations augs) throws XNIException {\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp) {\n\t\t\t\n\t\t\toperations.pop();\n\t\t} else if (Ops.FILTER == topOp) {\n\t\t\t\n\t\t\toperations.pop();\n\t\t} else if (Ops.CSS == topOp) {\n\t\t\toperations.pop();\n\t\t\t\n\t\t\tCssScanner cssScanner = makeCssScanner();\n\t\t\ttry {\n\t\t\t\tCleanResults results = cssScanner.scanStyleSheet(cssContent.toString(), maxInputSize);\n\t\t\t\t\n\t\t\t\terrorMessages.addAll(results.getErrorMessages());\n\t\t\t\t\n                \n                if (results.getCleanHTML() == null || results.getCleanHTML().equals(\"\")) {\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\n\t\t\t\t\tsuper.startElement(element, cssAttributes, new AugmentationsImpl());\n\t\t\t\t\t\n\t\t\t\t\tsuper.characters(new XMLStringBuffer(results.getCleanHTML()), new AugmentationsImpl());\n\t\t\t\t\t\n\t\t\t\t\tsuper.endElement(element, augs);\n\t\t\t\t}\n\t\t\t} catch (ScanException e) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_TAG_MALFORMED, new Object[] {\n\t\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(cssContent.toString())\n\t\t\t\t});\n\t\t\t} finally {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tcssContent = null;\n\t\t\t\tcssAttributes = null;\n\t\t\t}\n\t\t} else {\n\t\t\t\n\t\t\toperations.pop();\n\t\t\tsuper.endElement(element, augs);\n\t\t}\n\t}\n\n\tprivate CssScanner makeCssScanner() {\n\t\tif (cssScanner == null) {\n            cssScanner = externalCssScanner ? new ExternalCssScanner(policy, messages) : new CssScanner(policy, messages);\n\t\t}\n\t\treturn cssScanner;\n\t}\n\n\tpublic void processingInstruction(String target, XMLString data, Augmentations augs) throws XNIException {\n\t\t\n\t}\n\t\n\tpublic void startCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = true;\n\t\tsuper.startCDATA(augs);\n\t}\n\t\n\tpublic void endCDATA(Augmentations augs) throws XNIException {\n\t\tinCdata = false;\n\t\tsuper.endCDATA(augs);\n\t}\n\n\tpublic void startElement(QName element, XMLAttributes attributes, Augmentations augs) throws XNIException {\n\t\t\n        String tagNameLowerCase = element.localpart.toLowerCase();\n        Tag tag = policy.getTagByLowercaseName(tagNameLowerCase);\n\n\t\t\n\t\tboolean masqueradingParam = false;\n\t\tString embedName = null;\n\t\tString embedValue = null;\n\t\tif (tag == null && isValidateParamAsEmbed && \"param\".equals(tagNameLowerCase)) {\n\t\t\tTag embedPolicy = policy.getEmbedTag();\n\t\t\tif (embedPolicy != null && embedPolicy.isAction( Policy.ACTION_VALIDATE)) {\n\t\t\t\ttag = embedPolicy;\n\t\t\t\tmasqueradingParam = true;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tembedName = attributes.getValue(\"name\");\n\t\t\t\tembedValue = attributes.getValue(\"value\");\n\t\t\t\tXMLAttributes masqueradingAttrs = new XMLAttributesImpl();\n\t\t\t\tmasqueradingAttrs.addAttribute(makeSimpleQname(embedName), \"CDATA\", embedValue);\n\t\t\t\tattributes = masqueradingAttrs;\n\t\t\t}\n\t\t}\n\n\t\tXMLAttributes validattributes = new XMLAttributesImpl();\n        Ops topOp = peekTop();\n        if (Ops.REMOVE == topOp || Ops.CSS == topOp) {\n\t\t\t\n\t\t\t\n\t\t\tthis.operations.push( Ops.REMOVE);\n\t\t} else if ((tag == null && policy.isEncodeUnknownTag()) || (tag != null && tag.isAction( \"encode\" ))) {\n\t\t\tString name = \"<\" + element.localpart + \">\";\n\t\t\tsuper.characters( new XMLString( name.toCharArray(), 0, name.length() ), augs );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag == null) {\n\t\t\taddError( ErrorMessageUtil.ERROR_TAG_NOT_IN_POLICY,\n                      new Object[]{ HTMLEntityEncoder.htmlEntityEncode( element.localpart ) } );\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"filter\")) {\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_FILTERED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.FILTER);\n\t\t} else if (tag.isAction( \"validate\")) {\n\n\t\t\tboolean isStyle = \"style\".endsWith(element.localpart);\n\n\t\t\tif (isStyle) {\n\t\t\t\tthis.operations.push(Ops.CSS);\n\t\t\t\tcssContent = new StringBuffer();\n\t\t\t\tcssAttributes = attributes;\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tboolean removeTag = false;\n\t\t\t\tboolean filterTag = false;\n\t\t\t\tfor (int i = 0; i < attributes.getLength(); i++) {\n\t\t\t\t\tString name = attributes.getQName(i);\n\t\t\t\t\tString value = attributes.getValue(i);\n\t\t\t\t\tString nameLower = name.toLowerCase();\n\t\t\t\t\tAttribute attribute = tag.getAttributeByName(nameLower);\n\t\t\t\t\tif (attribute == null) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tattribute = policy.getGlobalAttributeByName(nameLower);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (\"style\".equalsIgnoreCase(name)) {\n\t\t\t\t\t\tCssScanner styleScanner = makeCssScanner();\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tCleanResults cr = styleScanner.scanInlineStyle(value, element.localpart, maxInputSize);\n\t\t\t\t\t\t\tattributes.setValue(i, cr.getCleanHTML());\n\t\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(name), \"CDATA\", cr.getCleanHTML());\n\t\t\t\t\t\t\terrorMessages.addAll(cr.getErrorMessages());\n\t\t\t\t\t\t} catch (ScanException e) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_CSS_ATTRIBUTE_MALFORMED, new Object[] {\n\t\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (attribute != null) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tboolean isValid = false;\n                        if (attribute.containsAllowedValue(value.toLowerCase())) {\n                            validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            isValid = true;\n                        }\n\n\n                        if (!isValid) {\n                            isValid = attribute.matchesAllowedExpression(value);\n                            if (isValid) {\n                                validattributes.addAttribute(makeSimpleQname(name), \"CDATA\", value);\n                            }\n                        }\n\n\n                        \n\t\t\t\t\t\t\n\t\t\t\t\t\tif (!isValid && \"removeTag\".equals(attribute.getOnInvalid())) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID_REMOVED,\n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tremoveTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid && (\"filterTag\".equals(attribute.getOnInvalid()) || masqueradingParam)) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_CAUSE_FILTER, \n\t\t\t\t\t\t\t\tnew Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if (!isValid) {\n\t\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_INVALID, new Object[] { tag.getName(), HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value) });\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t} else { \n\t\t\t\t\t\taddError(ErrorMessageUtil.ERROR_ATTRIBUTE_NOT_IN_POLICY, new Object[] {\n\t\t\t\t\t\t\t\telement.localpart, HTMLEntityEncoder.htmlEntityEncode(name), HTMLEntityEncoder.htmlEntityEncode(value)\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\t\tfilterTag = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (removeTag) {\n\t\t\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t\t\t} else if (filterTag) {\n\t\t\t\t\tthis.operations.push(Ops.FILTER);\n\t\t\t\t} else {\n\n\t\t\t\t\tif (isNofollowAnchors && \"a\".equals(element.localpart)) {\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"rel\"), \"CDATA\", \"nofollow\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif (masqueradingParam) {\n\t\t\t\t\t\tvalidattributes = new XMLAttributesImpl();\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"name\"), \"CDATA\", embedName);\n\t\t\t\t\t\tvalidattributes.addAttribute(makeSimpleQname(\"value\"), \"CDATA\", embedValue);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.operations.push(Ops.KEEP);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (tag.isAction( \"truncate\")) {\n\t\t\tthis.operations.push(Ops.TRUNCATE);\n\t\t} else {\n\t\t\t\n\t\t\taddError(ErrorMessageUtil.ERROR_TAG_DISALLOWED, new Object[] {\n\t\t\t\tHTMLEntityEncoder.htmlEntityEncode(element.localpart)\n\t\t\t});\n\t\t\tthis.operations.push(Ops.REMOVE);\n\t\t}\n\t\t\n\t\tif ( Ops.TRUNCATE.equals( operations.peek() )) {\n\t\t\t\n\t\t\tsuper.startElement(element, new XMLAttributesImpl(), augs);\n\t\t} else if ( Ops.KEEP.equals(operations.peek())) {\n\t\t\t\n\t\t\tsuper.startElement(element, validattributes, augs);\n\t\t}\n\t}\n\n\tprivate QName makeSimpleQname(String name) {\n\t\treturn new QName(\"\", name, name, \"\");\n\t}\n\n\tprivate void addError(String errorKey, Object[] objs) {\n\t\terrorMessages.add(ErrorMessageUtil.getMessage(messages, errorKey, objs));\n\t}\n\n\tpublic List<String> getErrorMessages() {\n\t\treturn errorMessages;\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 58,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45bc09c8bd7f17283e2a7e85ce3f02cb4be4fd1a",
    "cve_id": "CVE-2018-1000820",
    "cwe_id": "CWE-611",
    "filename": "src/main/java/apoc/load/Xml.java",
    "code": "package apoc.load;\n\nimport apoc.util.FileUtils;\nimport apoc.result.MapResult;\nimport apoc.result.NodeResult;\nimport apoc.util.Util;\nimport org.apache.commons.lang3.StringUtils;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.graphdb.Label;\nimport org.neo4j.graphdb.RelationshipType;\nimport org.neo4j.logging.Log;\nimport org.neo4j.procedure.*;\nimport org.w3c.dom.CharacterData;\nimport org.w3c.dom.*;\n\nimport javax.xml.namespace.QName;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathExpression;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.*;\nimport java.util.stream.Stream;\n\nimport static apoc.util.Util.cleanUrl;\nimport static javax.xml.stream.XMLStreamConstants.*;\n\npublic class Xml {\n\n    public static final XMLInputFactory FACTORY = XMLInputFactory.newFactory();\n\n    @Context\n    public GraphDatabaseService db;\n\n    @Context\n    public Log log;\n\n    @Procedure\n    @Description(\"apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.\")\n    public Stream<MapResult> xml(@Name(\"url\") String url, @Name(value = \"path\", defaultValue = \"/\") String path, @Name(value = \"config\",defaultValue = \"{}\") Map<String, Object> config, @Name(value = \"simple\", defaultValue = \"false\") boolean simpleMode) throws Exception {\n        return xmlXpathToMapResult(url, simpleMode, path ,config);\n    }\n\n    @Procedure(deprecatedBy = \"apoc.load.xml\")\n    @Deprecated\n    @Description(\"apoc.load.xmlSimple('http://example.com/test.xml') YIELD value as doc CREATE (p:Person) SET p.name = doc.name load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _children fields. This method does intentionally not work with XML mixed content.\")\n    public Stream<MapResult> xmlSimple(@Name(\"url\") String url) throws Exception {\n        return xmlToMapResult(url, true);\n    }\n\n    private Stream<MapResult> xmlXpathToMapResult(@Name(\"url\") String url, boolean simpleMode, String path, Map<String, Object> config) throws Exception {\n        if (config == null) config = Collections.emptyMap();\n        boolean failOnError = (boolean) config.getOrDefault(\"failOnError\", true);\n        List<MapResult> result = new ArrayList<>();\n        try {\n            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n            DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();\n\n            FileUtils.checkReadAllowed(url);\n\n            Map<String, Object> headers = (Map) config.getOrDefault( \"headers\", Collections.emptyMap() );\n\n            Document doc = documentBuilder.parse(Util.openInputStream(url, headers, null));\n            XPathFactory xPathFactory = XPathFactory.newInstance();\n\n            XPath xPath = xPathFactory.newXPath();\n\n            path = StringUtils.isEmpty(path) ? \"/\" : path;\n            XPathExpression xPathExpression = xPath.compile(path);\n            NodeList nodeList = (NodeList) xPathExpression.evaluate(doc, XPathConstants.NODESET);\n\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                final Deque<Map<String, Object>> stack = new LinkedList<>();\n\n                handleNode(stack, nodeList.item(i), simpleMode);\n                for (int index = 0; index < stack.size(); index++) {\n                    result.add(new MapResult(stack.pollFirst()));\n                }\n            }\n        }\n        catch (FileNotFoundException e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new FileNotFoundException(e.getMessage());\n        }\n        catch (Exception e){\n            if(!failOnError)\n                return Stream.of(new MapResult(Collections.emptyMap()));\n            else\n                throw new Exception(e);\n        }\n        return result.stream();\n    }\n\n    private Stream<MapResult> xmlToMapResult(@Name(\"url\") String url, boolean simpleMode) {\n        try {\n            XMLStreamReader reader = getXMLStreamReaderFromUrl(url);\n            final Deque<Map<String, Object>> stack = new LinkedList<>();\n            do {\n                handleXmlEvent(stack, reader, simpleMode);\n            } while (proceedReader(reader));\n\n            return Stream.of(new MapResult(stack.getFirst()));\n        } catch (IOException | XMLStreamException e) {\n            throw new RuntimeException(\"Can't read url \" + cleanUrl(url) + \" as XML\", e);\n        }\n    }\n\n    private XMLStreamReader getXMLStreamReaderFromUrl(String url) throws IOException, XMLStreamException {\n        FileUtils.checkReadAllowed(url);\n        URLConnection urlConnection = new URL(url).openConnection();\n        FACTORY.setProperty(XMLInputFactory.IS_COALESCING, true);\n        return FACTORY.createXMLStreamReader(urlConnection.getInputStream());\n    }\n\n\n    private boolean proceedReader(XMLStreamReader reader) throws XMLStreamException {\n        if (reader.hasNext()) {\n            do {\n                reader.next();\n            } while (reader.isWhiteSpace());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private void handleXmlEvent(Deque<Map<String, Object>> stack, XMLStreamReader reader, boolean simpleMode) throws XMLStreamException {\n\n        Map<String, Object> elementMap;\n        switch (reader.getEventType()) {\n            case START_DOCUMENT:\n            case END_DOCUMENT:\n                \n                break;\n            case START_ELEMENT:\n                int attributes = reader.getAttributeCount();\n                elementMap = new LinkedHashMap<>(attributes + 3);\n                elementMap.put(\"_type\", reader.getLocalName());\n                for (int a = 0; a < attributes; a++) {\n                    elementMap.put(reader.getAttributeLocalName(a), reader.getAttributeValue(a));\n                }\n                if (!stack.isEmpty()) {\n                    final Map<String, Object> last = stack.getLast();\n                    String key = simpleMode ? \"_\" + reader.getLocalName() : \"_children\";\n                    amendToList(last, key, elementMap);\n                }\n                stack.addLast(elementMap);\n                break;\n\n            case END_ELEMENT:\n                elementMap = stack.size() > 1 ? stack.removeLast() : stack.getLast();\n\n                \n                \n                Object children = elementMap.get(\"_children\");\n                if (children != null) {\n                    if ((children instanceof String) || collectionIsAllStrings(children)) {\n                        elementMap.put(\"_text\", children);\n                        elementMap.remove(\"_children\");\n                    }\n                }\n                break;\n\n            case CHARACTERS:\n                final String text = reader.getText().trim();\n                if (!text.isEmpty()) {\n                    Map<String, Object> map = stack.getLast();\n                    amendToList(map, \"_children\", text);\n                }\n                break;\n            default:\n                throw new RuntimeException(\"dunno know how to handle xml event type \" + reader.getEventType());\n        }\n    }\n\n    private void handleNode(Deque<Map<String, Object>> stack, Node node, boolean simpleMode) {\n\n        \n        if (node.getNodeType() == Node.DOCUMENT_NODE) {\n            NodeList children = node.getChildNodes();\n            for (int i = 0; i < children.getLength(); i++) {\n                if (children.item(i).getLocalName() != null) {\n                    handleNode(stack, children.item(i), simpleMode);\n                    return;\n                }\n            }\n        }\n\n        Map<String, Object> elementMap = new LinkedHashMap<>();\n        handleTypeAndAttributes(node, elementMap);\n\n        \n        NodeList children = node.getChildNodes();\n        int count = 0;\n        for (int i = 0; i < children.getLength(); i++) {\n            Node child = children.item(i);\n\n            \n            if (child.getNodeType() != Node.TEXT_NODE && child.getNodeType() != Node.CDATA_SECTION_NODE) {\n                handleNode(stack, child, simpleMode);\n                count++;\n            } else {\n                \n                handleTextNode(child, elementMap);\n            }\n        }\n\n        if (children.getLength() > 1) {\n            if (!stack.isEmpty()) {\n                List<Object> nodeChildren = new ArrayList<>();\n                for (int i = 0; i < count; i++) {\n                    nodeChildren.add(stack.pollLast());\n                }\n                String key = simpleMode ? \"_\" + node.getLocalName() : \"_children\";\n                Collections.reverse(nodeChildren);\n                if (nodeChildren.size() > 0) {\n                    \n                    Object text = elementMap.get(\"_text\");\n                    if (text instanceof List) {\n                        for (Object element : (List) text) {\n                            nodeChildren.add(element);\n                        }\n                        elementMap.remove(\"_text\");\n                    }\n\n                    elementMap.put(key, nodeChildren);\n                }\n            }\n        }\n\n        if (!elementMap.isEmpty()) {\n            stack.addLast(elementMap);\n        }\n    }\n\n    \n    private void handleTypeAndAttributes(Node node, Map<String, Object> elementMap) {\n        \n        if (node.getLocalName() != null) {\n            elementMap.put(\"_type\", node.getLocalName());\n        }\n\n        \n        if (node.getAttributes() != null) {\n            NamedNodeMap attributeMap = node.getAttributes();\n            for (int i = 0; i < attributeMap.getLength(); i++) {\n                Node attribute = attributeMap.item(i);\n                elementMap.put(attribute.getNodeName(), attribute.getNodeValue());\n            }\n        }\n    }\n\n    \n    private void handleTextNode(Node node, Map<String, Object> elementMap) {\n        Object text = \"\";\n        int nodeType = node.getNodeType();\n        switch (nodeType) {\n            case Node.TEXT_NODE:\n                text = normalizeText(node.getNodeValue());\n                break;\n            case Node.CDATA_SECTION_NODE:\n                text = normalizeText(((CharacterData) node).getData());\n                break;\n            default:\n                break;\n        }\n\n        \n        if (!StringUtils.isEmpty(text.toString())) {\n            \n            Object previousText = elementMap.get(\"_text\");\n            if (previousText != null) {\n                \n                text = Arrays.asList(previousText.toString(), text);\n            }\n            elementMap.put(\"_text\", text);\n        }\n    }\n\n    \n    private String normalizeText(String text) {\n        String[] tokens = StringUtils.split(text, \"\\n\");\n        for (int i = 0; i < tokens.length; i++) {\n            tokens[i] = tokens[i].trim();\n        }\n\n        return StringUtils.join(tokens, \" \").trim();\n    }\n\n    private boolean collectionIsAllStrings(Object collection) {\n        if (collection instanceof Collection) {\n            return ((Collection<Object>) collection).stream().allMatch(o -> o instanceof String);\n        } else {\n            return false;\n        }\n    }\n\n    private void amendToList(Map<String, Object> map, String key, Object value) {\n        final Object element = map.get(key);\n        if (element == null) {\n            map.put(key, value);\n        } else {\n            if (element instanceof List) {\n                ((List) element).add(value);\n            } else {\n                List<Object> list = new LinkedList<>();\n                list.add(element);\n                list.add(value);\n                map.put(key, list);\n            }\n        }\n    }\n\n    public static class ParentAndChildPair {\n        private org.neo4j.graphdb.Node parent;\n        private org.neo4j.graphdb.Node previousChild=null;\n\n        public ParentAndChildPair(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getParent() {\n            return parent;\n        }\n\n        public void setParent(org.neo4j.graphdb.Node parent) {\n            this.parent = parent;\n        }\n\n        public org.neo4j.graphdb.Node getPreviousChild() {\n            return previousChild;\n        }\n\n        public void setPreviousChild(org.neo4j.graphdb.Node previousChild) {\n            this.previousChild = previousChild;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            ParentAndChildPair that = (ParentAndChildPair) o;\n            return parent.equals(that.parent);\n        }\n\n        @Override\n        public int hashCode() {\n            return parent.hashCode();\n        }\n    }\n\n    private static class XmlImportConfig {\n\n        private boolean createNextWordRelationship = false;\n\n        public boolean isCreateNextWordRelationship() {\n            return createNextWordRelationship;\n        }\n\n        public XmlImportConfig(Map<String,Object> config) {\n            Boolean _createNextWordRelationship = (Boolean) config.get(\"createNextWordRelationships\");\n            if (_createNextWordRelationship!=null) {\n                createNextWordRelationship = _createNextWordRelationship;\n            }\n        }\n\n    }\n\n    @Procedure(mode = Mode.WRITE, value = \"apoc.xml.import\")\n    public Stream<NodeResult> importToGraph(@Name(\"url\") String url, @Name(value=\"config\", defaultValue = \"{}\") Map<String, Object> config) throws IOException, XMLStreamException {\n        final XMLStreamReader xml = getXMLStreamReaderFromUrl(url);\n\n        XmlImportConfig importConfig = new XmlImportConfig(config);\n        \n\n        \n        Deque<ParentAndChildPair> parents = new ArrayDeque<>();\n        org.neo4j.graphdb.Node root = db.createNode(Label.label(\"XmlDocument\"));\n        setPropertyIfNotNull(root, \"_xmlVersion\", xml.getVersion());\n        setPropertyIfNotNull(root, \"_xmlEncoding\", xml.getEncoding());\n        root.setProperty(\"url\", url);\n        parents.push(new ParentAndChildPair(root));\n        org.neo4j.graphdb.Node last = root;\n        org.neo4j.graphdb.Node lastWord = root;\n\n        while (xml.hasNext()) {\n            xml.next();\n\n            switch (xml.getEventType()) {\n                case XMLStreamConstants.START_DOCUMENT:\n                    \n                    break;\n\n                case XMLStreamConstants.PROCESSING_INSTRUCTION:\n                    org.neo4j.graphdb.Node pi = db.createNode(Label.label(\"XmlProcessingInstruction\"));\n                    pi.setProperty(\"_piData\", xml.getPIData());\n                    pi.setProperty(\"_piTarget\", xml.getPITarget());\n                    last = connectWithParent(pi, parents.peek(), last);\n                    break;\n\n                case XMLStreamConstants.START_ELEMENT:\n                    final QName qName = xml.getName();\n                    final org.neo4j.graphdb.Node tag = db.createNode(Label.label(\"XmlTag\"));\n                    tag.setProperty(\"_name\", qName.getLocalPart());\n                    for (int i=0; i<xml.getAttributeCount(); i++) {\n                        tag.setProperty(xml.getAttributeLocalName(i), xml.getAttributeValue(i));\n                    }\n\n                    last = connectWithParent(tag, parents.peek(), last);\n                    parents.push(new ParentAndChildPair(tag));\n                    break;\n\n                case XMLStreamConstants.CHARACTERS:\n                    String text = xml.getText().trim();\n                    String[] words = text.split(\"\\\\s\");\n                    for (int i = 0; i < words.length; i++) {\n                        final String currentWord = words[i];\n                        if (!currentWord.isEmpty()) {\n                            org.neo4j.graphdb.Node word = db.createNode(Label.label(\"XmlWord\"));\n                            word.setProperty(\"text\", currentWord);\n                            last = connectWithParent(word, parents.peek(), last);\n                            if (importConfig.isCreateNextWordRelationship()) {\n                                lastWord.createRelationshipTo(word, RelationshipType.withName(\"NEXT_WORD\"));\n                                lastWord = word;\n                            }\n                        }\n                    }\n                    break;\n\n                case XMLStreamConstants.END_ELEMENT:\n                    ParentAndChildPair parent = parents.pop();\n                    if (parent.getPreviousChild()!=null) {\n                        parent.getPreviousChild().createRelationshipTo(parent.getParent(), RelationshipType.withName(\"LAST_CHILD_OF\"));\n                    }\n                    break;\n\n                case XMLStreamConstants.END_DOCUMENT:\n                    parents.pop();\n                    break;\n\n                case XMLStreamConstants.COMMENT:\n                case XMLStreamConstants.SPACE:\n                    \n                    break;\n                default:\n                    log.warn(\"xml file contains a {} type structure - ignoring this.\", xml.getEventType());\n            }\n\n        }\n        if (!parents.isEmpty()) {\n            throw new IllegalStateException(\"non empty parents\");\n        }\n        return Stream.of(new NodeResult(root));\n    }\n\n    private void setPropertyIfNotNull(org.neo4j.graphdb.Node root, String propertyKey, Object value) {\n        if (value!=null) {\n            root.setProperty(propertyKey, value);\n        }\n    }\n\n    private org.neo4j.graphdb.Node connectWithParent(org.neo4j.graphdb.Node thisNode, ParentAndChildPair parentAndChildPair, org.neo4j.graphdb.Node last) {\n        final org.neo4j.graphdb.Node parent = parentAndChildPair.getParent();\n        final org.neo4j.graphdb.Node previousChild = parentAndChildPair.getPreviousChild();\n\n        last.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT\"));\n        thisNode.createRelationshipTo(parent, RelationshipType.withName(\"IS_CHILD_OF\"));\n        if (previousChild ==null) {\n            thisNode.createRelationshipTo(parent, RelationshipType.withName(\"FIRST_CHILD_OF\"));\n        } else {\n            previousChild.createRelationshipTo(thisNode, RelationshipType.withName(\"NEXT_SIBLING\"));\n        }\n        parentAndChildPair.setPreviousChild(thisNode);\n        last = thisNode;\n        return last;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 58,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45bc09c8bd7f17283e2a7e85ce3f02cb4be4fd1a",
    "cve_id": "CVE-2018-1000820",
    "cwe_id": "CWE-611",
    "filename": "src/test/java/apoc/load/XmlTest.java",
    "code": "package apoc.load;\n\nimport apoc.util.TestUtil;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.neo4j.graphdb.GraphDatabaseService;\nimport org.neo4j.helpers.collection.Iterators;\nimport org.neo4j.test.TestGraphDatabaseFactory;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\nimport static apoc.util.TestUtil.testCall;\nimport static apoc.util.TestUtil.testCallEmpty;\nimport static apoc.util.TestUtil.testResult;\nimport static apoc.util.Util.map;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\n\npublic class XmlTest {\n\n    public static final String XML_AS_NESTED_MAP =\n            \"{_type=parent, name=databases, \" +\n                    \"_children=[\" +\n                    \"{_type=child, name=Neo4j, _text=Neo4j is a graph database}, \" +\n                    \"{_type=child, name=relational, _children=[\" +\n                    \"{_type=grandchild, name=MySQL, _text=MySQL is a database & relational}, \" +\n                    \"{_type=grandchild, name=Postgres, _text=Postgres is a relational database}]}]}\";\n    public static final String XML_AS_NESTED_SIMPLE_MAP =\n            \"{_type=parent, name=databases, \" +\n                    \"_child=[\" +\n                    \"{_type=child, name=Neo4j, _text=Neo4j is a graph database}, \" +\n                    \"{_type=child, name=relational, _grandchild=[\" +\n                    \"{_type=grandchild, name=MySQL, _text=MySQL is a database & relational}, \" +\n                    \"{_type=grandchild, name=Postgres, _text=Postgres is a relational database}]}]}\";\n    public static final String XML_XPATH_AS_NESTED_MAP =\n            \"[{_type=book, id=bk103, _children=[{_type=author, _text=Corets, Eva}, {_type=title, _text=Maeve Ascendant}, {_type=genre, _text=Fantasy}, {_type=price, _text=5.95}, {_type=publish_date, _text=2000-11-17}, {_type=description, _text=After the collapse of a nanotechnology \" +\n                    \"society in England, the young survivors lay the \" +\n                    \"foundation for a new society.}]}]\";\n    private GraphDatabaseService db;\n\n    @Before\n    public void setUp() throws Exception {\n        db = new TestGraphDatabaseFactory().newImpermanentDatabaseBuilder().setConfig(\"apoc.import.file.enabled\", \"true\").newGraphDatabase();\n        TestUtil.registerProcedure(db, Xml.class);\n    }\n\n    @After\n    public void tearDown() {\n        db.shutdown();\n    }\n\n    @Test\n    public void testLoadXml() throws Exception {\n        testCall(db, \"CALL apoc.load.xml('file:databases.xml')\", \n                (row) -> {\n                    Object value = row.get(\"value\");\n                    assertEquals(XML_AS_NESTED_MAP, value.toString());\n                });\n    }\n\n    @Test\n    public void testLoadXmlSimple() throws Exception {\n        testCall(db, \"CALL apoc.load.xmlSimple('file:databases.xml')\", \n                (row) -> {\n                    Object value = row.get(\"value\");\n                    assertEquals(XML_AS_NESTED_SIMPLE_MAP, value.toString());\n                });\n    }\n\n    @Test\n    public void testMixedContent() {\n        testCall(db, \"CALL apoc.load.xml('file:src/test/resources/xml/mixedcontent.xml')\", \n                (row) -> {\n                    Object value = row.get(\"value\");\n                    \n                    assertEquals(\"{_type=root, _children=[{_type=text, _children=[{_type=mixed}, text0, text1]}, {_type=text, _text=text as cdata}]}\", value.toString());\n\n                });\n    }\n\n    @Test\n    public void testBookIds() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testFilterIntoCollection() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/xml/books.xml') yield value as catalog\\n\" +\n                        \"    UNWIND catalog._children as book\\n\" +\n                        \"    RETURN book.id, [attr IN book._children WHERE attr._type IN ['author','title'] | [attr._type, attr._text]] as pairs\"\n                , result -> {\n                    assertEquals(\"+----------------------------------------------------------------------------------------------------------------+\\n\" +\n                            \"| book.id | pairs                                                                                                |\\n\" +\n                            \"+----------------------------------------------------------------------------------------------------------------+\\n\" +\n                            \"| \\\"bk101\\\" | [[\\\"author\\\",\\\"Gambardella, Matthew\\\"],[\\\"author\\\",\\\"Arciniegas, Fabio\\\"],[\\\"title\\\",\\\"XML Developer's Guide\\\"]] |\\n\" +\n                            \"| \\\"bk102\\\" | [[\\\"author\\\",\\\"Ralls, Kim\\\"],[\\\"title\\\",\\\"Midnight Rain\\\"]]                                                  |\\n\" +\n                            \"| \\\"bk103\\\" | [[\\\"author\\\",\\\"Corets, Eva\\\"],[\\\"title\\\",\\\"Maeve Ascendant\\\"]]                                               |\\n\" +\n                            \"| \\\"bk104\\\" | [[\\\"author\\\",\\\"Corets, Eva\\\"],[\\\"title\\\",\\\"Oberon's Legacy\\\"]]                                               |\\n\" +\n                            \"| \\\"bk105\\\" | [[\\\"author\\\",\\\"Corets, Eva\\\"],[\\\"title\\\",\\\"The Sundered Grail\\\"]]                                            |\\n\" +\n                            \"| \\\"bk106\\\" | [[\\\"author\\\",\\\"Randall, Cynthia\\\"],[\\\"title\\\",\\\"Lover Birds\\\"]]                                              |\\n\" +\n                            \"| \\\"bk107\\\" | [[\\\"author\\\",\\\"Thurman, Paula\\\"],[\\\"title\\\",\\\"Splish Splash\\\"]]                                              |\\n\" +\n                            \"| \\\"bk108\\\" | [[\\\"author\\\",\\\"Knorr, Stefan\\\"],[\\\"title\\\",\\\"Creepy Crawlies\\\"]]                                             |\\n\" +\n                            \"| \\\"bk109\\\" | [[\\\"author\\\",\\\"Kress, Peter\\\"],[\\\"title\\\",\\\"Paradox Lost\\\"]]                                                 |\\n\" +\n                            \"| \\\"bk110\\\" | [[\\\"author\\\",\\\"O'Brien, Tim\\\"],[\\\"title\\\",\\\"Microsoft .NET: The Programming Bible\\\"]]                        |\\n\" +\n                            \"| \\\"bk111\\\" | [[\\\"author\\\",\\\"O'Brien, Tim\\\"],[\\\"title\\\",\\\"MSXML3: A Comprehensive Guide\\\"]]                                |\\n\" +\n                            \"| \\\"bk112\\\" | [[\\\"author\\\",\\\"Galos, Mike\\\"],[\\\"title\\\",\\\"Visual Studio 7: A Comprehensive Guide\\\"]]                        |\\n\" +\n                            \"+----------------------------------------------------------------------------------------------------------------+\\n\" +\n                            \"12 rows\\n\", result.resultAsString());\n                });\n    }\n\n    @Test\n    public void testReturnCollectionElements() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/xml/books.xml') yield value as catalog\\n\"+\n                        \"UNWIND catalog._children as book\\n\" +\n                        \"WITH book.id as id, [attr IN book._children WHERE attr._type IN ['author','title'] | attr._text] as pairs\\n\" +\n                        \"RETURN id, pairs[0] as author, pairs[1] as title\"\n                , result -> {\n                    assertEquals(\"+-----------------------------------------------------------------------------+\\n\" +\n                            \"| id      | author                 | title                                    |\\n\" +\n                            \"+-----------------------------------------------------------------------------+\\n\" +\n                            \"| \\\"bk101\\\" | \\\"Gambardella, Matthew\\\" | \\\"Arciniegas, Fabio\\\"                      |\\n\" +\n                            \"| \\\"bk102\\\" | \\\"Ralls, Kim\\\"           | \\\"Midnight Rain\\\"                          |\\n\" +\n                            \"| \\\"bk103\\\" | \\\"Corets, Eva\\\"          | \\\"Maeve Ascendant\\\"                        |\\n\" +\n                            \"| \\\"bk104\\\" | \\\"Corets, Eva\\\"          | \\\"Oberon's Legacy\\\"                        |\\n\" +\n                            \"| \\\"bk105\\\" | \\\"Corets, Eva\\\"          | \\\"The Sundered Grail\\\"                     |\\n\" +\n                            \"| \\\"bk106\\\" | \\\"Randall, Cynthia\\\"     | \\\"Lover Birds\\\"                            |\\n\" +\n                            \"| \\\"bk107\\\" | \\\"Thurman, Paula\\\"       | \\\"Splish Splash\\\"                          |\\n\" +\n                            \"| \\\"bk108\\\" | \\\"Knorr, Stefan\\\"        | \\\"Creepy Crawlies\\\"                        |\\n\" +\n                            \"| \\\"bk109\\\" | \\\"Kress, Peter\\\"         | \\\"Paradox Lost\\\"                           |\\n\" +\n                            \"| \\\"bk110\\\" | \\\"O'Brien, Tim\\\"         | \\\"Microsoft .NET: The Programming Bible\\\"  |\\n\" +\n                            \"| \\\"bk111\\\" | \\\"O'Brien, Tim\\\"         | \\\"MSXML3: A Comprehensive Guide\\\"          |\\n\" +\n                            \"| \\\"bk112\\\" | \\\"Galos, Mike\\\"          | \\\"Visual Studio 7: A Comprehensive Guide\\\" |\\n\" +\n                            \"+-----------------------------------------------------------------------------+\\n\" +\n                            \"12 rows\\n\", result.resultAsString());\n                });\n    }\n\n    @Test\n    public void testLoadXmlXpathAuthorFromBookId () {\n        testCall(db, \"CALL apoc.load.xml('file:src/test/resources/xml/books.xml', '/catalog/book[@id=\\\"bk102\\\"]/author') yield value as result\",\n                (r) -> {\n                    assertEquals(\"author\", ((Map) r.get(\"result\")).get(\"_type\"));\n                    assertEquals(\"Ralls, Kim\", ((Map) r.get(\"result\")).get(\"_text\"));\n                });\n    }\n\n    @Test\n    public void testLoadXmlXpathGenreFromBookTitle () {\n        testCall(db, \"CALL apoc.load.xml('file:src/test/resources/xml/books.xml', '/catalog/book[title=\\\"Maeve Ascendant\\\"]/genre') yield value as result\",\n                (r) -> {\n                    assertEquals(\"genre\", ((Map) r.get(\"result\")).get(\"_type\"));\n                    assertEquals(\"Fantasy\", ((Map) r.get(\"result\")).get(\"_text\"));\n                });\n    }\n\n    @Test\n    public void testLoadXmlXpathReturnBookFromBookTitle () {\n        testCall(db, \"CALL apoc.load.xml('file:src/test/resources/xml/books.xml', '/catalog/book[title=\\\"Maeve Ascendant\\\"]/.') yield value as result\",\n                (r) -> {\n                    Object value = r.values();\n                    assertEquals(XML_XPATH_AS_NESTED_MAP, value.toString());\n                });\n    }\n\n    @Test\n    public void testLoadXmlXpathBooKsFromGenre () {\n            testResult(db, \"CALL apoc.load.xml('file:src/test/resources/xml/books.xml', '/catalog/book[genre=\\\"Computer\\\"]') yield value as result\",\n                (r) -> {\n                    Map<String, Object> next = r.next();\n                    Object result = next.get(\"result\");\n                    Map resultMap = (Map) next.get(\"result\");\n                    Object children = resultMap.get(\"_children\");\n\n                    List<Object>  childrenList = (List<Object>) children;\n                    assertEquals(\"bk101\", ((Map) result).get(\"id\"));\n                    assertEquals(\"author\", ((Map) childrenList.get(0)).get(\"_type\"));\n                    assertEquals(\"Gambardella, Matthew\", ((Map) childrenList.get(0)).get(\"_text\"));\n                    assertEquals(\"author\", ((Map) childrenList.get(1)).get(\"_type\"));\n                    assertEquals(\"Arciniegas, Fabio\", ((Map) childrenList.get(1)).get(\"_text\"));\n                    next = r.next();\n                    result = next.get(\"result\");\n                    resultMap = (Map) next.get(\"result\");\n                    children = resultMap.get(\"_children\");\n                    childrenList = (List<Object>) children;\n                    assertEquals(\"bk110\", ((Map) result).get(\"id\"));\n                    assertEquals(\"author\", ((Map) childrenList.get(0)).get(\"_type\"));\n                    assertEquals(\"O'Brien, Tim\", ((Map) childrenList.get(0)).get(\"_text\"));\n                    assertEquals(\"title\", ((Map) childrenList.get(1)).get(\"_type\"));\n                    assertEquals(\"Microsoft .NET: The Programming Bible\", ((Map) childrenList.get(1)).get(\"_text\"));\n                    next = r.next();\n                    result = next.get(\"result\");\n                    resultMap = (Map) next.get(\"result\");\n                    children = resultMap.get(\"_children\");\n                    childrenList = (List<Object>) children;\n                    assertEquals(\"bk111\", ((Map) result).get(\"id\"));\n                    assertEquals(\"author\", ((Map) childrenList.get(0)).get(\"_type\"));\n                    assertEquals(\"O'Brien, Tim\", ((Map) childrenList.get(0)).get(\"_text\"));\n                    assertEquals(\"title\", ((Map) childrenList.get(1)).get(\"_type\"));\n                    assertEquals(\"MSXML3: A Comprehensive Guide\", ((Map) childrenList.get(1)).get(\"_text\"));\n                    next = r.next();\n                    result = next.get(\"result\");\n                    resultMap = (Map) next.get(\"result\");\n                    children = resultMap.get(\"_children\");\n                    childrenList = (List<Object>) children;\n                    assertEquals(\"bk112\", ((Map) result).get(\"id\"));\n                    assertEquals(\"author\", ((Map) childrenList.get(0)).get(\"_type\"));\n                    assertEquals(\"Galos, Mike\", ((Map) childrenList.get(0)).get(\"_text\"));\n                    assertEquals(\"title\", ((Map) childrenList.get(1)).get(\"_type\"));\n                    assertEquals(\"Visual Studio 7: A Comprehensive Guide\", ((Map) childrenList.get(1)).get(\"_text\"));\n                    assertEquals(false, r.hasNext());\n                });\n    }\n\n    @Test\n    public void testLoadXmlNoFailOnError () {\n        testCall(db, \"CALL apoc.load.xml('file:src/test/resources/books.xm', '', {failOnError:false}) yield value as result\",\n                (r) -> {\n                    Map resultMap = (Map) r.get(\"result\");\n                    assertEquals(Collections.emptyMap(), resultMap);\n                });\n    }\n\n    @Test\n    public void testLoadXmlWithImport() {\n        testCall(db, \"call apoc.xml.import('file:src/test/resources/xml/humboldt_soemmering01_1791.TEI-P5.xml', {createNextWordRelationships: true}) yield node\",\n                row -> {\n                   assertNotNull(row.get(\"node\"));\n                });\n        testResult(db, \"match (n) return labels(n)[0] as label, count(*) as count\", result -> {\n            final Map<String, Long> resultMap = result.stream().collect(Collectors.toMap(o -> (String)o.get(\"label\"), o -> (Long)o.get(\"count\")));\n            assertEquals(2l, (long)resultMap.get(\"XmlProcessingInstruction\"));\n            assertEquals(1l, (long)resultMap.get(\"XmlDocument\"));\n            assertEquals(1737l, (long)resultMap.get(\"XmlWord\"));\n            assertEquals(454l, (long)resultMap.get(\"XmlTag\"));\n        });\n\n        \n        testCallEmpty(db, \"match (n) where size( (n)-[:NEXT]->() ) > 1 return n\", null);\n        testCallEmpty(db, \"match (n) where size( (n)-[:NEXT_SIBLING]->() ) > 1 return n\", null);\n\n        \n        testCallEmpty(db, \"match (n) where size( (n)<-[:FIRST_CHILD_OF]-() ) > 1 return n\", null);\n        testCallEmpty(db, \"match (n) where size( (n)<-[:LAST_CHILD_OF]-() ) > 1 return n\", null);\n\n        \n        testResult(db, \"match p=(:XmlDocument)-[:NEXT_WORD*]->(e:XmlWord) where not (e)-[:NEXT_WORD]->() return length(p) as len\",\n                result -> {\n                    Map<String, Object> r = Iterators.single(result);\n                    assertEquals(1737l, r.get(\"len\"));\n                });\n\n    }\n\n    @Test\n    public void testLoadXmlFromZip() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/testload.zip!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTar() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/testload.tar!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTarGz() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/testload.tar.gz!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTgz() {\n        testResult(db, \"call apoc.load.xml('file:src/test/resources/testload.tgz!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromZipByUrl() {\n        testResult(db, \"call apoc.load.xml('https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/3.4/src/test/resources/testload.zip?raw=true!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTarByUrl() {\n        testResult(db, \"call apoc.load.xml('https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/3.4/src/test/resources/testload.tar?raw=true!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTarGzByUrl() {\n        testResult(db, \"call apoc.load.xml('https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/3.4/src/test/resources/testload.tar.gz?raw=true!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n\n    @Test\n    public void testLoadXmlFromTgzByUrl() {\n        testResult(db, \"call apoc.load.xml('https://github.com/neo4j-contrib/neo4j-apoc-procedures/blob/3.4/src/test/resources/testload.tgz?raw=true!xml/books.xml') yield value as catalog\\n\" +\n                \"UNWIND catalog._children as book\\n\" +\n                \"RETURN book.id as id\\n\", result -> {\n            List<Object> ids = Iterators.asList(result.columnAs(\"id\"));\n            assertTrue(IntStream.rangeClosed(1,12).allMatch(value -> ids.contains(String.format(\"bk1%02d\",value))));\n        });\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 59,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/neo4j/neo4j/commit/46de5d01ae2741ffe04c36270fc62c6d490f65c9",
    "cve_id": "CVE-2018-18389",
    "cwe_id": "CWE-287",
    "filename": "enterprise/security/src/main/java/org/neo4j/server/security/enterprise/auth/LdapRealm.java",
    "code": "\npackage org.neo4j.server.security.enterprise.auth;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.credential.AllowAllCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationException;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport org.apache.shiro.realm.ldap.DefaultLdapRealm;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapContextFactory;\nimport org.apache.shiro.realm.ldap.LdapUtils;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.io.IOException;\nimport java.net.ConnectException;\nimport java.net.SocketTimeoutException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Hashtable;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport javax.naming.AuthenticationException;\nimport javax.naming.CommunicationException;\nimport javax.naming.Context;\nimport javax.naming.NamingEnumeration;\nimport javax.naming.NamingException;\nimport javax.naming.directory.Attribute;\nimport javax.naming.directory.Attributes;\nimport javax.naming.directory.SearchControls;\nimport javax.naming.directory.SearchResult;\nimport javax.naming.ldap.InitialLdapContext;\nimport javax.naming.ldap.LdapContext;\nimport javax.naming.ldap.StartTlsRequest;\nimport javax.naming.ldap.StartTlsResponse;\n\nimport org.neo4j.graphdb.security.AuthProviderFailedException;\nimport org.neo4j.graphdb.security.AuthProviderTimeoutException;\nimport org.neo4j.graphdb.security.AuthorizationExpiredException;\nimport org.neo4j.internal.kernel.api.security.AuthenticationResult;\nimport org.neo4j.kernel.api.security.AuthToken;\nimport org.neo4j.kernel.api.security.exception.InvalidAuthTokenException;\nimport org.neo4j.kernel.configuration.Config;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.server.security.enterprise.log.SecurityLog;\n\nimport static java.lang.String.format;\n\n\npublic class LdapRealm extends DefaultLdapRealm implements RealmLifecycle, ShiroAuthorizationInfoProvider\n{\n    private static final String GROUP_DELIMITER = \";\";\n    private static final String KEY_VALUE_DELIMITER = \"=\";\n    private static final String ROLE_DELIMITER = \",\";\n    public static final String LDAP_REALM = \"ldap\";\n\n    private static final String JNDI_LDAP_CONNECT_TIMEOUT = \"com.sun.jndi.ldap.connect.timeout\";\n    private static final String JNDI_LDAP_READ_TIMEOUT = \"com.sun.jndi.ldap.read.timeout\";\n    private static final String JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART = \"timed out\"; \n    private static final String JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART = \"timed out\"; \n\n    public static final String LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE = \"LDAP connection timed out.\";\n    public static final String LDAP_READ_TIMEOUT_CLIENT_MESSAGE = \"LDAP response timed out.\";\n    public static final String LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE = \"LDAP authorization request failed.\";\n    public static final String LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE = \"LDAP connection refused.\";\n\n    private Boolean authenticationEnabled;\n    private Boolean authorizationEnabled;\n    private Boolean useStartTls;\n    private boolean useSAMAccountName;\n    private String userSearchBase;\n    private String userSearchFilter;\n    private List<String> membershipAttributeNames;\n    private Boolean useSystemAccountForAuthorization;\n    private Map<String,Collection<String>> groupToRoleMapping;\n    private final SecurityLog securityLog;\n    private final SecureHasher secureHasher;\n\n    \n    private static final String KEY_GROUP = \"\\\\s*('(.+)'|\\\"(.+)\\\"|(\\\\S)|(\\\\S.*\\\\S))\\\\s*\";\n    private static final String VALUE_GROUP = \"\\\\s*(.*)\";\n    private Pattern keyValuePattern = Pattern.compile( KEY_GROUP + KEY_VALUE_DELIMITER + VALUE_GROUP );\n\n    public LdapRealm( Config config, SecurityLog securityLog, SecureHasher secureHasher )\n    {\n        super();\n        this.securityLog = securityLog;\n        this.secureHasher = secureHasher;\n        setName( SecuritySettings.LDAP_REALM_NAME );\n        setRolePermissionResolver( PredefinedRolesBuilder.rolePermissionResolver );\n        configureRealm( config );\n        if ( isAuthenticationCachingEnabled() )\n        {\n            setCredentialsMatcher( secureHasher.getHashedCredentialsMatcher() );\n        }\n        else\n        {\n            setCredentialsMatcher( new AllowAllCredentialsMatcher() );\n        }\n    }\n\n    private String withRealm( String template, Object... args )\n    {\n        return \"{LdapRealm}: \" + format( template, args );\n    }\n\n    private String server( JndiLdapContextFactory jndiLdapContextFactory )\n    {\n        return \"'\" + jndiLdapContextFactory.getUrl() + \"'\" +\n                ( useStartTls ? \" using StartTLS\" : \"\" );\n    }\n\n    @Override\n    protected AuthenticationInfo queryForAuthenticationInfo( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        if ( authenticationEnabled )\n        {\n            if ( useSAMAccountName )\n            {\n                return queryForAuthenticationInfoSAM( token, ldapContextFactory );\n            }\n            else\n            {\n                String serverString = server( (JndiLdapContextFactory) ldapContextFactory );\n                try\n                {\n                    AuthenticationInfo info =\n                            useStartTls ? queryForAuthenticationInfoUsingStartTls( token, ldapContextFactory )\n                                        : super.queryForAuthenticationInfo( token, ldapContextFactory );\n                    securityLog.debug( withRealm( \"Authenticated user '%s' against %s\", token.getPrincipal(),\n                            serverString ) );\n                    return info;\n                }\n                catch ( Exception e )\n                {\n                    if ( isExceptionAnLdapConnectionTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionAnLdapReadTimeout( e ) )\n                    {\n                        throw new AuthProviderTimeoutException( LDAP_READ_TIMEOUT_CLIENT_MESSAGE, e );\n                    }\n                    else if ( isExceptionConnectionRefused( e ) )\n                    {\n                        throw new AuthProviderFailedException( LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE, e );\n                    }\n                    \n                    throw e;\n                }\n            }\n        }\n        else\n        {\n            return null;\n        }\n    }\n\n    protected AuthenticationInfo queryForAuthenticationInfoUsingStartTls( AuthenticationToken token,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = getLdapPrincipal(token);\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = getLdapContextUsingStartTls( ldapContextFactory, principal, credentials );\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo queryForAuthorizationInfo( PrincipalCollection principals,\n            LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        if ( authorizationEnabled )\n        {\n            String username = getUsername( principals );\n            if ( username == null )\n            {\n                return null;\n            }\n\n            if ( useSystemAccountForAuthorization )\n            {\n                \n                LdapContext ldapContext = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                          ldapContextFactory.getSystemLdapContext();\n\n                Set<String> roleNames;\n                try\n                {\n                    roleNames = findRoleNamesForUser( username, ldapContext );\n                }\n                finally\n                {\n                    LdapUtils.closeContext( ldapContext );\n                }\n\n                return new SimpleAuthorizationInfo( roleNames );\n            }\n            else\n            {\n                \n                Cache<Object,AuthorizationInfo> authorizationCache = getAuthorizationCache();\n                AuthorizationInfo authorizationInfo = authorizationCache.get( username );\n                if ( authorizationInfo == null )\n                {\n                    \n                    \n                    \n                    \n                    throw new AuthorizationExpiredException( \"LDAP authorization info expired.\" );\n                }\n                return authorizationInfo;\n            }\n        }\n        return null;\n    }\n\n    private String getUsername( PrincipalCollection principals )\n    {\n        String username = null;\n        Collection ldapPrincipals = principals.fromRealm( getName() );\n        if ( !ldapPrincipals.isEmpty() )\n        {\n            username = (String) ldapPrincipals.iterator().next();\n        }\n        else if ( useSystemAccountForAuthorization )\n        {\n            username = (String) principals.getPrimaryPrincipal();\n        }\n        return username;\n    }\n\n    private LdapContext getSystemLdapContextUsingStartTls( LdapContextFactory ldapContextFactory )\n            throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        return getLdapContextUsingStartTls( ldapContextFactory, jndiLdapContextFactory.getSystemUsername(),\n                jndiLdapContextFactory.getSystemPassword() );\n    }\n\n    @Override\n    protected AuthenticationInfo createAuthenticationInfo( AuthenticationToken token, Object ldapPrincipal,\n            Object ldapCredentials, LdapContext ldapContext )\n            throws NamingException\n    {\n        \n        \n        if ( authorizationEnabled && !useSystemAccountForAuthorization )\n        {\n            String username = (String) token.getPrincipal();\n            Set<String> roleNames = findRoleNamesForUser( username, ldapContext );\n            cacheAuthorizationInfo( username, roleNames );\n        }\n\n        if ( isAuthenticationCachingEnabled() )\n        {\n            SimpleHash hashedCredentials = secureHasher.hash( ((String) token.getCredentials()).getBytes() );\n            return new ShiroAuthenticationInfo( token.getPrincipal(), hashedCredentials.getBytes(),\n                    hashedCredentials.getSalt(), getName(), AuthenticationResult.SUCCESS );\n        }\n        else\n        {\n            return new ShiroAuthenticationInfo( token.getPrincipal(), getName(), AuthenticationResult.SUCCESS );\n        }\n    }\n\n    @Override\n    public boolean supports( AuthenticationToken token )\n    {\n        return supportsSchemeAndRealm( token );\n    }\n\n    private boolean supportsSchemeAndRealm( AuthenticationToken token )\n    {\n        try\n        {\n            if ( token instanceof ShiroAuthToken )\n            {\n                ShiroAuthToken shiroAuthToken = (ShiroAuthToken) token;\n                return shiroAuthToken.getScheme().equals( AuthToken.BASIC_SCHEME ) &&\n                       (shiroAuthToken.supportsRealm( LDAP_REALM ));\n            }\n            return false;\n        }\n        catch ( InvalidAuthTokenException e )\n        {\n            return false;\n        }\n    }\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo( PrincipalCollection principals )\n    {\n        try\n        {\n            AuthorizationInfo info = super.doGetAuthorizationInfo( principals );\n            securityLog.debug( withRealm( \"Queried for authorization info for user '%s'\",\n                    principals.getPrimaryPrincipal() ) );\n            return info;\n        }\n        catch ( AuthorizationException e )\n        {\n            securityLog.warn( withRealm( \"Failed to get authorization info: '%s' caused by '%s'\",\n                    e.getMessage(), e.getCause().getMessage() ) );\n            return null;\n        }\n    }\n\n    \n    \n    private boolean isExceptionAnLdapReadTimeout( Exception e )\n    {\n        return e instanceof NamingException &&\n               e.getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private boolean isExceptionAnLdapConnectionTimeout( Exception e )\n    {\n        return e instanceof CommunicationException &&\n               (((CommunicationException) e).getRootCause() instanceof SocketTimeoutException ||\n                ((CommunicationException) e).getRootCause().getMessage().contains(\n                        JNDI_LDAP_CONNECTION_TIMEOUT_MESSAGE_PART ) );\n    }\n\n    private boolean isExceptionConnectionRefused( Exception e )\n    {\n        return e instanceof CommunicationException &&\n                ((CommunicationException) e).getRootCause() instanceof ConnectException;\n    }\n\n    private boolean isAuthorizationExceptionAnLdapReadTimeout( AuthorizationException e )\n    {\n        \n        return e.getCause() != null && e.getCause() instanceof NamingException &&\n               e.getCause().getMessage().contains( JNDI_LDAP_READ_TIMEOUT_MESSAGE_PART );\n    }\n\n    private void cacheAuthorizationInfo( String username, Set<String> roleNames )\n    {\n        \n        Cache<Object, AuthorizationInfo> authorizationCache = getAuthorizationCache();\n        authorizationCache.put( username, new SimpleAuthorizationInfo( roleNames ) );\n    }\n\n    private void configureRealm( Config config )\n    {\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        Map<String,Object> environment = contextFactory.getEnvironment();\n        Long connectionTimeoutMillis = config.get( SecuritySettings.ldap_connection_timeout ).toMillis();\n        Long readTimeoutMillis = config.get( SecuritySettings.ldap_read_timeout ).toMillis();\n        environment.put( JNDI_LDAP_CONNECT_TIMEOUT, connectionTimeoutMillis.toString() );\n        environment.put( JNDI_LDAP_READ_TIMEOUT, readTimeoutMillis.toString() );\n        contextFactory.setEnvironment( environment );\n        contextFactory.setUrl( parseLdapServerUrl( config.get( SecuritySettings.ldap_server ) ) );\n        contextFactory.setAuthenticationMechanism( config.get( SecuritySettings.ldap_authentication_mechanism ) );\n        contextFactory.setReferral( config.get( SecuritySettings.ldap_referral ) );\n        contextFactory.setSystemUsername( config.get( SecuritySettings.ldap_authorization_system_username ) );\n        contextFactory.setSystemPassword( config.get( SecuritySettings.ldap_authorization_system_password ) );\n        contextFactory.setPoolingEnabled( config.get( SecuritySettings.ldap_authorization_connection_pooling ) );\n\n        setContextFactory( contextFactory );\n\n        String userDnTemplate = config.get( SecuritySettings.ldap_authentication_user_dn_template );\n        if ( userDnTemplate != null )\n        {\n            setUserDnTemplate( userDnTemplate );\n        }\n\n        authenticationEnabled = config.get( SecuritySettings.ldap_authentication_enabled );\n        authorizationEnabled = config.get( SecuritySettings.ldap_authorization_enabled );\n        useStartTls = config.get( SecuritySettings.ldap_use_starttls );\n\n        userSearchBase = config.get( SecuritySettings.ldap_authorization_user_search_base );\n        userSearchFilter = config.get( SecuritySettings.ldap_authorization_user_search_filter );\n        useSAMAccountName = config.get( SecuritySettings.ldap_authentication_use_samaccountname );\n        membershipAttributeNames = config.get( SecuritySettings.ldap_authorization_group_membership_attribute_names );\n        useSystemAccountForAuthorization = config.get( SecuritySettings.ldap_authorization_use_system_account );\n        groupToRoleMapping =\n                parseGroupToRoleMapping( config.get( SecuritySettings.ldap_authorization_group_to_role_mapping ) );\n\n        setAuthenticationCachingEnabled( config.get( SecuritySettings.ldap_authentication_cache_enabled ) );\n        setAuthorizationCachingEnabled( true );\n    }\n\n    private String parseLdapServerUrl( String rawLdapServer )\n    {\n        return (rawLdapServer == null) ? null :\n               rawLdapServer.contains( \"://\" ) ? rawLdapServer : \"ldap://\" + rawLdapServer;\n    }\n\n    private Map<String,Collection<String>> parseGroupToRoleMapping( String groupToRoleMappingString )\n    {\n        Map<String,Collection<String>> map = new HashMap<>();\n\n        if ( groupToRoleMappingString != null )\n        {\n            for ( String groupAndRoles : groupToRoleMappingString.split( GROUP_DELIMITER ) )\n            {\n                if ( !groupAndRoles.isEmpty() )\n                {\n                    Matcher matcher = keyValuePattern.matcher( groupAndRoles );\n                    if ( !(matcher.find() && matcher.groupCount() == 6) )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: wrong number of fields\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n\n                    String group = matcher.group(2) != null ? matcher.group(2) :\n                                   matcher.group(3) != null ? matcher.group(3) :\n                                   matcher.group(4) != null ? matcher.group(4) :\n                                   matcher.group(5) != null ? matcher.group(5) : \"\";\n\n                    if ( group.isEmpty() )\n                    {\n                        String errorMessage = format( \"Failed to parse setting %s: empty group name\",\n                                SecuritySettings.ldap_authorization_group_to_role_mapping.name() );\n                        throw new IllegalArgumentException( errorMessage );\n                    }\n                    Collection<String> roleList = new ArrayList<>();\n                    for ( String role : matcher.group(6).trim().split( ROLE_DELIMITER ) )\n                    {\n                        if ( !role.isEmpty() )\n                        {\n                            roleList.add( role );\n                        }\n                    }\n                    \n                    map.put( group.toLowerCase(), roleList );\n                }\n            }\n        }\n\n        return map;\n    }\n\n    private AuthenticationInfo queryForAuthenticationInfoSAM(\n            AuthenticationToken token, LdapContextFactory ldapContextFactory ) throws NamingException\n    {\n        Object principal = token.getPrincipal();\n        Object credentials = token.getCredentials();\n\n        LdapContext ctx = null;\n        try\n        {\n            ctx = useStartTls ? getSystemLdapContextUsingStartTls( ldapContextFactory ) :\n                                      ldapContextFactory.getSystemLdapContext();\n            String[] attrs = {\"cn\"};\n            SearchControls searchCtls = new SearchControls( SearchControls.SUBTREE_SCOPE, 1, 0, attrs, false, false );\n            Object[] searchArguments = new Object[]{principal};\n            String filter = \"sAMAccountName={0}\";\n            NamingEnumeration<SearchResult> search = ctx.search( userSearchBase, filter, searchArguments, searchCtls );\n            if ( search.hasMore() )\n            {\n                final SearchResult next = search.next();\n                String loginUser = next.getNameInNamespace();\n                if ( search.hasMore() )\n                {\n                    securityLog.error( \"More than one user matching: \" + principal );\n                    throw new AuthenticationException( \"More than one user matching: \" + principal );\n                }\n                else\n                {\n                    LdapContext ctx2 = ldapContextFactory.getLdapContext( loginUser, credentials );\n                    LdapUtils.closeContext( ctx2 );\n                }\n            }\n            else\n            {\n                throw new AuthenticationException( \"No user matching: \" + principal );\n            }\n            return createAuthenticationInfo( token, principal, credentials, ctx );\n        }\n        finally\n        {\n            LdapUtils.closeContext( ctx );\n        }\n    }\n\n    \n    Set<String> findRoleNamesForUser( String username, LdapContext ldapContext ) throws NamingException\n    {\n        Set<String> roleNames = new LinkedHashSet<>();\n\n        SearchControls searchCtls = new SearchControls();\n        searchCtls.setSearchScope( SearchControls.SUBTREE_SCOPE );\n        searchCtls.setReturningAttributes( membershipAttributeNames.toArray( new String[1] ) );\n\n        \n        Object[] searchArguments = new Object[]{username};\n\n        NamingEnumeration result = ldapContext.search( userSearchBase, userSearchFilter, searchArguments, searchCtls );\n\n        if ( result.hasMoreElements() )\n        {\n            SearchResult searchResult = (SearchResult) result.next();\n\n            if ( result.hasMoreElements() )\n            {\n                securityLog.warn(\n                        securityLog.isDebugEnabled() ?\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The first match that will \" +\n                                            \"be checked for group membership is '%s' but the search also matches '%s'. \" +\n                                            \"Please check your LDAP realm configuration.\",\n                            username, searchResult.toString(), result.next().toString() )\n                        :\n                        withRealm(\n                            \"LDAP user search for user principal '%s' is ambiguous. The search matches more \" +\n                                            \"than one entry. Please check your LDAP realm configuration.\",\n                            username )\n                    );\n            }\n\n            Attributes attributes = searchResult.getAttributes();\n            if ( attributes != null )\n            {\n                NamingEnumeration attributeEnumeration = attributes.getAll();\n                while ( attributeEnumeration.hasMore() )\n                {\n                    Attribute attribute = (Attribute) attributeEnumeration.next();\n                    String attributeId = attribute.getID();\n                    if ( membershipAttributeNames.stream().anyMatch( attributeId::equalsIgnoreCase ) )\n                    {\n                        Collection<String> groupNames = LdapUtils.getAllAttributeValues( attribute );\n                        Collection<String> rolesForGroups = getRoleNamesForGroups( groupNames );\n                        roleNames.addAll( rolesForGroups );\n                    }\n                }\n            }\n        }\n        return roleNames;\n    }\n\n    private void assertValidUserSearchSettings()\n    {\n        boolean proceedWithSearch = true;\n\n        if ( userSearchBase == null || userSearchBase.isEmpty() )\n        {\n            securityLog.error( \"LDAP user search base is empty.\" );\n            proceedWithSearch = false;\n        }\n        if ( userSearchFilter == null || !userSearchFilter.contains( \"{0}\" ) )\n        {\n            securityLog.warn( \"LDAP user search filter does not contain the argument placeholder {0}, \" +\n                    \"so the search result will be independent of the user principal.\" );\n        }\n        if ( membershipAttributeNames == null || membershipAttributeNames.isEmpty() )\n        {\n            \n            securityLog.error( \"LDAP group membership attribute names are empty. Authorization will not be possible.\" );\n            proceedWithSearch = false;\n        }\n\n        if ( !proceedWithSearch )\n        {\n            throw new IllegalArgumentException( \"Illegal LDAP user search settings, see security log for details.\" );\n        }\n    }\n\n    private Collection<String> getRoleNamesForGroups( Collection<String> groupNames )\n    {\n        Collection<String> roles = new ArrayList<>();\n        for ( String group : groupNames )\n        {\n            Collection<String> rolesForGroup = groupToRoleMapping.get( group.toLowerCase() );\n            if ( rolesForGroup != null )\n            {\n                roles.addAll( rolesForGroup );\n            }\n        }\n        return roles;\n    }\n\n    \n    Map<String,Collection<String>> getGroupToRoleMapping()\n    {\n        return groupToRoleMapping;\n    }\n\n    @Override\n    public void initialize()\n    {\n        if ( authorizationEnabled )\n        {\n            \n            assertValidUserSearchSettings();\n        }\n    }\n\n    @Override\n    public void start()\n    {\n    }\n\n    @Override\n    public void stop()\n    {\n    }\n\n    @Override\n    public void shutdown()\n    {\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfoSnapshot( PrincipalCollection principalCollection )\n    {\n        return getAuthorizationInfo( principalCollection );\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 59,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/neo4j/neo4j/commit/46de5d01ae2741ffe04c36270fc62c6d490f65c9",
    "cve_id": "CVE-2018-18389",
    "cwe_id": "CWE-287",
    "filename": "enterprise/security/src/test/java/org/neo4j/server/security/enterprise/auth/integration/bolt/LdapAuthIT.java",
    "code": "\npackage org.neo4j.server.security.enterprise.auth.integration.bolt;\n\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.exception.LdapOperationErrorException;\nimport org.apache.directory.server.annotations.CreateLdapServer;\nimport org.apache.directory.server.annotations.CreateTransport;\nimport org.apache.directory.server.annotations.SaslMechanism;\nimport org.apache.directory.server.core.annotations.ApplyLdifFiles;\nimport org.apache.directory.server.core.annotations.ContextEntry;\nimport org.apache.directory.server.core.annotations.CreateDS;\nimport org.apache.directory.server.core.annotations.CreatePartition;\nimport org.apache.directory.server.core.annotations.LoadSchema;\nimport org.apache.directory.server.core.api.filtering.EntryFilteringCursor;\nimport org.apache.directory.server.core.api.interceptor.BaseInterceptor;\nimport org.apache.directory.server.core.api.interceptor.Interceptor;\nimport org.apache.directory.server.core.api.interceptor.context.SearchOperationContext;\nimport org.apache.directory.server.core.integ.FrameworkRunner;\nimport org.apache.directory.server.ldap.handlers.extended.StartTlsHandler;\nimport org.apache.shiro.realm.ldap.JndiLdapContextFactory;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\nimport org.junit.runner.RunWith;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Reader;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport javax.naming.directory.BasicAttribute;\nimport javax.naming.directory.DirContext;\nimport javax.naming.directory.ModificationItem;\nimport javax.naming.ldap.LdapContext;\n\nimport org.neo4j.bolt.v1.transport.socket.client.TransportConnection;\nimport org.neo4j.graphdb.config.Setting;\nimport org.neo4j.internal.kernel.api.security.AuthSubject;\nimport org.neo4j.io.fs.FileSystemAbstraction;\nimport org.neo4j.kernel.api.exceptions.InvalidArgumentsException;\nimport org.neo4j.kernel.api.exceptions.Status;\nimport org.neo4j.kernel.impl.factory.GraphDatabaseFacade;\nimport org.neo4j.kernel.impl.proc.Procedures;\nimport org.neo4j.kernel.internal.GraphDatabaseAPI;\nimport org.neo4j.server.security.enterprise.auth.EnterpriseAuthAndUserManager;\nimport org.neo4j.server.security.enterprise.auth.ProcedureInteractionTestBase;\nimport org.neo4j.server.security.enterprise.auth.plugin.api.PredefinedRoles;\nimport org.neo4j.server.security.enterprise.configuration.SecuritySettings;\nimport org.neo4j.test.DoubleLatch;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.neo4j.bolt.v1.messaging.message.InitMessage.init;\nimport static org.neo4j.bolt.v1.messaging.message.PullAllMessage.pullAll;\nimport static org.neo4j.bolt.v1.messaging.message.RunMessage.run;\nimport static org.neo4j.bolt.v1.messaging.util.MessageMatchers.msgFailure;\nimport static org.neo4j.bolt.v1.messaging.util.MessageMatchers.msgRecord;\nimport static org.neo4j.bolt.v1.messaging.util.MessageMatchers.msgSuccess;\nimport static org.neo4j.bolt.v1.runtime.spi.StreamMatchers.eqRecord;\nimport static org.neo4j.bolt.v1.transport.integration.TransportTestUtil.eventuallyDisconnects;\nimport static org.neo4j.bolt.v1.transport.integration.TransportTestUtil.eventuallyReceives;\nimport static org.neo4j.server.security.enterprise.auth.LdapRealm.LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE;\nimport static org.neo4j.server.security.enterprise.auth.LdapRealm.LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE;\nimport static org.neo4j.server.security.enterprise.auth.LdapRealm.LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE;\nimport static org.neo4j.server.security.enterprise.auth.LdapRealm.LDAP_READ_TIMEOUT_CLIENT_MESSAGE;\nimport static org.neo4j.values.storable.Values.stringValue;\nimport static org.neo4j.values.virtual.VirtualValues.EMPTY_LIST;\n\ninterface TimeoutTests\n{ \n}\n\n@RunWith( FrameworkRunner.class )\n@CreateDS(\n        name = \"Test\",\n        partitions = {@CreatePartition(\n                name = \"example\",\n                suffix = \"dc=example,dc=com\",\n                contextEntry = @ContextEntry( entryLdif = \"dn: dc=example,dc=com\\n\" +\n                                                          \"dc: example\\n\" +\n                                                          \"o: example\\n\" +\n                                                          \"objectClass: top\\n\" +\n                                                          \"objectClass: dcObject\\n\" +\n                                                          \"objectClass: organization\\n\\n\" ) ),\n        },\n        loadedSchemas = {\n                @LoadSchema( name = \"nis\" ),\n        } )\n@CreateLdapServer(\n        transports = {@CreateTransport( protocol = \"LDAP\", port = 10389, address = \"0.0.0.0\" ),\n                @CreateTransport( protocol = \"LDAPS\", port = 10636, address = \"0.0.0.0\", ssl = true )\n        },\n\n        saslMechanisms = {\n                @SaslMechanism( name = \"DIGEST-MD5\", implClass = org.apache.directory.server.ldap.handlers.sasl\n                        .digestMD5.DigestMd5MechanismHandler.class ),\n                @SaslMechanism( name = \"CRAM-MD5\", implClass = org.apache.directory.server.ldap.handlers.sasl\n                        .cramMD5.CramMd5MechanismHandler.class )\n        },\n        saslHost = \"0.0.0.0\",\n        extendedOpHandlers = {StartTlsHandler.class},\n        keyStore = \"target/test-classes/neo4j_ldap_test_keystore.jks\",\n        certificatePassword = \"secret\"\n)\n@ApplyLdifFiles( \"ldap_test_data.ldif\" )\npublic class LdapAuthIT extends EnterpriseAuthenticationTestBase\n{\n    private static final String LDAP_ERROR_MESSAGE_INVALID_CREDENTIALS = \"LDAP: error code 49 - INVALID_CREDENTIALS\";\n    private static final String NON_ROUTABLE_IP = \"192.0.2.0\"; \n    private static final String REFUSED_IP = \"127.0.0.1\"; \n    private final String MD5_HASHED_abc123 = \"{MD5}6ZoYxCjLONXyYIU2eJIuAw==\";\n    \n\n    @Before\n    @Override\n    public void setup()\n    {\n        super.setup();\n        getLdapServer().setConfidentialityRequired( false );\n    }\n\n    private void restartNeo4jServerWithSaslDigestMd5()\n    {\n        server.shutdownDatabase();\n        server.ensureDatabase( asSettings( ldapOnlyAuthSettings.andThen(\n                settings ->\n                {\n                    settings.put( SecuritySettings.ldap_authentication_mechanism, \"DIGEST-MD5\" );\n                    settings.put( SecuritySettings.ldap_authentication_user_dn_template, \"{0}\" );\n                }\n        ) ) );\n        lookupConnectorAddress();\n    }\n\n    private void restartNeo4jServerWithSaslCramMd5()\n    {\n        server.shutdownDatabase();\n        server.ensureDatabase( asSettings( ldapOnlyAuthSettings.andThen(\n                settings ->\n                {\n                    settings.put( SecuritySettings.ldap_authentication_mechanism, \"CRAM-MD5\" );\n                    settings.put( SecuritySettings.ldap_authentication_user_dn_template, \"{0}\" );\n                }\n        ) ) );\n        lookupConnectorAddress();\n    }\n\n    @Override\n    protected Consumer<Map<Setting<?>,String>> getSettingsFunction()\n    {\n        return super.getSettingsFunction().andThen( ldapOnlyAuthSettings ).andThen( settings ->\n        {\n            settings.put( SecuritySettings.ldap_server, \"0.0.0.0:10389\" );\n            settings.put( SecuritySettings.ldap_authentication_user_dn_template, \"cn={0},ou=users,dc=example,dc=com\" );\n            settings.put( SecuritySettings.ldap_authentication_cache_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_system_username, \"uid=admin,ou=system\" );\n            settings.put( SecuritySettings.ldap_authorization_system_password, \"secret\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_user_search_base, \"dc=example,dc=com\" );\n            settings.put( SecuritySettings.ldap_authorization_user_search_filter, \"(&(objectClass=*)(uid={0}))\" );\n            settings.put( SecuritySettings.ldap_authorization_group_membership_attribute_names, \"gidnumber\" );\n            settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping,\n                    \"500=reader;501=publisher;502=architect;503=admin\" );\n            settings.put( SecuritySettings.procedure_roles, \"test.allowedReadProcedure:role1\" );\n            settings.put( SecuritySettings.ldap_read_timeout, \"1s\" );\n        } );\n    }\n\n    @Test\n    public void shouldLoginWithLdap() throws Throwable\n    {\n        assertAuth( \"neo4j\", \"abc123\" );\n        reconnect();\n        assertAuth( \"neo4j\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldLoginWithLdapWithAuthenticationCacheDisabled() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_authentication_cache_enabled, \"false\" ) ) );\n\n        assertAuth( \"neo4j\", \"abc123\" );\n        reconnect();\n        assertAuth( \"neo4j\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldFailToLoginWithLdapIfInvalidCredentials() throws Throwable\n    {\n        assertAuthFail( \"neo4j\", \"CANT_REMEMBER_MY_PASSWORDS_ANYMORE!\" );\n    }\n\n    @Test\n    public void shoulFailToLoginWithLdapIfInvalidCredentialsFollowingSuccessfulLogin() throws Throwable\n    {\n        assertAuth( \"neo4j\", \"abc123\" );\n        reconnect();\n        assertAuthFail( \"neo4j\", \"\" );\n    }\n\n    @Test\n    public void shouldLoginWithLdapUsingSaslDigestMd5() throws Throwable\n    {\n        \n        restartNeo4jServerWithSaslDigestMd5();\n\n        \n        assertAuth( \"neo4j\", MD5_HASHED_abc123 );\n    }\n\n    @Test\n    public void shouldFailToLoginWithLdapDigestMd5IfInvalidCredentials() throws Throwable\n    {\n        \n        restartNeo4jServerWithSaslDigestMd5();\n\n        \n        assertAuthFail( \"neo4j\", MD5_HASHED_abc123.toUpperCase() );\n    }\n\n    @Test\n    public void shouldLoginWithLdapUsingSaslCramMd5() throws Throwable\n    {\n        \n        restartNeo4jServerWithSaslCramMd5();\n\n        \n        assertAuth( \"neo4j\", MD5_HASHED_abc123 );\n    }\n\n    @Test\n    public void shouldFailToLoginWithLdapCramMd5IfInvalidCredentials() throws Throwable\n    {\n        \n        restartNeo4jServerWithSaslCramMd5();\n\n        \n        assertAuthFail( \"neo4j\", MD5_HASHED_abc123.toUpperCase() );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithLdapOnly() throws Throwable\n    {\n        testAuthWithReaderUser();\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizePublisherWithLdapOnly() throws Throwable\n    {\n        testAuthWithPublisherUser();\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserWithLdapOnly() throws Throwable\n    {\n        testAuthWithNoPermissionUser( \"smith\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldShowCurrentUser() throws Throwable\n    {\n        \n        assertAuth( \"smith\", \"abc123\" );\n        client.send( util.chunk(\n                run( \"CALL dbms.showCurrentUser()\" ),\n                pullAll() ) );\n\n        \n        \n        assertThat( client, util.eventuallyReceives(\n                msgSuccess(),\n                msgRecord(\n                        eqRecord( equalTo( stringValue( \"smith\" ) ), equalTo( EMPTY_LIST ), equalTo( EMPTY_LIST ) ) )\n        ) );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserWithLdapOnlyAndNoGroupToRoleMapping() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                .andThen(\n                        settings -> settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping, null ) ) );\n\n        \n        \n        \n        testAuthWithNoPermissionUser( \"neo\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeWithLdapOnlyAndQuotedGroupToRoleMapping() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping,\n                        \" '500'  =\\t reader  ; \\\"501\\\"\\t=publisher\\n;502 =architect  ;  \\\"503\\\"=  \\nadmin\" ) ) );\n\n        \n        testAuthWithReaderUser();\n        reconnect();\n        testAuthWithPublisherUser();\n        reconnect();\n        testAuthWithNoPermissionUser( \"smith\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithUserLdapContext() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        \n        testAuthWithReaderUser();\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizePublisherWithUserLdapContext() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        \n        testAuthWithPublisherUser();\n    }\n\n    @Test\n    public void shouldFailIfAuthorizationExpiredWithUserLdapContext() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        \n        assertAuth( \"neo4j\", \"abc123\" );\n        assertReadSucceeds();\n\n        \n        client.send( util.chunk(\n                run( \"CALL dbms.security.clearAuthCache()\" ), pullAll() ) );\n        assertThat( client, util.eventuallyReceives( msgSuccess(), msgSuccess() ) );\n\n        \n        client.send( util.chunk(\n                run( \"MATCH (n) RETURN n\" ), pullAll() ) );\n        assertThat( client, util.eventuallyReceives(\n                msgFailure( Status.Security.AuthorizationExpired, \"LDAP authorization info expired.\" ) ) );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    @Test\n    public void shouldSucceedIfAuthorizationExpiredWithinTransactionWithUserLdapContext() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        \n        assertAuth( \"neo4j\", \"abc123\" );\n\n        client.send( util.chunk(\n                run( \"CALL dbms.security.clearAuthCache() MATCH (n) RETURN n\" ), pullAll() ) );\n\n        \n        assertThat( client, util.eventuallyReceives( msgSuccess(), msgSuccess() ) );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserWithUserLdapContext() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        \n        testAuthWithNoPermissionUser( \"smith\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserWithUserLdapContextAndNoGroupToRoleMapping()\n            throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n            settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping, null );\n        } );\n\n        \n        \n        \n        testAuthWithNoPermissionUser( \"neo\", \"abc123\" );\n    }\n\n    @Test\n    public void shouldBeAbleToLoginWithLdapAndAuthorizeInternally() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \",\" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"false\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"false\" );\n        } );\n\n        \n        \n        testCreateReaderUser();\n\n        \n        reconnect();\n\n        testAuthWithReaderUser();\n    }\n\n    @Test\n    public void shouldBeAbleToLoginNativelyAndAuthorizeWithLdap() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \",\" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"false\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"false\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n        } );\n\n        \n        String ldapReaderUser = \"neo\";\n        String nativePassword = \"nativePassword\";\n\n        createNativeUser( ldapReaderUser, nativePassword );\n\n        \n        \n        testAuthWithReaderUser( ldapReaderUser, nativePassword, null );\n    }\n\n    @Test\n    public void shouldKeepAuthorizationForLifetimeOfTransaction() throws Throwable\n    {\n        restartServerWithoutSystemAccount();\n\n        DoubleLatch latch = new DoubleLatch( 2 );\n        final Throwable[] threadFail = {null};\n\n        Thread readerThread = new Thread( () ->\n        {\n            try\n            {\n                assertAuth( \"neo\", \"abc123\" );\n                assertBeginTransactionSucceeds();\n                assertReadSucceeds();\n\n                latch.startAndWaitForAllToStart();\n                latch.finishAndWaitForAllToFinish();\n\n                assertReadSucceeds();\n            }\n            catch ( Throwable t )\n            {\n                threadFail[0] = t;\n                \n                latch.start();\n                latch.finish();\n            }\n        } );\n\n        readerThread.start();\n        latch.startAndWaitForAllToStart();\n\n        clearAuthCacheFromDifferentConnection();\n\n        latch.finishAndWaitForAllToFinish();\n\n        readerThread.join();\n        if ( threadFail[0] != null )\n        {\n            throw threadFail[0];\n        }\n    }\n\n    @Test\n    public void shouldKeepAuthorizationForLifetimeOfTransactionWithProcedureAllowed() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n            settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping, \"503=admin;504=role1\" );\n        } );\n\n        GraphDatabaseAPI graphDatabaseAPI = (GraphDatabaseAPI) server.graphDatabaseService();\n        graphDatabaseAPI.getDependencyResolver().resolveDependency( Procedures.class )\n                .registerProcedure( ProcedureInteractionTestBase.ClassWithProcedures.class );\n\n        DoubleLatch latch = new DoubleLatch( 2 );\n        final Throwable[] threadFail = {null};\n\n        Thread readerThread = new Thread( () ->\n        {\n            try\n            {\n                assertAuth( \"smith\", \"abc123\" );\n                assertBeginTransactionSucceeds();\n                assertAllowedReadProcedure();\n\n                latch.startAndWaitForAllToStart();\n                latch.finishAndWaitForAllToFinish();\n\n                assertAllowedReadProcedure();\n            }\n            catch ( Throwable t )\n            {\n                threadFail[0] = t;\n                \n                latch.start();\n                latch.finish();\n            }\n        } );\n\n        readerThread.start();\n        latch.startAndWaitForAllToStart();\n\n        clearAuthCacheFromDifferentConnection();\n\n        latch.finishAndWaitForAllToFinish();\n\n        readerThread.join();\n        if ( threadFail[0] != null )\n        {\n            throw threadFail[0];\n        }\n    }\n\n    @Test\n    public void shouldBeAbleToUseProcedureAllowedAnnotationWithLdapGroupToRoleMapping() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                .andThen( settings -> settings\n                        .put( SecuritySettings.ldap_authorization_group_to_role_mapping, \"500=role1\" ) ) );\n\n        GraphDatabaseAPI graphDatabaseAPI = (GraphDatabaseAPI) server.graphDatabaseService();\n        graphDatabaseAPI.getDependencyResolver().resolveDependency( Procedures.class )\n                .registerProcedure( ProcedureInteractionTestBase.ClassWithProcedures.class );\n\n        assertAuth( \"neo\", \"abc123\" );\n        assertAllowedReadProcedure();\n    }\n\n    @Test\n    public void shouldFailIfInvalidLdapServer() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen(\n                settings -> settings.put( SecuritySettings.ldap_server, \"ldap://127.0.0.1\" ) ) );\n\n        assertConnectionRefused( authToken( \"neo\", \"abc123\", null ),\n                LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    @Test\n    @Category( TimeoutTests.class )\n    public void shouldTimeoutIfLdapServerDoesNotRespond() throws Throwable\n    {\n        try ( DirectoryServiceWaitOnSearch ignore = new DirectoryServiceWaitOnSearch( 5000 ) )\n        {\n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                    .andThen( settings -> settings.put( SecuritySettings.ldap_read_timeout, \"1s\" ) ) );\n\n            assertAuth( \"neo\", \"abc123\" );\n            assertReadFails( \"neo\", \"\" );\n        }\n    }\n\n    @Test\n    @Category( TimeoutTests.class )\n    public void shouldTimeoutIfLdapServerDoesNotRespondWithoutConnectionPooling() throws Throwable\n    {\n        try ( DirectoryServiceWaitOnSearch ignore = new DirectoryServiceWaitOnSearch( 5000 ) )\n        {\n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen( settings ->\n            {\n                \n                settings.put( SecuritySettings.ldap_read_timeout, \"1s\" );\n                settings.put( SecuritySettings.ldap_authorization_connection_pooling, \"false\" );\n            } ) );\n\n            assertAuth( \"neo\", \"abc123\" );\n            assertReadFails( \"neo\", \"\" );\n        }\n    }\n\n    @Test\n    @Category( TimeoutTests.class )\n    public void shouldFailIfLdapSearchFails() throws Throwable\n    {\n        try ( DirectoryServiceFailOnSearch ignore = new DirectoryServiceFailOnSearch() )\n        {\n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                    .andThen( settings -> settings.put( SecuritySettings.ldap_read_timeout, \"1s\" ) ) );\n\n            assertAuth( \"neo\", \"abc123\" );\n            assertReadFails( \"neo\", \"\" );\n        }\n    }\n\n    @Test\n    public void shouldTimeoutIfLdapServerDoesNotRespondWithLdapUserContext() throws Throwable\n    {\n        try ( DirectoryServiceWaitOnSearch ignore = new DirectoryServiceWaitOnSearch( 5000 ) )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen( settings ->\n            {\n                settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n                settings.put( SecuritySettings.ldap_read_timeout, \"1s\" );\n            } ) );\n\n            assertConnectionTimeout( authToken( \"neo\", \"abc123\", null ),\n                    LDAP_READ_TIMEOUT_CLIENT_MESSAGE );\n        }\n    }\n\n    private void assertAllowedReadProcedure() throws IOException\n    {\n        client.send( util.chunk( run( \"CALL test.allowedReadProcedure()\" ), pullAll() ) );\n\n        \n        assertThat( client, util.eventuallyReceives(\n                msgSuccess(),\n                msgRecord( eqRecord( equalTo( stringValue( \"foo\" ) ) ) ),\n                msgSuccess() ) );\n    }\n\n    \n    \n    \n    \n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithLdapOnlyUsingLDAPS() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                    .andThen( settings -> settings.put( SecuritySettings.ldap_server, \"ldaps://localhost:10636\" ) ) );\n\n            \n            testAuthWithReaderUser();\n        }\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithUserLdapContextUsingLDAPS() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen( settings ->\n            {\n                settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n                settings.put( SecuritySettings.ldap_server, \"ldaps://localhost:10636\" );\n            } ) );\n\n            \n            testAuthWithReaderUser();\n        }\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithLdapOnlyUsingStartTls() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen( settings ->\n            {\n                settings.put( SecuritySettings.ldap_server, \"localhost:10389\" );\n                settings.put( SecuritySettings.ldap_use_starttls, \"true\" );\n            } ) );\n\n            \n            testAuthWithReaderUser();\n        }\n    }\n\n    @Test\n    public void shouldBeAbleToLoginAndAuthorizeReaderWithLdapUserContextUsingStartTls() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen( settings ->\n            {\n                settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n                settings.put( SecuritySettings.ldap_server, \"localhost:10389\" );\n                settings.put( SecuritySettings.ldap_use_starttls, \"true\" );\n            } ) );\n\n            \n            testAuthWithReaderUser();\n        }\n    }\n\n    \n    \n    \n    \n\n    \n    public void shouldNotBeAbleToLoginUnknownUserOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings );\n\n        assertAuthFail( \"unknown\", \"abc123ABC123\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderWithUserLdapContextOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2UsingSystemAccountSettings );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizePublisherWithUserLdapContextOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings );\n\n        assertAuth( \"tank\", \"abc123ABC123\" );\n        assertWriteSucceeds();\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizePublisherOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2UsingSystemAccountSettings );\n\n        assertAuth( \"tank\", \"abc123ABC123\" );\n        assertWriteSucceeds();\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserWithUserLdapContextOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings );\n\n        assertAuth( \"smith\", \"abc123ABC123\" );\n        assertReadFails( \"smith\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeNoPermissionUserOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2UsingSystemAccountSettings );\n\n        assertAuth( \"smith\", \"abc123ABC123\" );\n        assertReadFails( \"smith\", \"\" );\n    }\n\n    \n    \n    \n    \n    \n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderUsingLdapsOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2UsingSystemAccountSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_server, \"ldaps://henrik.neohq.net:636\" ) ) );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderWithUserLdapContextUsingLDAPSOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_server, \"ldaps://henrik.neohq.net:636\" ) ) );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderUsingStartTlsOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2UsingSystemAccountSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_use_starttls, \"true\" ) ) );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n    public void shouldBeAbleToLoginAndAuthorizeReaderWithUserLdapContextUsingStartTlsOnEC2() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( activeDirectoryOnEc2NotUsingSystemAccountSettings\n                .andThen( settings -> settings.put( SecuritySettings.ldap_use_starttls, \"true\" ) ) );\n\n        assertAuth( \"neo\", \"abc123ABC123\" );\n        assertReadSucceeds();\n        assertWriteFails( \"neo\", \"\" );\n    }\n\n    \n\n    @Test\n    public void shouldBeAbleToLoginWithLdapWhenSelectingRealmFromClient() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \",\" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"tank\" );\n\n        \n        \n        \n        reconnect();\n        assertAuth( \"tank\", createdUserPassword, \"native\" );\n        assertRoles( PredefinedRoles.READER, PredefinedRoles.PUBLISHER );\n\n        \n        reconnect();\n        assertAuth( \"tank\", \"abc123\", \"ldap\" );\n        assertRoles( PredefinedRoles.READER, PredefinedRoles.PUBLISHER );\n    }\n\n    @Test\n    public void shouldBeAbleToAuthorizeUsingNativeWithLdapEnabled() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.LDAP_REALM_NAME + \",\" + SecuritySettings.NATIVE_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"simon\" );\n\n        \n        reconnect();\n        assertAuth( \"simon\", createdUserPassword, \"native\" );\n\n        \n        assertReadSucceeds();\n    }\n\n    @Test\n    public void shouldBeAbleToAuthorizeUsingNativeWhenLdapFails() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.LDAP_REALM_NAME + \",\" + SecuritySettings.NATIVE_REALM_NAME );\n            settings.put( SecuritySettings.ldap_server, \"ldap://\" + REFUSED_IP );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        createNativeUser( \"simon\", createdUserPassword, PredefinedRoles.READER );\n\n        \n        assertAuth( \"simon\", createdUserPassword );\n\n        \n        assertReadSucceeds();\n    }\n\n    @Test\n    public void shouldNotLogErrorsFromLdapRealmWhenLoginSuccessfulInNativeRealmAndNativeFirst() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \",\" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"foo\" );\n\n        \n        \n        reconnect();\n        assertAuth( \"foo\", createdUserPassword );\n\n        \n        assertSecurityLogDoesNotContain( \"ERROR\" );\n    }\n\n    @Test\n    public void shouldNotLogErrorsFromLdapRealmWhenLoginSuccessfulInNativeRealmAndLdapFirst() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.LDAP_REALM_NAME + \",\" + SecuritySettings.NATIVE_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"foo\" );\n\n        \n        \n        reconnect();\n        assertAuth( \"foo\", createdUserPassword );\n\n        \n        assertSecurityLogDoesNotContain( \"ERROR\" );\n    }\n\n    @Test\n    public void shouldLogInvalidCredentialErrorFromLdapRealm() throws Throwable\n    {\n        \n        assertAuthFail( \"neo\", \"wrong-password\" );\n\n        \n        assertSecurityLogContains( LDAP_ERROR_MESSAGE_INVALID_CREDENTIALS );\n    }\n\n    @Test\n    public void shouldLogInvalidCredentialErrorFromLdapRealmWithMultipleRealmsFailingAndNativeFirst() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \", \" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"foo\" );\n\n        \n        \n        reconnect();\n        assertAuthFail( \"foo\", \"wrong-password\" );\n\n        \n        assertSecurityLogContains( LDAP_ERROR_MESSAGE_INVALID_CREDENTIALS );\n    }\n\n    @Test\n    public void shouldLogInvalidCredentialErrorFromLdapRealmWithMultipleRealmsFailingAndLdapFirst() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.LDAP_REALM_NAME + \", \" + SecuritySettings.NATIVE_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n        } );\n\n        \n        \n        testCreateReaderUser( \"foo\" );\n\n        \n        \n        reconnect();\n        assertAuthFail( \"foo\", \"wrong-password\" );\n\n        \n        assertSecurityLogContains( LDAP_ERROR_MESSAGE_INVALID_CREDENTIALS );\n    }\n\n    \n    \n    public void shouldLogConnectionTimeoutFromLdapRealm() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen(\n                settings ->\n                {\n                    settings.put( SecuritySettings.ldap_server, \"ldap://\" + NON_ROUTABLE_IP );\n                    settings.put( SecuritySettings.ldap_connection_timeout, \"1s\" );\n                } ) );\n\n        assertConnectionTimeout( authToken( \"neo\", \"abc123\", null ),\n                LDAP_CONNECTION_TIMEOUT_CLIENT_MESSAGE );\n\n        assertSecurityLogContains( \"ERROR\" );\n        assertSecurityLogContains( NON_ROUTABLE_IP );\n    }\n\n    \n    \n    public void shouldLogConnectionTimeoutFromLdapRealmWithMultipleRealms() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \", \" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n            settings.put( SecuritySettings.ldap_server, \"ldap://\" + NON_ROUTABLE_IP );\n            settings.put( SecuritySettings.ldap_connection_timeout, \"1s\" );\n        } );\n\n        assertAuthFail( \"neo\", \"abc123\" );\n\n        assertSecurityLogContains( \"ERROR\" );\n        assertSecurityLogContains( \"LDAP connection timed out\" );\n        assertSecurityLogContains( NON_ROUTABLE_IP );\n    }\n\n    @Test\n    public void shouldLogConnectionRefusedFromLdapRealm() throws Throwable\n    {\n        \n        restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings.andThen(\n                settings -> settings.put( SecuritySettings.ldap_server, \"ldap://\" + REFUSED_IP ) ) );\n\n        assertConnectionRefused( authToken( \"neo\", \"abc123\", null ),\n                LDAP_CONNECTION_REFUSED_CLIENT_MESSAGE );\n\n        assertSecurityLogContains( \"ERROR\" );\n        assertSecurityLogContains( \"auth server connection refused\" );\n        assertSecurityLogContains( REFUSED_IP );\n    }\n\n    @Test\n    public void shouldLogConnectionRefusedFromLdapRealmWithMultipleRealms() throws Throwable\n    {\n        restartNeo4jServerWithOverriddenSettings( settings ->\n        {\n            settings.put( SecuritySettings.auth_providers,\n                    SecuritySettings.NATIVE_REALM_NAME + \", \" + SecuritySettings.LDAP_REALM_NAME );\n            settings.put( SecuritySettings.native_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.native_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n            settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n            settings.put( SecuritySettings.ldap_server, \"ldap://\" + REFUSED_IP );\n        } );\n\n        assertAuthFail( \"neo\", \"abc123\" );\n\n        assertSecurityLogContains( \"ERROR\" );\n        assertSecurityLogContains( \"LDAP connection refused\" );\n        assertSecurityLogContains( REFUSED_IP );\n    }\n\n    @Test\n    public void shouldClearAuthenticationCache() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                    .andThen( settings -> settings.put( SecuritySettings.ldap_server, \"ldaps://localhost:10636\" ) ) );\n\n            \n            assertAuth( \"tank\", \"abc123\", \"ldap\" );\n            changeLDAPPassword( \"tank\", \"abc123\", \"123abc\" );\n\n            \n            reconnect();\n\n            \n            assertAuthFail( \"tank\", \"123abc\" );\n            reconnect();\n            assertAuth( \"tank\", \"abc123\", \"ldap\" );\n\n            \n            reconnect();\n            testClearAuthCache();\n            reconnect();\n\n            \n            assertAuthFail( \"tank\", \"abc123\" );\n            reconnect();\n            assertAuth( \"tank\", \"123abc\", \"ldap\" );\n        }\n    }\n\n    @Test\n    public void shouldClearAuthorizationCache() throws Throwable\n    {\n        getLdapServer().setConfidentialityRequired( true );\n\n        try ( EmbeddedTestCertificates ignore = new EmbeddedTestCertificates() )\n        {\n            \n            restartNeo4jServerWithOverriddenSettings( ldapOnlyAuthSettings\n                    .andThen( settings -> settings.put( SecuritySettings.ldap_server, \"ldaps://localhost:10636\" ) ) );\n\n            \n            assertAuth( \"tank\", \"abc123\", \"ldap\" );\n            assertReadSucceeds();\n            assertWriteSucceeds();\n\n            \n            changeLDAPGroup( \"tank\", \"abc123\", \"reader\" );\n\n            \n            reconnect();\n            assertAuth( \"tank\", \"abc123\", \"ldap\" );\n\n            \n            assertReadSucceeds();\n            assertWriteSucceeds();\n\n            \n            reconnect();\n            testClearAuthCache();\n            reconnect();\n\n            \n            assertAuth( \"tank\", \"abc123\", \"ldap\" );\n            assertReadSucceeds();\n            assertWriteFails( \"tank\", \"reader\" );\n        }\n    }\n\n    private void clearAuthCacheFromDifferentConnection() throws Exception\n    {\n        TransportConnection adminClient = cf.newInstance();\n\n        \n        Map<String,Object> authToken = authToken( \"neo4j\", \"abc123\", null );\n        adminClient.connect( address )\n                .send( util.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( util.chunk(\n                        init( \"TestClient/1.1\", authToken ) ) );\n        assertThat( adminClient, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( adminClient, util.eventuallyReceives( msgSuccess() ) );\n\n        \n        adminClient.send( util.chunk( run( \"CALL dbms.security.clearAuthCache()\" ), pullAll() ) );\n        assertThat( adminClient, util.eventuallyReceives( msgSuccess(), msgSuccess() ) );\n    }\n\n    private void assertLdapAuthorizationTimeout() throws IOException\n    {\n        \n        client.send( util.chunk( run( \"MATCH (n) RETURN n\" ), pullAll() ) );\n\n        \n        assertThat( client, util.eventuallyReceives(\n                msgFailure( Status.Security.AuthProviderTimeout, LDAP_READ_TIMEOUT_CLIENT_MESSAGE ) ) );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    private void assertLdapAuthorizationFailed() throws IOException\n    {\n        \n        client.send( util.chunk( run( \"MATCH (n) RETURN n\" ), pullAll() ) );\n\n        \n        assertThat( client, util.eventuallyReceives(\n                msgFailure( Status.Security.AuthProviderFailed, LDAP_AUTHORIZATION_FAILURE_CLIENT_MESSAGE ) ) );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    private void assertConnectionTimeout( Map<String,Object> authToken, String message ) throws Exception\n    {\n        client.connect( address )\n                .send( util.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( util.chunk(\n                        init( \"TestClient/1.1\", authToken ) ) );\n\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, util.eventuallyReceives( msgFailure( Status.Security.AuthProviderTimeout, message ) ) );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    private void assertConnectionRefused( Map<String,Object> authToken, String message ) throws Exception\n    {\n        client.connect( address )\n                .send( util.acceptedVersions( 1, 0, 0, 0 ) )\n                .send( util.chunk(\n                        init( \"TestClient/1.1\", authToken ) ) );\n\n        assertThat( client, eventuallyReceives( new byte[]{0, 0, 0, 1} ) );\n        assertThat( client, util.eventuallyReceives( msgFailure( Status.Security.AuthProviderFailed, message ) ) );\n\n        assertThat( client, eventuallyDisconnects() );\n    }\n\n    private void testClearAuthCache() throws Exception\n    {\n        assertAuth( \"neo4j\", \"abc123\" );\n\n        client.send( util.chunk( run( \"CALL dbms.security.clearAuthCache()\" ), pullAll() ) );\n\n        assertThat( client, util.eventuallyReceives( msgSuccess(), msgSuccess() ) );\n    }\n\n    private void restartServerWithoutSystemAccount()\n    {\n        restartNeo4jServerWithOverriddenSettings(\n                settings -> settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" ) );\n    }\n\n    private void assertSecurityLogContains( String message ) throws IOException\n    {\n        FileSystemAbstraction fileSystem = server.getFileSystem();\n        File workingDirectory = server.getWorkingDirectory();\n        File logFile = new File( workingDirectory, \"storeDir/logs/security.log\" );\n\n        Reader reader = fileSystem.openAsReader( logFile, Charset.forName( \"UTF-8\" ) );\n        BufferedReader bufferedReader = new BufferedReader( reader );\n        String line;\n        boolean foundError = false;\n\n        while ( (line = bufferedReader.readLine()) != null )\n        {\n            if ( line.contains( message ) )\n            {\n                foundError = true;\n            }\n        }\n        bufferedReader.close();\n        reader.close();\n\n        assertThat( \"Security log should contain message '\" + message + \"'\", foundError );\n    }\n\n    private void assertSecurityLogDoesNotContain( String message ) throws IOException\n    {\n        FileSystemAbstraction fileSystem = server.getFileSystem();\n        File workingDirectory = server.getWorkingDirectory();\n        File logFile = new File( workingDirectory, \"storeDir/logs/security.log\" );\n\n        Reader reader = fileSystem.openAsReader( logFile, Charset.forName( \"UTF-8\" ) );\n        BufferedReader bufferedReader = new BufferedReader( reader );\n        String line;\n\n        while ( (line = bufferedReader.readLine()) != null )\n        {\n            assertThat( \"Security log should not contain message '\" + message + \"'\",\n                    !line.contains( message ) );\n        }\n        bufferedReader.close();\n        reader.close();\n    }\n\n    private void modifyLDAPAttribute( String username, Object credentials, String attribute, Object value )\n            throws Throwable\n    {\n        String principal = String.format( \"cn=%s,ou=users,dc=example,dc=com\", username );\n        String principal1 = String.format( \"cn=%s,ou=users,dc=example,dc=com\", username );\n        JndiLdapContextFactory contextFactory = new JndiLdapContextFactory();\n        contextFactory.setUrl( \"ldaps://localhost:10636\" );\n        LdapContext ctx = contextFactory.getLdapContext( principal1, credentials );\n\n        ModificationItem[] mods = new ModificationItem[1];\n        mods[0] = new ModificationItem( DirContext.REPLACE_ATTRIBUTE, new BasicAttribute( attribute, value ) );\n\n        \n        ctx.modifyAttributes( principal, mods );\n        ctx.close();\n    }\n\n    private void changeLDAPPassword( String username, Object credentials, Object newCredentials ) throws Throwable\n    {\n        modifyLDAPAttribute( username, credentials, \"userpassword\", newCredentials );\n    }\n\n    private void changeLDAPGroup( String username, Object credentials, String group ) throws Throwable\n    {\n        String gid;\n        switch ( group )\n        {\n        case \"reader\":\n            gid = \"500\";\n            break;\n        case \"publisher\":\n            gid = \"501\";\n            break;\n        case \"architect\":\n            gid = \"502\";\n            break;\n        case \"admin\":\n            gid = \"503\";\n            break;\n        case \"none\":\n            gid = \"504\";\n            break;\n        default:\n            throw new IllegalArgumentException( \"Invalid group name '\" + group +\n                                                \"', expected one of none, reader, publisher, architect, or admin\" );\n        }\n        modifyLDAPAttribute( username, credentials, \"gidnumber\", gid );\n    }\n\n    private void createNativeUser( String username, String password, String... roles ) throws IOException, InvalidArgumentsException\n    {\n        GraphDatabaseFacade gds = (GraphDatabaseFacade) server.graphDatabaseService();\n        EnterpriseAuthAndUserManager authManager =\n                gds.getDependencyResolver().resolveDependency( EnterpriseAuthAndUserManager.class );\n\n        authManager.getUserManager( AuthSubject.AUTH_DISABLED, true )\n                .newUser( username, password, false );\n\n        for ( String role : roles )\n        {\n            authManager.getUserManager( AuthSubject.AUTH_DISABLED, true )\n                    .addRoleToUser( role, username );\n        }\n    }\n\n    private class DirectoryServiceWaitOnSearch implements AutoCloseable\n    {\n        private final Interceptor waitOnSearchInterceptor;\n\n        DirectoryServiceWaitOnSearch( long waitingTimeMillis )\n        {\n            waitOnSearchInterceptor = new BaseInterceptor()\n            {\n                @Override\n                public String getName()\n                {\n                    return getClass().getName();\n                }\n\n                @Override\n                public EntryFilteringCursor search( SearchOperationContext searchContext ) throws LdapException\n                {\n                    try\n                    {\n                        Thread.sleep( waitingTimeMillis );\n                    }\n                    catch ( InterruptedException e )\n                    {\n                        Thread.interrupted();\n                    }\n                    return super.search( searchContext );\n                }\n            };\n\n            try\n            {\n                getService().addFirst( waitOnSearchInterceptor );\n            }\n            catch ( LdapException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n\n        @Override\n        public void close()\n        {\n            getService().remove( waitOnSearchInterceptor.getName() );\n        }\n    }\n\n    private class DirectoryServiceFailOnSearch implements AutoCloseable\n    {\n        private final Interceptor failOnSearchInterceptor;\n\n        DirectoryServiceFailOnSearch()\n        {\n            failOnSearchInterceptor = new BaseInterceptor()\n            {\n                @Override\n                public String getName()\n                {\n                    return getClass().getName();\n                }\n\n                @Override\n                public EntryFilteringCursor search( SearchOperationContext searchContext ) throws LdapException\n                {\n                    throw new LdapOperationErrorException();\n                }\n            };\n\n            try\n            {\n                getService().addFirst( failOnSearchInterceptor );\n            }\n            catch ( LdapException e )\n            {\n                throw new RuntimeException( e );\n            }\n        }\n\n        @Override\n        public void close()\n        {\n            getService().remove( failOnSearchInterceptor.getName() );\n        }\n    }\n\n    private static Consumer<Map<Setting<?>,String>> ldapOnlyAuthSettings = settings ->\n    {\n        settings.put( SecuritySettings.auth_provider, SecuritySettings.LDAP_REALM_NAME );\n        settings.put( SecuritySettings.native_authentication_enabled, \"false\" );\n        settings.put( SecuritySettings.native_authorization_enabled, \"false\" );\n        settings.put( SecuritySettings.ldap_authentication_enabled, \"true\" );\n        settings.put( SecuritySettings.ldap_authorization_enabled, \"true\" );\n    };\n\n    private static Consumer<Map<Setting<?>,String>> activeDirectoryOnEc2Settings = settings ->\n    {\n        settings.put( SecuritySettings.auth_provider, SecuritySettings.LDAP_REALM_NAME );\n        \n        settings.put( SecuritySettings.ldap_server, \"henrik.neohq.net:389\" );\n        settings.put( SecuritySettings.ldap_authentication_user_dn_template, \"cn={0},cn=Users,dc=neo4j,dc=com\" );\n        settings.put( SecuritySettings.ldap_authorization_user_search_base, \"cn=Users,dc=neo4j,dc=com\" );\n        settings.put( SecuritySettings.ldap_authorization_user_search_filter, \"(&(objectClass=*)(CN={0}))\" );\n        settings.put( SecuritySettings.ldap_authorization_group_membership_attribute_names, \"memberOf\" );\n        settings.put( SecuritySettings.ldap_authorization_group_to_role_mapping,\n                \"'CN=Neo4j Read Only,CN=Users,DC=neo4j,DC=com'=reader;\" +\n                \"CN=Neo4j Read-Write,CN=Users,DC=neo4j,DC=com=publisher;\" +\n                \"CN=Neo4j Schema Manager,CN=Users,DC=neo4j,DC=com=architect;\" +\n                \"CN=Neo4j Administrator,CN=Users,DC=neo4j,DC=com=admin\"\n        );\n    };\n\n    private static Consumer<Map<Setting<?>,String>> activeDirectoryOnEc2NotUsingSystemAccountSettings =\n            activeDirectoryOnEc2Settings.andThen(\n                    settings -> settings.put( SecuritySettings.ldap_authorization_use_system_account, \"false\" ) );\n\n    private static Consumer<Map<Setting<?>,String>> activeDirectoryOnEc2UsingSystemAccountSettings =\n            activeDirectoryOnEc2Settings.andThen( settings ->\n            {\n                settings.put( SecuritySettings.ldap_authorization_use_system_account, \"true\" );\n                settings.put( SecuritySettings.ldap_authorization_system_username, \"Petra Selmer\" );\n                settings.put( SecuritySettings.ldap_authorization_system_password, \"S0uthAfrica\" );\n            } );\n\n    \n    \n    private class EmbeddedTestCertificates implements AutoCloseable\n    {\n        private static final String KEY_STORE = \"javax.net.ssl.keyStore\";\n        private static final String KEY_STORE_PASSWORD = \"javax.net.ssl.keyStorePassword\";\n        private static final String TRUST_STORE = \"javax.net.ssl.trustStore\";\n        private static final String TRUST_STORE_PASSWORD = \"javax.net.ssl.trustStorePassword\";\n\n        private final String keyStore = System.getProperty( KEY_STORE );\n        private final String keyStorePassword = System.getProperty( KEY_STORE_PASSWORD );\n        private final String trustStore = System.getProperty( TRUST_STORE );\n        private final String trustStorePassword = System.getProperty( TRUST_STORE_PASSWORD );\n\n        EmbeddedTestCertificates()\n        {\n            File keyStoreFile = fileFromResources( \"/neo4j_ldap_test_keystore.jks\" );\n            String keyStorePath = keyStoreFile.getAbsolutePath();\n\n            System.setProperty( KEY_STORE, keyStorePath );\n            System.setProperty( KEY_STORE_PASSWORD, \"secret\" );\n            System.setProperty( TRUST_STORE, keyStorePath );\n            System.setProperty( TRUST_STORE_PASSWORD, \"secret\" );\n        }\n\n        @Override\n        public void close()\n        {\n            resetProperty( KEY_STORE, keyStore );\n            resetProperty( KEY_STORE_PASSWORD, keyStorePassword );\n            resetProperty( TRUST_STORE, trustStore );\n            resetProperty( TRUST_STORE_PASSWORD, trustStorePassword );\n        }\n\n        private File fileFromResources( String path )\n        {\n            URL url = getClass().getResource( path );\n            return new File( url.getFile() );\n        }\n\n        private void resetProperty( String property, String value )\n        {\n            if ( value == null )\n            {\n                System.clearProperty( property );\n            }\n            else\n            {\n                System.setProperty( property, value );\n            }\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 60,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/opennetworkinglab/onos/commit/1a783729a1d7e0cd59d59a8dd3a73cdd6ac0f30d",
    "cve_id": "CVE-2018-1000615",
    "cwe_id": "Not Mapping",
    "filename": "protocols/ovsdb/rfc/src/main/java/org/onosproject/ovsdb/rfc/utils/VersionUtil.java",
    "code": "\npackage org.onosproject.ovsdb.rfc.utils;\n\n\npublic final class VersionUtil {\n\n    \n    private VersionUtil() {\n    }\n\n    public static final String DEFAULT_VERSION_STRING = \"0.0.0\";\n    private static final String FORMAT = \"(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\";\n\n    \n    public static void versionMatch(String version) {\n        if (!version.matches(FORMAT)) {\n            throw new IllegalArgumentException(\"<\" + version\n                    + \"> does not match format \" + FORMAT);\n        }\n    }\n\n    \n    public static int versionCompare(String fromVersion, String toVersion) {\n        String[] fromArr = fromVersion.split(\"\\\\.\");\n        String[] toArr = toVersion.split(\"\\\\.\");\n        int fromFirst = Integer.parseInt(fromArr[0]);\n        int fromMiddle = Integer.parseInt(fromArr[1]);\n        int fromEnd = Integer.parseInt(fromArr[2]);\n        int toFirst = Integer.parseInt(toArr[0]);\n        int toMiddle = Integer.parseInt(toArr[1]);\n        int toEnd = Integer.parseInt(toArr[2]);\n        if (fromFirst - toFirst != 0) {\n            return fromFirst - toFirst;\n        } else if (fromMiddle - toMiddle != 0) {\n            return fromMiddle - toMiddle;\n        } else {\n            return fromEnd - toEnd;\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 61,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/OpenRefine/OpenRefine/commit/6a0d7d56e4ffb420316ce7849fde881344fbf881",
    "cve_id": "CVE-2018-20157",
    "cwe_id": "CWE-611",
    "filename": "main/src/com/google/refine/importers/XmlImporter.java",
    "code": "\n\npackage com.google.refine.importers;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PushbackInputStream;\nimport java.io.Serializable;\nimport java.util.List;\n\nimport javax.xml.stream.XMLInputFactory;\nimport javax.xml.stream.XMLStreamConstants;\nimport javax.xml.stream.XMLStreamException;\nimport javax.xml.stream.XMLStreamReader;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.ImportColumnGroup;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importers.tree.TreeReader;\nimport com.google.refine.importers.tree.TreeReaderException;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class XmlImporter extends TreeImportingParserBase {\n    static final Logger logger = LoggerFactory.getLogger(XmlImporter.class);\n    \n    public XmlImporter() {\n        super(true);\n    }\n    \n    static private class PreviewParsingState {\n        int tokenCount;\n    }\n    \n    final static private int PREVIEW_PARSING_LIMIT = 1000;\n    \n    @Override\n    public ObjectNode createParserUIInitializationData(\n            ImportingJob job, List<ObjectNode> fileRecords, String format) {\n        ObjectNode options = super.createParserUIInitializationData(job, fileRecords, format);\n        try {\n            if (fileRecords.size() > 0) {\n                ObjectNode firstFileRecord = fileRecords.get(0);\n                File file = ImportingUtilities.getFile(job, firstFileRecord);\n                InputStream is = new FileInputStream(file);\n                \n                try {\n                    XMLStreamReader parser = createXMLStreamReader(is);\n                    PreviewParsingState state = new PreviewParsingState();\n\n                    while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                        int tokenType = parser.next();\n                        state.tokenCount++;\n                        if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                            ObjectNode rootElement = descendElement(parser, state);\n                            if (rootElement != null) {\n                                JSONUtilities.safePut(options, \"dom\", rootElement);\n                                break;\n                            }\n                        } else {\n                            \n                        }\n                    }\n                } catch (XMLStreamException e) {\n                    logger.warn(\"Error generating parser UI initialization data for XML file\", e);\n                } finally {\n                    is.close();\n                }\n            }\n        } catch (IOException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n\n        return options;\n    }\n    \n    final static private ObjectNode descendElement(XMLStreamReader parser, PreviewParsingState state) {\n        ObjectNode result = ParsingUtilities.mapper.createObjectNode();\n        {\n            String name = parser.getLocalName();\n            JSONUtilities.safePut(result, \"n\", name);\n            \n            String prefix = parser.getPrefix();\n            if (prefix != null) {\n                JSONUtilities.safePut(result, \"p\", prefix);\n            }\n            String nsUri = parser.getNamespaceURI();\n            if (nsUri != null) {\n                JSONUtilities.safePut(result, \"uri\", nsUri);\n            }\n        }\n        \n        int namespaceCount = parser.getNamespaceCount();\n        if (namespaceCount > 0) {\n            ArrayNode namespaces = result.putArray(\"ns\");\n            \n            for (int i = 0; i < namespaceCount; i++) {\n                ObjectNode namespace = ParsingUtilities.mapper.createObjectNode();\n                namespaces.add(namespace);\n                JSONUtilities.safePut(namespace, \"p\", parser.getNamespacePrefix(i));\n                JSONUtilities.safePut(namespace, \"uri\", parser.getNamespaceURI(i));\n            }\n        }\n        \n        int attributeCount = parser.getAttributeCount();\n        if (attributeCount > 0) {\n            ArrayNode attributes = result.putArray(\"a\");\n            \n            for (int i = 0; i < attributeCount; i++) {\n                ObjectNode attribute = ParsingUtilities.mapper.createObjectNode();\n                attributes.add(attribute);\n                JSONUtilities.safePut(attribute, \"n\", parser.getAttributeLocalName(i));\n                JSONUtilities.safePut(attribute, \"v\", parser.getAttributeValue(i));\n                String prefix = parser.getAttributePrefix(i);\n                if (prefix != null) {\n                    JSONUtilities.safePut(attribute, \"p\", prefix);\n                }\n            }\n        }\n        \n        ArrayNode children = ParsingUtilities.mapper.createArrayNode();\n        try {\n            while (parser.hasNext() && state.tokenCount < PREVIEW_PARSING_LIMIT) {\n                int tokenType = parser.next();\n                state.tokenCount++;\n                if (tokenType == XMLStreamConstants.END_ELEMENT) {\n                    break;\n                } else if (tokenType == XMLStreamConstants.START_ELEMENT) {\n                    ObjectNode childElement = descendElement(parser, state);\n                    if (childElement != null) {\n                        children.add(childElement);\n                    }\n                } else if (tokenType == XMLStreamConstants.CHARACTERS ||\n                           tokenType == XMLStreamConstants.CDATA ||\n                           tokenType == XMLStreamConstants.SPACE) {\n                    ObjectNode childElement = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(childElement, \"t\", parser.getText());\n                    children.add(childElement);\n                } else {\n                    \n                }\n            }\n        } catch (XMLStreamException e) {\n            logger.error(\"Error generating parser UI initialization data for XML file\", e);\n        }\n        \n        if (children.size() > 0) {\n        \tresult.put(\"c\", children);\n        }\n        return result;\n    }\n    \n    @Override\n    public void parseOneFile(Project project, ProjectMetadata metadata,\n            ImportingJob job, String fileSource, InputStream inputStream,\n            ImportColumnGroup rootColumnGroup, int limit, ObjectNode options,\n            List<Exception> exceptions) {\n        \n        try {\n            parseOneFile(project, metadata, job, fileSource,\n                new XmlParser(inputStream), rootColumnGroup, limit, options, exceptions);\n            \n            super.parseOneFile(project, metadata, job, fileSource, inputStream, rootColumnGroup, limit, options, exceptions);\n        } catch (XMLStreamException e) {\n            exceptions.add(e);\n        } catch (IOException e) {\n            exceptions.add(e);\n        }\n    }\n    \n    static public class XmlParser implements TreeReader {\n        final protected XMLStreamReader parser;\n        \n        public XmlParser(InputStream inputStream) throws XMLStreamException, IOException {\n            parser = createXMLStreamReader(inputStream);\n        }\n        \n        @Override\n        public Token next() throws TreeReaderException {\n            try {\n                if (!parser.hasNext()) {\n                    throw new TreeReaderException(\"End of XML stream\");\n                }\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            int currentToken = -1;\n            try {\n                currentToken = parser.next();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n            \n            return mapToToken(currentToken);\n        }\n        \n        protected Token mapToToken(int token) {\n            switch(token){\n                case XMLStreamConstants.START_ELEMENT: return Token.StartEntity;\n                case XMLStreamConstants.END_ELEMENT: return Token.EndEntity;\n                case XMLStreamConstants.CHARACTERS: return Token.Value;\n                case XMLStreamConstants.START_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.END_DOCUMENT: return Token.Ignorable;\n                case XMLStreamConstants.SPACE: return Token.Value;\n                case XMLStreamConstants.PROCESSING_INSTRUCTION: return Token.Ignorable;\n                case XMLStreamConstants.NOTATION_DECLARATION: return Token.Ignorable;\n                case XMLStreamConstants.NAMESPACE: return Token.Ignorable;\n                case XMLStreamConstants.ENTITY_REFERENCE: return Token.Ignorable;\n                case XMLStreamConstants.DTD: return Token.Ignorable;\n                case XMLStreamConstants.COMMENT: return Token.Ignorable;\n                case XMLStreamConstants.CDATA: return Token.Ignorable;\n                case XMLStreamConstants.ATTRIBUTE: return Token.Ignorable;\n                default:\n                    return Token.Ignorable;\n            }\n        }\n        \n        @Override\n        public Token current() throws TreeReaderException {\n            return this.mapToToken(parser.getEventType());\n        }\n        \n        @Override\n        public boolean hasNext() throws TreeReaderException {\n            try {\n                return parser.hasNext();\n            } catch (XMLStreamException e) {\n                throw new TreeReaderException(e);\n            }\n        }\n        \n        @Override\n        public String getFieldName() throws TreeReaderException {\n            try {\n                return parser.getLocalName();\n            } catch (IllegalStateException e) {\n                return null;\n            }\n        }\n        \n        @Override\n        public String getPrefix(){\n            return parser.getPrefix();\n        }\n        \n        @Override\n        public String getFieldValue(){\n            return parser.getText();\n        }\n    \n        @Override\n        public Serializable getValue() {\n            \n            return getFieldValue();\n        }\n\n        @Override\n        public int getAttributeCount(){\n            return parser.getAttributeCount();\n        }\n        \n        @Override\n        public String getAttributeValue(int index){\n            return parser.getAttributeValue(index);\n        }\n        \n        @Override\n        public String getAttributePrefix(int index){\n            return parser.getAttributePrefix(index);\n        }\n        \n        @Override\n        public String getAttributeLocalName(int index){\n            return parser.getAttributeLocalName(index);\n        }\n    }\n    \n    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }\n    \n    final static private InputStream wrapPrefixRemovingInputStream(InputStream inputStream)\n            throws XMLStreamException, IOException {\n        PushbackInputStream pis = new PushbackInputStream(inputStream);\n        int b;\n        int count = 0;\n        while (count < 100 && (b = pis.read()) >= 0) {\n            if (++count > 100) {\n                throw new XMLStreamException(\n                    \"File starts with too much non-XML content to skip over\");\n            } else if (b == '<') {\n                pis.unread(b);\n                break;\n            }\n        }\n        return pis;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 61,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/OpenRefine/OpenRefine/commit/6a0d7d56e4ffb420316ce7849fde881344fbf881",
    "cve_id": "CVE-2018-20157",
    "cwe_id": "CWE-611",
    "filename": "main/tests/server/src/com/google/refine/tests/importers/XmlImporterTests.java",
    "code": "\n\npackage com.google.refine.tests.importers;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.LinkedList;\n\nimport org.slf4j.LoggerFactory;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterMethod;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.BeforeTest;\nimport org.testng.annotations.Test;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.importers.XmlImporter;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.model.Row;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\n\npublic class XmlImporterTests extends ImporterTest {\n\n    @Override\n    @BeforeTest\n    public void init() {\n        logger = LoggerFactory.getLogger(this.getClass());\n    }\n    \n    \n    ByteArrayInputStream inputStream = null;\n\n    \n    XmlImporter SUT = null;\n    \n    @Override\n    @BeforeMethod\n    public void setUp(){\n        super.setUp();\n        SUT = new XmlImporter();\n    }\n\n    @Override\n    @AfterMethod\n    public void tearDown() {\n        SUT = null;\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                \n            }\n            inputStream = null;\n        }\n        super.tearDown();\n    }\n\n    @Test\n    public void canParseSample(){\n        RunTest(getSample());\n\n        log(project);\n        assertProjectCreated(project, 4, 6);\n\n        Row row = project.rows.get(0);\n        Assert.assertNotNull(row);\n        Assert.assertNotNull(row.getCell(1));\n        Assert.assertEquals(row.getCell(1).value, \"Author 1, The\");\n    }\n    \n    @Test\n    public void canParseDeeplyNestedSample(){\n        RunTest(getDeeplyNestedSample(), getNestedOptions(job, SUT));\n\n        log(project);\n        assertProjectCreated(project, 4, 6);\n\n        Row row = project.rows.get(0);\n        Assert.assertNotNull(row);\n        Assert.assertNotNull(row.getCell(1));\n        Assert.assertEquals(row.getCell(1).value, \"Author 1, The\");\n    }\n    \n    @Test\n    public void canParseSampleWithMixedElement(){\n        RunTest(getMixedElementSample(), getNestedOptions(job, SUT));\n\n        log(project);\n        assertProjectCreated(project, 4, 6);\n        \n        Row row = project.rows.get(0);\n        Assert.assertNotNull(row);\n        Assert.assertNotNull(row.getCell(1));\n        Assert.assertEquals(row.getCell(1).value, \"Author 1, The\");\n    }\n\n    @Test\n    public void canParseSampleWithDuplicateNestedElements(){\n        RunTest(getSampleWithDuplicateNestedElements());\n\n        log(project);\n        assertProjectCreated(project, 4, 12);\n\n        Row row = project.rows.get(0);\n        Assert.assertNotNull(row);\n        Assert.assertEquals(row.cells.size(), 4);\n        Assert.assertNotNull(row.getCell(1));\n        Assert.assertEquals(row.getCell(1).value, \"Author 1, The\");\n        Assert.assertEquals(project.rows.get(1).getCell(1).value, \"Author 1, Another\");\n    }\n\n    @Test\n    public void testCanParseLineBreak(){\n\n        RunTest(getSampleWithLineBreak());\n\n        log(project);\n        assertProjectCreated(project, 4, 6);\n\n        Row row = project.rows.get(3);\n        Assert.assertNotNull(row);\n        Assert.assertEquals(row.cells.size(), 4);\n        Assert.assertNotNull(row.getCell(1));\n        Assert.assertEquals(row.getCell(1).value, \"With line\\n break\");\n    }\n\n    @Test\n    public void testElementsWithVaryingStructure(){\n        RunTest(getSampleWithVaryingStructure());\n\n        log(project);\n        assertProjectCreated(project, 5, 6);\n\n        Assert.assertEquals(project.columnModel.getColumnByCellIndex(4).getName(), \"book - genre\");\n\n        Row row0 = project.rows.get(0);\n        Assert.assertNotNull(row0);\n        Assert.assertEquals(row0.cells.size(),4);\n\n        Row row5  = project.rows.get(5);\n        Assert.assertNotNull(row5);\n        Assert.assertEquals(row5.cells.size(),5);\n    }\n\n    @Test\n    public void testElementWithNestedTree(){\n        RunTest(getSampleWithTreeStructure());\n        log(project);\n        assertProjectCreated(project, 5, 6);\n\n        Assert.assertEquals(project.columnModel.columnGroups.size(),1);\n        Assert.assertEquals(project.columnModel.columnGroups.get(0).keyColumnIndex, 2);\n        Assert.assertEquals(project.columnModel.columnGroups.get(0).startColumnIndex, 2);\n        Assert.assertNull(project.columnModel.columnGroups.get(0).parentGroup);\n        Assert.assertEquals(project.columnModel.columnGroups.get(0).subgroups.size(),0);\n        Assert.assertEquals(project.columnModel.columnGroups.get(0).columnSpan,2);\n    }\n\n    \n\n    public static String getTypicalElement(int id){\n        return \"<book id=\\\"\" + id + \"\\\">\" +\n        \"<author>Author \" + id + \", The</author>\" +\n        \"<title>Book title \" + id + \"</title>\" +\n        \"<publish_date>2010-05-26</publish_date>\" +\n        \"</book>\";\n    }\n\n    public static String getElementWithDuplicateSubElement(int id){\n        return \"<book id=\\\"\" + id + \"\\\">\" +\n        \"<authors>\" +\n        \"<author>Author \" + id + \", The</author>\" +\n        \"<author>Author \" + id + \", Another</author>\" +\n        \"</authors>\" +\n        \"<title>Book title \" + id + \"</title>\" +\n        \"<publish_date>2010-05-26</publish_date>\" +\n        \"</book>\";\n    }\n\n    public static String getSample(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><library>\");\n        for(int i = 1; i < 7; i++){\n            sb.append(getTypicalElement(i));\n        }\n        sb.append(\"</library>\");\n        return sb.toString();\n    }\n    \n    public static ObjectNode getOptions(ImportingJob job, TreeImportingParserBase parser) {\n        ObjectNode options = parser.createParserUIInitializationData(\n                job, new LinkedList<>(), \"text/json\");\n        \n        ArrayNode path = ParsingUtilities.mapper.createArrayNode();\n        JSONUtilities.append(path, \"library\");\n        JSONUtilities.append(path, \"book\");\n        \n        JSONUtilities.safePut(options, \"recordPath\", path);\n        return options;\n    }\n    \n    public static ObjectNode getNestedOptions(ImportingJob job, TreeImportingParserBase parser) {\n        ObjectNode options = parser.createParserUIInitializationData(\n                job, new LinkedList<>(), \"text/json\");\n        \n        ArrayNode path = ParsingUtilities.mapper.createArrayNode();\n        JSONUtilities.append(path, \"nest\");\n        JSONUtilities.append(path, \"nest2\");\n        JSONUtilities.append(path, \"library\");\n        JSONUtilities.append(path, \"book\");\n        \n        JSONUtilities.safePut(options, \"recordPath\", path);\n        return options;\n    }\n    \n    public static String getDeeplyNestedSample(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><nest><nest2><library>\");\n        for(int i = 1; i < 7; i++){\n            sb.append(getTypicalElement(i));\n        }\n        sb.append(\"</library></nest2>\");\n        sb.append(\"<anElement>asdf</anElement></nest>\");\n        return sb.toString();\n    }\n    \n    public static String getMixedElementSample(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><nest>\");\n        sb.append(\"somemixeduptext\");\n        sb.append(\"<nest2><library>\");\n        for(int i = 1; i < 7; i++){\n            sb.append(getTypicalElement(i));\n        }\n        sb.append(\"</library></nest2>\");\n        sb.append(\"<anElement>asdf</anElement></nest>\");\n        return sb.toString();\n    }\n\n    public static String getSampleWithDuplicateNestedElements(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><library>\");\n        for(int i = 1; i < 7; i++){\n            sb.append(getElementWithDuplicateSubElement(i));\n        }\n        sb.append(\"</library>\");\n        return sb.toString();\n\n    }\n\n    public static String getSampleWithLineBreak(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><library>\");\n        for(int i = 1; i < 4; i++){\n            sb.append(getTypicalElement(i));\n        }\n        sb.append(\"<book id=\\\"4\\\">\" +\n                \"<author>With line\\n break</author>\" +\n                \"<title>Book title 4</title>\" +\n                \"<publish_date>2010-05-26</publish_date>\" +\n                \"</book>\");\n        sb.append(getTypicalElement(5));\n        sb.append(getTypicalElement(6));\n        sb.append(\"</library>\");\n        return sb.toString();\n    }\n\n    public static String getSampleWithVaryingStructure(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><library>\");\n        for(int i = 1; i < 6; i++){\n            sb.append(getTypicalElement(i));\n        }\n        sb.append(\"<book id=\\\"6\\\">\" +\n                \"<author>Author 6, The</author>\" +\n                \"<title>Book title 6</title>\" +\n                \"<genre>New element not seen in other records</genre>\" +\n                \"<publish_date>2010-05-26</publish_date>\" +\n                \"</book>\");\n        sb.append(\"</library>\");\n        return sb.toString();\n    }\n\n    public static String getSampleWithTreeStructure(){\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"<?xml version=\\\"1.0\\\"?><library>\");\n        for(int i = 1; i < 7; i++){\n            sb.append(\"<book id=\\\"\" + i + \"\\\">\" +\n                    \"<author><author-name>Author \" + i + \", The</author-name>\" +\n                    \"<author-dob>1950-0\" + i + \"-15</author-dob></author>\" +\n                    \"<title>Book title \" + i + \"</title>\" +\n                    \"<publish_date>2010-05-26</publish_date>\" +\n                    \"</book>\");\n        }\n        sb.append(\"</library>\");\n        return sb.toString();\n    }\n\n    private void RunTest(String testString){\n        RunTest(testString, getOptions(job, SUT));\n    }\n    \n    private void RunTest(String testString, ObjectNode objectNode) {\n        try {\n            inputStream = new ByteArrayInputStream(testString.getBytes( \"UTF-8\" ));\n        } catch (UnsupportedEncodingException e1) {\n            Assert.fail();\n        }\n\n        try {\n            parseOneFile(SUT, inputStream, objectNode);\n        } catch (Exception e) {\n            e.printStackTrace();\n            Assert.fail();\n        }\n    }\n    \n    @Override\n    protected void parseOneFile(TreeImportingParserBase parser, InputStream inputStream, ObjectNode options) {\n        parseOneInputStream(parser, inputStream, options);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 62,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/OpenRefine/OpenRefine/commit/e243e73e4064de87a913946bd320fbbe246da656",
    "cve_id": "CVE-2018-19859",
    "cwe_id": "CWE-22",
    "filename": "main/src/com/google/refine/importing/ImportingUtilities.java",
    "code": "\n\npackage com.google.refine.importing;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.ProgressListener;\nimport org.apache.commons.fileupload.disk.DiskFileItemFactory;\nimport org.apache.commons.fileupload.servlet.ServletFileUpload;\nimport org.apache.commons.fileupload.util.Streams;\nimport org.apache.http.HttpEntity;\nimport org.apache.http.HttpResponse;\nimport org.apache.http.auth.AuthScope;\nimport org.apache.http.auth.UsernamePasswordCredentials;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DecompressingHttpClient;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.apache.http.util.EntityUtils;\nimport org.apache.tools.bzip2.CBZip2InputStream;\nimport org.apache.tools.tar.TarEntry;\nimport org.apache.tools.tar.TarInputStream;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectManager;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.RefineServlet;\nimport com.google.refine.importing.ImportingManager.Format;\nimport com.google.refine.importing.UrlRewriter.Result;\nimport com.google.refine.model.Project;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class ImportingUtilities {\n    final static protected Logger logger = LoggerFactory.getLogger(\"importing-utilities\");\n    \n    static public interface Progress {\n        public void setProgress(String message, int percent);\n        public boolean isCanceled();\n    }\n    \n    static public void loadDataAndPrepareJob(\n        HttpServletRequest request,\n        HttpServletResponse response,\n        Properties parameters,\n        final ImportingJob job,\n        ObjectNode config) throws IOException, ServletException {\n        \n        ObjectNode retrievalRecord = ParsingUtilities.mapper.createObjectNode();\n        JSONUtilities.safePut(config, \"retrievalRecord\", retrievalRecord);\n        JSONUtilities.safePut(config, \"state\", \"loading-raw-data\");\n        \n        final ObjectNode progress = ParsingUtilities.mapper.createObjectNode();\n        JSONUtilities.safePut(config, \"progress\", progress);\n        try {\n            ImportingUtilities.retrieveContentFromPostRequest(\n                request,\n                parameters,\n                job.getRawDataDir(),\n                retrievalRecord,\n                new Progress() {\n                    @Override\n                    public void setProgress(String message, int percent) {\n                        if (message != null) {\n                            JSONUtilities.safePut(progress, \"message\", message);\n                        }\n                        JSONUtilities.safePut(progress, \"percent\", percent);\n                    }\n                    @Override\n                    public boolean isCanceled() {\n                        return job.canceled;\n                    }\n                }\n            );\n        } catch (Exception e) {\n            JSONUtilities.safePut(config, \"state\", \"error\");\n            JSONUtilities.safePut(config, \"error\", \"Error uploading data\");\n            JSONUtilities.safePut(config, \"errorDetails\", e.getLocalizedMessage());\n            return;\n        }\n        \n        ArrayNode fileSelectionIndexes = ParsingUtilities.mapper.createArrayNode();\n        JSONUtilities.safePut(config, \"fileSelection\", fileSelectionIndexes);\n        \n        String bestFormat = ImportingUtilities.autoSelectFiles(job, retrievalRecord, fileSelectionIndexes);\n        bestFormat = ImportingUtilities.guessBetterFormat(job, bestFormat);\n        \n        ArrayNode rankedFormats = ParsingUtilities.mapper.createArrayNode();\n        ImportingUtilities.rankFormats(job, bestFormat, rankedFormats);\n        JSONUtilities.safePut(config, \"rankedFormats\", rankedFormats);\n        \n        JSONUtilities.safePut(config, \"state\", \"ready\");\n        JSONUtilities.safePut(config, \"hasData\", true);\n        config.remove(\"progress\");\n    }\n    \n    static public void updateJobWithNewFileSelection(ImportingJob job, ArrayNode fileSelectionArray) {\n        job.setFileSelection(fileSelectionArray);\n        \n        String bestFormat = ImportingUtilities.getCommonFormatForSelectedFiles(job, fileSelectionArray);\n        bestFormat = ImportingUtilities.guessBetterFormat(job, bestFormat);\n        \n        ArrayNode rankedFormats = ParsingUtilities.mapper.createArrayNode();\n        ImportingUtilities.rankFormats(job, bestFormat, rankedFormats);\n        job.setRankedFormats(rankedFormats);\n    }\n    \n    static public void retrieveContentFromPostRequest(\n        HttpServletRequest request,\n        Properties parameters,\n        File rawDataDir,\n        ObjectNode retrievalRecord,\n        final Progress progress\n    ) throws Exception {\n        ArrayNode fileRecords = ParsingUtilities.mapper.createArrayNode();\n        JSONUtilities.safePut(retrievalRecord, \"files\", fileRecords);\n        \n        int clipboardCount = 0;\n        int uploadCount = 0;\n        int downloadCount = 0;\n        int archiveCount = 0;\n        \n        \n        \n        final SavingUpdate update = new SavingUpdate() {\n            @Override\n            public void savedMore() {\n                progress.setProgress(null, calculateProgressPercent(totalExpectedSize, totalRetrievedSize));\n            }\n            @Override\n            public boolean isCanceled() {\n                return progress.isCanceled();\n            }\n        };\n        \n        DiskFileItemFactory fileItemFactory = new DiskFileItemFactory();\n        \n        ServletFileUpload upload = new ServletFileUpload(fileItemFactory);\n        upload.setProgressListener(new ProgressListener() {\n            boolean setContentLength = false;\n            long lastBytesRead = 0;\n            \n            @Override\n            public void update(long bytesRead, long contentLength, int itemCount) {\n                if (!setContentLength) {\n                    \n                    if (contentLength >= 0) {\n                        update.totalExpectedSize += contentLength;\n                        setContentLength = true;\n                    }\n                }\n                if (setContentLength) {\n                    update.totalRetrievedSize += (bytesRead - lastBytesRead);\n                    lastBytesRead = bytesRead;\n                    \n                    update.savedMore();\n                }\n            }\n        });\n\n        @SuppressWarnings(\"unchecked\")\n        List<FileItem> tempFiles = (List<FileItem>)upload.parseRequest(request);\n        \n        progress.setProgress(\"Uploading data ...\", -1);\n        parts: for (FileItem fileItem : tempFiles) {\n            if (progress.isCanceled()) {\n                break;\n            }\n            \n            InputStream stream = fileItem.getInputStream();\n            \n            String name = fileItem.getFieldName().toLowerCase();\n            if (fileItem.isFormField()) {\n                if (name.equals(\"clipboard\")) {\n                    String encoding = request.getCharacterEncoding();\n                    if (encoding == null) {\n                        encoding = \"UTF-8\";\n                    }\n                    \n                    File file = allocateFile(rawDataDir, \"clipboard.txt\");\n                    \n                    ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(fileRecord, \"origin\", \"clipboard\");\n                    JSONUtilities.safePut(fileRecord, \"declaredEncoding\", encoding);\n                    JSONUtilities.safePut(fileRecord, \"declaredMimeType\", (String) null);\n                    JSONUtilities.safePut(fileRecord, \"format\", \"text\");\n                    JSONUtilities.safePut(fileRecord, \"fileName\", \"(clipboard)\");\n                    JSONUtilities.safePut(fileRecord, \"location\", getRelativePath(file, rawDataDir));\n                    \n                    progress.setProgress(\"Uploading pasted clipboard text\",\n                        calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));\n                    \n                    JSONUtilities.safePut(fileRecord, \"size\", saveStreamToFile(stream, file, null));\n                    JSONUtilities.append(fileRecords, fileRecord);\n                    \n                    clipboardCount++;\n                    \n                } else if (name.equals(\"download\")) {\n                    String urlString = Streams.asString(stream);\n                    URL url = new URL(urlString);\n                    \n                    ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(fileRecord, \"origin\", \"download\");\n                    JSONUtilities.safePut(fileRecord, \"url\", urlString);\n                    \n                    for (UrlRewriter rewriter : ImportingManager.urlRewriters) {\n                        Result result = rewriter.rewrite(urlString);\n                        if (result != null) {\n                            urlString = result.rewrittenUrl;\n                            url = new URL(urlString);\n                            \n                            JSONUtilities.safePut(fileRecord, \"url\", urlString);\n                            JSONUtilities.safePut(fileRecord, \"format\", result.format);\n                            if (!result.download) {\n                                downloadCount++;\n                                JSONUtilities.append(fileRecords, fileRecord);\n                                continue parts;\n                            }\n                        }\n                    }\n\n                    if (\"http\".equals(url.getProtocol()) || \"https\".equals(url.getProtocol())) {\n                        DefaultHttpClient client = new DefaultHttpClient();\n                        DecompressingHttpClient httpclient = \n                                new DecompressingHttpClient(client);\n                        HttpGet httpGet = new HttpGet(url.toURI());\n                        httpGet.setHeader(\"User-Agent\", RefineServlet.getUserAgent());\n                        if (\"https\".equals(url.getProtocol())) {\n                            \n                            String userinfo = url.getUserInfo();\n                            if (userinfo != null) {\n                                int s = userinfo.indexOf(':');\n                                if (s > 0) {\n                                    String user = userinfo.substring(0, s);\n                                    String pw = userinfo.substring(s + 1, userinfo.length());\n                                    client.getCredentialsProvider().setCredentials(\n                                            new AuthScope(url.getHost(), 443),\n                                            new UsernamePasswordCredentials(user, pw));\n                                }\n                            }\n                        }\n \n                        HttpResponse response = httpclient.execute(httpGet);\n                        \n                        try {\n                            response.getStatusLine();\n                            HttpEntity entity = response.getEntity();\n                            if (entity == null) {\n                                throw new Exception(\"No content found in \" + url.toString());\n                            }\n                            InputStream stream2 = entity.getContent();\n                            String encoding = null;\n                            if (entity.getContentEncoding() != null) {\n                                encoding = entity.getContentEncoding().getValue();\n                            }\n                            JSONUtilities.safePut(fileRecord, \"declaredEncoding\", encoding);\n                            String contentType = null;\n                            if (entity.getContentType() != null) {\n                                contentType = entity.getContentType().getValue();\n                            }\n                            JSONUtilities.safePut(fileRecord, \"declaredMimeType\", contentType);\n                            if (saveStream(stream2, url, rawDataDir, progress, update, \n                                    fileRecord, fileRecords,\n                                    entity.getContentLength())) {\n                                archiveCount++;\n                            }\n                            downloadCount++;\n                            EntityUtils.consume(entity);\n                        } finally {\n                            httpGet.releaseConnection();\n                        }\n                    } else {\n                        \n                        URLConnection urlConnection = url.openConnection();\n                        urlConnection.setConnectTimeout(5000);\n                        urlConnection.connect();\n                        InputStream stream2 = urlConnection.getInputStream();\n                        JSONUtilities.safePut(fileRecord, \"declaredEncoding\", \n                                urlConnection.getContentEncoding());\n                        JSONUtilities.safePut(fileRecord, \"declaredMimeType\", \n                                urlConnection.getContentType());\n                        try {\n                            if (saveStream(stream2, url, rawDataDir, progress, \n                                    update, fileRecord, fileRecords,\n                                    urlConnection.getContentLength())) {\n                                archiveCount++;\n                            }\n                            downloadCount++;\n                        } finally {\n                            stream2.close();\n                        }\n                    }\n                } else {\n                    String value = Streams.asString(stream);\n                    parameters.put(name, value);\n                    \n\n                    \n                }\n\n            } else { \n                String fileName = fileItem.getName();\n                if (fileName.length() > 0) {\n                    long fileSize = fileItem.getSize();\n                    \n                    File file = allocateFile(rawDataDir, fileName);\n                    \n                    ObjectNode fileRecord = ParsingUtilities.mapper.createObjectNode();\n                    JSONUtilities.safePut(fileRecord, \"origin\", \"upload\");\n                    JSONUtilities.safePut(fileRecord, \"declaredEncoding\", request.getCharacterEncoding());\n                    JSONUtilities.safePut(fileRecord, \"declaredMimeType\", fileItem.getContentType());\n                    JSONUtilities.safePut(fileRecord, \"fileName\", fileName);\n                    JSONUtilities.safePut(fileRecord, \"location\", getRelativePath(file, rawDataDir));\n\n                    progress.setProgress(\n                        \"Saving file \" + fileName + \" locally (\" + formatBytes(fileSize) + \" bytes)\",\n                        calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));\n                    \n                    JSONUtilities.safePut(fileRecord, \"size\", saveStreamToFile(stream, file, null));\n                    if (postProcessRetrievedFile(rawDataDir, file, fileRecord, fileRecords, progress)) {\n                        archiveCount++;\n                    }\n                    \n                    uploadCount++;\n                }\n            }\n            \n            stream.close();\n        }\n        \n        \n        for (FileItem fileItem : tempFiles) {\n            fileItem.delete();\n        }\n        \n        JSONUtilities.safePut(retrievalRecord, \"uploadCount\", uploadCount);\n        JSONUtilities.safePut(retrievalRecord, \"downloadCount\", downloadCount);\n        JSONUtilities.safePut(retrievalRecord, \"clipboardCount\", clipboardCount);\n        JSONUtilities.safePut(retrievalRecord, \"archiveCount\", archiveCount);\n    }\n\n    private static boolean saveStream(InputStream stream, URL url, File rawDataDir, final Progress progress,\n            final SavingUpdate update, ObjectNode fileRecord, ArrayNode fileRecords, long length)\n            throws IOException, Exception {\n        String localname = url.getPath();\n        if (localname.isEmpty() || localname.endsWith(\"/\")) {\n            localname = localname + \"temp\";\n        }\n        File file = allocateFile(rawDataDir, localname);\n\n        JSONUtilities.safePut(fileRecord, \"fileName\", file.getName());\n        JSONUtilities.safePut(fileRecord, \"location\", getRelativePath(file, rawDataDir));\n\n        update.totalExpectedSize += length;\n\n        progress.setProgress(\"Downloading \" + url.toString(),\n            calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));\n        \n        long actualLength = saveStreamToFile(stream, file, update);\n        JSONUtilities.safePut(fileRecord, \"size\", actualLength);\n        if (actualLength == 0) {\n            throw new Exception(\"No content found in \" + url.toString());\n        } else if (length >= 0) {\n            update.totalExpectedSize += (actualLength - length);\n        } else {\n            update.totalExpectedSize += actualLength;\n        }\n        progress.setProgress(\"Saving \" + url.toString() + \" locally\",\n            calculateProgressPercent(update.totalExpectedSize, update.totalRetrievedSize));\n        return postProcessRetrievedFile(rawDataDir, file, fileRecord, fileRecords, progress);\n    }\n    \n    static public String getRelativePath(File file, File dir) {\n        String location = file.getAbsolutePath().substring(dir.getAbsolutePath().length());\n        return (location.startsWith(File.separator)) ? location.substring(1) : location;\n    }\n    \n    static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }\n    \n    static public Reader getFileReader(ImportingJob job, ObjectNode fileRecord, String commonEncoding)\n        throws FileNotFoundException {\n        \n        return getFileReader(getFile(job, JSONUtilities.getString(fileRecord, \"location\", \"\")), fileRecord, commonEncoding);\n    }\n    \n    static public Reader getFileReader(File file, ObjectNode fileRecord, String commonEncoding) throws FileNotFoundException {\n        return getReaderFromStream(new FileInputStream(file), fileRecord, commonEncoding);\n    }\n    \n    static public Reader getReaderFromStream(InputStream inputStream, ObjectNode fileRecord, String commonEncoding) {\n        String encoding = getEncoding(fileRecord);\n        if (encoding == null) {\n            encoding = commonEncoding;\n        }\n        if (encoding != null) {\n            try {\n                return new InputStreamReader(inputStream, encoding);\n            } catch (UnsupportedEncodingException e) {\n                \n            }\n        }\n        return new InputStreamReader(inputStream);\n    }\n    \n    static public File getFile(ImportingJob job, ObjectNode fileRecord) {\n        return getFile(job, JSONUtilities.getString(fileRecord, \"location\", \"\"));\n    }\n    \n    static public File getFile(ImportingJob job, String location) {\n        return new File(job.getRawDataDir(), location);\n    }\n    \n    static public String getFileSource(ObjectNode fileRecord) {\n        return JSONUtilities.getString(\n            fileRecord,\n            \"url\",\n            JSONUtilities.getString(fileRecord, \"fileName\", \"unknown\")\n        );\n    }\n    \n    static private abstract class SavingUpdate {\n        public long totalExpectedSize = 0;\n        public long totalRetrievedSize = 0;\n        \n        abstract public void savedMore();\n        abstract public boolean isCanceled();\n    }\n    static public long saveStreamToFile(InputStream stream, File file, SavingUpdate update) throws IOException {\n        long length = 0;\n        FileOutputStream fos = new FileOutputStream(file);\n        try {\n            byte[] bytes = new byte[16*1024];\n            int c;\n            while ((update == null || !update.isCanceled()) && (c = stream.read(bytes)) > 0) {\n                fos.write(bytes, 0, c);\n                length += c;\n\n                if (update != null) {\n                    update.totalRetrievedSize += c;\n                    update.savedMore();\n                }\n            }\n            return length;\n        } finally {\n            fos.close();\n        }\n    }\n    \n    static public boolean postProcessRetrievedFile(\n            File rawDataDir, File file, ObjectNode fileRecord, ArrayNode fileRecords, final Progress progress) {\n        \n        String mimeType = JSONUtilities.getString(fileRecord, \"declaredMimeType\", null);\n        String contentEncoding = JSONUtilities.getString(fileRecord, \"declaredEncoding\", null);\n        \n        InputStream archiveIS = tryOpenAsArchive(file, mimeType, contentEncoding);\n        if (archiveIS != null) {\n            try {\n                if (explodeArchive(rawDataDir, archiveIS, fileRecord, fileRecords, progress)) {\n                    file.delete();\n                    return true;\n                }\n            } finally {\n                try {\n                    archiveIS.close();\n                } catch (IOException e) {\n                    \n                }\n            }\n        }\n        \n        InputStream uncompressedIS = tryOpenAsCompressedFile(file, mimeType, contentEncoding);\n        if (uncompressedIS != null) {\n            try {\n                File file2 = uncompressFile(rawDataDir, uncompressedIS, fileRecord, progress);\n                \n                file.delete();\n                file = file2;\n            } catch (IOException e) {\n                \n                e.printStackTrace();\n            } finally {\n                try {\n                    uncompressedIS.close();\n                } catch (IOException e) {\n                    \n                }\n            }\n        }\n        \n        postProcessSingleRetrievedFile(file, fileRecord);\n        JSONUtilities.append(fileRecords, fileRecord);\n        \n        return false;\n    }\n    \n    static public void postProcessSingleRetrievedFile(File file, ObjectNode fileRecord) {\n        if (!fileRecord.has(\"format\")) {\n            JSONUtilities.safePut(fileRecord, \"format\",\n                ImportingManager.getFormat(\n                    file.getName(),\n                    JSONUtilities.getString(fileRecord, \"declaredMimeType\", null)));\n        }\n    }\n    \n    static public InputStream tryOpenAsArchive(File file, String mimeType) {\n        return tryOpenAsArchive(file, mimeType, null);\n    }\n    \n    static public InputStream tryOpenAsArchive(File file, String mimeType, String contentType) {\n        String fileName = file.getName();\n        try {\n            if (fileName.endsWith(\".tar.gz\") || fileName.endsWith(\".tgz\")) {\n                return new TarInputStream(new GZIPInputStream(new FileInputStream(file)));\n            } else if (fileName.endsWith(\".tar.bz2\")) {\n                return new TarInputStream(new CBZip2InputStream(new FileInputStream(file)));\n            } else if (fileName.endsWith(\".tar\") || \"application/x-tar\".equals(contentType)) {\n                return new TarInputStream(new FileInputStream(file));\n            } else if (fileName.endsWith(\".zip\") \n                    || \"application/x-zip-compressed\".equals(contentType)\n                    || \"application/zip\".equals(contentType) \n                    || \"application/x-compressed\".equals(contentType)\n                    || \"multipar/x-zip\".equals(contentType)) {\n                return new ZipInputStream(new FileInputStream(file));\n            } else if (fileName.endsWith(\".kmz\")) {\n                return new ZipInputStream(new FileInputStream(file));\n            }\n        } catch (IOException e) {\n        }\n        return null;\n    }\n    \n    static public boolean explodeArchive(\n        File rawDataDir,\n        InputStream archiveIS,\n        ObjectNode archiveFileRecord,\n        ArrayNode fileRecords,\n        final Progress progress\n    ) {\n        if (archiveIS instanceof TarInputStream) {\n            TarInputStream tis = (TarInputStream) archiveIS;\n            try {\n                TarEntry te;\n                while (!progress.isCanceled() && (te = tis.getNextEntry()) != null) {\n                    if (!te.isDirectory()) {\n                        String fileName2 = te.getName();\n                        File file2 = allocateFile(rawDataDir, fileName2);\n                        \n                        progress.setProgress(\"Extracting \" + fileName2, -1);\n                        \n                        ObjectNode fileRecord2 = ParsingUtilities.mapper.createObjectNode();\n                        JSONUtilities.safePut(fileRecord2, \"origin\", JSONUtilities.getString(archiveFileRecord, \"origin\", null));\n                        JSONUtilities.safePut(fileRecord2, \"declaredEncoding\", (String) null);\n                        JSONUtilities.safePut(fileRecord2, \"declaredMimeType\", (String) null);\n                        JSONUtilities.safePut(fileRecord2, \"fileName\", fileName2);\n                        JSONUtilities.safePut(fileRecord2, \"archiveFileName\", JSONUtilities.getString(archiveFileRecord, \"fileName\", null));\n                        JSONUtilities.safePut(fileRecord2, \"location\", getRelativePath(file2, rawDataDir));\n\n                        JSONUtilities.safePut(fileRecord2, \"size\", saveStreamToFile(tis, file2, null));\n                        postProcessSingleRetrievedFile(file2, fileRecord2);\n                        \n                        JSONUtilities.append(fileRecords, fileRecord2);\n                    }\n                }\n            } catch (IOException e) {\n                \n                e.printStackTrace();\n            }\n            return true;\n        } else if (archiveIS instanceof ZipInputStream) {\n            ZipInputStream zis = (ZipInputStream) archiveIS;\n            try {\n                ZipEntry ze;\n                while (!progress.isCanceled() && (ze = zis.getNextEntry()) != null) {\n                    if (!ze.isDirectory()) {\n                        String fileName2 = ze.getName();\n                        File file2 = allocateFile(rawDataDir, fileName2);\n                        \n                        progress.setProgress(\"Extracting \" + fileName2, -1);\n                        \n                        ObjectNode fileRecord2 = ParsingUtilities.mapper.createObjectNode();\n                        JSONUtilities.safePut(fileRecord2, \"origin\", JSONUtilities.getString(archiveFileRecord, \"origin\", null));\n                        JSONUtilities.safePut(fileRecord2, \"declaredEncoding\", (String) null);\n                        JSONUtilities.safePut(fileRecord2, \"declaredMimeType\", (String) null);\n                        JSONUtilities.safePut(fileRecord2, \"fileName\", fileName2);\n                        JSONUtilities.safePut(fileRecord2, \"archiveFileName\", JSONUtilities.getString(archiveFileRecord, \"fileName\", null));\n                        JSONUtilities.safePut(fileRecord2, \"location\", getRelativePath(file2, rawDataDir));\n\n                        JSONUtilities.safePut(fileRecord2, \"size\", saveStreamToFile(zis, file2, null));\n                        postProcessSingleRetrievedFile(file2, fileRecord2);\n                        \n                        JSONUtilities.append(fileRecords, fileRecord2);\n                    }\n                }\n            } catch (IOException e) {\n                \n                e.printStackTrace();\n            }\n            return true;\n        }\n        return false;\n    }\n    \n    static public InputStream tryOpenAsCompressedFile(File file, String mimeType) {\n        return tryOpenAsCompressedFile(file, mimeType, null);\n    }\n    \n    static public InputStream tryOpenAsCompressedFile(File file, String mimeType, String contentEncoding) {\n        String fileName = file.getName();\n        try {\n            if (fileName.endsWith(\".gz\") \n                    || \"gzip\".equals(contentEncoding) \n                    || \"x-gzip\".equals(contentEncoding)\n                    || \"application/x-gzip\".equals(mimeType)) {                \n                return new GZIPInputStream(new FileInputStream(file));\n            } else if (fileName.endsWith(\".bz2\")\n                    ||\"application/x-bzip2\".equals(mimeType)) {\n                InputStream is = new FileInputStream(file);\n                is.mark(4);\n                if (!(is.read() == 'B' && is.read() == 'Z')) {\n                    \n                    is.reset();\n                }\n                return new CBZip2InputStream(is);\n            }\n        } catch (IOException e) {\n            logger.warn(\"Something that looked like a compressed file gave an error on open: \"+file,e);\n        }\n        return null;\n    }\n    \n    static public File uncompressFile(\n        File rawDataDir,\n        InputStream uncompressedIS,\n        ObjectNode fileRecord,\n        final Progress progress\n    ) throws IOException {\n        String fileName = JSONUtilities.getString(fileRecord, \"location\", \"unknown\");\n        for (String ext : new String[] {\".gz\",\".bz2\"}) {\n            if (fileName.endsWith(ext)) {\n                fileName = fileName.substring(0, fileName.length()-ext.length());\n                break;\n            }\n        }\n        File file2 = allocateFile(rawDataDir, fileName);\n        \n        progress.setProgress(\"Uncompressing \" + fileName, -1);\n        \n        saveStreamToFile(uncompressedIS, file2, null);\n        \n        JSONUtilities.safePut(fileRecord, \"declaredEncoding\", (String) null);\n        JSONUtilities.safePut(fileRecord, \"declaredMimeType\", (String) null);\n        JSONUtilities.safePut(fileRecord, \"location\", getRelativePath(file2, rawDataDir));\n        \n        return file2;\n    }\n    \n    static private int calculateProgressPercent(long totalExpectedSize, long totalRetrievedSize) {\n        return totalExpectedSize == 0 ? -1 : (int) (totalRetrievedSize * 100 / totalExpectedSize);\n    }\n    \n    static private String formatBytes(long bytes) {\n        return NumberFormat.getIntegerInstance().format(bytes);\n    }\n    \n    static public String getEncoding(ObjectNode firstFileRecord) {\n        String encoding = JSONUtilities.getString(firstFileRecord, \"encoding\", null);\n        if (encoding == null || encoding.isEmpty()) {\n            encoding = JSONUtilities.getString(firstFileRecord, \"declaredEncoding\", null);\n        }\n        return encoding;\n    }\n\n    \n    static public String autoSelectFiles(ImportingJob job, ObjectNode retrievalRecord, ArrayNode fileSelectionIndexes) {\n        final Map<String, Integer> formatToCount = new HashMap<String, Integer>();\n        List<String> formats = new ArrayList<String>();\n        \n        ArrayNode fileRecords = JSONUtilities.getArray(retrievalRecord, \"files\");\n        int count = fileRecords.size();\n        for (int i = 0; i < count; i++) {\n            ObjectNode fileRecord = JSONUtilities.getObjectElement(fileRecords, i);\n            String format = JSONUtilities.getString(fileRecord, \"format\", null);\n            if (format != null) {\n                if (formatToCount.containsKey(format)) {\n                    formatToCount.put(format, formatToCount.get(format) + 1);\n                } else {\n                    formatToCount.put(format, 1);\n                    formats.add(format);\n                }\n            }\n        }\n        Collections.sort(formats, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return formatToCount.get(o2) - formatToCount.get(o1);\n            }\n        });\n        \n        \n        String bestFormat = formats.size() > 0 ? formats.get(0) : \"text/line-based\";\n        if (JSONUtilities.getInt(retrievalRecord, \"archiveCount\", 0) == 0) {\n            \n            for (int i = 0; i < count; i++) {\n                JSONUtilities.append(fileSelectionIndexes, i);\n            }\n        } else {\n            \n            for (int i = 0; i < count; i++) {\n                ObjectNode fileRecord = JSONUtilities.getObjectElement(fileRecords, i);\n                String format = JSONUtilities.getString(fileRecord, \"format\", null);\n                if (format != null && format.equals(bestFormat)) {\n                    JSONUtilities.append(fileSelectionIndexes, i);\n                }\n            }\n            \n            \n            \n            if (fileSelectionIndexes.size() == 0 && count > 0) {\n                for (int i = 0; i < count; i++) {\n                    JSONUtilities.append(fileSelectionIndexes, i);\n                }\n            }\n        }\n        return bestFormat;\n    }\n    \n    static public String getCommonFormatForSelectedFiles(ImportingJob job, ArrayNode fileSelectionIndexes) {\n        ObjectNode retrievalRecord = job.getRetrievalRecord();\n        \n        final Map<String, Integer> formatToCount = new HashMap<String, Integer>();\n        List<String> formats = new ArrayList<String>();\n        \n        ArrayNode fileRecords = JSONUtilities.getArray(retrievalRecord, \"files\");\n        int count = fileSelectionIndexes.size();\n        for (int i = 0; i < count; i++) {\n            int index = JSONUtilities.getIntElement(fileSelectionIndexes, i, -1);\n            if (index >= 0 && index < fileRecords.size()) {\n                ObjectNode fileRecord = JSONUtilities.getObjectElement(fileRecords, index);\n                String format = JSONUtilities.getString(fileRecord, \"format\", null);\n                if (format != null) {\n                    if (formatToCount.containsKey(format)) {\n                        formatToCount.put(format, formatToCount.get(format) + 1);\n                    } else {\n                        formatToCount.put(format, 1);\n                        formats.add(format);\n                    }\n                }\n            }\n        }\n        Collections.sort(formats, new Comparator<String>() {\n            @Override\n            public int compare(String o1, String o2) {\n                return formatToCount.get(o2) - formatToCount.get(o1);\n            }\n        });\n        \n        return formats.size() > 0 ? formats.get(0) : null;\n    }\n    \n    static String guessBetterFormat(ImportingJob job, String bestFormat) {\n        ObjectNode retrievalRecord = job.getRetrievalRecord();\n        return retrievalRecord != null ? guessBetterFormat(job, retrievalRecord, bestFormat) : bestFormat;\n    }\n    \n    static String guessBetterFormat(ImportingJob job, ObjectNode retrievalRecord, String bestFormat) {\n        ArrayNode fileRecords = JSONUtilities.getArray(retrievalRecord, \"files\");\n        return fileRecords != null ? guessBetterFormat(job, fileRecords, bestFormat) : bestFormat;\n    }\n    \n    static String guessBetterFormat(ImportingJob job, ArrayNode fileRecords, String bestFormat) {\n        if (bestFormat != null && fileRecords != null && fileRecords.size() > 0) {\n            ObjectNode firstFileRecord = JSONUtilities.getObjectElement(fileRecords, 0);\n            String encoding = getEncoding(firstFileRecord);\n            String location = JSONUtilities.getString(firstFileRecord, \"location\", null);\n            \n            if (location != null) {\n                File file = new File(job.getRawDataDir(), location);\n                \n                while (true) {\n                    String betterFormat = null;\n                    \n                    List<FormatGuesser> guessers = ImportingManager.formatToGuessers.get(bestFormat);\n                    if (guessers != null) {\n                        for (FormatGuesser guesser : guessers) {\n                            betterFormat = guesser.guess(file, encoding, bestFormat);\n                            if (betterFormat != null) {\n                                break;\n                            }\n                        }\n                    }\n                    \n                    if (betterFormat != null && !betterFormat.equals(bestFormat)) {\n                        bestFormat = betterFormat;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n        return bestFormat;\n    }\n    \n    static void rankFormats(ImportingJob job, final String bestFormat, ArrayNode rankedFormats) {\n        final Map<String, String[]> formatToSegments = new HashMap<String, String[]>();\n        \n        boolean download = bestFormat == null ? true :\n            ImportingManager.formatToRecord.get(bestFormat).download;\n        \n        List<String> formats = new ArrayList<String>(ImportingManager.formatToRecord.keySet().size());\n        for (String format : ImportingManager.formatToRecord.keySet()) {\n            Format record = ImportingManager.formatToRecord.get(format);\n            if (record.uiClass != null && record.parser != null && record.download == download) {\n                formats.add(format);\n                formatToSegments.put(format, format.split(\"/\"));\n            }\n        }\n        \n        if (bestFormat == null) {\n            Collections.sort(formats);\n        } else {\n            Collections.sort(formats, new Comparator<String>() {\n                @Override\n                public int compare(String format1, String format2) {\n                    if (format1.equals(bestFormat)) {\n                        return -1;\n                    } else if (format2.equals(bestFormat)) {\n                        return 1;\n                    } else {\n                        return compareBySegments(format1, format2);\n                    }\n                }\n                \n                int compareBySegments(String format1, String format2) {\n                    int c = commonSegments(format2) - commonSegments(format1);\n                    return c != 0 ? c : format1.compareTo(format2);\n                }\n                \n                int commonSegments(String format) {\n                    String[] bestSegments = formatToSegments.get(bestFormat);\n                    String[] segments = formatToSegments.get(format);\n                    if (bestSegments == null || segments == null) {\n                        return 0;\n                    } else {\n                        int i;\n                        for (i = 0; i < bestSegments.length && i < segments.length; i++) {\n                            if (!bestSegments[i].equals(segments[i])) {\n                                break;\n                            }\n                        }\n                        return i;\n                    }\n                }\n            });\n        }\n        \n        for (String format : formats) {\n            rankedFormats.add(format);\n        }\n    }\n\n    \n    static public void previewParse(ImportingJob job, String format, ObjectNode optionObj, List<Exception> exceptions) {\n        Format record = ImportingManager.formatToRecord.get(format);\n        if (record == null || record.parser == null) {\n            \n            return;\n        }\n        \n        job.prepareNewProject();\n        \n        record.parser.parse(\n            job.project,\n            job.metadata,\n            job,\n            job.getSelectedFileRecords(),\n            format,\n            100,\n            optionObj,\n            exceptions\n        );\n        \n        job.project.update(); \n    }\n    \n    static public long createProject(\n            final ImportingJob job,\n            final String format,\n            final ObjectNode optionObj,\n            final List<Exception> exceptions,\n            boolean synchronous) {\n        final Format record = ImportingManager.formatToRecord.get(format);\n        if (record == null || record.parser == null) {\n            \n            return -1;\n        }\n        \n        job.setState(\"creating-project\");\n        \n        final Project project = new Project();\n        if (synchronous) {\n            createProjectSynchronously(\n                job, format, optionObj, exceptions, record, project);\n        } else {\n            new Thread() {\n                @Override\n                public void run() {\n                    createProjectSynchronously(\n                        job, format, optionObj, exceptions, record, project);\n                }\n            }.start();\n        }\n        return project.id;\n    }\n    \n    static private void createProjectSynchronously(\n        final ImportingJob job,\n        final String format,\n        final ObjectNode optionObj,\n        final List<Exception> exceptions,\n        final Format record,\n        final Project project\n    ) {\n        ProjectMetadata pm = createProjectMetadata(optionObj);\n        record.parser.parse(\n            project,\n            pm,\n            job,\n            job.getSelectedFileRecords(),\n            format,\n            -1,\n            optionObj,\n            exceptions\n        );\n        \n        if (!job.canceled) {\n            if (exceptions.size() == 0) {\n                project.update(); \n                \n                ProjectManager.singleton.registerProject(project, pm);\n                \n                job.setProjectID(project.id);\n                job.setState(\"created-project\");\n            } else {\n                job.setError(exceptions);\n            }\n            job.touch();\n            job.updating = false;\n        }\n    }\n\n    static public ProjectMetadata createProjectMetadata(ObjectNode optionObj) {\n        ProjectMetadata pm = new ProjectMetadata();\n        pm.setName(JSONUtilities.getString(optionObj, \"projectName\", \"Untitled\"));\n        pm.setTags(JSONUtilities.getStringArray(optionObj, \"projectTags\"));\n\n        String encoding = JSONUtilities.getString(optionObj, \"encoding\", \"UTF-8\");\n        if (\"\".equals(encoding)) {\n            \n            encoding = \"UTF-8\";\n        }\n        pm.setEncoding(encoding);\n        return pm;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 62,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/OpenRefine/OpenRefine/commit/e243e73e4064de87a913946bd320fbbe246da656",
    "cve_id": "CVE-2018-19859",
    "cwe_id": "CWE-22",
    "filename": "main/tests/server/src/com/google/refine/tests/importing/ImportingUtilitiesTests.java",
    "code": "\npackage com.google.refine.tests.importing;\n\nimport java.util.LinkedList;\n\nimport org.testng.Assert;\nimport org.testng.annotations.BeforeMethod;\nimport org.testng.annotations.Test;\n\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\nimport com.google.refine.ProjectMetadata;\nimport com.google.refine.importers.tree.TreeImportingParserBase;\nimport com.google.refine.importing.ImportingJob;\nimport com.google.refine.importing.ImportingUtilities;\nimport com.google.refine.tests.importers.ImporterTest;\nimport com.google.refine.util.JSONUtilities;\nimport com.google.refine.util.ParsingUtilities;\n\npublic class ImportingUtilitiesTests extends ImporterTest {\n\n    @Override\n    @BeforeMethod\n    public void setUp(){\n        super.setUp();\n    }\n    \n    @Test\n    public void createProjectMetadataTest()\n            throws Exception {\n        ObjectNode optionObj = ParsingUtilities.evaluateJsonStringToObjectNode(\n                \"{\\\"projectName\\\":\\\"acme\\\",\\\"projectTags\\\":[],\\\"created\\\":\\\"2017-12-18T13:28:40.659\\\",\\\"modified\\\":\\\"2017-12-20T09:28:06.654\\\",\\\"creator\\\":\\\"\\\",\\\"contributors\\\":\\\"\\\",\\\"subject\\\":\\\"\\\",\\\"description\\\":\\\"\\\",\\\"rowCount\\\":50,\\\"customMetadata\\\":{}}\");\n        ProjectMetadata pm = ImportingUtilities.createProjectMetadata(optionObj);\n        Assert.assertEquals(pm.getName(), \"acme\");\n        Assert.assertEquals(pm.getEncoding(), \"UTF-8\");\n        Assert.assertTrue(pm.getTags().length == 0);\n    }\n    \n    private ObjectNode getNestedOptions(ImportingJob job, TreeImportingParserBase parser) {\n        ObjectNode options = parser.createParserUIInitializationData(\n                job, new LinkedList<>(), \"text/json\");\n        \n        ArrayNode path = ParsingUtilities.mapper.createArrayNode();\n        path.add(\"results\");\n        path.add(\"result\");\n        \n        JSONUtilities.safePut(options, \"recordPath\", path);\n        return options;\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 63,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/resteasy/Resteasy/commit/acf15f2a8067f7e4cf5838342cecfa0b78a174fb",
    "cve_id": "CVE-2020-1695",
    "cwe_id": "CWE-20",
    "filename": "resteasy-core/src/main/java/org/jboss/resteasy/plugins/delegates/MediaTypeHeaderDelegate.java",
    "code": "package org.jboss.resteasy.plugins.delegates;\n\nimport org.jboss.resteasy.resteasy_jaxrs.i18n.Messages;\nimport org.jboss.resteasy.util.HeaderParameterParser;\n\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.ext.RuntimeDelegate;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\n\npublic class MediaTypeHeaderDelegate implements RuntimeDelegate.HeaderDelegate\n{\n   public static final MediaTypeHeaderDelegate INSTANCE = new MediaTypeHeaderDelegate();\n\n   private static Map<String, MediaType> map = new ConcurrentHashMap<String, MediaType>();\n   private static Map<MediaType, String> reverseMap = new ConcurrentHashMap<MediaType, String>();\n   private static final int MAX_MT_CACHE_SIZE =\n       Integer.getInteger(\"org.jboss.resteasy.max_mediatype_cache_size\", 200);\n\n   public Object fromString(String type) throws IllegalArgumentException\n   {\n      if (type == null) throw new IllegalArgumentException(Messages.MESSAGES.mediaTypeValueNull());\n      return parse(type);\n   }\n\n   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }\n\n   public static MediaType parse(String type)\n   {\n      MediaType result = map.get(type);\n      if (result == null) {\n          result = internalParse(type);\n          final int size = map.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n              map.clear();\n              reverseMap.clear();\n          }\n          map.put(type, result);\n          reverseMap.put(result, type);\n      }\n      return result;\n   }\n\n   private static MediaType internalParse(String type)\n   {\n      int typeIndex = type.indexOf('/');\n      int paramIndex = type.indexOf(';');\n      String major = null;\n      String subtype = null;\n      if (typeIndex < 0) \n      {\n         major = type;\n         if (paramIndex > -1)\n         {\n            major = major.substring(0, paramIndex);\n         }\n         if (!MediaType.MEDIA_TYPE_WILDCARD.equals(major))\n         {\n            throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n         }\n         subtype = MediaType.MEDIA_TYPE_WILDCARD;\n      }\n      else\n      {\n         major = type.substring(0, typeIndex);\n         if (paramIndex > -1)\n         {\n            subtype = type.substring(typeIndex + 1, paramIndex);\n         }\n         else\n         {\n            subtype = type.substring(typeIndex + 1);\n         }\n      }\n      if (major.length() < 1 || subtype.length() < 1)\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      if (!isValid(major) || !isValid(subtype))\n      {\n         throw new IllegalArgumentException(Messages.MESSAGES.failureParsingMediaType(type));\n      }\n      String params = null;\n      if (paramIndex > -1) params = type.substring(paramIndex + 1);\n      if (params != null && !params.equals(\"\"))\n      {\n         HashMap<String, String> typeParams = new HashMap<String, String>();\n\n         int start = 0;\n\n         while (start < params.length())\n         {\n            start = HeaderParameterParser.setParam(typeParams, params, start);\n         }\n         return new MediaType(major, subtype, typeParams);\n      }\n      else\n      {\n         return new MediaType(major, subtype);\n      }\n   }\n\n   private static final char[] quotedChars = \"()<>@,;:\\\\\\\"/[]?= \\t\\r\\n\".toCharArray();\n\n   public static boolean quoted(String str)\n   {\n      for (int i = 0; i < str.length(); i++)\n      {\n         char c = str.charAt(i);\n         for (char q : quotedChars) {\n            if (c == q) return true;\n         }\n      }\n      return false;\n   }\n\n   public String toString(Object o)\n   {\n      if (o == null) throw new IllegalArgumentException(Messages.MESSAGES.paramNull());\n      MediaType type = (MediaType) o;\n      String result = reverseMap.get(type);\n      if (result == null) {\n          result = internalToString(type);\n          final int size = reverseMap.size();\n          if (size >= MAX_MT_CACHE_SIZE) {\n             reverseMap.clear();\n             map.clear();\n          }\n          reverseMap.put(type, result);\n          map.put(result, type);\n      }\n      return result;\n   }\n\n   private String internalToString(MediaType type)\n   {\n      StringBuilder buf = new StringBuilder();\n\n      buf.append(type.getType().toLowerCase()).append(\"/\").append(type.getSubtype().toLowerCase());\n      if (type.getParameters() == null || type.getParameters().size() == 0) return buf.toString();\n      for (String name : type.getParameters().keySet())\n      {\n         buf.append(';').append(name).append('=');\n         String val = type.getParameters().get(name);\n         if (quoted(val)) buf.append('\"').append(val).append('\"');\n         else buf.append(val);\n      }\n      return buf.toString();\n   }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 64,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-data-commons/commit/371f6590c509c72f8e600f3d05e110941607fba",
    "cve_id": "CVE-2018-1274",
    "cwe_id": "CWE-770",
    "filename": "src/main/java/org/springframework/data/mapping/PropertyPath.java",
    "code": "\npackage org.springframework.data.mapping;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Stack;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport org.springframework.data.util.ClassTypeInformation;\nimport org.springframework.data.util.TypeInformation;\nimport org.springframework.util.Assert;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n\npublic class PropertyPath implements Iterable<PropertyPath> {\n\n\tprivate static final String DELIMITERS = \"_\\\\.\";\n\tprivate static final String ALL_UPPERCASE = \"[A-Z0-9._$]+\";\n\tprivate static final Pattern SPLITTER = Pattern.compile(\"(?:[%s]?([%s]*?[^%s]+))\".replaceAll(\"%s\", DELIMITERS));\n\n\tprivate final TypeInformation<?> owningType;\n\tprivate final String name;\n\tprivate final TypeInformation<?> type;\n\tprivate final boolean isCollection;\n\n\tprivate PropertyPath next;\n\n\t\n\tPropertyPath(String name, Class<?> owningType) {\n\t\tthis(name, ClassTypeInformation.from(owningType), Collections.<PropertyPath> emptyList());\n\t}\n\n\t\n\tPropertyPath(String name, TypeInformation<?> owningType, List<PropertyPath> base) {\n\n\t\tAssert.hasText(name, \"Name must not be null or empty!\");\n\t\tAssert.notNull(owningType, \"Owning type must not be null!\");\n\t\tAssert.notNull(base, \"Perviously found properties must not be null!\");\n\n\t\tString propertyName = name.matches(ALL_UPPERCASE) ? name : StringUtils.uncapitalize(name);\n\t\tTypeInformation<?> propertyType = owningType.getProperty(propertyName);\n\n\t\tif (propertyType == null) {\n\t\t\tthrow new PropertyReferenceException(propertyName, owningType, base);\n\t\t}\n\n\t\tthis.owningType = owningType;\n\t\tthis.isCollection = propertyType.isCollectionLike();\n\t\tthis.type = propertyType.getActualType();\n\t\tthis.name = propertyName;\n\t}\n\n\t\n\tpublic TypeInformation<?> getOwningType() {\n\t\treturn owningType;\n\t}\n\n\t\n\tpublic String getSegment() {\n\t\treturn name;\n\t}\n\n\t\n\tpublic PropertyPath getLeafProperty() {\n\n\t\tPropertyPath result = this;\n\n\t\twhile (result.hasNext()) {\n\t\t\tresult = result.next();\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t\n\tpublic Class<?> getType() {\n\t\treturn this.type.getType();\n\t}\n\n\t\n\tpublic PropertyPath next() {\n\t\treturn next;\n\t}\n\n\t\n\tpublic boolean hasNext() {\n\t\treturn next != null;\n\t}\n\n\t\n\tpublic String toDotPath() {\n\n\t\tif (hasNext()) {\n\t\t\treturn getSegment() + \".\" + next().toDotPath();\n\t\t}\n\n\t\treturn getSegment();\n\t}\n\n\t\n\tpublic boolean isCollection() {\n\t\treturn isCollection;\n\t}\n\n\t\n\t@Override\n\tpublic boolean equals(Object obj) {\n\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (obj == null || !getClass().equals(obj.getClass())) {\n\t\t\treturn false;\n\t\t}\n\n\t\tPropertyPath that = (PropertyPath) obj;\n\n\t\treturn this.name.equals(that.name) && this.type.equals(that.type)\n\t\t\t\t&& ObjectUtils.nullSafeEquals(this.next, that.next);\n\t}\n\n\t\n\t@Override\n\tpublic int hashCode() {\n\n\t\tint result = 17;\n\n\t\tresult += 31 * name.hashCode();\n\t\tresult += 31 * type.hashCode();\n\t\tresult += 31 * (next == null ? 0 : next.hashCode());\n\n\t\treturn result;\n\t}\n\n\t\n\tpublic Iterator<PropertyPath> iterator() {\n\t\treturn new Iterator<PropertyPath>() {\n\n\t\t\tprivate PropertyPath current = PropertyPath.this;\n\n\t\t\tpublic boolean hasNext() {\n\t\t\t\treturn current != null;\n\t\t\t}\n\n\t\t\tpublic PropertyPath next() {\n\t\t\t\tPropertyPath result = current;\n\t\t\t\tthis.current = current.next();\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tpublic void remove() {\n\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t}\n\t\t};\n\t}\n\n\t\n\tpublic static PropertyPath from(String source, Class<?> type) {\n\t\treturn from(source, ClassTypeInformation.from(type));\n\t}\n\n\t\n\tpublic static PropertyPath from(String source, TypeInformation<?> type) {\n\n\t\tAssert.hasText(source, \"Source must not be null or empty!\");\n\t\tAssert.notNull(type, \"TypeInformation must not be null or empty!\");\n\n\t\tList<String> iteratorSource = new ArrayList<String>();\n\t\tMatcher matcher = SPLITTER.matcher(\"_\" + source);\n\n\t\twhile (matcher.find()) {\n\t\t\titeratorSource.add(matcher.group(1));\n\t\t}\n\n\t\tIterator<String> parts = iteratorSource.iterator();\n\n\t\tPropertyPath result = null;\n\t\tStack<PropertyPath> current = new Stack<PropertyPath>();\n\n\t\twhile (parts.hasNext()) {\n\t\t\tif (result == null) {\n\t\t\t\tresult = create(parts.next(), type, current);\n\t\t\t\tcurrent.push(result);\n\t\t\t} else {\n\t\t\t\tcurrent.push(create(parts.next(), current));\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t\n\tprivate static PropertyPath create(String source, Stack<PropertyPath> base) {\n\n\t\tPropertyPath previous = base.peek();\n\n\t\tPropertyPath propertyPath = create(source, previous.type, base);\n\t\tprevious.next = propertyPath;\n\t\treturn propertyPath;\n\t}\n\n\t\n\tprivate static PropertyPath create(String source, TypeInformation<?> type, List<PropertyPath> base) {\n\t\treturn create(source, type, \"\", base);\n\t}\n\n\t\n\tprivate static PropertyPath create(String source, TypeInformation<?> type, String addTail, List<PropertyPath> base) {\n\n\t\tPropertyReferenceException exception = null;\n\t\tPropertyPath current = null;\n\n\t\ttry {\n\n\t\t\tcurrent = new PropertyPath(source, type, base);\n\n\t\t\tif (!base.isEmpty()) {\n\t\t\t\tbase.get(base.size() - 1).next = current;\n\t\t\t}\n\n\t\t\tList<PropertyPath> newBase = new ArrayList<PropertyPath>(base);\n\t\t\tnewBase.add(current);\n\n\t\t\tif (StringUtils.hasText(addTail)) {\n\t\t\t\tcurrent.next = create(addTail, current.type, newBase);\n\t\t\t}\n\n\t\t\treturn current;\n\n\t\t} catch (PropertyReferenceException e) {\n\n\t\t\tif (current != null) {\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\texception = e;\n\t\t}\n\n\t\tPattern pattern = Pattern.compile(\"\\\\p{Lu}+\\\\p{Ll}*$\");\n\t\tMatcher matcher = pattern.matcher(source);\n\n\t\tif (matcher.find() && matcher.start() != 0) {\n\n\t\t\tint position = matcher.start();\n\t\t\tString head = source.substring(0, position);\n\t\t\tString tail = source.substring(position);\n\n\t\t\ttry {\n\t\t\t\treturn create(head, type, tail + addTail, base);\n\t\t\t} catch (PropertyReferenceException e) {\n\t\t\t\tthrow e.hasDeeperResolutionDepthThan(exception) ? e : exception;\n\t\t\t}\n\t\t}\n\n\t\tthrow exception;\n\t}\n\n\t\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"%s.%s\", owningType.getType().getSimpleName(), toDotPath());\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 64,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-data-commons/commit/371f6590c509c72f8e600f3d05e110941607fba",
    "cve_id": "CVE-2018-1274",
    "cwe_id": "CWE-770",
    "filename": "src/test/java/org/springframework/data/mapping/PropertyPathUnitTests.java",
    "code": "\npackage org.springframework.data.mapping;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.*;\nimport static org.springframework.data.mapping.PropertyPath.*;\n\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.springframework.data.util.ClassTypeInformation;\nimport org.springframework.data.util.TypeInformation;\n\n\n@SuppressWarnings(\"unused\")\npublic class PropertyPathUnitTests {\n\n\t@Rule public ExpectedException exception = ExpectedException.none();\n\n\t@Test\n\t@SuppressWarnings(\"rawtypes\")\n\tpublic void parsesSimplePropertyCorrectly() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userName\", Foo.class);\n\t\tassertThat(reference.hasNext(), is(false));\n\t\tassertThat(reference.toDotPath(), is(\"userName\"));\n\t\tassertThat(reference.getOwningType(), is((TypeInformation) ClassTypeInformation.from(Foo.class)));\n\t}\n\n\t@Test\n\tpublic void parsesPathPropertyCorrectly() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userName\", Bar.class);\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t\tassertThat(reference.toDotPath(), is(\"user.name\"));\n\t}\n\n\t@Test\n\tpublic void prefersLongerMatches() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userName\", Sample.class);\n\t\tassertThat(reference.hasNext(), is(false));\n\t\tassertThat(reference.toDotPath(), is(\"userName\"));\n\t}\n\n\t@Test\n\tpublic void testname() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userName\", Sample2.class);\n\t\tassertThat(reference.getSegment(), is(\"user\"));\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void prefersExplicitPaths() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"user_name\", Sample.class);\n\t\tassertThat(reference.getSegment(), is(\"user\"));\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void handlesGenericsCorrectly() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"usersName\", Bar.class);\n\t\tassertThat(reference.getSegment(), is(\"users\"));\n\t\tassertThat(reference.isCollection(), is(true));\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void handlesMapCorrectly() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userMapName\", Bar.class);\n\t\tassertThat(reference.getSegment(), is(\"userMap\"));\n\t\tassertThat(reference.isCollection(), is(false));\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void handlesArrayCorrectly() throws Exception {\n\n\t\tPropertyPath reference = PropertyPath.from(\"userArrayName\", Bar.class);\n\t\tassertThat(reference.getSegment(), is(\"userArray\"));\n\t\tassertThat(reference.isCollection(), is(true));\n\t\tassertThat(reference.hasNext(), is(true));\n\t\tassertThat(reference.next(), is(new PropertyPath(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void handlesInvalidCollectionCompountTypeProperl() {\n\n\t\ttry {\n\t\t\tPropertyPath.from(\"usersMame\", Bar.class);\n\t\t\tfail(\"Expected PropertyReferenceException!\");\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getPropertyName(), is(\"mame\"));\n\t\t\tassertThat(e.getBaseProperty(), is(PropertyPath.from(\"users\", Bar.class)));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void handlesInvalidMapValueTypeProperly() {\n\n\t\ttry {\n\t\t\tPropertyPath.from(\"userMapMame\", Bar.class);\n\t\t\tfail();\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getPropertyName(), is(\"mame\"));\n\t\t\tassertThat(e.getBaseProperty(), is(PropertyPath.from(\"userMap\", Bar.class)));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void findsNested() {\n\n\t\tPropertyPath from = PropertyPath.from(\"barUserName\", Sample.class);\n\n\t\tassertThat(from, is(notNullValue()));\n\t\tassertThat(from.getLeafProperty(), is(PropertyPath.from(\"name\", FooBar.class)));\n\t}\n\n\t@Test \n\tpublic void handlesEmptyUnderscoresCorrectly() {\n\n\t\tPropertyPath propertyPath = PropertyPath.from(\"_foo\", Sample2.class);\n\t\tassertThat(propertyPath.getSegment(), is(\"_foo\"));\n\t\tassertThat(propertyPath.getType(), is(typeCompatibleWith(Foo.class)));\n\n\t\tpropertyPath = PropertyPath.from(\"_foo__email\", Sample2.class);\n\t\tassertThat(propertyPath.toDotPath(), is(\"_foo._email\"));\n\t}\n\n\t@Test\n\tpublic void supportsDotNotationAsWell() {\n\n\t\tPropertyPath propertyPath = PropertyPath.from(\"bar.userMap.name\", Sample.class);\n\n\t\tassertThat(propertyPath, is(notNullValue()));\n\t\tassertThat(propertyPath.getSegment(), is(\"bar\"));\n\t\tassertThat(propertyPath.getLeafProperty(), is(PropertyPath.from(\"name\", FooBar.class)));\n\t}\n\n\t@Test\n\tpublic void returnsCorrectIteratorForSingleElement() {\n\n\t\tPropertyPath propertyPath = PropertyPath.from(\"userName\", Foo.class);\n\n\t\tIterator<PropertyPath> iterator = propertyPath.iterator();\n\t\tassertThat(iterator.hasNext(), is(true));\n\t\tassertThat(iterator.next(), is(propertyPath));\n\t\tassertThat(iterator.hasNext(), is(false));\n\t}\n\n\t@Test\n\tpublic void returnsCorrectIteratorForMultipleElement() {\n\n\t\tPropertyPath propertyPath = PropertyPath.from(\"user.name\", Bar.class);\n\n\t\tIterator<PropertyPath> iterator = propertyPath.iterator();\n\t\tassertThat(iterator.hasNext(), is(true));\n\t\tassertThat(iterator.next(), is(propertyPath));\n\t\tassertThat(iterator.hasNext(), is(true));\n\t\tassertThat(iterator.next(), is(propertyPath.next()));\n\t\tassertThat(iterator.hasNext(), is(false));\n\t}\n\n\t@Test \n\tpublic void rejectsInvalidPropertyWithLeadingUnderscore() {\n\t\ttry {\n\t\t\tPropertyPath.from(\"_id\", Foo.class);\n\t\t\tfail();\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getMessage(), containsString(\"property _id\"));\n\t\t}\n\t}\n\n\t@Test \n\tpublic void rejectsNestedInvalidPropertyWithLeadingUnderscore() {\n\t\ttry {\n\t\t\tPropertyPath.from(\"_foo_id\", Sample2.class);\n\t\t\tfail();\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getMessage(), containsString(\"property id\"));\n\t\t}\n\t}\n\n\t@Test \n\tpublic void rejectsNestedInvalidPropertyExplictlySplitWithLeadingUnderscore() {\n\t\ttry {\n\t\t\tPropertyPath.from(\"_foo__id\", Sample2.class);\n\t\t\tfail();\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getMessage(), containsString(\"property _id\"));\n\t\t}\n\t}\n\n\t@Test(expected = PropertyReferenceException.class) \n\tpublic void rejectsInvalidPathsContainingDigits() {\n\t\tPropertyPath.from(\"PropertyThatWillFail4Sure\", Foo.class);\n\t}\n\n\t@Test\n\tpublic void rejectsInvalidProperty() {\n\n\t\ttry {\n\t\t\tPropertyPath.from(\"bar\", Foo.class);\n\t\t\tfail();\n\t\t} catch (PropertyReferenceException e) {\n\t\t\tassertThat(e.getBaseProperty(), is(nullValue()));\n\t\t}\n\t}\n\n\t@Test\n\tpublic void samePathsEqual() {\n\n\t\tPropertyPath left = PropertyPath.from(\"user.name\", Bar.class);\n\t\tPropertyPath right = PropertyPath.from(\"user.name\", Bar.class);\n\n\t\tPropertyPath shortPath = PropertyPath.from(\"user\", Bar.class);\n\n\t\tassertThat(left, is(right));\n\t\tassertThat(right, is(left));\n\t\tassertThat(left, is(not(shortPath)));\n\t\tassertThat(shortPath, is(not(left)));\n\n\t\tassertThat(left, is(not(new Object())));\n\t}\n\n\t@Test\n\tpublic void hashCodeTests() {\n\n\t\tPropertyPath left = PropertyPath.from(\"user.name\", Bar.class);\n\t\tPropertyPath right = PropertyPath.from(\"user.name\", Bar.class);\n\n\t\tPropertyPath shortPath = PropertyPath.from(\"user\", Bar.class);\n\n\t\tassertThat(left.hashCode(), is(right.hashCode()));\n\t\tassertThat(left.hashCode(), is(not(shortPath.hashCode())));\n\t}\n\n\t@Test \n\tpublic void findsAllUppercaseProperty() {\n\n\t\tPropertyPath path = PropertyPath.from(\"UUID\", Foo.class);\n\n\t\tassertThat(path, is(notNullValue()));\n\t\tassertThat(path.getSegment(), is(\"UUID\"));\n\t}\n\n\t@Test \n\tpublic void findsNestedAllUppercaseProperty() {\n\n\t\tPropertyPath path = PropertyPath.from(\"_fooUUID\", Sample2.class);\n\n\t\tassertThat(path, is(notNullValue()));\n\t\tassertThat(path.getSegment(), is(\"_foo\"));\n\t\tassertThat(path.hasNext(), is(true));\n\t\tassertThat(path.next().getSegment(), is(\"UUID\"));\n\t}\n\n\t@Test \n\tpublic void exposesPreviouslyReferencedPathInExceptionMessage() {\n\n\t\texception.expect(PropertyReferenceException.class);\n\t\texception.expectMessage(\"bar\"); \n\t\texception.expectMessage(\"String\"); \n\t\texception.expectMessage(\"Bar.user.name\"); \n\n\t\tPropertyPath.from(\"userNameBar\", Bar.class);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class) \n\tpublic void rejectsNullSource() {\n\t\tfrom(null, Foo.class);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class) \n\tpublic void rejectsEmptySource() {\n\t\tfrom(\"\", Foo.class);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class) \n\tpublic void rejectsNullClass() {\n\t\tfrom(\"foo\", (Class<?>) null);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class) \n\tpublic void rejectsNullTypeInformation() {\n\t\tfrom(\"foo\", (TypeInformation<?>) null);\n\t}\n\n\t@Test \n\tpublic void returnsCompletePathIfResolutionFailedCompletely() {\n\n\t\texception.expect(PropertyReferenceException.class);\n\t\texception.expectMessage(\"somethingDifferent\");\n\n\t\tfrom(\"somethingDifferent\", Foo.class);\n\t}\n\n\t@Test \n\tpublic void includesResolvedPathInExceptionMessage() {\n\n\t\texception.expect(PropertyReferenceException.class);\n\t\texception.expectMessage(\"fooName\");\n\t\texception.expectMessage(FooBar.class.getSimpleName());\n\t\texception.expectMessage(\"Bar.user\");\n\n\t\tfrom(\"userFooName\", Bar.class);\n\t}\n\n\t@Test \n\tpublic void includesPropertyHintsOnTypos() {\n\n\t\texception.expect(PropertyReferenceException.class);\n\t\texception.expectMessage(\"userName\");\n\n\t\tfrom(\"userAme\", Foo.class);\n\t}\n\n\tprivate class Foo {\n\n\t\tString userName;\n\t\tString _email;\n\t\tString UUID;\n\t}\n\n\tprivate class Bar {\n\n\t\tprivate FooBar user;\n\t\tprivate Set<FooBar> users;\n\t\tprivate Map<String, FooBar> userMap;\n\t\tprivate FooBar[] userArray;\n\t}\n\n\tprivate class FooBar {\n\n\t\tprivate String name;\n\t}\n\n\tprivate class Sample {\n\n\t\tprivate String userName;\n\t\tprivate FooBar user;\n\t\tprivate Bar bar;\n\t}\n\n\tprivate class Sample2 {\n\n\t\tprivate String userNameWhatever;\n\t\tprivate FooBar user;\n\t\tprivate Foo _foo;\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 65,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45",
    "cve_id": "CVE-2017-8046",
    "cwe_id": "CWE-20",
    "filename": "spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/json/patch/AddOperation.java",
    "code": "\npackage org.springframework.data.rest.webmvc.json.patch;\n\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\nimport org.springframework.data.mapping.PropertyPath;\n\n\nclass AddOperation extends PatchOperation {\n\n\t\n\tpublic AddOperation(String path, Object value) {\n\t\tsuper(\"add\", path, value);\n\t}\n\n\t\n\t@Override\n\t<T> void perform(Object targetObject, Class<T> type) {\n\t\taddValue(targetObject, evaluateValueFromTarget(targetObject, type));\n\t}\n\n\t\n\t@Override\n\tprotected <T> Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\tif (!path.endsWith(\"-\")) {\n\t\t\treturn super.evaluateValueFromTarget(targetObject, entityType);\n\t\t}\n\n\t\tString pathSource = Arrays.stream(path.split(\"/\"))\n\t\t\t\t.filter(it -> !it.matches(\"\\\\d\")) \n\t\t\t\t.filter(it -> !it.equals(\"-\")) \n\t\t\t\t.filter(it -> !it.isEmpty()) \n\t\t\t\t.collect(Collectors.joining(\".\"));\n\n\t\tPropertyPath propertyPath = PropertyPath.from(pathSource, entityType);\n\n\t\treturn value instanceof LateObjectEvaluator ? ((LateObjectEvaluator) value).evaluate(propertyPath.getType())\n\t\t\t\t: value;\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 65,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45",
    "cve_id": "CVE-2017-8046",
    "cwe_id": "CWE-20",
    "filename": "spring-data-rest-webmvc/src/main/java/org/springframework/data/rest/webmvc/json/patch/PatchOperation.java",
    "code": "\npackage org.springframework.data.rest.webmvc.json.patch;\n\nimport static org.springframework.data.rest.webmvc.json.patch.PathToSpEL.*;\n\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.springframework.core.CollectionFactory;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.ExpressionException;\nimport org.springframework.expression.spel.SpelEvaluationException;\n\n\npublic abstract class PatchOperation {\n\n\tprotected final String op;\n\tprotected final String path;\n\tprotected final Object value;\n\tprotected final Expression spelExpression;\n\n\t\n\tpublic PatchOperation(String op, String path) {\n\t\tthis(op, path, null);\n\t}\n\n\t\n\tpublic PatchOperation(String op, String path, Object value) {\n\n\t\tthis.op = op;\n\t\tthis.path = path;\n\t\tthis.value = value;\n\t\tthis.spelExpression = pathToExpression(path);\n\t}\n\n\t\n\tpublic String getOp() {\n\t\treturn op;\n\t}\n\n\t\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\t\n\tpublic Object getValue() {\n\t\treturn value;\n\t}\n\n\t\n\tprotected Object popValueAtPath(Object target, String removePath) {\n\n\t\tInteger listIndex = targetListIndex(removePath);\n\t\tExpression expression = pathToExpression(removePath);\n\t\tObject value = expression.getValue(target);\n\n\t\tif (listIndex == null) {\n\n\t\t\ttry {\n\t\t\t\texpression.setValue(target, null);\n\t\t\t\treturn value;\n\t\t\t} catch (SpelEvaluationException o_O) {\n\t\t\t\tthrow new PatchException(\"Path '\" + removePath + \"' is not nullable.\", o_O);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tExpression parentExpression = pathToParentExpression(removePath);\n\t\t\tList<?> list = (List<?>) parentExpression.getValue(target);\n\t\t\tlist.remove(listIndex >= 0 ? listIndex.intValue() : list.size() - 1);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\t\n\t@SuppressWarnings({ \"unchecked\", \"null\" })\n\tprotected void addValue(Object target, Object value) {\n\n\t\tExpression parentExpression = pathToParentExpression(path);\n\t\tObject parent = parentExpression != null ? parentExpression.getValue(target) : null;\n\t\tInteger listIndex = targetListIndex(path);\n\n\t\tif (parent == null || !(parent instanceof List) || listIndex == null) {\n\n\t\t\tTypeDescriptor descriptor = parentExpression.getValueTypeDescriptor(target);\n\n\t\t\t\n\t\t\tif (descriptor.isCollection() && !Collection.class.isInstance(value)) {\n\n\t\t\t\tCollection<Object> collection = CollectionFactory.createCollection(descriptor.getType(), 1);\n\t\t\t\tcollection.add(value);\n\n\t\t\t\tparentExpression.setValue(target, collection);\n\n\t\t\t} else {\n\t\t\t\tspelExpression.setValue(target, value);\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tList<Object> list = (List<Object>) parentExpression.getValue(target);\n\t\t\tlist.add(listIndex >= 0 ? listIndex.intValue() : list.size(), value);\n\t\t}\n\t}\n\n\t\n\tprotected void setValueOnTarget(Object target, Object value) {\n\t\tspelExpression.setValue(target, value);\n\t}\n\n\t\n\tprotected Object getValueFromTarget(Object target) {\n\n\t\ttry {\n\t\t\treturn spelExpression.getValue(target);\n\t\t} catch (ExpressionException e) {\n\t\t\tthrow new PatchException(\"Unable to get value from target\", e);\n\t\t}\n\t}\n\n\t\n\tprotected <T> Object evaluateValueFromTarget(Object targetObject, Class<T> entityType) {\n\n\t\treturn value instanceof LateObjectEvaluator\n\t\t\t\t? ((LateObjectEvaluator) value).evaluate(spelExpression.getValueType(targetObject)) : value;\n\t}\n\n\t\n\tabstract <T> void perform(Object target, Class<T> type);\n\n\tprivate Integer targetListIndex(String path) {\n\n\t\tString[] pathNodes = path.split(\"\\\\/\");\n\t\tString lastNode = pathNodes[pathNodes.length - 1];\n\n\t\tif (APPEND_CHARACTERS.contains(lastNode)) {\n\t\t\treturn -1;\n\t\t}\n\n\t\ttry {\n\t\t\treturn Integer.parseInt(lastNode);\n\t\t} catch (NumberFormatException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 65,
    "sub_id": 2,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-data-rest/commit/8f269e28fe8038a6c60f31a1c36cfda04795ab45",
    "cve_id": "CVE-2017-8046",
    "cwe_id": "CWE-20",
    "filename": "spring-data-rest-webmvc/src/test/java/org/springframework/data/rest/webmvc/json/patch/JsonPatchTests.java",
    "code": "\npackage org.springframework.data.rest.webmvc.json.patch;\n\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.ExpectedException;\nimport org.springframework.core.io.ClassPathResource;\n\nimport com.fasterxml.jackson.core.JsonParseException;\nimport com.fasterxml.jackson.databind.JsonMappingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n\npublic class JsonPatchTests {\n\n\tpublic @Rule ExpectedException exception = ExpectedException.none();\n\n\t@Test\n\tpublic void manySuccessfulOperations() throws Exception {\n\n\t\tList<Todo> todos = new ArrayList<Todo>();\n\t\ttodos.add(new Todo(1L, \"A\", true));\n\t\ttodos.add(new Todo(2L, \"B\", false));\n\t\ttodos.add(new Todo(3L, \"C\", false));\n\t\ttodos.add(new Todo(4L, \"D\", false));\n\t\ttodos.add(new Todo(5L, \"E\", false));\n\t\ttodos.add(new Todo(6L, \"F\", false));\n\n\t\tPatch patch = readJsonPatch(\"patch-many-successful-operations.json\");\n\t\tassertEquals(6, patch.size());\n\n\t\tList<Todo> patchedTodos = patch.apply(todos, Todo.class);\n\n\t\tassertEquals(6, todos.size());\n\t\tassertTrue(patchedTodos.get(1).isComplete());\n\t\tassertEquals(\"C\", patchedTodos.get(3).getDescription());\n\t\tassertEquals(\"A\", patchedTodos.get(4).getDescription());\n\t}\n\n\t@Test\n\tpublic void failureAtBeginning() throws Exception {\n\n\t\tList<Todo> todos = new ArrayList<Todo>();\n\t\ttodos.add(new Todo(1L, \"A\", true));\n\t\ttodos.add(new Todo(2L, \"B\", false));\n\t\ttodos.add(new Todo(3L, \"C\", false));\n\t\ttodos.add(new Todo(4L, \"D\", false));\n\t\ttodos.add(new Todo(5L, \"E\", false));\n\t\ttodos.add(new Todo(6L, \"F\", false));\n\n\t\tPatch patch = readJsonPatch(\"patch-failing-operation-first.json\");\n\n\t\ttry {\n\t\t\tpatch.apply(todos, Todo.class);\n\t\t\tfail();\n\t\t} catch (PatchException e) {\n\t\t\tassertEquals(\"Test against path '/5/description' failed.\", e.getMessage());\n\t\t}\n\n\t\tassertEquals(6, todos.size());\n\t\tassertFalse(todos.get(1).isComplete());\n\t\tassertEquals(\"D\", todos.get(3).getDescription());\n\t\tassertEquals(\"E\", todos.get(4).getDescription());\n\t\tassertEquals(\"F\", todos.get(5).getDescription());\n\t}\n\n\t@Test\n\tpublic void failureInMiddle() throws Exception {\n\n\t\tList<Todo> todos = new ArrayList<Todo>();\n\t\ttodos.add(new Todo(1L, \"A\", true));\n\t\ttodos.add(new Todo(2L, \"B\", false));\n\t\ttodos.add(new Todo(3L, \"C\", false));\n\t\ttodos.add(new Todo(4L, \"D\", false));\n\t\ttodos.add(new Todo(5L, \"E\", false));\n\t\ttodos.add(new Todo(6L, \"F\", false));\n\n\t\tPatch patch = readJsonPatch(\"patch-failing-operation-in-middle.json\");\n\n\t\ttry {\n\t\t\tpatch.apply(todos, Todo.class);\n\t\t\tfail();\n\t\t} catch (PatchException e) {\n\t\t\tassertEquals(\"Test against path '/5/description' failed.\", e.getMessage());\n\t\t}\n\n\t\tassertEquals(6, todos.size());\n\t\tassertFalse(todos.get(1).isComplete());\n\t\tassertEquals(\"D\", todos.get(3).getDescription());\n\t\tassertEquals(\"E\", todos.get(4).getDescription());\n\t\tassertEquals(\"F\", todos.get(5).getDescription());\n\t}\n\n\t@Test \n\tpublic void patchArray() throws Exception {\n\n\t\tTodo todo = new Todo(1L, \"F\", false);\n\n\t\tPatch patch = readJsonPatch(\"patch-array.json\");\n\t\tassertEquals(1, patch.size());\n\n\t\tTodo patchedTodo = patch.apply(todo, Todo.class);\n\t\tassertEquals(Arrays.asList(\"one\", \"two\", \"three\"), patchedTodo.getItems());\n\t}\n\n\t@Test \n\tpublic void patchUnknownType() throws Exception {\n\n\t\tTodo todo = new Todo();\n\t\ttodo.setAmount(BigInteger.ONE);\n\n\t\texception.expect(PatchException.class);\n\t\texception.expectMessage(\"/amount\");\n\t\texception.expectMessage(\"18446744073709551616\");\n\n\t\treadJsonPatch(\"patch-biginteger.json\");\n\t}\n\n\t@Test \n\tpublic void failureWithInvalidPatchContent() throws Exception {\n\n\t\tTodo todo = new Todo();\n\t\ttodo.setDescription(\"Description\");\n\n\t\tPatch patch = readJsonPatch(\"patch-failing-with-invalid-content.json\");\n\n\t\texception.expect(PatchException.class);\n\t\texception.expectMessage(\"content\");\n\t\texception.expectMessage(\"blabla\");\n\t\texception.expectMessage(String.class.toString());\n\n\t\tpatch.apply(todo, Todo.class);\n\t}\n\n\tprivate Patch readJsonPatch(String jsonPatchFile) throws IOException, JsonParseException, JsonMappingException {\n\n\t\tClassPathResource resource = new ClassPathResource(jsonPatchFile, getClass());\n\t\tJsonNode node = new ObjectMapper().readValue(resource.getInputStream(), JsonNode.class);\n\t\tPatch patch = new JsonPatchPatchConverter(new ObjectMapper()).convert(node);\n\n\t\treturn patch;\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 66,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-framework/commit/e2d6e709c3c65a4951eb096843ee75d5200cfcad",
    "cve_id": "CVE-2016-9878",
    "cwe_id": "CWE-22",
    "filename": "spring-webmvc/src/main/java/org/springframework/web/servlet/ResourceServlet.java",
    "code": "\n\npackage org.springframework.web.servlet;\n\nimport java.io.IOException;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.util.AntPathMatcher;\nimport org.springframework.util.PathMatcher;\nimport org.springframework.util.StringUtils;\nimport org.springframework.web.context.support.ServletContextResource;\n\n\n@SuppressWarnings(\"serial\")\n@Deprecated\npublic class ResourceServlet extends HttpServletBean {\n\n\t\n\tpublic static final String RESOURCE_URL_DELIMITERS = \",; \\t\\n\";\n\n\t\n\tpublic static final String RESOURCE_PARAM_NAME = \"resource\";\n\n\n\tprivate String defaultUrl;\n\n\tprivate String allowedResources;\n\n\tprivate String contentType;\n\n\tprivate boolean applyLastModified = false;\n\n\tprivate PathMatcher pathMatcher;\n\n\tprivate long startupTime;\n\n\n\t\n\tpublic void setDefaultUrl(String defaultUrl) {\n\t\tthis.defaultUrl = defaultUrl;\n\t}\n\n\t\n\tpublic void setAllowedResources(String allowedResources) {\n\t\tthis.allowedResources = allowedResources;\n\t}\n\n\t\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t\n\tpublic void setApplyLastModified(boolean applyLastModified) {\n\t\tthis.applyLastModified = applyLastModified;\n\t}\n\n\n\t\n\t@Override\n\tprotected void initServletBean() {\n\t\tthis.pathMatcher = getPathMatcher();\n\t\tthis.startupTime = System.currentTimeMillis();\n\t}\n\n\t\n\tprotected PathMatcher getPathMatcher() {\n\t\treturn new AntPathMatcher();\n\t}\n\n\n\t\n\t@Override\n\tprotected final void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\n\t\t\n\t\tString resourceUrl = determineResourceUrl(request);\n\n\t\tif (resourceUrl != null) {\n\t\t\ttry {\n\t\t\t\tdoInclude(request, response, resourceUrl);\n\t\t\t}\n\t\t\tcatch (ServletException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException ex) {\n\t\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\t\tlogger.warn(\"Failed to include content of resource [\" + resourceUrl + \"]\", ex);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!includeDefaultUrl(request, response)) {\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t\n\t\telse if (!includeDefaultUrl(request, response)) {\n\t\t\tthrow new ServletException(\"No target resource URL found for request\");\n\t\t}\n\t}\n\n\t\n\tprotected String determineResourceUrl(HttpServletRequest request) {\n\t\treturn request.getParameter(RESOURCE_PARAM_NAME);\n\t}\n\n\t\n\tprivate boolean includeDefaultUrl(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\n\t\tif (this.defaultUrl == null) {\n\t\t\treturn false;\n\t\t}\n\t\tdoInclude(request, response, this.defaultUrl);\n\t\treturn true;\n\t}\n\n\t\n\tprivate void doInclude(HttpServletRequest request, HttpServletResponse response, String resourceUrl)\n\t\t\tthrows ServletException, IOException {\n\n\t\tif (this.contentType != null) {\n\t\t\tresponse.setContentType(this.contentType);\n\t\t}\n\n\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\tfor (String url : resourceUrls) {\n\t\t\t\n\t\t\tif (this.allowedResources != null && !this.pathMatcher.match(this.allowedResources, url)) {\n\t\t\t\tthrow new ServletException(\"Resource [\" + url +\n\t\t\t\t\t\t\"] does not match allowed pattern [\" + this.allowedResources + \"]\");\n\t\t\t}\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Including resource [\" + url + \"]\");\n\t\t\t}\n\t\t\tRequestDispatcher rd = request.getRequestDispatcher(url);\n\t\t\trd.include(request, response);\n\t\t}\n\t}\n\n\t\n\t@Override\n\tprotected final long getLastModified(HttpServletRequest request) {\n\t\tif (this.applyLastModified) {\n\t\t\tString resourceUrl = determineResourceUrl(request);\n\t\t\tif (resourceUrl == null) {\n\t\t\t\tresourceUrl = this.defaultUrl;\n\t\t\t}\n\t\t\tif (resourceUrl != null) {\n\t\t\t\tString[] resourceUrls = StringUtils.tokenizeToStringArray(resourceUrl, RESOURCE_URL_DELIMITERS);\n\t\t\t\tlong latestTimestamp = -1;\n\t\t\t\tfor (String url : resourceUrls) {\n\t\t\t\t\tlong timestamp = getFileTimestamp(url);\n\t\t\t\t\tif (timestamp > latestTimestamp) {\n\t\t\t\t\t\tlatestTimestamp = timestamp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn (latestTimestamp > this.startupTime ? latestTimestamp : this.startupTime);\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t\n\tprotected long getFileTimestamp(String resourceUrl) {\n\t\tServletContextResource resource = new ServletContextResource(getServletContext(), resourceUrl);\n\t\ttry {\n\t\t\tlong lastModifiedTime = resource.lastModified();\n\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\tlogger.debug(\"Last-modified timestamp of \" + resource + \" is \" + lastModifiedTime);\n\t\t\t}\n\t\t\treturn lastModifiedTime;\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tif (logger.isWarnEnabled()) {\n\t\t\t\tlogger.warn(\"Couldn't retrieve last-modified timestamp of \" + resource +\n\t\t\t\t\t\t\" - using ResourceServlet startup time\");\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 67,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-framework/commit/423aa28ed584b4ff6e5bad218c09beef5e91951",
    "cve_id": "CVE-2018-15756",
    "cwe_id": "Not Mapping",
    "filename": "spring-web/src/main/java/org/springframework/http/HttpRange.java",
    "code": "\n\npackage org.springframework.http;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.core.io.support.ResourceRegion;\nimport org.springframework.lang.Nullable;\nimport org.springframework.util.Assert;\nimport org.springframework.util.CollectionUtils;\nimport org.springframework.util.ObjectUtils;\nimport org.springframework.util.StringUtils;\n\n\npublic abstract class HttpRange {\n\n\tprivate static final String BYTE_RANGE_PREFIX = \"bytes=\";\n\n\n\t\n\tpublic ResourceRegion toResourceRegion(Resource resource) {\n\t\t\n\t\t\n\t\tAssert.isTrue(resource.getClass() != InputStreamResource.class,\n\t\t\t\t\"Cannot convert an InputStreamResource to a ResourceRegion\");\n\t\ttry {\n\t\t\tlong contentLength = resource.contentLength();\n\t\t\tAssert.isTrue(contentLength > 0, \"Resource content length should be > 0\");\n\t\t\tlong start = getRangeStart(contentLength);\n\t\t\tlong end = getRangeEnd(contentLength);\n\t\t\treturn new ResourceRegion(resource, start, end - start + 1);\n\t\t}\n\t\tcatch (IOException ex) {\n\t\t\tthrow new IllegalArgumentException(\"Failed to convert Resource to ResourceRegion\", ex);\n\t\t}\n\t}\n\n\t\n\tpublic abstract long getRangeStart(long length);\n\n\t\n\tpublic abstract long getRangeEnd(long length);\n\n\n\t\n\tpublic static HttpRange createByteRange(long firstBytePos) {\n\t\treturn new ByteRange(firstBytePos, null);\n\t}\n\n\t\n\tpublic static HttpRange createByteRange(long firstBytePos, long lastBytePos) {\n\t\treturn new ByteRange(firstBytePos, lastBytePos);\n\t}\n\n\t\n\tpublic static HttpRange createSuffixRange(long suffixLength) {\n\t\treturn new SuffixByteRange(suffixLength);\n\t}\n\n\t\n\tpublic static List<HttpRange> parseRanges(@Nullable String ranges) {\n\t\tif (!StringUtils.hasLength(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tif (!ranges.startsWith(BYTE_RANGE_PREFIX)) {\n\t\t\tthrow new IllegalArgumentException(\"Range '\" + ranges + \"' does not start with 'bytes='\");\n\t\t}\n\t\tranges = ranges.substring(BYTE_RANGE_PREFIX.length());\n\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(ranges, \",\");\n\t\tList<HttpRange> result = new ArrayList<>(tokens.length);\n\t\tfor (String token : tokens) {\n\t\t\tresult.add(parseRange(token));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static HttpRange parseRange(String range) {\n\t\tAssert.hasLength(range, \"Range String must not be empty\");\n\t\tint dashIdx = range.indexOf('-');\n\t\tif (dashIdx > 0) {\n\t\t\tlong firstPos = Long.parseLong(range.substring(0, dashIdx));\n\t\t\tif (dashIdx < range.length() - 1) {\n\t\t\t\tLong lastPos = Long.parseLong(range.substring(dashIdx + 1, range.length()));\n\t\t\t\treturn new ByteRange(firstPos, lastPos);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new ByteRange(firstPos, null);\n\t\t\t}\n\t\t}\n\t\telse if (dashIdx == 0) {\n\t\t\tlong suffixLength = Long.parseLong(range.substring(1));\n\t\t\treturn new SuffixByteRange(suffixLength);\n\t\t}\n\t\telse {\n\t\t\tthrow new IllegalArgumentException(\"Range '\" + range + \"' does not contain \\\"-\\\"\");\n\t\t}\n\t}\n\n\t\n\tpublic static List<ResourceRegion> toResourceRegions(List<HttpRange> ranges, Resource resource) {\n\t\tif (CollectionUtils.isEmpty(ranges)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tList<ResourceRegion> regions = new ArrayList<>(ranges.size());\n\t\tfor (HttpRange range : ranges) {\n\t\t\tregions.add(range.toResourceRegion(resource));\n\t\t}\n\t\treturn regions;\n\t}\n\n\t\n\tpublic static String toString(Collection<HttpRange> ranges) {\n\t\tAssert.notEmpty(ranges, \"Ranges Collection must not be empty\");\n\t\tStringBuilder builder = new StringBuilder(BYTE_RANGE_PREFIX);\n\t\tfor (Iterator<HttpRange> iterator = ranges.iterator(); iterator.hasNext(); ) {\n\t\t\tHttpRange range = iterator.next();\n\t\t\tbuilder.append(range);\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\n\t\n\tprivate static class ByteRange extends HttpRange {\n\n\t\tprivate final long firstPos;\n\n\t\t@Nullable\n\t\tprivate final Long lastPos;\n\n\t\tpublic ByteRange(long firstPos, @Nullable Long lastPos) {\n\t\t\tassertPositions(firstPos, lastPos);\n\t\t\tthis.firstPos = firstPos;\n\t\t\tthis.lastPos = lastPos;\n\t\t}\n\n\t\tprivate void assertPositions(long firstBytePos, @Nullable Long lastBytePos) {\n\t\t\tif (firstBytePos < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid first byte position: \" + firstBytePos);\n\t\t\t}\n\t\t\tif (lastBytePos != null && lastBytePos < firstBytePos) {\n\t\t\t\tthrow new IllegalArgumentException(\"firstBytePosition=\" + firstBytePos +\n\t\t\t\t\t\t\" should be less then or equal to lastBytePosition=\" + lastBytePos);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getRangeStart(long length) {\n\t\t\treturn this.firstPos;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getRangeEnd(long length) {\n\t\t\tif (this.lastPos != null && this.lastPos < length) {\n\t\t\t\treturn this.lastPos;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn length - 1;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(other instanceof ByteRange)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tByteRange otherRange = (ByteRange) other;\n\t\t\treturn (this.firstPos == otherRange.firstPos &&\n\t\t\t\t\tObjectUtils.nullSafeEquals(this.lastPos, otherRange.lastPos));\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn (ObjectUtils.nullSafeHashCode(this.firstPos) * 31 +\n\t\t\t\t\tObjectUtils.nullSafeHashCode(this.lastPos));\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tbuilder.append(this.firstPos);\n\t\t\tbuilder.append('-');\n\t\t\tif (this.lastPos != null) {\n\t\t\t\tbuilder.append(this.lastPos);\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}\n\t}\n\n\n\t\n\tprivate static class SuffixByteRange extends HttpRange {\n\n\t\tprivate final long suffixLength;\n\n\t\tpublic SuffixByteRange(long suffixLength) {\n\t\t\tif (suffixLength < 0) {\n\t\t\t\tthrow new IllegalArgumentException(\"Invalid suffix length: \" + suffixLength);\n\t\t\t}\n\t\t\tthis.suffixLength = suffixLength;\n\t\t}\n\n\t\t@Override\n\t\tpublic long getRangeStart(long length) {\n\t\t\tif (this.suffixLength < length) {\n\t\t\t\treturn length - this.suffixLength;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic long getRangeEnd(long length) {\n\t\t\treturn length - 1;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object other) {\n\t\t\tif (this == other) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(other instanceof SuffixByteRange)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tSuffixByteRange otherRange = (SuffixByteRange) other;\n\t\t\treturn (this.suffixLength == otherRange.suffixLength);\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\treturn Long.hashCode(this.suffixLength);\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"-\" + this.suffixLength;\n\t\t}\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 67,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-framework/commit/423aa28ed584b4ff6e5bad218c09beef5e91951",
    "cve_id": "CVE-2018-15756",
    "cwe_id": "Not Mapping",
    "filename": "spring-web/src/test/java/org/springframework/http/HttpRangeTests.java",
    "code": "\n\npackage org.springframework.http;\n\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Test;\n\nimport org.springframework.core.io.ByteArrayResource;\nimport org.springframework.core.io.InputStreamResource;\nimport org.springframework.core.io.support.ResourceRegion;\n\nimport static org.junit.Assert.*;\nimport static org.mockito.BDDMockito.*;\n\n\npublic class HttpRangeTests {\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void invalidFirstPosition() {\n\t\tHttpRange.createByteRange(-1);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void invalidLastLessThanFirst() {\n\t\tHttpRange.createByteRange(10, 9);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void invalidSuffixLength() {\n\t\tHttpRange.createSuffixRange(-1);\n\t}\n\n\t@Test\n\tpublic void byteRange() {\n\t\tHttpRange range = HttpRange.createByteRange(0, 499);\n\t\tassertEquals(0, range.getRangeStart(1000));\n\t\tassertEquals(499, range.getRangeEnd(1000));\n\t}\n\n\t@Test\n\tpublic void byteRangeWithoutLastPosition() {\n\t\tHttpRange range = HttpRange.createByteRange(9500);\n\t\tassertEquals(9500, range.getRangeStart(10000));\n\t\tassertEquals(9999, range.getRangeEnd(10000));\n\t}\n\n\t@Test\n\tpublic void byteRangeOfZeroLength() {\n\t\tHttpRange range = HttpRange.createByteRange(9500, 9500);\n\t\tassertEquals(9500, range.getRangeStart(10000));\n\t\tassertEquals(9500, range.getRangeEnd(10000));\n\t}\n\n\t@Test\n\tpublic void suffixRange() {\n\t\tHttpRange range = HttpRange.createSuffixRange(500);\n\t\tassertEquals(500, range.getRangeStart(1000));\n\t\tassertEquals(999, range.getRangeEnd(1000));\n\t}\n\n\t@Test\n\tpublic void suffixRangeShorterThanRepresentation() {\n\t\tHttpRange range = HttpRange.createSuffixRange(500);\n\t\tassertEquals(0, range.getRangeStart(350));\n\t\tassertEquals(349, range.getRangeEnd(350));\n\t}\n\n\t@Test\n\tpublic void parseRanges() {\n\t\tList<HttpRange> ranges = HttpRange.parseRanges(\"bytes=0-0,500-,-1\");\n\t\tassertEquals(3, ranges.size());\n\t\tassertEquals(0, ranges.get(0).getRangeStart(1000));\n\t\tassertEquals(0, ranges.get(0).getRangeEnd(1000));\n\t\tassertEquals(500, ranges.get(1).getRangeStart(1000));\n\t\tassertEquals(999, ranges.get(1).getRangeEnd(1000));\n\t\tassertEquals(999, ranges.get(2).getRangeStart(1000));\n\t\tassertEquals(999, ranges.get(2).getRangeEnd(1000));\n\t}\n\n\t@Test\n\tpublic void rangeToString() {\n\t\tList<HttpRange> ranges = new ArrayList<>();\n\t\tranges.add(HttpRange.createByteRange(0, 499));\n\t\tranges.add(HttpRange.createByteRange(9500));\n\t\tranges.add(HttpRange.createSuffixRange(500));\n\t\tassertEquals(\"Invalid Range header\", \"bytes=0-499, 9500-, -500\", HttpRange.toString(ranges));\n\t}\n\n\t@Test\n\tpublic void toResourceRegion() {\n\t\tbyte[] bytes = \"Spring Framework\".getBytes(StandardCharsets.UTF_8);\n\t\tByteArrayResource resource = new ByteArrayResource(bytes);\n\t\tHttpRange range = HttpRange.createByteRange(0, 5);\n\t\tResourceRegion region = range.toResourceRegion(resource);\n\t\tassertEquals(resource, region.getResource());\n\t\tassertEquals(0L, region.getPosition());\n\t\tassertEquals(6L, region.getCount());\n\t}\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void toResourceRegionInputStreamResource() {\n\t\tInputStreamResource resource = mock(InputStreamResource.class);\n\t\tHttpRange range = HttpRange.createByteRange(0, 9);\n\t\trange.toResourceRegion(resource);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class)\n\tpublic void toResourceRegionIllegalLength() {\n\t\tByteArrayResource resource = mock(ByteArrayResource.class);\n\t\tgiven(resource.contentLength()).willReturn(-1L);\n\t\tHttpRange range = HttpRange.createByteRange(0, 9);\n\t\trange.toResourceRegion(resource);\n\t}\n\n\t@Test(expected = IllegalArgumentException.class)\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void toResourceRegionExceptionLength() throws IOException {\n\t\tInputStreamResource resource = mock(InputStreamResource.class);\n\t\tgiven(resource.contentLength()).willThrow(IOException.class);\n\t\tHttpRange range = HttpRange.createByteRange(0, 9);\n\t\trange.toResourceRegion(resource);\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 68,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-framework/commit/e02ff3a0da50744b0980d5d665fd242eedea767",
    "cve_id": "CVE-2018-1272",
    "cwe_id": "Not Mapping",
    "filename": "spring-core/src/main/java/org/springframework/util/MimeTypeUtils.java",
    "code": "\n\npackage org.springframework.util;\n\nimport java.nio.charset.Charset;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Random;\n\nimport org.springframework.util.MimeType.SpecificityComparator;\n\n\n@SuppressWarnings(\"deprecation\")\npublic abstract class MimeTypeUtils {\n\n\tprivate static final byte[] BOUNDARY_CHARS =\n\t\t\tnew byte[] {'-', '_', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', 'a', 'b', 'c', 'd', 'e', 'f', 'g',\n\t\t\t\t\t'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A',\n\t\t\t\t\t'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U',\n\t\t\t\t\t'V', 'W', 'X', 'Y', 'Z'};\n\n\tprivate static final Random RND = new Random();\n\n\tprivate static Charset US_ASCII = Charset.forName(\"US-ASCII\");\n\n\t\n\tpublic static final Comparator<MimeType> SPECIFICITY_COMPARATOR = new SpecificityComparator<MimeType>();\n\n\t\n\tpublic static final MimeType ALL;\n\n\t\n\tpublic static final String ALL_VALUE = \"*/*\";\n\n\t\n\t@Deprecated\n\tpublic final static MimeType APPLICATION_ATOM_XML;\n\n\t\n\t@Deprecated\n\tpublic final static String APPLICATION_ATOM_XML_VALUE = \"application/atom+xml\";\n\n\t\n\t@Deprecated\n\tpublic final static MimeType APPLICATION_FORM_URLENCODED;\n\n\t\n\t@Deprecated\n\tpublic final static String APPLICATION_FORM_URLENCODED_VALUE = \"application/x-www-form-urlencoded\";\n\n\t\n\tpublic final static MimeType APPLICATION_JSON;\n\n\t\n\tpublic final static String APPLICATION_JSON_VALUE = \"application/json\";\n\n\t\n\tpublic final static MimeType APPLICATION_OCTET_STREAM;\n\n\t\n\tpublic final static String APPLICATION_OCTET_STREAM_VALUE = \"application/octet-stream\";\n\n\t\n\t@Deprecated\n\tpublic final static MimeType APPLICATION_XHTML_XML;\n\n\t\n\t@Deprecated\n\tpublic final static String APPLICATION_XHTML_XML_VALUE = \"application/xhtml+xml\";\n\n\t\n\tpublic final static MimeType APPLICATION_XML;\n\n\t\n\tpublic final static String APPLICATION_XML_VALUE = \"application/xml\";\n\n\t\n\tpublic final static MimeType IMAGE_GIF;\n\n\t\n\tpublic final static String IMAGE_GIF_VALUE = \"image/gif\";\n\n\t\n\tpublic final static MimeType IMAGE_JPEG;\n\n\t\n\tpublic final static String IMAGE_JPEG_VALUE = \"image/jpeg\";\n\n\t\n\tpublic final static MimeType IMAGE_PNG;\n\n\t\n\tpublic final static String IMAGE_PNG_VALUE = \"image/png\";\n\n\t\n\t@Deprecated\n\tpublic final static MimeType MULTIPART_FORM_DATA;\n\n\t\n\t@Deprecated\n\tpublic final static String MULTIPART_FORM_DATA_VALUE = \"multipart/form-data\";\n\n\t\n\tpublic final static MimeType TEXT_HTML;\n\n\t\n\tpublic final static String TEXT_HTML_VALUE = \"text/html\";\n\n\t\n\tpublic final static MimeType TEXT_PLAIN;\n\n\t\n\tpublic final static String TEXT_PLAIN_VALUE = \"text/plain\";\n\n\t\n\tpublic final static MimeType TEXT_XML;\n\n\t\n\tpublic final static String TEXT_XML_VALUE = \"text/xml\";\n\n\n\tstatic {\n\t\tALL = MimeType.valueOf(ALL_VALUE);\n\t\tAPPLICATION_ATOM_XML = MimeType.valueOf(APPLICATION_ATOM_XML_VALUE);\n\t\tAPPLICATION_FORM_URLENCODED = MimeType.valueOf(APPLICATION_FORM_URLENCODED_VALUE);\n\t\tAPPLICATION_JSON = MimeType.valueOf(APPLICATION_JSON_VALUE);\n\t\tAPPLICATION_OCTET_STREAM = MimeType.valueOf(APPLICATION_OCTET_STREAM_VALUE);\n\t\tAPPLICATION_XHTML_XML = MimeType.valueOf(APPLICATION_XHTML_XML_VALUE);\n\t\tAPPLICATION_XML = MimeType.valueOf(APPLICATION_XML_VALUE);\n\t\tIMAGE_GIF = MimeType.valueOf(IMAGE_GIF_VALUE);\n\t\tIMAGE_JPEG = MimeType.valueOf(IMAGE_JPEG_VALUE);\n\t\tIMAGE_PNG = MimeType.valueOf(IMAGE_PNG_VALUE);\n\t\tMULTIPART_FORM_DATA = MimeType.valueOf(MULTIPART_FORM_DATA_VALUE);\n\t\tTEXT_HTML = MimeType.valueOf(TEXT_HTML_VALUE);\n\t\tTEXT_PLAIN = MimeType.valueOf(TEXT_PLAIN_VALUE);\n\t\tTEXT_XML = MimeType.valueOf(TEXT_XML_VALUE);\n\t}\n\n\n\t\n\tpublic static MimeType parseMimeType(String mimeType) {\n\t\tif (!StringUtils.hasLength(mimeType)) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\n\t\t}\n\n\t\tint index = mimeType.indexOf(';');\n\t\tString fullType = (index >= 0 ? mimeType.substring(0, index) : mimeType).trim();\n\t\tif (fullType.isEmpty()) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"'mimeType' must not be empty\");\n\t\t}\n\n\t\t\n\t\tif (MimeType.WILDCARD_TYPE.equals(fullType)) {\n\t\t\tfullType = \"*/*\";\n\t\t}\n\t\tint subIndex = fullType.indexOf('/');\n\t\tif (subIndex == -1) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"does not contain '/'\");\n\t\t}\n\t\tif (subIndex == fullType.length() - 1) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"does not contain subtype after '/'\");\n\t\t}\n\t\tString type = fullType.substring(0, subIndex);\n\t\tString subtype = fullType.substring(subIndex + 1, fullType.length());\n\t\tif (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"wildcard type is legal only in '*/*' (all mime types)\");\n\t\t}\n\n\t\tMap<String, String> parameters = null;\n\t\tdo {\n\t\t\tint nextIndex = index + 1;\n\t\t\tboolean quoted = false;\n\t\t\twhile (nextIndex < mimeType.length()) {\n\t\t\t\tchar ch = mimeType.charAt(nextIndex);\n\t\t\t\tif (ch == ';') {\n\t\t\t\t\tif (!quoted) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (ch == '\"') {\n\t\t\t\t\tquoted = !quoted;\n\t\t\t\t}\n\t\t\t\tnextIndex++;\n\t\t\t}\n\t\t\tString parameter = mimeType.substring(index + 1, nextIndex).trim();\n\t\t\tif (parameter.length() > 0) {\n\t\t\t\tif (parameters == null) {\n\t\t\t\t\tparameters = new LinkedHashMap<String, String>(4);\n\t\t\t\t}\n\t\t\t\tint eqIndex = parameter.indexOf('=');\n\t\t\t\tif (eqIndex >= 0) {\n\t\t\t\t\tString attribute = parameter.substring(0, eqIndex);\n\t\t\t\t\tString value = parameter.substring(eqIndex + 1, parameter.length());\n\t\t\t\t\tparameters.put(attribute, value);\n\t\t\t\t}\n\t\t\t}\n\t\t\tindex = nextIndex;\n\t\t}\n\t\twhile (index < mimeType.length());\n\n\t\ttry {\n\t\t\treturn new MimeType(type, subtype, parameters);\n\t\t}\n\t\tcatch (UnsupportedCharsetException ex) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, \"unsupported charset '\" + ex.getCharsetName() + \"'\");\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tthrow new InvalidMimeTypeException(mimeType, ex.getMessage());\n\t\t}\n\t}\n\n\t\n\tpublic static List<MimeType> parseMimeTypes(String mimeTypes) {\n\t\tif (!StringUtils.hasLength(mimeTypes)) {\n\t\t\treturn Collections.emptyList();\n\t\t}\n\t\tString[] tokens = StringUtils.tokenizeToStringArray(mimeTypes, \",\");\n\t\tList<MimeType> result = new ArrayList<MimeType>(tokens.length);\n\t\tfor (String token : tokens) {\n\t\t\tresult.add(parseMimeType(token));\n\t\t}\n\t\treturn result;\n\t}\n\n\t\n\tpublic static String toString(Collection<? extends MimeType> mimeTypes) {\n\t\tStringBuilder builder = new StringBuilder();\n\t\tfor (Iterator<? extends MimeType> iterator = mimeTypes.iterator(); iterator.hasNext();) {\n\t\t\tMimeType mimeType = iterator.next();\n\t\t\tmimeType.appendTo(builder);\n\t\t\tif (iterator.hasNext()) {\n\t\t\t\tbuilder.append(\", \");\n\t\t\t}\n\t\t}\n\t\treturn builder.toString();\n\t}\n\n\n\t\n\tpublic static void sortBySpecificity(List<MimeType> mimeTypes) {\n\t\tAssert.notNull(mimeTypes, \"'mimeTypes' must not be null\");\n\t\tif (mimeTypes.size() > 1) {\n\t\t\tCollections.sort(mimeTypes, SPECIFICITY_COMPARATOR);\n\t\t}\n\t}\n\n\t\n\tpublic static byte[] generateMultipartBoundary() {\n\t\tbyte[] boundary = new byte[RND.nextInt(11) + 30];\n\t\tfor (int i = 0; i < boundary.length; i++) {\n\t\t\tboundary[i] = BOUNDARY_CHARS[RND.nextInt(BOUNDARY_CHARS.length)];\n\t\t}\n\t\treturn boundary;\n\t}\n\n\t\n\tpublic static String generateMultipartBoundaryString() {\n\t\treturn new String(generateMultipartBoundary(), US_ASCII);\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 69,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/c70b65c5df0e170a2d34d812b83db0b7bc71ea25",
    "cve_id": "CVE-2018-15801",
    "cwe_id": "CWE-345",
    "filename": "oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/JwtIssuerValidator.java",
    "code": "\npackage org.springframework.security.oauth2.jwt;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport org.springframework.security.oauth2.core.OAuth2Error;\nimport org.springframework.security.oauth2.core.OAuth2ErrorCodes;\nimport org.springframework.security.oauth2.core.OAuth2TokenValidator;\nimport org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;\nimport org.springframework.util.Assert;\n\n\npublic final class JwtIssuerValidator implements OAuth2TokenValidator<Jwt> {\n\tprivate static OAuth2Error INVALID_ISSUER =\n\t\t\tnew OAuth2Error(\n\t\t\t\t\tOAuth2ErrorCodes.INVALID_REQUEST,\n\t\t\t\t\t\"This iss claim is not equal to the configured issuer\",\n\t\t\t\t\t\"https://tools.ietf.org/html/rfc6750#section-3.1\");\n\n\tprivate final URL issuer;\n\n\t\n\tpublic JwtIssuerValidator(String issuer) {\n\t\tAssert.notNull(issuer, \"issuer cannot be null\");\n\n\t\ttry {\n\t\t\tthis.issuer = new URL(issuer);\n\t\t} catch (MalformedURLException ex) {\n\t\t\tthrow new IllegalArgumentException(\n\t\t\t\t\t\"Invalid Issuer URL \" + issuer + \" : \" + ex.getMessage(),\n\t\t\t\t\tex);\n\t\t}\n\t}\n\n\t\n\t@Override\n\tpublic OAuth2TokenValidatorResult validate(Jwt token) {\n\t\tAssert.notNull(token, \"token cannot be null\");\n\n\t\tif (this.issuer.equals(token.getIssuer())) {\n\t\t\treturn OAuth2TokenValidatorResult.success();\n\t\t} else {\n\t\t\treturn OAuth2TokenValidatorResult.failure(INVALID_ISSUER);\n\t\t}\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 69,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/c70b65c5df0e170a2d34d812b83db0b7bc71ea25",
    "cve_id": "CVE-2018-15801",
    "cwe_id": "CWE-345",
    "filename": "oauth2/oauth2-jose/src/test/java/org/springframework/security/oauth2/jwt/JwtIssuerValidatorTests.java",
    "code": "\npackage org.springframework.security.oauth2.jwt;\n\nimport java.time.Instant;\nimport java.util.Collections;\nimport java.util.Map;\n\nimport org.junit.Test;\n\nimport org.springframework.security.oauth2.core.OAuth2TokenValidatorResult;\nimport org.springframework.security.oauth2.jose.jws.JwsAlgorithms;\nimport org.springframework.security.oauth2.jwt.Jwt;\nimport org.springframework.security.oauth2.jwt.JwtClaimNames;\nimport org.springframework.security.oauth2.jwt.JwtIssuerValidator;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.assertj.core.api.Assertions.assertThatCode;\n\n\npublic class JwtIssuerValidatorTests {\n\tprivate static final String MOCK_TOKEN = \"token\";\n\tprivate static final Instant MOCK_ISSUED_AT = Instant.MIN;\n\tprivate static final Instant MOCK_EXPIRES_AT = Instant.MAX;\n\tprivate static final Map<String, Object> MOCK_HEADERS =\n\t\t\tCollections.singletonMap(\"alg\", JwsAlgorithms.RS256);\n\n\tprivate static final String ISSUER = \"https://issuer\";\n\n\tprivate final JwtIssuerValidator validator = new JwtIssuerValidator(ISSUER);\n\n\t@Test\n\tpublic void validateWhenIssuerMatchesThenReturnsSuccess() {\n\t\tJwt jwt = new Jwt(\n\t\t\t\tMOCK_TOKEN,\n\t\t\t\tMOCK_ISSUED_AT,\n\t\t\t\tMOCK_EXPIRES_AT,\n\t\t\t\tMOCK_HEADERS,\n\t\t\t\tCollections.singletonMap(\"iss\", ISSUER));\n\n\t\tassertThat(this.validator.validate(jwt))\n\t\t\t\t.isEqualTo(OAuth2TokenValidatorResult.success());\n\t}\n\n\t@Test\n\tpublic void validateWhenIssuerMismatchesThenReturnsError() {\n\t\tJwt jwt = new Jwt(\n\t\t\t\tMOCK_TOKEN,\n\t\t\t\tMOCK_ISSUED_AT,\n\t\t\t\tMOCK_EXPIRES_AT,\n\t\t\t\tMOCK_HEADERS,\n\t\t\t\tCollections.singletonMap(JwtClaimNames.ISS, \"https://other\"));\n\n\t\tOAuth2TokenValidatorResult result = this.validator.validate(jwt);\n\n\t\tassertThat(result.getErrors()).isNotEmpty();\n\t}\n\n\t@Test\n\tpublic void validateWhenJwtIsNullThenThrowsIllegalArgumentException() {\n\t\tassertThatCode(() -> this.validator.validate(null))\n\t\t\t\t.isInstanceOf(IllegalArgumentException.class);\n\t}\n\n\t@Test\n\tpublic void constructorWhenMalformedIssuerIsGivenThenThrowsIllegalArgumentException() {\n\t\tassertThatCode(() -> new JwtIssuerValidator(\"issuer\"))\n\t\t\t\t.isInstanceOf(IllegalArgumentException.class);\n\t}\n\n\t@Test\n\tpublic void constructorWhenNullIssuerIsGivenThenThrowsIllegalArgumentException() {\n\t\tassertThatCode(() -> new JwtIssuerValidator(null))\n\t\t\t\t.isInstanceOf(IllegalArgumentException.class);\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 70,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/b2d4fec3617c497c5a8eb9c7e5270e0c7db293ee",
    "cve_id": "CVE-2019-11272",
    "cwe_id": "CWE-522",
    "filename": "core/src/main/java/org/springframework/security/authentication/encoding/PlaintextPasswordEncoder.java",
    "code": "\n\npackage org.springframework.security.authentication.encoding;\n\nimport java.util.Locale;\n\n\n@Deprecated\npublic class PlaintextPasswordEncoder extends BasePasswordEncoder {\n\t\n\t\n\n\tprivate boolean ignorePasswordCase = false;\n\n\t\n\t\n\n\tpublic String encodePassword(String rawPass, Object salt) {\n\t\treturn mergePasswordAndSalt(rawPass, salt, true);\n\t}\n\n\tpublic boolean isIgnorePasswordCase() {\n\t\treturn ignorePasswordCase;\n\t}\n\n\tpublic boolean isPasswordValid(String encPass, String rawPass, Object salt) {\n\t\tString pass1 = encPass + \"\";\n\n\t\t\n\t\t\n\t\t\n\t\tString pass2 = mergePasswordAndSalt(rawPass, salt, false);\n\n\t\tif (ignorePasswordCase) {\n\t\t\t\n\t\t\t\n\t\t\tpass1 = pass1.toLowerCase(Locale.ENGLISH);\n\t\t\tpass2 = pass2.toLowerCase(Locale.ENGLISH);\n\t\t}\n\t\treturn PasswordEncoderUtils.equals(pass1, pass2);\n\t}\n\n\t\n\tpublic String[] obtainPasswordAndSalt(String password) {\n\t\treturn demergePasswordAndSalt(password);\n\t}\n\n\t\n\tpublic void setIgnorePasswordCase(boolean ignorePasswordCase) {\n\t\tthis.ignorePasswordCase = ignorePasswordCase;\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 70,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/b2d4fec3617c497c5a8eb9c7e5270e0c7db293ee",
    "cve_id": "CVE-2019-11272",
    "cwe_id": "CWE-522",
    "filename": "core/src/test/java/org/springframework/security/authentication/encoding/PlaintextPasswordEncoderTests.java",
    "code": "\n\npackage org.springframework.security.authentication.encoding;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\nimport org.junit.Test;\n\n\npublic class PlaintextPasswordEncoderTests {\n\n\t\n\t\n\t@Test\n\tpublic void testBasicFunctionality() {\n\t\tPlaintextPasswordEncoder pe = new PlaintextPasswordEncoder();\n\n\t\tString raw = \"abc123\";\n\t\tString rawDiffCase = \"AbC123\";\n\t\tString badRaw = \"abc321\";\n\t\tString salt = \"THIS_IS_A_SALT\";\n\n\t\tString encoded = pe.encodePassword(raw, salt);\n\t\tassertThat(encoded).isEqualTo(\"abc123{THIS_IS_A_SALT}\");\n\t\tassertThat(pe.isPasswordValid(encoded, raw, salt)).isTrue();\n\t\tassertThat(pe.isPasswordValid(encoded, badRaw, salt)).isFalse();\n\n\t\t\n\t\tassertThat(pe.isIgnorePasswordCase()).isFalse();\n\t\tencoded = pe.encodePassword(rawDiffCase, salt);\n\t\tassertThat(pe.isPasswordValid(encoded, raw, salt)).isFalse();\n\n\t\t\n\t\tpe = new PlaintextPasswordEncoder();\n\t\tpe.setIgnorePasswordCase(true);\n\n\t\t\n\t\tencoded = pe.encodePassword(rawDiffCase, salt);\n\t\tassertThat(pe.isPasswordValid(encoded, raw, salt)).isTrue();\n\t\tassertThat(pe.isPasswordValid(encoded, badRaw, salt)).isFalse();\n\t}\n\n\t@Test\n\tpublic void testMergeDemerge() {\n\t\tPlaintextPasswordEncoder pwd = new PlaintextPasswordEncoder();\n\n\t\tString merged = pwd.encodePassword(\"password\", \"foo\");\n\t\tString[] demerged = pwd.obtainPasswordAndSalt(merged);\n\t\tassertThat(demerged[0]).isEqualTo(\"password\");\n\t\tassertThat(demerged[1]).isEqualTo(\"foo\");\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 71,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/1304c958bf9c38940082f3ad1558d413ed82f2b",
    "cve_id": "CVE-2019-3795",
    "cwe_id": "CWE-332",
    "filename": "core/src/main/java/org/springframework/security/core/token/SecureRandomFactoryBean.java",
    "code": "\npackage org.springframework.security.core.token;\n\nimport java.io.InputStream;\nimport java.security.SecureRandom;\n\nimport org.springframework.beans.factory.FactoryBean;\nimport org.springframework.core.io.Resource;\nimport org.springframework.util.Assert;\nimport org.springframework.util.FileCopyUtils;\n\n\npublic class SecureRandomFactoryBean implements FactoryBean<SecureRandom> {\n\n\tprivate String algorithm = \"SHA1PRNG\";\n\tprivate Resource seed;\n\n\tpublic SecureRandom getObject() throws Exception {\n\t\tSecureRandom rnd = SecureRandom.getInstance(algorithm);\n\n\t\tif (seed != null) {\n\t\t\t\n\t\t\tbyte[] seedBytes = FileCopyUtils.copyToByteArray(seed.getInputStream());\n\t\t\trnd.setSeed(seedBytes);\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\t\n\t\t\trnd.nextBytes(new byte[1]);\n\t\t}\n\n\t\treturn rnd;\n\t}\n\n\tpublic Class<SecureRandom> getObjectType() {\n\t\treturn SecureRandom.class;\n\t}\n\n\tpublic boolean isSingleton() {\n\t\treturn false;\n\t}\n\n\t\n\tpublic void setAlgorithm(String algorithm) {\n\t\tAssert.hasText(algorithm, \"Algorithm required\");\n\t\tthis.algorithm = algorithm;\n\t}\n\n\t\n\tpublic void setSeed(Resource seed) {\n\t\tthis.seed = seed;\n\t}\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 71,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security/commit/1304c958bf9c38940082f3ad1558d413ed82f2b",
    "cve_id": "CVE-2019-3795",
    "cwe_id": "CWE-332",
    "filename": "core/src/test/java/org/springframework/security/core/token/SecureRandomFactoryBeanTests.java",
    "code": "\npackage org.springframework.security.core.token;\n\nimport static org.assertj.core.api.Assertions.*;\n\nimport java.security.SecureRandom;\n\nimport org.junit.Test;\nimport org.springframework.core.io.ClassPathResource;\nimport org.springframework.core.io.Resource;\nimport org.springframework.security.core.token.SecureRandomFactoryBean;\n\n\npublic class SecureRandomFactoryBeanTests {\n\t@Test\n\tpublic void testObjectType() {\n\t\tSecureRandomFactoryBean factory = new SecureRandomFactoryBean();\n\t\tassertThat(factory.getObjectType()).isEqualTo(SecureRandom.class);\n\t}\n\n\t@Test\n\tpublic void testIsSingleton() {\n\t\tSecureRandomFactoryBean factory = new SecureRandomFactoryBean();\n\t\tassertThat(factory.isSingleton()).isFalse();\n\t}\n\n\t@Test\n\tpublic void testCreatesUsingDefaults() throws Exception {\n\t\tSecureRandomFactoryBean factory = new SecureRandomFactoryBean();\n\t\tObject result = factory.getObject();\n\t\tassertThat(result).isInstanceOf(SecureRandom.class);\n\t\tint rnd = ((SecureRandom) result).nextInt();\n\t\tassertThat(rnd).isNotEqualTo(0);\n\t}\n\n\t@Test\n\tpublic void testCreatesUsingSeed() throws Exception {\n\t\tSecureRandomFactoryBean factory = new SecureRandomFactoryBean();\n\t\tResource resource = new ClassPathResource(\n\t\t\t\t\"org/springframework/security/core/token/SecureRandomFactoryBeanTests.class\");\n\t\tassertThat(resource).isNotNull();\n\t\tfactory.setSeed(resource);\n\t\tObject result = factory.getObject();\n\t\tassertThat(result).isInstanceOf(SecureRandom.class);\n\t\tint rnd = ((SecureRandom) result).nextInt();\n\t\tassertThat(rnd).isNotEqualTo(0);\n\t}\n\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 72,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/spring-projects/spring-security-oauth/commit/fff77d3fea477b566bcacfbfc95f85821a2bdc2d",
    "cve_id": "CVE-2016-4977",
    "cwe_id": "CWE-19",
    "filename": "spring-security-oauth2/src/main/java/org/springframework/security/oauth2/provider/endpoint/SpelView.java",
    "code": "\n\npackage org.springframework.security.oauth2.provider.endpoint;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.context.expression.MapAccessor;\nimport org.springframework.expression.Expression;\nimport org.springframework.expression.spel.standard.SpelExpressionParser;\nimport org.springframework.expression.spel.support.StandardEvaluationContext;\nimport org.springframework.util.PropertyPlaceholderHelper;\nimport org.springframework.util.PropertyPlaceholderHelper.PlaceholderResolver;\nimport org.springframework.web.servlet.View;\nimport org.springframework.web.servlet.support.ServletUriComponentsBuilder;\n\n\nclass SpelView implements View {\n\n\tprivate final String template;\n\n\tprivate final SpelExpressionParser parser = new SpelExpressionParser();\n\n\tprivate final StandardEvaluationContext context = new StandardEvaluationContext();\n\n\tprivate PropertyPlaceholderHelper helper;\n\n\tprivate PlaceholderResolver resolver;\n\n\tpublic SpelView(String template) {\n\t\tthis.template = template;\n\t\tthis.context.addPropertyAccessor(new MapAccessor());\n\t\tthis.helper = new PropertyPlaceholderHelper(\"${\", \"}\");\n\t\tthis.resolver = new PlaceholderResolver() {\n\t\t\tpublic String resolvePlaceholder(String name) {\n\t\t\t\tExpression expression = parser.parseExpression(name);\n\t\t\t\tObject value = expression.getValue(context);\n\t\t\t\treturn value == null ? null : value.toString();\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic String getContentType() {\n\t\treturn \"text/html\";\n\t}\n\n\tpublic void render(Map<String, ?> model, HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows Exception {\n\t\tMap<String, Object> map = new HashMap<String, Object>(model);\n\t\tString path = ServletUriComponentsBuilder.fromContextPath(request).build()\n\t\t\t\t.getPath();\n\t\tmap.put(\"path\", (Object) path==null ? \"\" : path);\n\t\tcontext.setRootObject(map);\n\t\tString result = helper.replacePlaceholders(template, resolver);\n\t\tresponse.setContentType(getContentType());\n\t\tresponse.getWriter().append(result);\n\t}\n\n}",
    "is_vulnerable": 1
  },
  {
    "id": 73,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d",
    "cve_id": "CVE-2018-1000850",
    "cwe_id": "CWE-22",
    "filename": "retrofit/src/main/java/retrofit2/RequestBuilder.java",
    "code": "\npackage retrofit2;\n\nimport java.io.IOException;\nimport javax.annotation.Nullable;\nimport okhttp3.FormBody;\nimport okhttp3.Headers;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okio.Buffer;\nimport okio.BufferedSink;\n\nfinal class RequestBuilder {\n  private static final char[] HEX_DIGITS =\n      { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n  private static final String PATH_SEGMENT_ALWAYS_ENCODE_SET = \" \\\"<>^`{}|\\\\?#\";\n\n  private final String method;\n\n  private final HttpUrl baseUrl;\n  private @Nullable String relativeUrl;\n  private @Nullable HttpUrl.Builder urlBuilder;\n\n  private final Request.Builder requestBuilder;\n  private @Nullable MediaType contentType;\n\n  private final boolean hasBody;\n  private @Nullable MultipartBody.Builder multipartBuilder;\n  private @Nullable FormBody.Builder formBuilder;\n  private @Nullable RequestBody body;\n\n  RequestBuilder(String method, HttpUrl baseUrl,\n      @Nullable String relativeUrl, @Nullable Headers headers, @Nullable MediaType contentType,\n      boolean hasBody, boolean isFormEncoded, boolean isMultipart) {\n    this.method = method;\n    this.baseUrl = baseUrl;\n    this.relativeUrl = relativeUrl;\n    this.requestBuilder = new Request.Builder();\n    this.contentType = contentType;\n    this.hasBody = hasBody;\n\n    if (headers != null) {\n      requestBuilder.headers(headers);\n    }\n\n    if (isFormEncoded) {\n      \n      formBuilder = new FormBody.Builder();\n    } else if (isMultipart) {\n      \n      multipartBuilder = new MultipartBody.Builder();\n      multipartBuilder.setType(MultipartBody.FORM);\n    }\n  }\n\n  void setRelativeUrl(Object relativeUrl) {\n    this.relativeUrl = relativeUrl.toString();\n  }\n\n  void addHeader(String name, String value) {\n    if (\"Content-Type\".equalsIgnoreCase(name)) {\n      try {\n        contentType = MediaType.get(value);\n      } catch (IllegalArgumentException e) {\n        throw new IllegalArgumentException(\"Malformed content type: \" + value, e);\n      }\n    } else {\n      requestBuilder.addHeader(name, value);\n    }\n  }\n\n  void addPathParam(String name, String value, boolean encoded) {\n    if (relativeUrl == null) {\n      \n      throw new AssertionError();\n    }\n    relativeUrl = relativeUrl.replace(\"{\" + name + \"}\", canonicalizeForPath(value, encoded));\n  }\n\n  private static String canonicalizeForPath(String input, boolean alreadyEncoded) {\n    int codePoint;\n    for (int i = 0, limit = input.length(); i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        \n        Buffer out = new Buffer();\n        out.writeUtf8(input, 0, i);\n        canonicalizeForPath(out, input, i, limit, alreadyEncoded);\n        return out.readUtf8();\n      }\n    }\n\n    \n    return input;\n  }\n\n  private static void canonicalizeForPath(Buffer out, String input, int pos, int limit,\n      boolean alreadyEncoded) {\n    Buffer utf8Buffer = null; \n    int codePoint;\n    for (int i = pos; i < limit; i += Character.charCount(codePoint)) {\n      codePoint = input.codePointAt(i);\n      if (alreadyEncoded\n          && (codePoint == '\\t' || codePoint == '\\n' || codePoint == '\\f' || codePoint == '\\r')) {\n        \n      } else if (codePoint < 0x20 || codePoint >= 0x7f\n          || PATH_SEGMENT_ALWAYS_ENCODE_SET.indexOf(codePoint) != -1\n          || (!alreadyEncoded && (codePoint == '/' || codePoint == '%'))) {\n        \n        if (utf8Buffer == null) {\n          utf8Buffer = new Buffer();\n        }\n        utf8Buffer.writeUtf8CodePoint(codePoint);\n        while (!utf8Buffer.exhausted()) {\n          int b = utf8Buffer.readByte() & 0xff;\n          out.writeByte('%');\n          out.writeByte(HEX_DIGITS[(b >> 4) & 0xf]);\n          out.writeByte(HEX_DIGITS[b & 0xf]);\n        }\n      } else {\n        \n        out.writeUtf8CodePoint(codePoint);\n      }\n    }\n  }\n\n  void addQueryParam(String name, @Nullable String value, boolean encoded) {\n    if (relativeUrl != null) {\n      \n      urlBuilder = baseUrl.newBuilder(relativeUrl);\n      if (urlBuilder == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n      relativeUrl = null;\n    }\n\n    if (encoded) {\n      \n      urlBuilder.addEncodedQueryParameter(name, value);\n    } else {\n      \n      urlBuilder.addQueryParameter(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") \n  void addFormField(String name, String value, boolean encoded) {\n    if (encoded) {\n      formBuilder.addEncoded(name, value);\n    } else {\n      formBuilder.add(name, value);\n    }\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") \n  void addPart(Headers headers, RequestBody body) {\n    multipartBuilder.addPart(headers, body);\n  }\n\n  @SuppressWarnings(\"ConstantConditions\") \n  void addPart(MultipartBody.Part part) {\n    multipartBuilder.addPart(part);\n  }\n\n  void setBody(RequestBody body) {\n    this.body = body;\n  }\n\n  Request.Builder get() {\n    HttpUrl url;\n    HttpUrl.Builder urlBuilder = this.urlBuilder;\n    if (urlBuilder != null) {\n      url = urlBuilder.build();\n    } else {\n      \n      \n      url = baseUrl.resolve(relativeUrl);\n      if (url == null) {\n        throw new IllegalArgumentException(\n            \"Malformed URL. Base: \" + baseUrl + \", Relative: \" + relativeUrl);\n      }\n    }\n\n    RequestBody body = this.body;\n    if (body == null) {\n      \n      if (formBuilder != null) {\n        body = formBuilder.build();\n      } else if (multipartBuilder != null) {\n        body = multipartBuilder.build();\n      } else if (hasBody) {\n        \n        body = RequestBody.create(null, new byte[0]);\n      }\n    }\n\n    MediaType contentType = this.contentType;\n    if (contentType != null) {\n      if (body != null) {\n        body = new ContentTypeOverridingRequestBody(body, contentType);\n      } else {\n        requestBuilder.addHeader(\"Content-Type\", contentType.toString());\n      }\n    }\n\n    return requestBuilder\n        .url(url)\n        .method(method, body);\n  }\n\n  private static class ContentTypeOverridingRequestBody extends RequestBody {\n    private final RequestBody delegate;\n    private final MediaType contentType;\n\n    ContentTypeOverridingRequestBody(RequestBody delegate, MediaType contentType) {\n      this.delegate = delegate;\n      this.contentType = contentType;\n    }\n\n    @Override public MediaType contentType() {\n      return contentType;\n    }\n\n    @Override public long contentLength() throws IOException {\n      return delegate.contentLength();\n    }\n\n    @Override public void writeTo(BufferedSink sink) throws IOException {\n      delegate.writeTo(sink);\n    }\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 73,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/square/retrofit/commit/b9a7f6ad72073ddd40254c0058710e87a073047d",
    "cve_id": "CVE-2018-1000850",
    "cwe_id": "CWE-22",
    "filename": "retrofit/src/test/java/retrofit2/RequestFactoryTest.java",
    "code": "\npackage retrofit2;\n\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport okhttp3.HttpUrl;\nimport okhttp3.MediaType;\nimport okhttp3.MultipartBody;\nimport okhttp3.Request;\nimport okhttp3.RequestBody;\nimport okhttp3.ResponseBody;\nimport okio.Buffer;\nimport org.junit.Test;\nimport retrofit2.helpers.NullObjectConverterFactory;\nimport retrofit2.helpers.ToStringConverterFactory;\nimport retrofit2.http.Body;\nimport retrofit2.http.DELETE;\nimport retrofit2.http.Field;\nimport retrofit2.http.FieldMap;\nimport retrofit2.http.FormUrlEncoded;\nimport retrofit2.http.GET;\nimport retrofit2.http.HEAD;\nimport retrofit2.http.HTTP;\nimport retrofit2.http.Header;\nimport retrofit2.http.HeaderMap;\nimport retrofit2.http.Headers;\nimport retrofit2.http.Multipart;\nimport retrofit2.http.OPTIONS;\nimport retrofit2.http.PATCH;\nimport retrofit2.http.POST;\nimport retrofit2.http.PUT;\nimport retrofit2.http.Part;\nimport retrofit2.http.PartMap;\nimport retrofit2.http.Path;\nimport retrofit2.http.Query;\nimport retrofit2.http.QueryMap;\nimport retrofit2.http.QueryName;\nimport retrofit2.http.Url;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\n@SuppressWarnings({\"UnusedParameters\", \"unused\"}) \npublic final class RequestFactoryTest {\n  private static final MediaType TEXT_PLAIN = MediaType.get(\"text/plain\");\n\n  @Test public void customMethodNoBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM1\", path = \"/foo\")\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"CUSTOM1\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void customMethodWithBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM2\", path = \"/foo\", hasBody = true)\n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"CUSTOM2\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void onlyOneEncodingIsAllowedMultipartFirst() {\n    class Example {\n      @Multipart \n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Only one encoding annotation is allowed.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void onlyOneEncodingIsAllowedFormEncodingFirst() {\n    class Example {\n      @FormUrlEncoded \n      @Multipart \n      @POST(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Only one encoding annotation is allowed.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void invalidPathParam() throws Exception {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@Path(\"hey!\") String thing) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Path parameter name must match \\\\{([a-zA-Z][a-zA-Z0-9_-]*)\\\\}.\"\n              + \" Found: hey! (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void pathParamNotAllowedInQuery() throws Exception {\n    class Example {\n      @GET(\"/foo?bar={bar}\") \n      Call<ResponseBody> method(@Path(\"bar\") String thing) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"URL query string \\\"bar={bar}\\\" must not have replace block.\"\n              + \" For dynamic query parameters use @Query.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipleParameterAnnotationsNotAllowed() throws Exception {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@Body @Query(\"nope\") String o) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multiple Retrofit annotations found, only one allowed. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @interface NonNull {}\n\n  @Test public void multipleParameterAnnotationsOnlyOneRetrofitAllowed() throws Exception {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@Query(\"maybe\") @NonNull Object o) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"yep\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/?maybe=yep\");\n  }\n\n  @Test public void twoMethodsFail() {\n    class Example {\n      @PATCH(\"/foo\") \n      @POST(\"/foo\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n        assertThat(e.getMessage())\n            .isIn(\"Only one HTTP method is allowed. Found: PATCH and POST.\\n    for method Example.method\",\n                  \"Only one HTTP method is allowed. Found: POST and PATCH.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void lackingMethod() {\n    class Example {\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"HTTP method annotation is required (e.g., @GET, @POST, etc.).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitMultipartForbidden() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@Part(\"a\") int a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters can only be used with multipart encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitMultipartWithPartMapForbidden() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@PartMap Map<String, String> params) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap parameters can only be used with multipart encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartFailsOnNonBodyMethod() {\n    class Example {\n      @Multipart \n      @GET(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multipart can only be specified on HTTP methods with request body (e.g., @POST).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartFailsWithNoParts() {\n    class Example {\n      @Multipart \n      @POST(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multipart method must contain at least one @Part.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitFormEncodingByFieldForbidden() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@Field(\"a\") int a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Field parameters can only be used with form encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void implicitFormEncodingByFieldMapForbidden() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap Map<String, String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@FieldMap parameters can only be used with form encoding. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void formEncodingFailsOnNonBodyMethod() {\n    class Example {\n      @FormUrlEncoded \n      @GET(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"FormUrlEncoded can only be specified on HTTP methods with request body (e.g., @POST).\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void formEncodingFailsWithNoParts() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Form-encoded method must contain at least one @Field.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headersFailWhenEmptyOnMethod() {\n    class Example {\n      @GET(\"/\") \n      @Headers({}) \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Headers annotation is empty.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headersFailWhenMalformed() {\n    class Example {\n      @GET(\"/\") \n      @Headers(\"Malformed\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Headers value must be in the form \\\"Name: Value\\\". Found: \\\"Malformed\\\"\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void pathParamNonPathParamAndTypedBytes() {\n    class Example {\n      @PUT(\"/{a}\") \n      Call<ResponseBody> method(@Path(\"a\") int a, @Path(\"b\") int b, @Body int c) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"URL \\\"/{a}\\\" does not contain \\\"{b}\\\". (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void parameterWithoutAnnotation() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(String a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"No Retrofit annotation found. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void nonBodyHttpMethodWithSingleEntity() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@Body String o) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Non-body HTTP method cannot contain @Body.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void queryMapMustBeAMap() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@QueryMap List<String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@QueryMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void queryMapSupportsSubclasses() {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@QueryMap Foo a) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/?hello=world\");\n  }\n\n  @Test public void queryMapRejectsNull() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map was null.\");\n    }\n  }\n\n  @Test public void queryMapRejectsNullKeys() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Map<String, String> queryParams = new LinkedHashMap<>();\n    queryParams.put(\"ping\", \"pong\");\n    queryParams.put(null, \"kat\");\n\n    try {\n      buildRequest(Example.class, queryParams);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map contained null key.\");\n    }\n  }\n\n  @Test public void queryMapRejectsNullValues() {\n    class Example {\n      @GET(\"/\") \n      Call<ResponseBody> method(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Map<String, String> queryParams = new LinkedHashMap<>();\n    queryParams.put(\"ping\", \"pong\");\n    queryParams.put(\"kit\", null);\n\n    try {\n      buildRequest(Example.class, queryParams);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Query map contained null value for key 'kit'.\");\n    }\n  }\n\n  @Test public void getWithHeaderMap() {\n    class Example {\n      @GET(\"/search\")\n      Call<ResponseBody> method(@HeaderMap Map<String, Object> headers) {\n        return null;\n      }\n    }\n\n    Map<String, Object> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(\"Accept-Charset\", \"utf-8\");\n\n    Request request = buildRequest(Example.class, headers);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/search\");\n    assertThat(request.body()).isNull();\n    assertThat(request.headers().size()).isEqualTo(2);\n    assertThat(request.header(\"Accept\")).isEqualTo(\"text/plain\");\n    assertThat(request.header(\"Accept-Charset\")).isEqualTo(\"utf-8\");\n  }\n\n  @Test public void headerMapMustBeAMap() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap List<String> headers) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@HeaderMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void headerMapSupportsSubclasses() {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @GET(\"/search\")\n      Call<ResponseBody> method(@HeaderMap Foo headers) {\n        return null;\n      }\n    }\n\n    Foo headers = new Foo();\n    headers.put(\"Accept\", \"text/plain\");\n\n    Request request = buildRequest(Example.class, headers);\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/search\");\n    assertThat(request.headers().size()).isEqualTo(1);\n    assertThat(request.header(\"Accept\")).isEqualTo(\"text/plain\");\n  }\n\n  @Test public void headerMapRejectsNull() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, (Map<String, String>) null);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map was null.\");\n    }\n  }\n\n  @Test public void headerMapRejectsNullKeys() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    Map<String, String> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(null, \"utf-8\");\n\n    try {\n      buildRequest(Example.class, headers);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map contained null key.\");\n    }\n  }\n\n  @Test public void headerMapRejectsNullValues() {\n    class Example {\n      @GET(\"/\")\n      Call<ResponseBody> method(@HeaderMap Map<String, String> headers) {\n        return null;\n      }\n    }\n\n    Map<String, String> headers = new LinkedHashMap<>();\n    headers.put(\"Accept\", \"text/plain\");\n    headers.put(\"Accept-Charset\", null);\n\n    try {\n      buildRequest(Example.class, headers);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Header map contained null value for key 'Accept-Charset'.\");\n    }\n  }\n\n  @Test public void twoBodies() {\n    class Example {\n      @PUT(\"/\") \n      Call<ResponseBody> method(@Body String o1, @Body String o2) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Multiple @Body method annotations found. (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void bodyInNonBodyRequest() {\n    class Example {\n      @Multipart \n      @PUT(\"/\") \n      Call<ResponseBody> method(@Part(\"one\") String o1, @Body String o2) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Body parameters cannot be used with form or multi-part encoding. (parameter #2)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void get() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void delete() {\n    class Example {\n      @DELETE(\"/foo/bar/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"DELETE\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertNull(request.body());\n  }\n\n  @Test public void head() {\n    class Example {\n      @HEAD(\"/foo/bar/\") \n      Call<Void> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"HEAD\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headWithoutVoidThrows() {\n    class Example {\n      @HEAD(\"/foo/bar/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"HEAD method must use Void as response type.\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void post() {\n    class Example {\n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void put() {\n    class Example {\n      @PUT(\"/foo/bar/\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"PUT\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void patch() {\n    class Example {\n      @PATCH(\"/foo/bar/\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.method()).isEqualTo(\"PATCH\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void options() {\n    class Example {\n      @OPTIONS(\"/foo/bar/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"OPTIONS\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"po ng\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/po%20ng/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUnusedAndInvalidNamedPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/{kit,kat}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/%7Bkit,kat%7D/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"po%20ng\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/po%20ng/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathSegments() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/pong/more\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz/pong/more/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUnencodedPathSegmentsPreventsRequestSplitting() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = false) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/\\r\\nheader: blue\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz%2F%0D%0Aheader:%20blue/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedPathStillPreventsRequestSplitting() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(value = \"ping\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"baz/\\r\\npong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/baz/pong/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void pathParamRequired() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Path parameter \\\"ping\\\" value must not be null.\");\n    }\n  }\n\n  @Test public void getWithQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(value = \"pi%20ng\", encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"p%20o%20n%20g\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?pi%20ng=p%20o%20n%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void queryParamOptionalOmitsQuery() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new Object[] { null });\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n  }\n\n  @Test public void queryParamOptional() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"foo\") String foo, @Query(\"ping\") String ping,\n          @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", null, \"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?foo=bar&kit=kat\");\n  }\n\n  @Test public void getWithQueryUrlAndParam() {\n    class Example {\n      @GET(\"/foo/bar/?hi=mom\") \n      Call<ResponseBody> method(@Query(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hi=mom&ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQuery() {\n    class Example {\n      @GET(\"/foo/bar/?hi=mom\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hi=mom\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit,\n          @Query(\"riff\") String riff) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", \"kat\", \"raff\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/?kit=kat&riff=raff\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Query(\"kit\") String kit, @Path(\"ping\") String ping) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"kat\", \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @Query. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryNameThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@QueryName String kit, @Path(\"ping\") String ping) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"kat\", \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @QueryName. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryMapThenPathThrows() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Path(\"ping\") String ping) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"pong\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Path parameter must not come after a @QueryMap. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithPathAndQueryQuestionMarkParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong?\", \"kat?\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString())\n        .isEqualTo(\"http://example.com/foo/bar/pong%3F/?kit=kat%3F\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryAmpersandParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong&\", \"kat&\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong&/?kit=kat%26\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithPathAndQueryHashParam() {\n    class Example {\n      @GET(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Query(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong#\", \"kat#\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong%23/?kit=kat%23\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"key\") List<Object> keys) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(1, 2, null, \"three\", \"1\");\n    Request request = buildRequest(Example.class, values);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=three&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"key\") Object[] keys) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\", \"1\" };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=three&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamPrimitiveArray() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Query(\"key\") int[] keys) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3, 1 };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?key=1&key=2&key=3&key=1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParam() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryNameParam() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName(encoded = true) String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"p%20o%20n%20g\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?p%20o%20n%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void queryNameParamOptionalOmitsQuery() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new Object[] { null });\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n  }\n\n  @Test public void getWithQueryNameParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName List<Object> keys) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(1, 2, null, \"three\", \"1\");\n    Request request = buildRequest(Example.class, values);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&three&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName Object[] keys) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\", \"1\" };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&three&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryNameParamPrimitiveArray() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryName int[] keys) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3, 1 };\n    Request request = buildRequest(Example.class, new Object[] { values });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?1&2&3&1\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithQueryParamMap() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryMap Map<String, Object> query) {\n        return null;\n      }\n    }\n\n    Map<String, Object> params = new LinkedHashMap<>();\n    params.put(\"kit\", \"kat\");\n    params.put(\"ping\", \"pong\");\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?kit=kat&ping=pong\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithEncodedQueryParamMap() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@QueryMap(encoded = true) Map<String, Object> query) {\n        return null;\n      }\n    }\n\n    Map<String, Object> params = new LinkedHashMap<>();\n    params.put(\"kit\", \"k%20t\");\n    params.put(\"pi%20ng\", \"p%20g\");\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?kit=k%20t&pi%20ng=p%20g\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getAbsoluteUrl() {\n    class Example {\n      @GET(\"http://example2.com/foo/bar/\")\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithStringUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithJavaUriUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url URI url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, URI.create(\"foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithStringUrlAbsolute() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"https://example2.com/foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"https://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithJavaUriUrlAbsolute() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url URI url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, URI.create(\"https://example2.com/foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"https://example2.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithUrlAbsoluteSameHost() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"http://example.com/foo/bar/\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithHttpUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url HttpUrl url) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, HttpUrl.get(\"http://example.com/foo/bar/\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url()).isEqualTo(HttpUrl.get(\"http://example.com/foo/bar/\"));\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void getWithNullUrl() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url HttpUrl url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, (HttpUrl) null);\n      fail();\n    } catch (NullPointerException expected) {\n      assertThat(expected).hasMessage(\"@Url parameter is null.\");\n    }\n  }\n\n  @Test public void getWithNonStringUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Url must be okhttp3.HttpUrl, String, java.net.URI, or android.net.Uri type.\"\n              + \" (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getUrlAndUrlParamThrows() {\n    class Example {\n      @GET(\"foo/bar\")\n      Call<ResponseBody> method(@Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Url cannot be used with @GET URL (parameter #1)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithoutUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Missing either @GET URL or @Url parameter.\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithUrlThenPathThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url, @Path(\"hey\") String hey) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Path parameters may not be used with @Url. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithPathThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Path(\"hey\") String hey, @Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"foo/bar\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"@Path can only be used with relative url on @GET (parameter #1)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryThenUrlThrows() {\n    class Example {\n      @GET(\"foo/bar\")\n      Call<ResponseBody> method(@Query(\"hey\") String hey, @Url Object url) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, \"hey\", \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @Query. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryNameThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@QueryName String name, @Url String url) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @QueryName. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithQueryMapThenUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@QueryMap Map<String, String> queries, @Url String url) {\n        throw new AssertionError();\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.singletonMap(\"kit\", \"kat\"), \"foo/bar/\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"A @Url parameter must not come after a @QueryMap. (parameter #2)\\n\"\n          + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void getWithUrlThenQuery() {\n    class Example {\n      @GET\n      Call<ResponseBody> method(@Url String url, @Query(\"hey\") String hey) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"foo/bar/\", \"hey!\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/?hey=hey%21\");\n  }\n\n  @Test public void postWithUrl() {\n    class Example {\n      @POST\n      Call<ResponseBody> method(@Url String url, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, \"http://example.com/foo/bar\", body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar\");\n    assertBody(request.body(), \"hi\");\n  }\n\n  @Test public void normalPostWithPathParam() {\n    class Example {\n      @POST(\"/foo/bar/{ping}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Hi!\");\n    Request request = buildRequest(Example.class, \"pong\", body);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/\");\n    assertBody(request.body(), \"Hi!\");\n  }\n\n  @Test public void emptyBody() {\n    class Example {\n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"\");\n  }\n\n  @Test public void customMethodEmptyBody() {\n    class Example {\n      @HTTP(method = \"CUSTOM\", path = \"/foo/bar/\", hasBody = true) \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"CUSTOM\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertBody(request.body(), \"\");\n  }\n\n  @Test public void bodyRequired() {\n    class Example {\n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Body parameter value must not be null.\");\n    }\n  }\n\n  @Test public void bodyWithPathParams() {\n    class Example {\n      @POST(\"/foo/bar/{ping}/{kit}/\") \n      Call<ResponseBody> method(@Path(\"ping\") String ping, @Body RequestBody body, @Path(\"kit\") String kit) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Hi!\");\n    Request request = buildRequest(Example.class, \"pong\", body, \"kat\");\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/pong/kat/\");\n    assertBody(request.body(), \"Hi!\");\n  }\n\n  @Test public void simpleMultipart() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") String ping, @Part(\"kit\") RequestBody kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", RequestBody.create(\n        TEXT_PLAIN, \"kat\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartArray() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") String[] ping) {\n        return null;\n      }\n    }\n\n    Request request =\n        buildRequest(Example.class, new Object[] { new String[] { \"pong1\", \"pong2\" } });\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong1\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong2\\r\\n--\");\n  }\n\n  @Test public void multipartRequiresName() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part RequestBody part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartIterableRequiresName() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part List<RequestBody> part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartArrayRequiresName() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part RequestBody[] part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part annotation must supply a name or use MultipartBody.Part parameter type. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartOkHttpPartForbidsName() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"name\") MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartOkHttpPart() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request = buildRequest(Example.class, part);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpIterablePart() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part List<MultipartBody.Part> part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part1 = MultipartBody.Part.createFormData(\"foo\", \"bar\");\n    MultipartBody.Part part2 = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request = buildRequest(Example.class, Arrays.asList(part1, part2));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"foo\\\"\\r\\n\")\n        .contains(\"\\r\\nbar\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpArrayPart() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part MultipartBody.Part[] part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part1 = MultipartBody.Part.createFormData(\"foo\", \"bar\");\n    MultipartBody.Part part2 = MultipartBody.Part.createFormData(\"kit\", \"kat\");\n    Request request =\n        buildRequest(Example.class, new Object[] { new MultipartBody.Part[] { part1, part2 } });\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"foo\\\"\\r\\n\")\n        .contains(\"\\r\\nbar\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartOkHttpPartWithFilename() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part MultipartBody.Part part) {\n        return null;\n      }\n    }\n\n    MultipartBody.Part part =\n        MultipartBody.Part.createFormData(\"kit\", \"kit.txt\", RequestBody.create(null, \"kat\"));\n    Request request = buildRequest(Example.class, part);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"; filename=\\\"kit.txt\\\"\\r\\n\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartIterable() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") List<String> ping) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, Arrays.asList(\"pong1\", \"pong2\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong1\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong2\\r\\n--\");\n  }\n\n  @Test public void multipartIterableOkHttpPart() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") List<MultipartBody.Part> part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartArrayOkHttpPart() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") MultipartBody.Part[] part) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@Part parameters using the MultipartBody.Part must not include a part name in the annotation. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartWithEncoding() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(value = \"ping\", encoding = \"8-bit\") String ping,\n          @Part(value = \"kit\", encoding = \"7-bit\") RequestBody kit) {\n        return null;\n      }\n    }\n\n    Request request = buildRequest(Example.class, \"pong\", RequestBody.create(\n        TEXT_PLAIN, \"kat\"));\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"Content-Transfer-Encoding: 7-bit\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMap() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", RequestBody.create(null, \"kat\"));\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMapWithEncoding() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap(encoding = \"8-bit\") Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", RequestBody.create(null, \"kat\"));\n\n    Request request = buildRequest(Example.class, params);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\\r\\n\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\npong\\r\\n--\");\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"kit\\\"\")\n        .contains(\"Content-Transfer-Encoding: 8-bit\")\n        .contains(\"\\r\\nkat\\r\\n--\");\n  }\n\n  @Test public void multipartPartMapRejectsNonStringKeys() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<Object, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap keys must be of type String: class java.lang.Object (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsOkHttpPartValues() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<String, MultipartBody.Part> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap values cannot be MultipartBody.Part. Use @Part List<Part> or a different value type instead. (parameter #1)\\n\"\n              + \"    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNull() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map was null.\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNullKeys() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(null, RequestBody.create(null, \"kat\"));\n\n    try {\n      buildRequest(Example.class, params);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map contained null key.\");\n    }\n  }\n\n  @Test public void multipartPartMapRejectsNullValues() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Map<String, RequestBody> parts) {\n        return null;\n      }\n    }\n\n    Map<String, RequestBody> params = new LinkedHashMap<>();\n    params.put(\"ping\", RequestBody.create(null, \"pong\"));\n    params.put(\"kit\", null);\n\n    try {\n      buildRequest(Example.class, params);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Part map contained null value for key 'kit'.\");\n    }\n  }\n\n  @Test public void multipartPartMapMustBeMap() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap List<Object> parts) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, Collections.emptyList());\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@PartMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void multipartPartMapSupportsSubclasses() throws IOException {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@PartMap Foo parts) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    Buffer buffer = new Buffer();\n    request.body().writeTo(buffer);\n    assertThat(buffer.readUtf8())\n        .contains(\"name=\\\"hello\\\"\")\n        .contains(\"\\r\\n\\r\\nworld\\r\\n--\");\n  }\n\n  @Test public void multipartNullRemovesPart() throws IOException {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") String ping, @Part(\"fizz\") String fizz) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"pong\", null);\n    assertThat(request.method()).isEqualTo(\"POST\");\n    assertThat(request.headers().size()).isZero();\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n\n    RequestBody body = request.body();\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String bodyString = buffer.readUtf8();\n\n    assertThat(bodyString)\n        .contains(\"Content-Disposition: form-data;\")\n        .contains(\"name=\\\"ping\\\"\")\n        .contains(\"\\r\\npong\\r\\n--\");\n  }\n\n  @Test public void multipartPartOptional() {\n    class Example {\n      @Multipart \n      @POST(\"/foo/bar/\") \n      Call<ResponseBody> method(@Part(\"ping\") RequestBody ping) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalStateException e) {\n      assertThat(e.getMessage()).isEqualTo(\"Multipart body must have at least one part.\");\n    }\n  }\n\n  @Test public void simpleFormEncoded() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(\"foo\") String foo, @Field(\"ping\") String ping) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", \"pong\");\n    assertBody(request.body(), \"foo=bar&ping=pong\");\n  }\n\n  @Test public void formEncodedWithEncodedNameFieldParam() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(value = \"na%20me\", encoded = true) String foo) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"ba%20r\");\n    assertBody(request.body(), \"na%20me=ba%20r\");\n  }\n\n  @Test public void formEncodedFieldOptional() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(\"foo\") String foo, @Field(\"ping\") String ping,\n          @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"bar\", null, \"kat\");\n    assertBody(request.body(), \"foo=bar&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldList() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(\"foo\") List<Object> fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    List<Object> values = Arrays.<Object>asList(\"foo\", \"bar\", null, 3);\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=foo&foo=bar&foo=3&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldArray() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(\"foo\") Object[] fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    Object[] values = { 1, 2, null, \"three\" };\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=1&foo=2&foo=three&kit=kat\");\n  }\n\n  @Test public void formEncodedFieldPrimitiveArray() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@Field(\"foo\") int[] fields, @Field(\"kit\") String kit) {\n        return null;\n      }\n    }\n\n    int[] values = { 1, 2, 3 };\n    Request request = buildRequest(Example.class, values, \"kat\");\n    assertBody(request.body(), \"foo=1&foo=2&foo=3&kit=kat\");\n  }\n\n  @Test public void formEncodedWithEncodedNameFieldParamMap() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@FieldMap(encoded = true) Map<String, Object> fieldMap) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"k%20it\", \"k%20at\");\n    fieldMap.put(\"pin%20g\", \"po%20ng\");\n\n    Request request = buildRequest(Example.class, fieldMap);\n    assertBody(request.body(), \"k%20it=k%20at&pin%20g=po%20ng\");\n  }\n\n  @Test public void formEncodedFieldMap() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/foo\") \n      Call<ResponseBody> method(@FieldMap Map<String, Object> fieldMap) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(\"ping\", \"pong\");\n\n    Request request = buildRequest(Example.class, fieldMap);\n    assertBody(request.body(), \"kit=kat&ping=pong\");\n  }\n\n  @Test public void fieldMapRejectsNull() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    try {\n      buildRequest(Example.class, new Object[] { null });\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map was null.\");\n    }\n  }\n\n  @Test public void fieldMapRejectsNullKeys() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(null, \"pong\");\n\n    try {\n      buildRequest(Example.class, fieldMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map contained null key.\");\n    }\n  }\n\n  @Test public void fieldMapRejectsNullValues() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap Map<String, Object> a) {\n        return null;\n      }\n    }\n\n    Map<String, Object> fieldMap = new LinkedHashMap<>();\n    fieldMap.put(\"kit\", \"kat\");\n    fieldMap.put(\"foo\", null);\n\n    try {\n      buildRequest(Example.class, fieldMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Field map contained null value for key 'foo'.\");\n    }\n  }\n\n  @Test public void fieldMapMustBeAMap() {\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap List<String> a) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"@FieldMap parameter type must be Map. (parameter #1)\\n    for method Example.method\");\n    }\n  }\n\n  @Test public void fieldMapSupportsSubclasses() throws IOException {\n    class Foo extends HashMap<String, String> {\n    }\n\n    class Example {\n      @FormUrlEncoded \n      @POST(\"/\") \n      Call<ResponseBody> method(@FieldMap Foo a) {\n        return null;\n      }\n    }\n\n    Foo foo = new Foo();\n    foo.put(\"hello\", \"world\");\n\n    Request request = buildRequest(Example.class, foo);\n    Buffer buffer = new Buffer();\n    request.body().writeTo(buffer);\n    assertThat(buffer.readUtf8()).isEqualTo(\"hello=world\");\n  }\n\n  @Test public void simpleHeaders() {\n    class Example {\n      @GET(\"/foo/bar/\")\n      @Headers({\n          \"ping: pong\",\n          \"kit: kat\"\n      })\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.get(\"kit\")).isEqualTo(\"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headersDoNotOverwriteEachOther() {\n    class Example {\n      @GET(\"/foo/bar/\")\n      @Headers({\n          \"ping: pong\",\n          \"kit: kat\",\n          \"kit: -kat\",\n      })\n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(3);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.values(\"kit\")).containsOnly(\"kat\", \"-kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamToString() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Header(\"kit\") BigInteger kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, new BigInteger(\"1234\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(1);\n    assertThat(headers.get(\"kit\")).isEqualTo(\"1234\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParam() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      @Headers(\"ping: pong\") \n      Call<ResponseBody> method(@Header(\"kit\") String kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"kat\");\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.get(\"ping\")).isEqualTo(\"pong\");\n    assertThat(headers.get(\"kit\")).isEqualTo(\"kat\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamList() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Header(\"foo\") List<String> kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, Arrays.asList(\"bar\", null, \"baz\"));\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.values(\"foo\")).containsExactly(\"bar\", \"baz\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void headerParamArray() {\n    class Example {\n      @GET(\"/foo/bar/\") \n      Call<ResponseBody> method(@Header(\"foo\") String[] kit) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, (Object) new String[] { \"bar\", null, \"baz\" });\n    assertThat(request.method()).isEqualTo(\"GET\");\n    okhttp3.Headers headers = request.headers();\n    assertThat(headers.size()).isEqualTo(2);\n    assertThat(headers.values(\"foo\")).containsExactly(\"bar\", \"baz\");\n    assertThat(request.url().toString()).isEqualTo(\"http://example.com/foo/bar/\");\n    assertThat(request.body()).isNull();\n  }\n\n  @Test public void contentTypeAnnotationHeaderOverrides() {\n    class Example {\n      @POST(\"/\") \n      @Headers(\"Content-Type: text/not-plain\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    Request request = buildRequest(Example.class, body);\n    assertThat(request.body().contentType().toString()).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void malformedContentTypeHeaderThrows() {\n    class Example {\n      @POST(\"/\") \n      @Headers(\"Content-Type: hello, world!\") \n      Call<ResponseBody> method(@Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    try {\n      buildRequest(Example.class, body);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Malformed content type: hello, world!\\n\"\n          + \"    for method Example.method\");\n      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); \n    }\n  }\n\n  @Test public void contentTypeAnnotationHeaderAddsHeaderWithNoBody() {\n    class Example {\n      @DELETE(\"/\") \n      @Headers(\"Content-Type: text/not-plain\") \n      Call<ResponseBody> method() {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class);\n    assertThat(request.headers().get(\"Content-Type\")).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void contentTypeParameterHeaderOverrides() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@Header(\"Content-Type\") String contentType, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"Plain\");\n    Request request = buildRequest(Example.class, \"text/not-plain\", body);\n    assertThat(request.body().contentType().toString()).isEqualTo(\"text/not-plain\");\n  }\n\n  @Test public void malformedContentTypeParameterThrows() {\n    class Example {\n      @POST(\"/\") \n      Call<ResponseBody> method(@Header(\"Content-Type\") String contentType, @Body RequestBody body) {\n        return null;\n      }\n    }\n    RequestBody body = RequestBody.create(TEXT_PLAIN, \"hi\");\n    try {\n      buildRequest(Example.class, \"hello, world!\", body);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\"Malformed content type: hello, world!\");\n      assertThat(e.getCause()).isInstanceOf(IllegalArgumentException.class); \n    }\n  }\n\n  @Test public void malformedAnnotationRelativeUrlThrows() {\n    class Example {\n      @GET(\"ftp://example.org\")\n      Call<ResponseBody> get() {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Malformed URL. Base: http://example.com/, Relative: ftp://example.org\");\n    }\n  }\n\n  @Test public void malformedParameterRelativeUrlThrows() {\n    class Example {\n      @GET\n      Call<ResponseBody> get(@Url String relativeUrl) {\n        return null;\n      }\n    }\n    try {\n      buildRequest(Example.class, \"ftp://example.org\");\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessage(\n          \"Malformed URL. Base: http://example.com/, Relative: ftp://example.org\");\n    }\n  }\n\n  @Test public void multipartPartsShouldBeInOrder() throws IOException {\n    class Example {\n      @Multipart\n      @POST(\"/foo\")\n      Call<ResponseBody> get(@Part(\"first\") String data, @Part(\"second\") String dataTwo, @Part(\"third\") String dataThree) {\n        return null;\n      }\n    }\n    Request request = buildRequest(Example.class, \"firstParam\", \"secondParam\", \"thirdParam\");\n    MultipartBody body = (MultipartBody) request.body();\n\n    Buffer buffer = new Buffer();\n    body.writeTo(buffer);\n    String readBody = buffer.readUtf8();\n\n    assertThat(readBody.indexOf(\"firstParam\")).isLessThan(readBody.indexOf(\"secondParam\"));\n    assertThat(readBody.indexOf(\"secondParam\")).isLessThan(readBody.indexOf(\"thirdParam\"));\n  }\n\n  @Test public void queryParamsSkippedIfConvertedToNull() throws Exception {\n    class Example {\n      @GET(\"/query\") Call<ResponseBody> queryPath(@Query(\"a\") Object a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Request request = buildRequest(Example.class, retrofitBuilder, \"Ignored\");\n\n    assertThat(request.url().toString()).doesNotContain(\"Ignored\");\n  }\n\n  @Test public void queryParamMapsConvertedToNullShouldError() throws Exception {\n    class Example {\n      @GET(\"/query\") Call<ResponseBody> queryPath(@QueryMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Map<String, String> queryMap = Collections.singletonMap(\"kit\", \"kat\");\n\n    try {\n      buildRequest(Example.class, retrofitBuilder, queryMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessageContaining(\n          \"Query map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.\");\n    }\n  }\n\n  @Test public void fieldParamsSkippedIfConvertedToNull() throws Exception {\n    class Example {\n      @FormUrlEncoded\n      @POST(\"/query\") Call<ResponseBody> queryPath(@Field(\"a\") Object a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Request request = buildRequest(Example.class, retrofitBuilder, \"Ignored\");\n\n    assertThat(request.url().toString()).doesNotContain(\"Ignored\");\n  }\n\n  @Test public void fieldParamMapsConvertedToNullShouldError() throws Exception {\n    class Example {\n      @FormUrlEncoded\n      @POST(\"/query\") Call<ResponseBody> queryPath(@FieldMap Map<String, String> a) {\n        return null;\n      }\n    }\n\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com\")\n        .addConverterFactory(new NullObjectConverterFactory());\n\n    Map<String, String> queryMap = Collections.singletonMap(\"kit\", \"kat\");\n\n    try {\n      buildRequest(Example.class, retrofitBuilder, queryMap);\n      fail();\n    } catch (IllegalArgumentException e) {\n      assertThat(e).hasMessageContaining(\n          \"Field map value 'kat' converted to null by retrofit2.helpers.NullObjectConverterFactory$1 for key 'kit'.\");\n    }\n  }\n\n  private static void assertBody(RequestBody body, String expected) {\n    assertThat(body).isNotNull();\n    Buffer buffer = new Buffer();\n    try {\n      body.writeTo(buffer);\n      assertThat(buffer.readUtf8()).isEqualTo(expected);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n  }\n\n  static <T> Request buildRequest(Class<T> cls, Retrofit.Builder builder, Object... args) {\n    okhttp3.Call.Factory callFactory = new okhttp3.Call.Factory() {\n      @Override public okhttp3.Call newCall(Request request) {\n        throw new UnsupportedOperationException(\"Not implemented\");\n      }\n    };\n\n    Retrofit retrofit = builder.callFactory(callFactory).build();\n\n    Method method = TestingUtils.onlyMethod(cls);\n    try {\n      return RequestFactory.parseAnnotations(retrofit, method).create(args);\n    } catch (RuntimeException e) {\n      throw e;\n    } catch (Exception e) {\n      throw new AssertionError(e);\n    }\n  }\n\n  static <T> Request buildRequest(Class<T> cls, Object... args) {\n    Retrofit.Builder retrofitBuilder = new Retrofit.Builder()\n        .baseUrl(\"http://example.com/\")\n        .addConverterFactory(new ToStringConverterFactory());\n\n    return buildRequest(cls, retrofitBuilder, args);\n  }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 74,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/swagger-api/swagger-parser/commit/4c6584306b40de9b2dfa9065c3a438cd918534af",
    "cve_id": "CVE-2017-1000207",
    "cwe_id": "CWE-502",
    "filename": "modules/swagger-parser/src/main/java/io/swagger/parser/util/DeserializationUtils.java",
    "code": "package io.swagger.parser.util;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport io.swagger.util.Json;\nimport io.swagger.util.Yaml;\n\nimport java.io.IOException;\n\n\npublic class DeserializationUtils {\n    public static JsonNode deserializeIntoTree(String contents, String fileOrHost) {\n        JsonNode result;\n\n        try {\n            if (isJson(contents)) {\n                result = Json.mapper().readTree(contents);\n            } else {\n                result = readYamlTree(contents);\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into a JsonNode tree\", e);\n        }\n\n        return result;\n    }\n\n    public static <T> T deserialize(Object contents, String fileOrHost, Class<T> expectedType) {\n        T result;\n\n        boolean isJson = false;\n\n        if(contents instanceof String && isJson((String)contents)) {\n            isJson = true;\n        }\n\n        try {\n            if (contents instanceof String) {\n                if (isJson) {\n                    result = Json.mapper().readValue((String) contents, expectedType);\n                } else {\n                    result = Yaml.mapper().readValue((String) contents, expectedType);\n                }\n            } else {\n                result = Json.mapper().convertValue(contents, expectedType);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"An exception was thrown while trying to deserialize the contents of \" + fileOrHost + \" into type \" + expectedType, e);\n        }\n\n        return result;\n    }\n\n    private static boolean isJson(String contents) {\n        return contents.toString().trim().startsWith(\"{\");\n    }\n\n    public static JsonNode readYamlTree(String contents) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), JsonNode.class);\n    }\n\n    public static <T> T readYamlValue(String contents, Class<T> expectedType) {\n        org.yaml.snakeyaml.Yaml yaml = new org.yaml.snakeyaml.Yaml();\n        return Json.mapper().convertValue(yaml.load(contents), expectedType);\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 75,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/x-stream/xstream/commit/f38a1da3ae9491930c2067c12cd2506738b21dab",
    "cve_id": "CVE-2019-10173",
    "cwe_id": "CWE-502",
    "filename": "xstream/src/java/com/thoughtworks/xstream/XStream.java",
    "code": "\npackage com.thoughtworks.xstream;\n\nimport java.io.EOFException;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.NotActiveException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectInputValidation;\nimport java.io.ObjectOutputStream;\nimport java.io.OutputStream;\nimport java.io.Reader;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Member;\nimport java.lang.reflect.Method;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.net.URI;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.text.DecimalFormatSymbols;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Currency;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TimeZone;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Vector;\nimport java.util.regex.Pattern;\n\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.Converter;\nimport com.thoughtworks.xstream.converters.ConverterLookup;\nimport com.thoughtworks.xstream.converters.ConverterRegistry;\nimport com.thoughtworks.xstream.converters.DataHolder;\nimport com.thoughtworks.xstream.converters.MarshallingContext;\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.SingleValueConverterWrapper;\nimport com.thoughtworks.xstream.converters.UnmarshallingContext;\nimport com.thoughtworks.xstream.converters.basic.BigDecimalConverter;\nimport com.thoughtworks.xstream.converters.basic.BigIntegerConverter;\nimport com.thoughtworks.xstream.converters.basic.BooleanConverter;\nimport com.thoughtworks.xstream.converters.basic.ByteConverter;\nimport com.thoughtworks.xstream.converters.basic.CharConverter;\nimport com.thoughtworks.xstream.converters.basic.DateConverter;\nimport com.thoughtworks.xstream.converters.basic.DoubleConverter;\nimport com.thoughtworks.xstream.converters.basic.FloatConverter;\nimport com.thoughtworks.xstream.converters.basic.IntConverter;\nimport com.thoughtworks.xstream.converters.basic.LongConverter;\nimport com.thoughtworks.xstream.converters.basic.NullConverter;\nimport com.thoughtworks.xstream.converters.basic.ShortConverter;\nimport com.thoughtworks.xstream.converters.basic.StringBufferConverter;\nimport com.thoughtworks.xstream.converters.basic.StringConverter;\nimport com.thoughtworks.xstream.converters.basic.URIConverter;\nimport com.thoughtworks.xstream.converters.basic.URLConverter;\nimport com.thoughtworks.xstream.converters.collections.ArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.BitSetConverter;\nimport com.thoughtworks.xstream.converters.collections.CharArrayConverter;\nimport com.thoughtworks.xstream.converters.collections.CollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.MapConverter;\nimport com.thoughtworks.xstream.converters.collections.PropertiesConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonCollectionConverter;\nimport com.thoughtworks.xstream.converters.collections.SingletonMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeMapConverter;\nimport com.thoughtworks.xstream.converters.collections.TreeSetConverter;\nimport com.thoughtworks.xstream.converters.extended.ColorConverter;\nimport com.thoughtworks.xstream.converters.extended.DynamicProxyConverter;\nimport com.thoughtworks.xstream.converters.extended.EncodedByteArrayConverter;\nimport com.thoughtworks.xstream.converters.extended.FileConverter;\nimport com.thoughtworks.xstream.converters.extended.FontConverter;\nimport com.thoughtworks.xstream.converters.extended.GregorianCalendarConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaClassConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaFieldConverter;\nimport com.thoughtworks.xstream.converters.extended.JavaMethodConverter;\nimport com.thoughtworks.xstream.converters.extended.LocaleConverter;\nimport com.thoughtworks.xstream.converters.extended.LookAndFeelConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlDateConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimeConverter;\nimport com.thoughtworks.xstream.converters.extended.SqlTimestampConverter;\nimport com.thoughtworks.xstream.converters.extended.TextAttributeConverter;\nimport com.thoughtworks.xstream.converters.reflection.ExternalizableConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionProvider;\nimport com.thoughtworks.xstream.converters.reflection.SerializableConverter;\nimport com.thoughtworks.xstream.core.ClassLoaderReference;\nimport com.thoughtworks.xstream.core.DefaultConverterLookup;\nimport com.thoughtworks.xstream.core.JVM;\nimport com.thoughtworks.xstream.core.MapBackedDataHolder;\nimport com.thoughtworks.xstream.core.ReferenceByIdMarshallingStrategy;\nimport com.thoughtworks.xstream.core.ReferenceByXPathMarshallingStrategy;\nimport com.thoughtworks.xstream.core.TreeMarshallingStrategy;\nimport com.thoughtworks.xstream.core.util.CompositeClassLoader;\nimport com.thoughtworks.xstream.core.util.CustomObjectInputStream;\nimport com.thoughtworks.xstream.core.util.CustomObjectOutputStream;\nimport com.thoughtworks.xstream.core.util.SelfStreamingInstanceChecker;\nimport com.thoughtworks.xstream.io.HierarchicalStreamDriver;\nimport com.thoughtworks.xstream.io.HierarchicalStreamReader;\nimport com.thoughtworks.xstream.io.HierarchicalStreamWriter;\nimport com.thoughtworks.xstream.io.StatefulWriter;\nimport com.thoughtworks.xstream.io.xml.XppDriver;\nimport com.thoughtworks.xstream.mapper.AnnotationConfiguration;\nimport com.thoughtworks.xstream.mapper.ArrayMapper;\nimport com.thoughtworks.xstream.mapper.AttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.AttributeMapper;\nimport com.thoughtworks.xstream.mapper.CachingMapper;\nimport com.thoughtworks.xstream.mapper.ClassAliasingMapper;\nimport com.thoughtworks.xstream.mapper.DefaultImplementationsMapper;\nimport com.thoughtworks.xstream.mapper.DefaultMapper;\nimport com.thoughtworks.xstream.mapper.DynamicProxyMapper;\nimport com.thoughtworks.xstream.mapper.ElementIgnoringMapper;\nimport com.thoughtworks.xstream.mapper.FieldAliasingMapper;\nimport com.thoughtworks.xstream.mapper.ImmutableTypesMapper;\nimport com.thoughtworks.xstream.mapper.ImplicitCollectionMapper;\nimport com.thoughtworks.xstream.mapper.LocalConversionMapper;\nimport com.thoughtworks.xstream.mapper.Mapper;\nimport com.thoughtworks.xstream.mapper.MapperWrapper;\nimport com.thoughtworks.xstream.mapper.OuterClassMapper;\nimport com.thoughtworks.xstream.mapper.PackageAliasingMapper;\nimport com.thoughtworks.xstream.mapper.SecurityMapper;\nimport com.thoughtworks.xstream.mapper.SystemAttributeAliasingMapper;\nimport com.thoughtworks.xstream.mapper.XStream11XmlFriendlyMapper;\nimport com.thoughtworks.xstream.security.AnyTypePermission;\nimport com.thoughtworks.xstream.security.ArrayTypePermission;\nimport com.thoughtworks.xstream.security.ExplicitTypePermission;\nimport com.thoughtworks.xstream.security.InterfaceTypePermission;\nimport com.thoughtworks.xstream.security.NoPermission;\nimport com.thoughtworks.xstream.security.NoTypePermission;\nimport com.thoughtworks.xstream.security.NullPermission;\nimport com.thoughtworks.xstream.security.PrimitiveTypePermission;\nimport com.thoughtworks.xstream.security.RegExpTypePermission;\nimport com.thoughtworks.xstream.security.TypeHierarchyPermission;\nimport com.thoughtworks.xstream.security.TypePermission;\nimport com.thoughtworks.xstream.security.WildcardTypePermission;\n\n\n\npublic class XStream {\n\n    \n    \n    private ReflectionProvider reflectionProvider;\n    private HierarchicalStreamDriver hierarchicalStreamDriver;\n    private ClassLoaderReference classLoaderReference;\n    private MarshallingStrategy marshallingStrategy;\n    private ConverterLookup converterLookup;\n    private ConverterRegistry converterRegistry;\n    private Mapper mapper;\n\n    private PackageAliasingMapper packageAliasingMapper;\n    private ClassAliasingMapper classAliasingMapper;\n    private FieldAliasingMapper fieldAliasingMapper;\n    private ElementIgnoringMapper elementIgnoringMapper;\n    private AttributeAliasingMapper attributeAliasingMapper;\n    private SystemAttributeAliasingMapper systemAttributeAliasingMapper;\n    private AttributeMapper attributeMapper;\n    private DefaultImplementationsMapper defaultImplementationsMapper;\n    private ImmutableTypesMapper immutableTypesMapper;\n    private ImplicitCollectionMapper implicitCollectionMapper;\n    private LocalConversionMapper localConversionMapper;\n    private SecurityMapper securityMapper;\n    private AnnotationConfiguration annotationConfiguration;\n\n    private transient boolean insecureWarning;\n\n    public static final int NO_REFERENCES = 1001;\n    public static final int ID_REFERENCES = 1002;\n    public static final int XPATH_RELATIVE_REFERENCES = 1003;\n    public static final int XPATH_ABSOLUTE_REFERENCES = 1004;\n    public static final int SINGLE_NODE_XPATH_RELATIVE_REFERENCES = 1005;\n    public static final int SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES = 1006;\n\n    public static final int PRIORITY_VERY_HIGH = 10000;\n    public static final int PRIORITY_NORMAL = 0;\n    public static final int PRIORITY_LOW = -10;\n    public static final int PRIORITY_VERY_LOW = -20;\n\n    private static final String ANNOTATION_MAPPER_TYPE = \"com.thoughtworks.xstream.mapper.AnnotationMapper\";\n    private static final Pattern IGNORE_ALL = Pattern.compile(\".*\");\n\n    \n    public XStream() {\n        this(null, (Mapper)null, new XppDriver());\n    }\n\n    \n    public XStream(ReflectionProvider reflectionProvider) {\n        this(reflectionProvider, (Mapper)null, new XppDriver());\n    }\n\n    \n    public XStream(HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(null, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver hierarchicalStreamDriver) {\n        this(reflectionProvider, (Mapper)null, hierarchicalStreamDriver);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, Mapper mapper, HierarchicalStreamDriver driver) {\n        this(reflectionProvider, driver, new CompositeClassLoader(), mapper);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference) {\n        this(reflectionProvider, driver, classLoaderReference, null);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader) {\n        this(reflectionProvider, driver, classLoader, null);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper) {\n        this(\n            reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, new DefaultConverterLookup());\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper) {\n        this(\n            reflectionProvider, driver, classLoaderReference, mapper, new DefaultConverterLookup());\n    }\n    \n    private XStream(\n            ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver, ClassLoaderReference classLoader,\n            Mapper mapper, final DefaultConverterLookup defaultConverterLookup) {\n        this(reflectionProvider, driver, classLoader, mapper, new ConverterLookup() {\n            public Converter lookupConverterForType(Class type) {\n                return defaultConverterLookup.lookupConverterForType(type);\n            }\n        }, new ConverterRegistry() {\n            public void registerConverter(Converter converter, int priority) {\n                defaultConverterLookup.registerConverter(converter, priority);\n            }\n        });\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoader classLoader, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        this(reflectionProvider, driver, new ClassLoaderReference(classLoader), mapper, converterLookup, converterRegistry);\n    }\n\n    \n    public XStream(\n        ReflectionProvider reflectionProvider, HierarchicalStreamDriver driver,\n        ClassLoaderReference classLoaderReference, Mapper mapper, ConverterLookup converterLookup,\n        ConverterRegistry converterRegistry) {\n        if (reflectionProvider == null) {\n            reflectionProvider = JVM.newReflectionProvider();\n        }\n        this.reflectionProvider = reflectionProvider;\n        this.hierarchicalStreamDriver = driver;\n        this.classLoaderReference = classLoaderReference;\n        this.converterLookup = converterLookup;\n        this.converterRegistry = converterRegistry;\n        this.mapper = mapper == null ? buildMapper() : mapper;\n\n        setupMappers();\n        setupSecurity();\n        setupAliases();\n        setupDefaultImplementations();\n        setupConverters();\n        setupImmutableTypes();\n        setMode(XPATH_RELATIVE_REFERENCES);\n    }\n\n    private Mapper buildMapper() {\n        Mapper mapper = new DefaultMapper(classLoaderReference);\n        if (useXStream11XmlFriendlyMapper()) {\n            mapper = new XStream11XmlFriendlyMapper(mapper);\n        }\n        mapper = new DynamicProxyMapper(mapper);\n        mapper = new PackageAliasingMapper(mapper);\n        mapper = new ClassAliasingMapper(mapper);\n        mapper = new ElementIgnoringMapper(mapper);\n        mapper = new FieldAliasingMapper(mapper);\n        mapper = new AttributeAliasingMapper(mapper);\n        mapper = new SystemAttributeAliasingMapper(mapper);\n        mapper = new ImplicitCollectionMapper(mapper, reflectionProvider);\n        mapper = new OuterClassMapper(mapper);\n        mapper = new ArrayMapper(mapper);\n        mapper = new DefaultImplementationsMapper(mapper);\n        mapper = new AttributeMapper(mapper, converterLookup, reflectionProvider);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(\n                \"com.thoughtworks.xstream.mapper.EnumMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new LocalConversionMapper(mapper);\n        mapper = new ImmutableTypesMapper(mapper);\n        if (JVM.isVersion(8)) {\n            mapper = buildMapperDynamically(\"com.thoughtworks.xstream.mapper.LambdaMapper\", new Class[]{Mapper.class},\n                new Object[]{mapper});\n        }\n        mapper = new SecurityMapper(mapper);\n        if (JVM.isVersion(5)) {\n            mapper = buildMapperDynamically(ANNOTATION_MAPPER_TYPE, new Class[]{\n                Mapper.class, ConverterRegistry.class, ConverterLookup.class,\n                ClassLoaderReference.class, ReflectionProvider.class}, new Object[]{\n                mapper, converterRegistry, converterLookup, classLoaderReference,\n                reflectionProvider});\n        }\n        mapper = wrapMapper((MapperWrapper)mapper);\n        mapper = new CachingMapper(mapper);\n        return mapper;\n    }\n\n    private Mapper buildMapperDynamically(String className, Class[] constructorParamTypes,\n        Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            return (Mapper)constructor.newInstance(constructorParamValues);\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate mapper : \" + className, e);\n        }\n    }\n\n    protected MapperWrapper wrapMapper(MapperWrapper next) {\n        return next;\n    }\n\n    \n    protected boolean useXStream11XmlFriendlyMapper() {\n        return false;\n    }\n\n    private void setupMappers() {\n        packageAliasingMapper = (PackageAliasingMapper)this.mapper\n            .lookupMapperOfType(PackageAliasingMapper.class);\n        classAliasingMapper = (ClassAliasingMapper)this.mapper\n            .lookupMapperOfType(ClassAliasingMapper.class);\n        elementIgnoringMapper = (ElementIgnoringMapper)this.mapper\n            .lookupMapperOfType(ElementIgnoringMapper.class);\n        fieldAliasingMapper = (FieldAliasingMapper)this.mapper\n            .lookupMapperOfType(FieldAliasingMapper.class);\n        attributeMapper = (AttributeMapper)this.mapper\n            .lookupMapperOfType(AttributeMapper.class);\n        attributeAliasingMapper = (AttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(AttributeAliasingMapper.class);\n        systemAttributeAliasingMapper = (SystemAttributeAliasingMapper)this.mapper\n            .lookupMapperOfType(SystemAttributeAliasingMapper.class);\n        implicitCollectionMapper = (ImplicitCollectionMapper)this.mapper\n            .lookupMapperOfType(ImplicitCollectionMapper.class);\n        defaultImplementationsMapper = (DefaultImplementationsMapper)this.mapper\n            .lookupMapperOfType(DefaultImplementationsMapper.class);\n        immutableTypesMapper = (ImmutableTypesMapper)this.mapper\n            .lookupMapperOfType(ImmutableTypesMapper.class);\n        localConversionMapper = (LocalConversionMapper)this.mapper\n            .lookupMapperOfType(LocalConversionMapper.class);\n        securityMapper = (SecurityMapper)this.mapper\n            .lookupMapperOfType(SecurityMapper.class);\n        annotationConfiguration = (AnnotationConfiguration)this.mapper\n            .lookupMapperOfType(AnnotationConfiguration.class);\n    }\n    \n    protected void setupSecurity() {\n        if (securityMapper == null) {\n            return;\n        }\n        \n        addPermission(AnyTypePermission.ANY);\n        insecureWarning = true;\n    }\n\n    \n    public static void setupDefaultSecurity(final XStream xstream) {\n        if (xstream.insecureWarning) {\n            xstream.addPermission(NoTypePermission.NONE);\n            xstream.addPermission(NullPermission.NULL);\n            xstream.addPermission(PrimitiveTypePermission.PRIMITIVES);\n            xstream.addPermission(ArrayTypePermission.ARRAYS);\n            xstream.addPermission(InterfaceTypePermission.INTERFACES);\n            xstream.allowTypeHierarchy(Calendar.class);\n            xstream.allowTypeHierarchy(Collection.class);\n            xstream.allowTypeHierarchy(Map.class);\n            xstream.allowTypeHierarchy(Map.Entry.class);\n            xstream.allowTypeHierarchy(Member.class);\n            xstream.allowTypeHierarchy(Number.class);\n            xstream.allowTypeHierarchy(Throwable.class);\n            xstream.allowTypeHierarchy(TimeZone.class);\n\n            Class type = JVM.loadClassForName(\"java.lang.Enum\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n            type = JVM.loadClassForName(\"java.nio.file.Path\");\n            if (type != null) {\n                xstream.allowTypeHierarchy(type);\n            }\n\n            final Set types = new HashSet();\n            types.add(BitSet.class);\n            types.add(Charset.class);\n            types.add(Class.class);\n            types.add(Currency.class);\n            types.add(Date.class);\n            types.add(DecimalFormatSymbols.class);\n            types.add(File.class);\n            types.add(Locale.class);\n            types.add(Object.class);\n            types.add(Pattern.class);\n            types.add(StackTraceElement.class);\n            types.add(String.class);\n            types.add(StringBuffer.class);\n            types.add(JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            types.add(URL.class);\n            types.add(URI.class);\n            types.add(JVM.loadClassForName(\"java.util.UUID\"));\n            if (JVM.isSQLAvailable()) {\n                types.add(JVM.loadClassForName(\"java.sql.Timestamp\"));\n                types.add(JVM.loadClassForName(\"java.sql.Time\"));\n                types.add(JVM.loadClassForName(\"java.sql.Date\"));\n            }\n            if (JVM.isVersion(8)) {\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.Clock\"));\n                types.add(JVM.loadClassForName(\"java.time.Duration\"));\n                types.add(JVM.loadClassForName(\"java.time.Instant\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDate\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.LocalTime\"));\n                types.add(JVM.loadClassForName(\"java.time.MonthDay\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n                types.add(JVM.loadClassForName(\"java.time.OffsetTime\"));\n                types.add(JVM.loadClassForName(\"java.time.Period\"));\n                types.add(JVM.loadClassForName(\"java.time.Ser\"));\n                types.add(JVM.loadClassForName(\"java.time.Year\"));\n                types.add(JVM.loadClassForName(\"java.time.YearMonth\"));\n                types.add(JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.ZoneId\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n                types.add(JVM.loadClassForName(\"java.time.chrono.Ser\"));\n                xstream.allowTypeHierarchy(JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n                types.add(JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n            }\n            types.remove(null);\n\n            final Iterator iter = types.iterator();\n            final Class[] classes = new Class[types.size()];\n            for (int i = 0; i < classes.length; ++i) {\n                classes[i] = (Class)iter.next();\n            }\n            xstream.allowTypes(classes);\n        } else {\n            throw new IllegalArgumentException(\"Security framework of XStream instance already initialized\");\n        }\n    }\n\n    protected void setupAliases() {\n        if (classAliasingMapper == null) {\n            return;\n        }\n\n        alias(\"null\", Mapper.Null.class);\n        alias(\"int\", Integer.class);\n        alias(\"float\", Float.class);\n        alias(\"double\", Double.class);\n        alias(\"long\", Long.class);\n        alias(\"short\", Short.class);\n        alias(\"char\", Character.class);\n        alias(\"byte\", Byte.class);\n        alias(\"boolean\", Boolean.class);\n        alias(\"number\", Number.class);\n        alias(\"object\", Object.class);\n        alias(\"big-int\", BigInteger.class);\n        alias(\"big-decimal\", BigDecimal.class);\n\n        alias(\"string-buffer\", StringBuffer.class);\n        alias(\"string\", String.class);\n        alias(\"java-class\", Class.class);\n        alias(\"method\", Method.class);\n        alias(\"constructor\", Constructor.class);\n        alias(\"field\", Field.class);\n        alias(\"date\", Date.class);\n        alias(\"uri\", URI.class);\n        alias(\"url\", URL.class);\n        alias(\"bit-set\", BitSet.class);\n\n        alias(\"map\", Map.class);\n        alias(\"entry\", Map.Entry.class);\n        alias(\"properties\", Properties.class);\n        alias(\"list\", List.class);\n        alias(\"set\", Set.class);\n        alias(\"sorted-set\", SortedSet.class);\n\n        alias(\"linked-list\", LinkedList.class);\n        alias(\"vector\", Vector.class);\n        alias(\"tree-map\", TreeMap.class);\n        alias(\"tree-set\", TreeSet.class);\n        alias(\"hashtable\", Hashtable.class);\n        \n        alias(\"empty-list\", Collections.EMPTY_LIST.getClass());\n        alias(\"empty-map\", Collections.EMPTY_MAP.getClass());\n        alias(\"empty-set\", Collections.EMPTY_SET.getClass());\n        alias(\"singleton-list\", Collections.singletonList(this).getClass());\n        alias(\"singleton-map\", Collections.singletonMap(this, null).getClass());\n        alias(\"singleton-set\", Collections.singleton(this).getClass());\n\n        if (JVM.isAWTAvailable()) {\n            \n            \n            \n            alias(\"awt-color\", JVM.loadClassForName(\"java.awt.Color\", false));\n            alias(\"awt-font\", JVM.loadClassForName(\"java.awt.Font\", false));\n            alias(\"awt-text-attribute\", JVM.loadClassForName(\"java.awt.font.TextAttribute\"));\n        }\n\n        Class type = JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\");\n        if (type != null) {\n            alias(\"activation-data-flavor\", type);\n        }\n\n        if (JVM.isSQLAvailable()) {\n            alias(\"sql-timestamp\", JVM.loadClassForName(\"java.sql.Timestamp\"));\n            alias(\"sql-time\", JVM.loadClassForName(\"java.sql.Time\"));\n            alias(\"sql-date\", JVM.loadClassForName(\"java.sql.Date\"));\n        }\n\n        alias(\"file\", File.class);\n        alias(\"locale\", Locale.class);\n        alias(\"gregorian-calendar\", Calendar.class);\n\n        if (JVM.isVersion(4)) {\n            aliasDynamically(\"auth-subject\", \"javax.security.auth.Subject\");\n            alias(\"linked-hash-map\", JVM.loadClassForName(\"java.util.LinkedHashMap\"));\n            alias(\"linked-hash-set\", JVM.loadClassForName(\"java.util.LinkedHashSet\"));\n            alias(\"trace\", JVM.loadClassForName(\"java.lang.StackTraceElement\"));\n            alias(\"currency\", JVM.loadClassForName(\"java.util.Currency\"));\n            aliasType(\"charset\", JVM.loadClassForName(\"java.nio.charset.Charset\"));\n        }\n\n        if (JVM.isVersion(5)) {\n            aliasDynamically(\"xml-duration\", \"javax.xml.datatype.Duration\");\n            alias(\"concurrent-hash-map\", JVM.loadClassForName(\"java.util.concurrent.ConcurrentHashMap\"));\n            alias(\"enum-set\", JVM.loadClassForName(\"java.util.EnumSet\"));\n            alias(\"enum-map\", JVM.loadClassForName(\"java.util.EnumMap\"));\n            alias(\"string-builder\", JVM.loadClassForName(\"java.lang.StringBuilder\"));\n            alias(\"uuid\", JVM.loadClassForName(\"java.util.UUID\"));\n        }\n        \n        if (JVM.isVersion(7)) {\n            aliasType(\"path\", JVM.loadClassForName(\"java.nio.file.Path\"));\n        }\n\n        if (JVM.isVersion(8)) {\n            alias(\"fixed-clock\", JVM.loadClassForName(\"java.time.Clock$FixedClock\"));\n            alias(\"offset-clock\", JVM.loadClassForName(\"java.time.Clock$OffsetClock\"));\n            alias(\"system-clock\", JVM.loadClassForName(\"java.time.Clock$SystemClock\"));\n            alias(\"tick-clock\", JVM.loadClassForName(\"java.time.Clock$TickClock\"));\n            alias(\"day-of-week\", JVM.loadClassForName(\"java.time.DayOfWeek\"));\n            alias(\"duration\", JVM.loadClassForName(\"java.time.Duration\"));\n            alias(\"instant\", JVM.loadClassForName(\"java.time.Instant\"));\n            alias(\"local-date\", JVM.loadClassForName(\"java.time.LocalDate\"));\n            alias(\"local-date-time\", JVM.loadClassForName(\"java.time.LocalDateTime\"));\n            alias(\"local-time\", JVM.loadClassForName(\"java.time.LocalTime\"));\n            alias(\"month\", JVM.loadClassForName(\"java.time.Month\"));\n            alias(\"month-day\", JVM.loadClassForName(\"java.time.MonthDay\"));\n            alias(\"offset-date-time\", JVM.loadClassForName(\"java.time.OffsetDateTime\"));\n            alias(\"offset-time\", JVM.loadClassForName(\"java.time.OffsetTime\"));\n            alias(\"period\", JVM.loadClassForName(\"java.time.Period\"));\n            alias(\"year\", JVM.loadClassForName(\"java.time.Year\"));\n            alias(\"year-month\", JVM.loadClassForName(\"java.time.YearMonth\"));\n            alias(\"zoned-date-time\", JVM.loadClassForName(\"java.time.ZonedDateTime\"));\n            aliasType(\"zone-id\", JVM.loadClassForName(\"java.time.ZoneId\"));\n            aliasType(\"chronology\", JVM.loadClassForName(\"java.time.chrono.Chronology\"));\n            alias(\"hijrah-date\", JVM.loadClassForName(\"java.time.chrono.HijrahDate\"));\n            alias(\"hijrah-era\", JVM.loadClassForName(\"java.time.chrono.HijrahEra\"));\n            alias(\"japanese-date\", JVM.loadClassForName(\"java.time.chrono.JapaneseDate\"));\n            alias(\"japanese-era\", JVM.loadClassForName(\"java.time.chrono.JapaneseEra\"));\n            alias(\"minguo-date\", JVM.loadClassForName(\"java.time.chrono.MinguoDate\"));\n            alias(\"minguo-era\", JVM.loadClassForName(\"java.time.chrono.MinguoEra\"));\n            alias(\"thai-buddhist-date\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistDate\"));\n            alias(\"thai-buddhist-era\", JVM.loadClassForName(\"java.time.chrono.ThaiBuddhistEra\"));\n            alias(\"chrono-field\", JVM.loadClassForName(\"java.time.temporal.ChronoField\"));\n            alias(\"chrono-unit\", JVM.loadClassForName(\"java.time.temporal.ChronoUnit\"));\n            alias(\"iso-field\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Field\"));\n            alias(\"iso-unit\", JVM.loadClassForName(\"java.time.temporal.IsoFields$Unit\"));\n            alias(\"julian-field\", JVM.loadClassForName(\"java.time.temporal.JulianFields$Field\"));\n            alias(\"temporal-value-range\", JVM.loadClassForName(\"java.time.temporal.ValueRange\"));\n            alias(\"week-fields\", JVM.loadClassForName(\"java.time.temporal.WeekFields\"));\n        }\n\n        if (JVM.loadClassForName(\"java.lang.invoke.SerializedLambda\") != null) {\n            aliasDynamically(\"serialized-lambda\", \"java.lang.invoke.SerializedLambda\");\n        }\n    }\n\n    private void aliasDynamically(String alias, String className) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            alias(alias, type);\n        }\n    }\n\n    protected void setupDefaultImplementations() {\n        if (defaultImplementationsMapper == null) {\n            return;\n        }\n        addDefaultImplementation(HashMap.class, Map.class);\n        addDefaultImplementation(ArrayList.class, List.class);\n        addDefaultImplementation(HashSet.class, Set.class);\n        addDefaultImplementation(TreeSet.class, SortedSet.class);\n        addDefaultImplementation(GregorianCalendar.class, Calendar.class);\n    }\n\n    protected void setupConverters() {\n        registerConverter(\n            new ReflectionConverter(mapper, reflectionProvider), PRIORITY_VERY_LOW);\n\n        registerConverter(\n            new SerializableConverter(mapper, reflectionProvider, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new ExternalizableConverter(mapper, classLoaderReference), PRIORITY_LOW);\n        registerConverter(new InternalBlackList(), PRIORITY_LOW);\n\n        registerConverter(new NullConverter(), PRIORITY_VERY_HIGH);\n        registerConverter(new IntConverter(), PRIORITY_NORMAL);\n        registerConverter(new FloatConverter(), PRIORITY_NORMAL);\n        registerConverter(new DoubleConverter(), PRIORITY_NORMAL);\n        registerConverter(new LongConverter(), PRIORITY_NORMAL);\n        registerConverter(new ShortConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new CharConverter(), PRIORITY_NORMAL);\n        registerConverter(new BooleanConverter(), PRIORITY_NORMAL);\n        registerConverter(new ByteConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new StringConverter(), PRIORITY_NORMAL);\n        registerConverter(new StringBufferConverter(), PRIORITY_NORMAL);\n        registerConverter(new DateConverter(), PRIORITY_NORMAL);\n        registerConverter(new BitSetConverter(), PRIORITY_NORMAL);\n        registerConverter(new URIConverter(), PRIORITY_NORMAL);\n        registerConverter(new URLConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigIntegerConverter(), PRIORITY_NORMAL);\n        registerConverter(new BigDecimalConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new ArrayConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new CharArrayConverter(), PRIORITY_NORMAL);\n        registerConverter(new CollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new MapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new TreeSetConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonCollectionConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new SingletonMapConverter(mapper), PRIORITY_NORMAL);\n        registerConverter(new PropertiesConverter(), PRIORITY_NORMAL);\n        registerConverter((Converter)new EncodedByteArrayConverter(), PRIORITY_NORMAL);\n\n        registerConverter(new FileConverter(), PRIORITY_NORMAL);\n        if (JVM.isSQLAvailable()) {\n            registerConverter(new SqlTimestampConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlTimeConverter(), PRIORITY_NORMAL);\n            registerConverter(new SqlDateConverter(), PRIORITY_NORMAL);\n        }\n        registerConverter(new DynamicProxyConverter(mapper, classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaClassConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaMethodConverter(classLoaderReference), PRIORITY_NORMAL);\n        registerConverter(new JavaFieldConverter(classLoaderReference), PRIORITY_NORMAL);\n\n        if (JVM.isAWTAvailable()) {\n            registerConverter(new FontConverter(mapper), PRIORITY_NORMAL);\n            registerConverter(new ColorConverter(), PRIORITY_NORMAL);\n            registerConverter(new TextAttributeConverter(), PRIORITY_NORMAL);\n        }\n        if (JVM.isSwingAvailable()) {\n            registerConverter(\n                new LookAndFeelConverter(mapper, reflectionProvider), PRIORITY_NORMAL);\n        }\n        registerConverter(new LocaleConverter(), PRIORITY_NORMAL);\n        registerConverter(new GregorianCalendarConverter(), PRIORITY_NORMAL);\n\n        if (JVM.isVersion(4)) {\n            \n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.SubjectConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.ThrowableConverter\",\n                PRIORITY_NORMAL, new Class[]{ConverterLookup.class},\n                new Object[]{converterLookup});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.StackTraceElementConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CurrencyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.RegexPatternConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.extended.CharsetConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n\n        if (JVM.isVersion(5)) {\n            \n            if (JVM.loadClassForName(\"javax.xml.datatype.Duration\") != null) {\n                registerConverterDynamically(\n                    \"com.thoughtworks.xstream.converters.extended.DurationConverter\",\n                    PRIORITY_NORMAL, null, null);\n            }\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumSetConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.enums.EnumMapConverter\", PRIORITY_NORMAL,\n                new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.StringBuilderConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\n                \"com.thoughtworks.xstream.converters.basic.UUIDConverter\", PRIORITY_NORMAL,\n                null, null);\n        }\n        if (JVM.loadClassForName(\"javax.activation.ActivationDataFlavor\") != null) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.ActivationDataFlavorConverter\",\n                PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(7)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.extended.PathConverter\",\n                    PRIORITY_NORMAL, null, null);\n        }\n        if (JVM.isVersion(8)) {\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ChronologyConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.DurationConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.HijrahDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.JapaneseEraConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.InstantConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.LocalTimeConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MinguoDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.MonthDayConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.OffsetTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.PeriodConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.SystemClockConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ThaiBuddhistDateConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ValueRangeConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.WeekFieldsConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class}, new Object[]{mapper});\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.YearMonthConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZonedDateTimeConverter\",\n                PRIORITY_NORMAL, null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.time.ZoneIdConverter\", PRIORITY_NORMAL,\n                null, null);\n            registerConverterDynamically(\"com.thoughtworks.xstream.converters.reflection.LambdaConverter\",\n                PRIORITY_NORMAL, new Class[]{Mapper.class, ReflectionProvider.class, ClassLoaderReference.class},\n                new Object[]{mapper, reflectionProvider, classLoaderReference});\n        }\n\n        registerConverter(\n            new SelfStreamingInstanceChecker(converterLookup, this), PRIORITY_NORMAL);\n    }\n\n    private void registerConverterDynamically(String className, int priority,\n        Class[] constructorParamTypes, Object[] constructorParamValues) {\n        try {\n            Class type = Class.forName(className, false, classLoaderReference.getReference());\n            Constructor constructor = type.getConstructor(constructorParamTypes);\n            Object instance = constructor.newInstance(constructorParamValues);\n            if (instance instanceof Converter) {\n                registerConverter((Converter)instance, priority);\n            } else if (instance instanceof SingleValueConverter) {\n                registerConverter((SingleValueConverter)instance, priority);\n            }\n        } catch (Exception e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        } catch (LinkageError e) {\n            throw new com.thoughtworks.xstream.InitializationException(\n                \"Could not instantiate converter : \" + className, e);\n        }\n    }\n\n    protected void setupImmutableTypes() {\n        if (immutableTypesMapper == null) {\n            return;\n        }\n\n        \n        addImmutableType(boolean.class, false);\n        addImmutableType(Boolean.class, false);\n        addImmutableType(byte.class, false);\n        addImmutableType(Byte.class, false);\n        addImmutableType(char.class, false);\n        addImmutableType(Character.class, false);\n        addImmutableType(double.class, false);\n        addImmutableType(Double.class, false);\n        addImmutableType(float.class, false);\n        addImmutableType(Float.class, false);\n        addImmutableType(int.class, false);\n        addImmutableType(Integer.class, false);\n        addImmutableType(long.class, false);\n        addImmutableType(Long.class, false);\n        addImmutableType(short.class, false);\n        addImmutableType(Short.class, false);\n\n        \n        addImmutableType(Mapper.Null.class, false);\n        addImmutableType(BigDecimal.class, false);\n        addImmutableType(BigInteger.class, false);\n        addImmutableType(String.class, false);\n        addImmutableType(URL.class, false);\n        addImmutableType(File.class, false);\n        addImmutableType(Class.class, false);\n\n        if (JVM.isVersion(7)) {\n            Class type = JVM.loadClassForName(\"java.nio.file.Paths\");\n            if (type != null) {\n                Method methodGet;\n                try {\n                    methodGet = type.getDeclaredMethod(\"get\", new Class[] {String.class, String[].class});\n                    if (methodGet != null) {\n                        Object path = methodGet.invoke(null, new Object[]{\".\", new String[0]});\n                        if (path != null) {\n                            addImmutableType(path.getClass(), false);\n                        }\n                    }\n                } catch (NoSuchMethodException e) {\n                } catch (SecurityException e) {\n                } catch (IllegalAccessException e) {\n                } catch (InvocationTargetException e) {\n                }\n            }\n        }\n\n        if (JVM.isAWTAvailable()) {\n            addImmutableTypeDynamically(\"java.awt.font.TextAttribute\", false);\n        }\n\n        if (JVM.isVersion(4)) {\n            \n            addImmutableTypeDynamically(\"java.nio.charset.Charset\", true);\n            addImmutableTypeDynamically(\"java.util.Currency\", true);\n        }\n        \n        if (JVM.isVersion(5)) {\n            addImmutableTypeDynamically(\"java.util.UUID\", true);\n        }\n\n        addImmutableType(URI.class, true);\n        addImmutableType(Collections.EMPTY_LIST.getClass(), true);\n        addImmutableType(Collections.EMPTY_SET.getClass(), true);\n        addImmutableType(Collections.EMPTY_MAP.getClass(), true);\n\n        if (JVM.isVersion(8)) {\n            addImmutableTypeDynamically(\"java.time.Duration\", false);\n            addImmutableTypeDynamically(\"java.time.Instant\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDate\", false);\n            addImmutableTypeDynamically(\"java.time.LocalDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.LocalTime\", false);\n            addImmutableTypeDynamically(\"java.time.MonthDay\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.OffsetTime\", false);\n            addImmutableTypeDynamically(\"java.time.Period\", false);\n            addImmutableTypeDynamically(\"java.time.Year\", false);\n            addImmutableTypeDynamically(\"java.time.YearMonth\", false);\n            addImmutableTypeDynamically(\"java.time.ZonedDateTime\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneId\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneOffset\", false);\n            addImmutableTypeDynamically(\"java.time.ZoneRegion\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.HijrahDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.IsoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.JapaneseEra\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.MinguoDate\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistChronology\", false);\n            addImmutableTypeDynamically(\"java.time.chrono.ThaiBuddhistDate\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Field\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.IsoFields$Unit\", false);\n            addImmutableTypeDynamically(\"java.time.temporal.JulianFields$Field\", false);\n        }\n    }\n\n    private void addImmutableTypeDynamically(String className, boolean isReferenceable) {\n        Class type = JVM.loadClassForName(className);\n        if (type != null) {\n            addImmutableType(type, isReferenceable);\n        }\n    }\n\n    public void setMarshallingStrategy(MarshallingStrategy marshallingStrategy) {\n        this.marshallingStrategy = marshallingStrategy;\n    }\n\n    \n    public String toXML(Object obj) {\n        Writer writer = new StringWriter();\n        toXML(obj, writer);\n        return writer.toString();\n    }\n\n    \n    public void toXML(Object obj, Writer out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    \n    public void toXML(Object obj, OutputStream out) {\n        HierarchicalStreamWriter writer = hierarchicalStreamDriver.createWriter(out);\n        try {\n            marshal(obj, writer);\n        } finally {\n            writer.flush();\n        }\n    }\n\n    \n    public void marshal(Object obj, HierarchicalStreamWriter writer) {\n        marshal(obj, writer, null);\n    }\n\n    \n    public void marshal(Object obj, HierarchicalStreamWriter writer, DataHolder dataHolder) {\n        marshallingStrategy.marshal(writer, obj, converterLookup, mapper, dataHolder);\n    }\n\n    \n    public Object fromXML(String xml) {\n        return fromXML(new StringReader(xml));\n    }\n\n    \n    public Object fromXML(Reader reader) {\n        return unmarshal(hierarchicalStreamDriver.createReader(reader), null);\n    }\n\n    \n    public Object fromXML(InputStream input) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), null);\n    }\n\n    \n    public Object fromXML(URL url) {\n        return fromXML(url, null);\n    }\n\n    \n    public Object fromXML(File file) {\n        return fromXML(file, null);\n    }\n\n    \n    public Object fromXML(String xml, Object root) {\n        return fromXML(new StringReader(xml), root);\n    }\n\n    \n    public Object fromXML(Reader xml, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(xml), root);\n    }\n\n    \n    public Object fromXML(URL url, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(url), root);\n    }\n\n    \n    public Object fromXML(File file, Object root) {\n        HierarchicalStreamReader reader = hierarchicalStreamDriver.createReader(file);\n        try {\n            return unmarshal(reader, root);\n        } finally {\n            reader.close();\n        }\n    }\n\n    \n    public Object fromXML(InputStream input, Object root) {\n        return unmarshal(hierarchicalStreamDriver.createReader(input), root);\n    }\n\n    \n    public Object unmarshal(HierarchicalStreamReader reader) {\n        return unmarshal(reader, null, null);\n    }\n\n    \n    public Object unmarshal(HierarchicalStreamReader reader, Object root) {\n        return unmarshal(reader, root, null);\n    }\n\n    \n    public Object unmarshal(HierarchicalStreamReader reader, Object root, DataHolder dataHolder) {\n        try {\n            if (insecureWarning) {\n                insecureWarning = false;\n                System.err.println(\"Security framework of XStream not initialized, XStream is probably vulnerable.\");\n            }\n            return marshallingStrategy.unmarshal(\n                root, reader, dataHolder, converterLookup, mapper);\n\n        } catch (ConversionException e) {\n            Package pkg = getClass().getPackage();\n            String version = pkg != null ? pkg.getImplementationVersion() : null;\n            e.add(\"version\", version != null ? version : \"not available\");\n            throw e;\n        }\n    }\n\n    \n    public void alias(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addClassAlias(name, type);\n    }\n\n    \n    public void aliasType(String name, Class type) {\n        if (classAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ClassAliasingMapper.class.getName()\n                + \" available\");\n        }\n        classAliasingMapper.addTypeAlias(name, type);\n    }\n\n    \n    public void alias(String name, Class type, Class defaultImplementation) {\n        alias(name, type);\n        addDefaultImplementation(defaultImplementation, type);\n    }\n\n    \n    public void aliasPackage(String name, String pkgName) {\n        if (packageAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + PackageAliasingMapper.class.getName()\n                + \" available\");\n        }\n        packageAliasingMapper.addPackageAlias(name, pkgName);\n    }\n\n    \n    public void aliasField(String alias, Class definedIn, String fieldName) {\n        if (fieldAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + FieldAliasingMapper.class.getName()\n                + \" available\");\n        }\n        fieldAliasingMapper.addFieldAlias(alias, definedIn, fieldName);\n    }\n\n    \n    public void aliasAttribute(String alias, String attributeName) {\n        if (attributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        attributeAliasingMapper.addAliasFor(attributeName, alias);\n    }\n\n    \n    public void aliasSystemAttribute(String alias, String systemAttributeName) {\n        if (systemAttributeAliasingMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + SystemAttributeAliasingMapper.class.getName()\n                + \" available\");\n        }\n        systemAttributeAliasingMapper.addAliasFor(systemAttributeName, alias);\n    }\n\n    \n    public void aliasAttribute(Class definedIn, String attributeName, String alias) {\n        aliasField(alias, definedIn, attributeName);\n        useAttributeFor(definedIn, attributeName);\n    }\n\n    \n    public void useAttributeFor(String fieldName, Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(fieldName, type);\n    }\n\n    \n    public void useAttributeFor(Class definedIn, String fieldName) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(definedIn, fieldName);\n    }\n\n    \n    public void useAttributeFor(Class type) {\n        if (attributeMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + AttributeMapper.class.getName()\n                + \" available\");\n        }\n        attributeMapper.addAttributeFor(type);\n    }\n\n    \n    public void addDefaultImplementation(Class defaultImplementation, Class ofType) {\n        if (defaultImplementationsMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + DefaultImplementationsMapper.class.getName()\n                + \" available\");\n        }\n        defaultImplementationsMapper.addDefaultImplementation(defaultImplementation, ofType);\n    }\n\n    \n    public void addImmutableType(Class type) {\n        addImmutableType(type, true);\n    }\n\n    \n    public void addImmutableType(final Class type, final boolean isReferenceable) {\n        if (immutableTypesMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImmutableTypesMapper.class.getName()\n                + \" available\");\n        }\n        immutableTypesMapper.addImmutableType(type, isReferenceable);\n    }\n\n    public void registerConverter(Converter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(Converter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(converter, priority);\n        }\n    }\n\n    public void registerConverter(SingleValueConverter converter) {\n        registerConverter(converter, PRIORITY_NORMAL);\n    }\n\n    public void registerConverter(SingleValueConverter converter, int priority) {\n        if (converterRegistry != null) {\n            converterRegistry.registerConverter(\n                new SingleValueConverterWrapper(converter), priority);\n        }\n    }\n\n    \n    public void registerLocalConverter(Class definedIn, String fieldName, Converter converter) {\n        if (localConversionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + LocalConversionMapper.class.getName()\n                + \" available\");\n        }\n        localConversionMapper.registerLocalConverter(definedIn, fieldName, converter);\n    }\n\n    \n    public void registerLocalConverter(Class definedIn, String fieldName,\n        SingleValueConverter converter) {\n        registerLocalConverter(\n            definedIn, fieldName, (Converter)new SingleValueConverterWrapper(converter));\n    }\n\n    \n    public Mapper getMapper() {\n        return mapper;\n    }\n\n    \n    public ReflectionProvider getReflectionProvider() {\n        return reflectionProvider;\n    }\n\n    public ConverterLookup getConverterLookup() {\n        return converterLookup;\n    }\n\n    \n    public void setMode(int mode) {\n        switch (mode) {\n        case NO_REFERENCES:\n            setMarshallingStrategy(new TreeMarshallingStrategy());\n            break;\n        case ID_REFERENCES:\n            setMarshallingStrategy(new ReferenceByIdMarshallingStrategy());\n            break;\n        case XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.RELATIVE));\n            break;\n        case XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                ReferenceByXPathMarshallingStrategy.ABSOLUTE));\n            break;\n        case SINGLE_NODE_XPATH_RELATIVE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.RELATIVE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        case SINGLE_NODE_XPATH_ABSOLUTE_REFERENCES:\n            setMarshallingStrategy(new ReferenceByXPathMarshallingStrategy(\n                  ReferenceByXPathMarshallingStrategy.ABSOLUTE \n                | ReferenceByXPathMarshallingStrategy.SINGLE_NODE));\n            break;\n        default:\n            throw new IllegalArgumentException(\"Unknown mode : \" + mode);\n        }\n    }\n\n    \n    public void addImplicitCollection(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName, null, null);\n    }\n\n    \n    public void addImplicitCollection(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, null, itemType);\n    }\n\n    \n    public void addImplicitCollection(Class ownerType, String fieldName, String itemFieldName,\n        Class itemType) {\n        addImplicitMap(ownerType, fieldName, itemFieldName, itemType, null);\n    }\n\n    \n    public void addImplicitArray(Class ownerType, String fieldName) {\n        addImplicitCollection(ownerType, fieldName);\n    }\n\n    \n    public void addImplicitArray(Class ownerType, String fieldName, Class itemType) {\n        addImplicitCollection(ownerType, fieldName, itemType);\n    }\n\n    \n    public void addImplicitArray(Class ownerType, String fieldName, String itemName) {\n        addImplicitCollection(ownerType, fieldName, itemName, null);\n    }\n\n    \n    public void addImplicitMap(Class ownerType, String fieldName, Class itemType, String keyFieldName) {\n        addImplicitMap(ownerType, fieldName, null, itemType, keyFieldName);\n    }\n\n    \n    public void addImplicitMap(Class ownerType, String fieldName, String itemName, \n        Class itemType, String keyFieldName) {\n        if (implicitCollectionMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ImplicitCollectionMapper.class.getName()\n                + \" available\");\n        }\n        implicitCollectionMapper.add(ownerType, fieldName, itemName, itemType, keyFieldName);\n    }\n\n    \n    public DataHolder newDataHolder() {\n        return new MapBackedDataHolder();\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(Writer writer) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), \"object-stream\");\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(HierarchicalStreamWriter writer)\n        throws IOException {\n        return createObjectOutputStream(writer, \"object-stream\");\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(Writer writer, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(writer), rootNodeName);\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(OutputStream out) throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), \"object-stream\");\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(OutputStream out, String rootNodeName)\n        throws IOException {\n        return createObjectOutputStream(\n            hierarchicalStreamDriver.createWriter(out), rootNodeName);\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName)\n            throws IOException {\n        return createObjectOutputStream(writer, rootNodeName, null);\n    }\n\n    \n    public ObjectOutputStream createObjectOutputStream(final HierarchicalStreamWriter writer, final String rootNodeName,\n            final DataHolder dataHolder) throws IOException {\n        final StatefulWriter statefulWriter = new StatefulWriter(writer);\n        statefulWriter.startNode(rootNodeName, null);\n        return new CustomObjectOutputStream(new CustomObjectOutputStream.StreamCallback() {\n            public void writeToStream(final Object object) {\n                marshal(object, statefulWriter, dataHolder);\n            }\n\n            public void writeFieldsToStream(Map fields) throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void defaultWriteObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to writeObject\");\n            }\n\n            public void flush() {\n                statefulWriter.flush();\n            }\n\n            public void close() {\n                if (statefulWriter.state() != StatefulWriter.STATE_CLOSED) {\n                    statefulWriter.endNode();\n                    statefulWriter.close();\n                }\n            }\n        });\n    }\n\n    \n    public ObjectInputStream createObjectInputStream(Reader xmlReader) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(xmlReader));\n    }\n\n    \n    public ObjectInputStream createObjectInputStream(InputStream in) throws IOException {\n        return createObjectInputStream(hierarchicalStreamDriver.createReader(in));\n    }\n\n    \n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader) throws IOException {\n        return createObjectInputStream(reader, null);\n    }\n\n    \n    public ObjectInputStream createObjectInputStream(final HierarchicalStreamReader reader, final DataHolder dataHolder)\n            throws IOException {\n        return new CustomObjectInputStream(new CustomObjectInputStream.StreamCallback() {\n            public Object readFromStream() throws EOFException {\n                if (!reader.hasMoreChildren()) {\n                    throw new EOFException();\n                }\n                reader.moveDown();\n                final Object result = unmarshal(reader, dataHolder);\n                reader.moveUp();\n                return result;\n            }\n\n            public Map readFieldsFromStream() throws IOException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void defaultReadObject() throws NotActiveException {\n                throw new NotActiveException(\"not in call to readObject\");\n            }\n\n            public void registerValidation(ObjectInputValidation validation, int priority)\n                throws NotActiveException {\n                throw new NotActiveException(\"stream inactive\");\n            }\n\n            public void close() {\n                reader.close();\n            }\n        }, classLoaderReference);\n    }\n\n    \n    public void setClassLoader(ClassLoader classLoader) {\n        classLoaderReference.setReference(classLoader);\n    }\n\n    \n    public ClassLoader getClassLoader() {\n        return classLoaderReference.getReference();\n    }\n    \n    \n    public ClassLoaderReference getClassLoaderReference() {\n        return classLoaderReference;\n    }\n\n    \n    public void omitField(Class definedIn, String fieldName) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.omitField(definedIn, fieldName);\n    }\n    \n    \n    public void ignoreUnknownElements() {\n        ignoreUnknownElements(IGNORE_ALL);\n    }\n\n    \n    public void ignoreUnknownElements(String pattern) {\n        ignoreUnknownElements(Pattern.compile(pattern));\n    }\n\n    \n    public void ignoreUnknownElements(final Pattern pattern) {\n        if (elementIgnoringMapper == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ElementIgnoringMapper.class.getName()\n                + \" available\");\n        }\n        elementIgnoringMapper.addElementsToIgnore(pattern);\n    }\n\n    \n    public void processAnnotations(final Class[] types) {\n        if (annotationConfiguration == null) {\n            throw new com.thoughtworks.xstream.InitializationException(\"No \"\n                + ANNOTATION_MAPPER_TYPE\n                + \" available\");\n        }\n        annotationConfiguration.processAnnotations(types);\n    }\n\n    \n    public void processAnnotations(final Class type) {\n        processAnnotations(new Class[]{type});\n    }\n\n    \n    public void autodetectAnnotations(boolean mode) {\n        if (annotationConfiguration != null) {\n            annotationConfiguration.autodetectAnnotations(mode);\n        }\n    }\n    \n    \n    public void addPermission(TypePermission permission) {\n        if (securityMapper != null) {\n            insecureWarning &= permission != NoTypePermission.NONE;\n            securityMapper.addPermission(permission);\n        }\n    }\n    \n    \n    public void allowTypes(String[] names) {\n        addPermission(new ExplicitTypePermission(names));\n    }\n    \n    \n    public void allowTypes(Class[] types) {\n        addPermission(new ExplicitTypePermission(types));\n    }\n    \n    \n    public void allowTypeHierarchy(Class type) {\n        addPermission(new TypeHierarchyPermission(type));\n    }\n    \n    \n    public void allowTypesByRegExp(String[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    \n    public void allowTypesByRegExp(Pattern[] regexps) {\n        addPermission(new RegExpTypePermission(regexps));\n    }\n    \n    \n    public void allowTypesByWildcard(String[] patterns) {\n        addPermission(new WildcardTypePermission(patterns));\n    }\n    \n    \n    public void denyPermission(TypePermission permission) {\n        addPermission(new NoPermission(permission));\n    }\n    \n    \n    public void denyTypes(String[] names) {\n        denyPermission(new ExplicitTypePermission(names));\n    }\n    \n    \n    public void denyTypes(Class[] types) {\n        denyPermission(new ExplicitTypePermission(types));\n    }\n    \n    \n    public void denyTypeHierarchy(Class type) {\n        denyPermission(new TypeHierarchyPermission(type));\n    }\n    \n    \n    public void denyTypesByRegExp(String[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    \n    public void denyTypesByRegExp(Pattern[] regexps) {\n        denyPermission(new RegExpTypePermission(regexps));\n    }\n    \n    \n    public void denyTypesByWildcard(String[] patterns) {\n        denyPermission(new WildcardTypePermission(patterns));\n    }\n\n    \n    public static class InitializationException extends XStreamException {\n        \n        public InitializationException(String message, Throwable cause) {\n            super(message, cause);\n        }\n\n        \n        public InitializationException(String message) {\n            super(message);\n        }\n    }\n\n    private class InternalBlackList implements Converter {\n\n        public boolean canConvert(final Class type) {\n            return (type == void.class || type == Void.class)\n                || (insecureWarning\n                    && type != null\n                    && (type.getName().equals(\"java.beans.EventHandler\")\n                        || type.getName().endsWith(\"$LazyIterator\")\n                        || type.getName().startsWith(\"javax.crypto.\")));\n        }\n\n        public void marshal(final Object source, final HierarchicalStreamWriter writer,\n                final MarshallingContext context) {\n            throw new ConversionException(\"Security alert. Marshalling rejected.\");\n        }\n\n        public Object unmarshal(final HierarchicalStreamReader reader, final UnmarshallingContext context) {\n            throw new ConversionException(\"Security alert. Unmarshalling rejected.\");\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 75,
    "sub_id": 1,
    "code_id": 0,
    "human_patch": "https://github.com/x-stream/xstream/commit/f38a1da3ae9491930c2067c12cd2506738b21dab",
    "cve_id": "CVE-2019-10173",
    "cwe_id": "CWE-502",
    "filename": "xstream/src/test/com/thoughtworks/acceptance/SecurityVulnerabilityTest.java",
    "code": "\npackage com.thoughtworks.acceptance;\n\nimport java.beans.EventHandler;\n\nimport com.thoughtworks.xstream.XStreamException;\nimport com.thoughtworks.xstream.converters.ConversionException;\nimport com.thoughtworks.xstream.converters.reflection.ReflectionConverter;\nimport com.thoughtworks.xstream.security.ForbiddenClassException;\nimport com.thoughtworks.xstream.security.ProxyTypePermission;\n\n\n\npublic class SecurityVulnerabilityTest extends AbstractAcceptanceTest {\n\n    private final static StringBuffer BUFFER = new StringBuffer();\n\n    protected void setUp() throws Exception {\n        super.setUp();\n        BUFFER.setLength(0);\n        xstream.alias(\"runnable\", Runnable.class);\n        xstream.allowTypeHierarchy(Runnable.class);\n        xstream.addPermission(ProxyTypePermission.PROXIES);\n    }\n\n    public void testCannotInjectEventHandler() {\n        final String xml = \"\"\n                + \"<string class='runnable-array'>\\n\"\n                + \"  <dynamic-proxy>\\n\"\n                + \"    <interface>java.lang.Runnable</interface>\\n\"\n                + \"    <handler class='java.beans.EventHandler'>\\n\"\n                + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n                + \"      <action>exec</action>\\n\"\n                + \"    </handler>\\n\"\n                + \"  </dynamic-proxy>\\n\"\n                + \"</string>\";\n\n        try {\n            xstream.fromXML(xml);\n            fail(\"Thrown \" + XStreamException.class.getName() + \" expected\");\n        } catch (final XStreamException e) {\n            assertTrue(e.getMessage().indexOf(EventHandler.class.getName()) > 0);\n        }\n        assertEquals(0, BUFFER.length());\n    }\n\n    public void testExplicitlyConvertEventHandler() {\n        final String xml = \"\"\n                + \"<string class='runnable-array'>\\n\"\n                + \"  <dynamic-proxy>\\n\"\n                + \"    <interface>java.lang.Runnable</interface>\\n\"\n                + \"    <handler class='java.beans.EventHandler'>\\n\"\n                + \"      <target class='com.thoughtworks.acceptance.SecurityVulnerabilityTest$Exec'/>\\n\"\n                + \"      <action>exec</action>\\n\"\n                + \"    </handler>\\n\"\n                + \"  </dynamic-proxy>\\n\"\n                + \"</string>\";\n\n        xstream.allowTypes(new Class[]{EventHandler.class});\n        xstream.registerConverter(new ReflectionConverter(xstream.getMapper(), xstream\n            .getReflectionProvider(), EventHandler.class));\n\n        final Runnable[] array = (Runnable[])xstream.fromXML(xml);\n        assertEquals(0, BUFFER.length());\n        array[0].run();\n        assertEquals(\"Executed!\", BUFFER.toString());\n    }\n\n    public static class Exec {\n\n        public void exec() {\n            BUFFER.append(\"Executed!\");\n        }\n    }\n\n    public void testDeniedInstanceOfVoid() {\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ForbiddenClassException.class.getName() + \" expected\");\n        } catch (final ForbiddenClassException e) {\n            \n        }\n    }\n\n    public void testAllowedInstanceOfVoid() {\n        xstream.allowTypes(new Class[] { void.class, Void.class });\n        try {\n            xstream.fromXML(\"<void/>\");\n            fail(\"Thrown \" + ConversionException.class.getName() + \" expected\");\n        } catch (final ConversionException e) {\n            assertEquals(\"void\", e.get(\"required-type\"));\n        }\n    }\n}\n",
    "is_vulnerable": 1
  },
  {
    "id": 76,
    "sub_id": 0,
    "code_id": 0,
    "human_patch": "https://github.com/zeroturnaround/zt-zip/commit/759b72f33bc8f4d69f84f09fcb7f010ad45d6fff",
    "cve_id": "CVE-2018-1002201",
    "cwe_id": "CWE-22",
    "filename": "src/main/java/org/zeroturnaround/zip/ZipUtil.java",
    "code": "\npackage org.zeroturnaround.zip;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.zip.Deflater;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\nimport java.util.zip.ZipInputStream;\nimport java.util.zip.ZipOutputStream;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.zeroturnaround.zip.commons.FileUtils;\nimport org.zeroturnaround.zip.commons.FilenameUtils;\nimport org.zeroturnaround.zip.commons.IOUtils;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformer;\nimport org.zeroturnaround.zip.transform.ZipEntryTransformerEntry;\n\n\npublic final class ZipUtil {\n\n  private static final String PATH_SEPARATOR = \"/\";\n\n  \n  public static final int DEFAULT_COMPRESSION_LEVEL = Deflater.DEFAULT_COMPRESSION;\n\n  \n  private static final Logger log = LoggerFactory.getLogger(\"org/zeroturnaround/zip/ZipUtil\".replace('/', '.')); \n\n  private ZipUtil() {\n  }\n\n  \n\n  \n  public static boolean containsEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return zf.getEntry(name) != null;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  @Deprecated\n  public static int getCompressionLevelOfEntry(File zip, String name) {\n    return getCompressionMethodOfEntry(zip, name);\n  }\n\n  \n  public static int getCompressionMethodOfEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      ZipEntry zipEntry = zf.getEntry(name);\n      if (zipEntry == null) {\n        return -1;\n      }\n      return zipEntry.getMethod();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static boolean containsAnyEntry(File zip, String[] names) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (int i = 0; i < names.length; i++) {\n        if (zf.getEntry(names[i]) != null) {\n          return true;\n        }\n      }\n      return false;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static byte[] unpackEntry(File zip, String name) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static byte[] unpackEntry(File zip, String name, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static byte[] unpackEntry(ZipFile zf, String name) {\n    try {\n      return doUnpackEntry(zf, name);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  private static byte[] doUnpackEntry(ZipFile zf, String name) throws IOException {\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return null; \n    }\n\n    InputStream is = zf.getInputStream(ze);\n    try {\n      return IOUtils.toByteArray(is);\n    }\n    finally {\n      IOUtils.closeQuietly(is);\n    }\n  }\n\n  \n  public static byte[] unpackEntry(InputStream is, String name) {\n    ByteArrayUnpacker action = new ByteArrayUnpacker();\n    if (!handle(is, name, action))\n      return null; \n    return action.getBytes();\n  }\n\n  \n  private static class ByteArrayUnpacker implements ZipEntryCallback {\n\n    private byte[] bytes;\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      bytes = IOUtils.toByteArray(in);\n    }\n\n    public byte[] getBytes() {\n      return bytes;\n    }\n\n  }\n\n  \n  public static boolean unpackEntry(File zip, String name, File file) {\n    return unpackEntry(zip, name, file, null);\n  }\n\n  \n  public static boolean unpackEntry(File zip, String name, File file, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset != null) {\n        zf = new ZipFile(zip, charset);\n      }\n      else {\n        zf = new ZipFile(zip);\n      }\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static boolean unpackEntry(ZipFile zf, String name, File file) {\n    try {\n      return doUnpackEntry(zf, name, file);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  private static boolean doUnpackEntry(ZipFile zf, String name, File file) throws IOException {\n    if (log.isTraceEnabled()) {\n      log.trace(\"Extracting '\" + zf.getName() + \"' entry '\" + name + \"' into '\" + file + \"'.\");\n    }\n\n    ZipEntry ze = zf.getEntry(name);\n    if (ze == null) {\n      return false; \n    }\n\n    if (ze.isDirectory() || zf.getInputStream(ze) == null) {\n      if (file.isDirectory()) {\n        return true;\n      }\n      if (file.exists()) {\n        FileUtils.forceDelete(file);\n      }\n      return file.mkdirs();\n    }\n\n    InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n    try {\n      FileUtils.copy(in, file);\n    }\n    finally {\n      IOUtils.closeQuietly(in);\n    }\n    return true;\n  }\n\n  \n  public static boolean unpackEntry(InputStream is, String name, File file) throws IOException {\n    return handle(is, name, new FileUnpacker(file));\n  }\n\n  \n  private static class FileUnpacker implements ZipEntryCallback {\n\n    private final File file;\n\n    public FileUnpacker(File file) {\n      this.file = file;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      FileUtils.copy(in, file);\n    }\n\n  }\n\n  \n\n  \n  public static void iterate(File zip, ZipEntryCallback action) {\n    iterate(zip, action, null);\n  }\n\n  \n  public static void iterate(File zip, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \"' with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action) {\n    iterate(zip, entryNames, action, null);\n  }\n\n  \n  public static void iterate(File zip, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    ZipFile zf = null;\n    try {\n      if (charset == null) {\n        zf = new ZipFile(zip);\n      }\n      else {\n        zf = new ZipFile(zip, charset);\n      }\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        InputStream is = zf.getInputStream(e);\n        try {\n          action.process(is, e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n        finally {\n          IOUtils.closeQuietly(is);\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static void iterate(File zip, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      Enumeration<? extends ZipEntry> en = zf.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e = (ZipEntry) en.nextElement();\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static void iterate(File zip, String[] entryNames, ZipInfoCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      for (int i = 0; i < entryNames.length; i++) {\n        ZipEntry e = zf.getEntry(entryNames[i]);\n        if (e == null) {\n          continue;\n        }\n        try {\n          action.process(e);\n        }\n        catch (IOException ze) {\n          throw new ZipException(\"Failed to process zip entry '\" + e.getName() + \" with action \" + action, ze);\n        }\n        catch (ZipBreakException ex) {\n          break;\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static void iterate(InputStream is, ZipEntryCallback action, Charset charset) {\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void iterate(InputStream is, ZipEntryCallback action) {\n    iterate(is, action, null);\n  }\n\n  \n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action, Charset charset) {\n    Set<String> namesSet = new HashSet<String>();\n    for (int i = 0; i < entryNames.length; i++) {\n      namesSet.add(entryNames[i]);\n    }\n    try {\n      ZipInputStream in = null;\n      try {\n        in = newCloseShieldZipInputStream(is, charset);\n        ZipEntry entry;\n        while ((entry = in.getNextEntry()) != null) {\n          if (!namesSet.contains(entry.getName())) {\n            \n            continue;\n          }\n          try {\n            action.process(in, entry);\n          }\n          catch (IOException ze) {\n            throw new ZipException(\"Failed to process zip entry '\" + entry.getName() + \" with action \" + action, ze);\n          }\n          catch (ZipBreakException ex) {\n            break;\n          }\n        }\n      }\n      finally {\n        if (in != null) {\n          in.close();\n        }\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void iterate(InputStream is, String[] entryNames, ZipEntryCallback action) {\n    iterate(is, entryNames, action, null);\n  }\n\n  \n  private static ZipInputStream newCloseShieldZipInputStream(final InputStream is, Charset charset) {\n    InputStream in = new BufferedInputStream(new CloseShieldInputStream(is));\n    if (charset == null) {\n      return new ZipInputStream(in);\n    }\n    return ZipFileUtil.createZipInputStream(in, charset);\n  }\n\n  \n  public static boolean handle(File zip, String name, ZipEntryCallback action) {\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n\n      ZipEntry ze = zf.getEntry(name);\n      if (ze == null) {\n        return false; \n      }\n\n      InputStream in = new BufferedInputStream(zf.getInputStream(ze));\n      try {\n        action.process(in, ze);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      return true;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n  }\n\n  \n  public static boolean handle(InputStream is, String name, ZipEntryCallback action) {\n    SingleZipEntryCallback helper = new SingleZipEntryCallback(name, action);\n    iterate(is, helper);\n    return helper.found();\n  }\n\n  \n  private static class SingleZipEntryCallback implements ZipEntryCallback {\n\n    private final String name;\n\n    private final ZipEntryCallback action;\n\n    private boolean found;\n\n    public SingleZipEntryCallback(String name, ZipEntryCallback action) {\n      this.name = name;\n      this.action = action;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (name.equals(zipEntry.getName())) {\n        found = true;\n        action.process(in, zipEntry);\n      }\n    }\n\n    public boolean found() {\n      return found;\n    }\n\n  }\n\n  \n\n  \n  public static void unpack(File zip, final File outputDir) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  \n  public static void unpack(File zip, final File outputDir, Charset charset) {\n    unpack(zip, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  \n  public static void unpack(File zip, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper), charset);\n  }\n\n  \n  public static void unpack(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Extracting '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unpacker(outputDir, mapper));\n  }\n\n  \n  public static void unwrap(File zip, final File outputDir) {\n    unwrap(zip, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  \n  public static void unwrap(File zip, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping '{}' into '{}'.\", zip, outputDir);\n    iterate(zip, new Unwraper(outputDir, mapper));\n  }\n\n  \n  public static void unpack(InputStream is, File outputDir) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, null);\n  }\n\n  \n  public static void unpack(InputStream is, File outputDir, Charset charset) {\n    unpack(is, outputDir, IdentityNameMapper.INSTANCE, charset);\n  }\n\n  \n  public static void unpack(InputStream is, File outputDir, NameMapper mapper) {\n    unpack(is, outputDir, mapper, null);\n  }\n\n  \n  public static void unpack(InputStream is, File outputDir, NameMapper mapper, Charset charset) {\n    log.debug(\"Extracting {} into '{}'.\", is, outputDir);\n    iterate(is, new Unpacker(outputDir, mapper), charset);\n  }\n\n  \n  public static void unwrap(InputStream is, File outputDir) {\n    unwrap(is, outputDir, IdentityNameMapper.INSTANCE);\n  }\n\n  \n  public static void unwrap(InputStream is, File outputDir, NameMapper mapper) {\n    log.debug(\"Unwrapping {} into '{}'.\", is, outputDir);\n    iterate(is, new Unwraper(outputDir, mapper));\n  }\n\n  \n  private static class Unpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public Unpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n\n        ZTFilePermissions permissions = ZipEntryUtil.getZTFilePermissions(zipEntry);\n        if (permissions != null) {\n          ZTFilePermissionsUtil.getDefaultStategy().setPermissions(file, permissions);\n        }\n      }\n    }\n  }\n\n  \n  public static class BackslashUnpacker implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n\n    public BackslashUnpacker(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public BackslashUnpacker(File outputDir) {\n      this(outputDir, IdentityNameMapper.INSTANCE);\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String name = mapper.map(zipEntry.getName());\n      if (name != null) {\n        \n        if (name.indexOf('\\\\') != -1) {\n          File parentDirectory = outputDir;\n          String[] dirs = name.split(\"\\\\\\\\\");\n\n          \n          for (int i = 0; i < dirs.length - 1; i++) {\n            File file = new File(parentDirectory, dirs[i]);\n            if (!file.exists()) {\n              FileUtils.forceMkdir(file);\n            }\n            parentDirectory = file;\n          }\n          File destFile = new File(parentDirectory, dirs[dirs.length - 1]);\n          FileUtils.copy(in, destFile);\n        }\n        \n        else {\n          File destFile = new File(outputDir, name);\n          FileUtils.copy(in, destFile);\n        }\n      }\n    }\n  }\n\n  \n  private static class Unwraper implements ZipEntryCallback {\n\n    private final File outputDir;\n    private final NameMapper mapper;\n    private String rootDir;\n\n    public Unwraper(File outputDir, NameMapper mapper) {\n      this.outputDir = outputDir;\n      this.mapper = mapper;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      String root = getRootName(zipEntry.getName());\n      if (rootDir == null) {\n        rootDir = root;\n      }\n      else if (!rootDir.equals(root)) {\n        throw new ZipException(\"Unwrapping with multiple roots is not supported, roots: \" + rootDir + \", \" + root);\n      }\n\n      String name = mapper.map(getUnrootedName(root, zipEntry.getName()));\n      if (name != null) {\n        File file = new File(outputDir, name);\n        if (zipEntry.isDirectory()) {\n          FileUtils.forceMkdir(file);\n        }\n        else {\n          FileUtils.forceMkdir(file.getParentFile());\n\n          if (log.isDebugEnabled() && file.exists()) {\n            log.debug(\"Overwriting file '{}'.\", zipEntry.getName());\n          }\n\n          FileUtils.copy(in, file);\n        }\n      }\n    }\n\n    private String getUnrootedName(String root, String name) {\n      return name.substring(root.length());\n    }\n\n    private String getRootName(final String name) {\n      String newName = name.substring(FilenameUtils.getPrefixLength(name));\n      int idx = newName.indexOf(PATH_SEPARATOR);\n      if (idx < 0) {\n        throw new ZipException(\"Entry \" + newName + \" from the root of the zip is not supported\");\n      }\n      return newName.substring(0, newName.indexOf(PATH_SEPARATOR));\n    }\n  }\n\n  \n  public static void explode(File zip) {\n    try {\n      \n      File tempFile = FileUtils.getTempFileFor(zip);\n\n      \n      FileUtils.moveFile(zip, tempFile);\n\n      \n      unpack(tempFile, zip);\n\n      \n      if (!tempFile.delete()) {\n        throw new IOException(\"Unable to delete file: \" + tempFile);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n\n  \n  public static byte[] packEntry(File file) {\n    log.trace(\"Compressing '{}' into a ZIP file with single entry.\", file);\n\n    ByteArrayOutputStream result = new ByteArrayOutputStream();\n    try {\n      ZipOutputStream out = new ZipOutputStream(result);\n      ZipEntry entry = ZipEntryUtil.fromFile(file.getName(), file);\n      InputStream in = new BufferedInputStream(new FileInputStream(file));\n      try {\n        ZipEntryUtil.addEntry(entry, in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n      out.close();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    return result.toByteArray();\n  }\n\n  \n\n  \n  public static void pack(File rootDir, File zip) {\n    pack(rootDir, zip, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void pack(File rootDir, File zip, int compressionLevel) {\n    pack(rootDir, zip, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  \n  public static void pack(final File sourceDir, final File targetZipFile, final boolean preserveRoot) {\n    if (preserveRoot) {\n      final String parentName = sourceDir.getName();\n      pack(sourceDir, targetZipFile, new NameMapper() {\n        public String map(String name) {\n          return parentName + PATH_SEPARATOR + name;\n        }\n      });\n    }\n    else {\n      pack(sourceDir, targetZipFile);\n    }\n  }\n\n  \n  public static void packEntry(File fileToPack, File destZipFile) {\n    packEntry(fileToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  \n  public static void packEntry(File fileToPack, File destZipFile, final String fileName) {\n    packEntry(fileToPack, destZipFile, new NameMapper() {\n      public String map(String name) {\n        return fileName;\n      }\n    });\n  }\n\n  \n  public static void packEntry(File fileToPack, File destZipFile, NameMapper mapper) {\n    packEntries(new File[] { fileToPack }, destZipFile, mapper);\n  }\n\n  \n  public static void packEntries(File[] filesToPack, File destZipFile) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE);\n  }\n\n  \n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper) {\n    packEntries(filesToPack, destZipFile, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void packEntries(File[] filesToPack, File destZipFile, int compressionLevel) {\n    packEntries(filesToPack, destZipFile, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  \n  public static void packEntries(File[] filesToPack, File destZipFile, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", filesToPack, destZipFile);\n\n    ZipOutputStream out = null;\n    FileOutputStream fos = null;\n    try {\n      fos = new FileOutputStream(destZipFile);\n      out = new ZipOutputStream(new BufferedOutputStream(fos));\n      out.setLevel(compressionLevel);\n\n      for (int i = 0; i < filesToPack.length; i++) {\n        File fileToPack = filesToPack[i];\n\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(mapper.map(fileToPack.getName()), fileToPack);\n        out.putNextEntry(zipEntry);\n        FileUtils.copy(fileToPack, out);\n        out.closeEntry();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n      IOUtils.closeQuietly(fos);\n    }\n  }\n\n  \n  public static void pack(File sourceDir, File targetZip, NameMapper mapper) {\n    pack(sourceDir, targetZip, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void pack(File sourceDir, File targetZip, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into '{}'.\", sourceDir, targetZip);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(targetZip)));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  \n  public static void pack(File sourceDir, OutputStream os) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void pack(File sourceDir, OutputStream os, int compressionLevel) {\n    pack(sourceDir, os, IdentityNameMapper.INSTANCE, compressionLevel);\n  }\n\n  \n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper) {\n    pack(sourceDir, os, mapper, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void pack(File sourceDir, OutputStream os, NameMapper mapper, int compressionLevel) {\n    log.debug(\"Compressing '{}' into a stream.\", sourceDir);\n    if (!sourceDir.exists()) {\n      throw new ZipException(\"Given file '\" + sourceDir + \"' doesn't exist!\");\n    }\n    ZipOutputStream out = null;\n    IOException error = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(os));\n      out.setLevel(compressionLevel);\n      pack(sourceDir, out, mapper, \"\", true);\n    }\n    catch (IOException e) {\n      error = e;\n    }\n    finally {\n      if (out != null && error == null) {\n        try {\n          out.finish();\n          out.flush();\n        }\n        catch (IOException e) {\n          error = e;\n        }\n      }\n    }\n    if (error != null) {\n      throw ZipExceptionUtil.rethrow(error);\n    }\n  }\n\n  \n  private static void pack(File dir, ZipOutputStream out, NameMapper mapper, String pathPrefix, boolean mustHaveChildren) throws IOException {\n    String[] filenames = dir.list();\n    if (filenames == null) {\n      if (!dir.exists()) {\n        throw new ZipException(\"Given file '\" + dir + \"' doesn't exist!\");\n      }\n      throw new IOException(\"Given file is not a directory '\" + dir + \"'\");\n    }\n\n    if (mustHaveChildren && filenames.length == 0) {\n      throw new ZipException(\"Given directory '\" + dir + \"' doesn't contain any files!\");\n    }\n\n    for (int i = 0; i < filenames.length; i++) {\n      String filename = filenames[i];\n      File file = new File(dir, filename);\n      boolean isDir = file.isDirectory();\n      String path = pathPrefix + file.getName(); \n      if (isDir) {\n        path += PATH_SEPARATOR; \n      }\n\n      \n      String name = mapper.map(path);\n      if (name != null) {\n        ZipEntry zipEntry = ZipEntryUtil.fromFile(name, file);\n\n        out.putNextEntry(zipEntry);\n\n        \n        if (!isDir) {\n          FileUtils.copy(file, out);\n        }\n\n        out.closeEntry();\n      }\n\n      \n      if (isDir) {\n        pack(file, out, mapper, path, false);\n      }\n    }\n  }\n\n  \n  public static void repack(File srcZip, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking '{}' into '{}'.\", srcZip, dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(srcZip, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  \n  public static void repack(InputStream is, File dstZip, int compressionLevel) {\n\n    log.debug(\"Repacking from input stream into '{}'.\", dstZip);\n\n    RepackZipEntryCallback callback = new RepackZipEntryCallback(dstZip, compressionLevel);\n\n    try {\n      iterate(is, callback);\n    }\n    finally {\n      callback.closeStream();\n    }\n  }\n\n  \n  public static void repack(File zip, int compressionLevel) {\n    try {\n      File tmpZip = FileUtils.getTempFileFor(zip);\n\n      repack(zip, tmpZip, compressionLevel);\n\n      \n      if (!zip.delete()) {\n        throw new IOException(\"Unable to delete the file: \" + zip);\n      }\n\n      \n      FileUtils.moveFile(tmpZip, zip);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  private static final class RepackZipEntryCallback implements ZipEntryCallback {\n\n    private ZipOutputStream out;\n\n    private RepackZipEntryCallback(File dstZip, int compressionLevel) {\n      try {\n        this.out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(dstZip)));\n        this.out.setLevel(compressionLevel);\n      }\n      catch (IOException e) {\n        ZipExceptionUtil.rethrow(e);\n      }\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      ZipEntryUtil.copyEntry(zipEntry, in, out);\n    }\n\n    private void closeStream() {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  \n  public static void unexplode(File dir) {\n    unexplode(dir, DEFAULT_COMPRESSION_LEVEL);\n  }\n\n  \n  public static void unexplode(File dir, int compressionLevel) {\n    try {\n      \n      File zip = FileUtils.getTempFileFor(dir);\n\n      \n      pack(dir, zip, compressionLevel);\n\n      \n      FileUtils.deleteDirectory(dir);\n\n      \n      FileUtils.moveFile(zip, dir);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void pack(ZipEntrySource[] entries, OutputStream os) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating stream from {}.\", Arrays.asList(entries));\n    }\n    pack(entries, os, false);\n  }\n\n  private static void pack(ZipEntrySource[] entries, OutputStream os, boolean closeStream) {\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.flush();\n      out.finish();\n      if (closeStream) {\n        out.close();\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void pack(ZipEntrySource[] entries, File zip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Creating '{}' from {}.\", zip, Arrays.asList(entries));\n    }\n\n    OutputStream out = null;\n    try {\n      out = new BufferedOutputStream(new FileOutputStream(zip));\n      pack(entries, out, true);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  \n  public static void addEntry(File zip, String path, File file, File destZip) {\n    addEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  \n  public static void addEntry(final File zip, final String path, final File file) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, file, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void addEntry(File zip, String path, byte[] bytes, File destZip) {\n    addEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  \n  public static void addEntry(File zip, String path, byte[] bytes, File destZip, final int compressionMethod) {\n    addEntry(zip, new ByteSource(path, bytes, compressionMethod), destZip);\n  }\n\n  \n  public static void addEntry(final File zip, final String path, final byte[] bytes) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void addEntry(final File zip, final String path, final byte[] bytes, final int compressionMethod) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, path, bytes, tmpFile, compressionMethod);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void addEntry(File zip, ZipEntrySource entry, File destZip) {\n    addEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  \n  public static void addEntry(final File zip, final ZipEntrySource entry) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntry(zip, entry, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void addEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    OutputStream destOut = null;\n    try {\n      destOut = new BufferedOutputStream(new FileOutputStream(destZip));\n      addEntries(zip, entries, destOut);\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(destOut);\n    }\n  }\n\n  \n  public static void addEntries(File zip, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to a stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(zip, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void addEntries(InputStream is, ZipEntrySource[] entries, OutputStream destOut) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying input stream to an output stream and adding \" + Arrays.asList(entries) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(destOut);\n      copyEntries(is, out);\n      for (int i = 0; i < entries.length; i++) {\n        addEntry(entries[i], out);\n      }\n      out.finish();\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void addEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void removeEntry(File zip, String path, File destZip) {\n    removeEntries(zip, new String[] { path }, destZip);\n  }\n\n  \n  public static void removeEntry(final File zip, final String path) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntry(zip, path, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  public static void removeEntries(File zip, String[] paths, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and removing paths \" + Arrays.asList(paths) + \".\");\n    }\n\n    ZipOutputStream out = null;\n    try {\n      out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      copyEntries(zip, out, new HashSet<String>(Arrays.asList(paths)));\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      IOUtils.closeQuietly(out);\n    }\n  }\n\n  \n  public static void removeEntries(final File zip, final String[] paths) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        removeEntries(zip, paths, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  private static void copyEntries(File zip, final ZipOutputStream out) {\n    \n    final Set<String> names = new HashSet<String>();\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  \n  private static void copyEntries(InputStream is, final ZipOutputStream out) {\n    \n    final Set<String> names = new HashSet<String>();\n    iterate(is, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  \n  private static void copyEntries(File zip, final ZipOutputStream out, final Set<String> ignoredEntries) {\n    final Set<String> names = new HashSet<String>();\n    final Set<String> dirNames = filterDirEntries(zip, ignoredEntries);\n    iterate(zip, new ZipEntryCallback() {\n      public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n        String entryName = zipEntry.getName();\n        if (ignoredEntries.contains(entryName)) {\n          return;\n        }\n\n        for (String dirName : dirNames) {\n          if (entryName.startsWith(dirName)) {\n            return;\n          }\n        }\n\n        if (names.add(entryName)) {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n        else if (log.isDebugEnabled()) {\n          log.debug(\"Duplicate entry: {}\", entryName);\n        }\n      }\n    });\n  }\n\n  \n  static Set<String> filterDirEntries(File zip, Collection<String> names) {\n    Set<String> dirs = new HashSet<String>();\n    if (zip == null) {\n      return dirs;\n    }\n    ZipFile zf = null;\n    try {\n      zf = new ZipFile(zip);\n      for (String entryName : names) {\n        ZipEntry entry = zf.getEntry(entryName);\n        if (entry != null) {\n          if (entry.isDirectory()) {\n            dirs.add(entry.getName());\n          }\n          else if (zf.getInputStream(entry) == null) {\n            \n            dirs.add(entry.getName() + PATH_SEPARATOR);\n          }\n        }\n      }\n\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf);\n    }\n    return dirs;\n  }\n\n  \n  public static boolean replaceEntry(File zip, String path, File file, File destZip) {\n    return replaceEntry(zip, new FileSource(path, file), destZip);\n  }\n\n  \n  public static boolean replaceEntry(final File zip, final String path, final File file) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new FileSource(path, file), tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean replaceEntry(File zip, String path, byte[] bytes, File destZip) {\n    return replaceEntry(zip, new ByteSource(path, bytes), destZip);\n  }\n\n  \n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes), tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean replaceEntry(final File zip, final String path, final byte[] bytes,\n      final int compressionMethod) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, new ByteSource(path, bytes, compressionMethod), tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean replaceEntry(File zip, ZipEntrySource entry, File destZip) {\n    return replaceEntries(zip, new ZipEntrySource[] { entry }, destZip);\n  }\n\n  \n  public static boolean replaceEntry(final File zip, final ZipEntrySource entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean replaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and replacing entries \" + Arrays.asList(entries) + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    final int entryCount = entryByPath.size();\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n    return entryByPath.size() < entryCount;\n  }\n\n  \n  public static boolean replaceEntries(final File zip, final ZipEntrySource[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return replaceEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  \n  public static void addOrReplaceEntries(File zip, ZipEntrySource[] entries, File destZip) {\n    if (log.isDebugEnabled()) {\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and adding/replacing entries \" + Arrays.asList(entries)\n          + \".\");\n    }\n\n    final Map<String, ZipEntrySource> entryByPath = entriesByPath(entries);\n    try {\n      final ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        \n        final Set<String> names = new HashSet<String>();\n        iterate(zip, new ZipEntryCallback() {\n          public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n            if (names.add(zipEntry.getName())) {\n              ZipEntrySource entry = (ZipEntrySource) entryByPath.remove(zipEntry.getName());\n              if (entry != null) {\n                addEntry(entry, out);\n              }\n              else {\n                ZipEntryUtil.copyEntry(zipEntry, in, out);\n              }\n            }\n            else if (log.isDebugEnabled()) {\n              log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n            }\n          }\n        });\n\n        \n        for (ZipEntrySource zipEntrySource : entryByPath.values()) {\n          addEntry(zipEntrySource, out);\n        }\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static void addOrReplaceEntries(final File zip, final ZipEntrySource[] entries) {\n    operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        addOrReplaceEntries(zip, entries, tmpFile);\n        return true;\n      }\n    });\n  }\n\n  \n  static Map<String, ZipEntrySource> entriesByPath(ZipEntrySource... entries) {\n    Map<String, ZipEntrySource> result = new HashMap<String, ZipEntrySource>();\n    for (int i = 0; i < entries.length; i++) {\n      ZipEntrySource source = entries[i];\n      result.put(source.getPath(), source);\n    }\n    return result;\n  }\n\n  \n  public static boolean transformEntry(File zip, String path, ZipEntryTransformer transformer, File destZip) {\n    if(zip.equals(destZip)){throw new IllegalArgumentException(\"Input (\" +zip.getAbsolutePath()+ \") is the same as the destination!\" +\n            \"Please use the transformEntry method without destination for in-place transformation.\" );}\n    return transformEntry(zip, new ZipEntryTransformerEntry(path, transformer), destZip);\n  }\n\n  \n  public static boolean transformEntry(final File zip, final String path, final ZipEntryTransformer transformer) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, path, transformer, tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean transformEntry(File zip, ZipEntryTransformerEntry entry, File destZip) {\n    return transformEntries(zip, new ZipEntryTransformerEntry[] { entry }, destZip);\n  }\n\n  \n  public static boolean transformEntry(final File zip, final ZipEntryTransformerEntry entry) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntry(zip, entry, tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean transformEntries(File zip, ZipEntryTransformerEntry[] entries, File destZip) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + zip + \"' to '\" + destZip + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(destZip)));\n      try {\n        TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n        iterate(zip, action);\n        return action.found();\n      }\n      finally {\n        IOUtils.closeQuietly(out);\n      }\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  public static boolean transformEntries(final File zip, final ZipEntryTransformerEntry[] entries) {\n    return operateInPlace(zip, new InPlaceAction() {\n      public boolean act(File tmpFile) {\n        return transformEntries(zip, entries, tmpFile);\n      }\n    });\n  }\n\n  \n  public static boolean transformEntry(InputStream is, String path, ZipEntryTransformer transformer, OutputStream os) {\n    return transformEntry(is, new ZipEntryTransformerEntry(path, transformer), os);\n  }\n\n  \n  public static boolean transformEntry(InputStream is, ZipEntryTransformerEntry entry, OutputStream os) {\n    return transformEntries(is, new ZipEntryTransformerEntry[] { entry }, os);\n  }\n\n  \n  public static boolean transformEntries(InputStream is, ZipEntryTransformerEntry[] entries, OutputStream os) {\n    if (log.isDebugEnabled())\n      log.debug(\"Copying '\" + is + \"' to '\" + os + \"' and transforming entries \" + Arrays.asList(entries) + \".\");\n\n    try {\n      ZipOutputStream out = new ZipOutputStream(os);\n      TransformerZipEntryCallback action = new TransformerZipEntryCallback(Arrays.asList(entries), out);\n      iterate(is, action);\n      \n      \n      out.finish();\n      return action.found();\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  private static class TransformerZipEntryCallback implements ZipEntryCallback {\n\n    private final Map<String, ZipEntryTransformer> entryByPath;\n    private final int entryCount;\n    private final ZipOutputStream out;\n    private final Set<String> names = new HashSet<String>();\n\n    public TransformerZipEntryCallback(List<ZipEntryTransformerEntry> entries, ZipOutputStream out) {\n      entryByPath = transformersByPath(entries);\n      entryCount = entryByPath.size();\n      this.out = out;\n    }\n\n    public void process(InputStream in, ZipEntry zipEntry) throws IOException {\n      if (names.add(zipEntry.getName())) {\n        ZipEntryTransformer entry = (ZipEntryTransformer) entryByPath.remove(zipEntry.getName());\n        if (entry != null) {\n          entry.transform(in, zipEntry, out);\n        }\n        else {\n          ZipEntryUtil.copyEntry(zipEntry, in, out);\n        }\n      }\n      else if (log.isDebugEnabled()) {\n        log.debug(\"Duplicate entry: {}\", zipEntry.getName());\n      }\n    }\n\n    \n    public boolean found() {\n      return entryByPath.size() < entryCount;\n    }\n\n  }\n\n  \n  static Map<String, ZipEntryTransformer> transformersByPath(List<ZipEntryTransformerEntry> entries) {\n    Map<String, ZipEntryTransformer> result = new HashMap<String, ZipEntryTransformer>();\n    for (ZipEntryTransformerEntry entry : entries) {\n      result.put(entry.getPath(), entry.getTransformer());\n    }\n    return result;\n  }\n\n  \n  private static void addEntry(ZipEntrySource entry, ZipOutputStream out) throws IOException {\n    out.putNextEntry(entry.getEntry());\n    InputStream in = entry.getInputStream();\n    if (in != null) {\n      try {\n        IOUtils.copy(in, out);\n      }\n      finally {\n        IOUtils.closeQuietly(in);\n      }\n    }\n    out.closeEntry();\n  }\n\n  \n\n  \n  public static boolean archiveEquals(File f1, File f2) {\n    try {\n      \n      if (FileUtils.contentEquals(f1, f2)) {\n        return true;\n      }\n\n      log.debug(\"Comparing archives '{}' and '{}'...\", f1, f2);\n\n      long start = System.currentTimeMillis();\n      boolean result = archiveEqualsInternal(f1, f2);\n      long time = System.currentTimeMillis() - start;\n      if (time > 0) {\n        log.debug(\"Archives compared in \" + time + \" ms.\");\n      }\n      return result;\n    }\n    catch (Exception e) {\n      log.debug(\"Could not compare '\" + f1 + \"' and '\" + f2 + \"':\", e);\n      return false;\n    }\n  }\n\n  private static boolean archiveEqualsInternal(File f1, File f2) throws IOException {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      \n      if (zf1.size() != zf2.size()) {\n        log.debug(\"Number of entries changed (\" + zf1.size() + \" vs \" + zf2.size() + \").\");\n        return false;\n      }\n      \n      Enumeration<? extends ZipEntry> en = zf1.entries();\n      while (en.hasMoreElements()) {\n        ZipEntry e1 = (ZipEntry) en.nextElement();\n        String path = e1.getName();\n        ZipEntry e2 = zf2.getEntry(path);\n\n        \n        if (!metaDataEquals(path, e1, e2)) {\n          return false;\n        }\n\n        \n        InputStream is1 = null;\n        InputStream is2 = null;\n        try {\n          is1 = zf1.getInputStream(e1);\n          is2 = zf2.getInputStream(e2);\n\n          if (!IOUtils.contentEquals(is1, is2)) {\n            log.debug(\"Entry '{}' content changed.\", path);\n            return false;\n          }\n        }\n        finally {\n          IOUtils.closeQuietly(is1);\n          IOUtils.closeQuietly(is2);\n        }\n      }\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n\n    log.debug(\"Archives are the same.\");\n\n    return true;\n  }\n\n  \n  private static boolean metaDataEquals(String path, ZipEntry e1, ZipEntry e2) throws IOException {\n    \n    if (e2 == null) {\n      log.debug(\"Entry '{}' removed.\", path);\n      return false;\n    }\n\n    \n    if (e1.isDirectory()) {\n      if (e2.isDirectory()) {\n        return true; \n      }\n      else {\n        log.debug(\"Entry '{}' not a directory any more.\", path);\n        return false;\n      }\n    }\n    else if (e2.isDirectory()) {\n      log.debug(\"Entry '{}' now a directory.\", path);\n      return false;\n    }\n\n    \n    long size1 = e1.getSize();\n    long size2 = e2.getSize();\n    if (size1 != -1 && size2 != -1 && size1 != size2) {\n      log.debug(\"Entry '\" + path + \"' size changed (\" + size1 + \" vs \" + size2 + \").\");\n      return false;\n    }\n\n    \n    long crc1 = e1.getCrc();\n    long crc2 = e2.getCrc();\n    if (crc1 != -1 && crc2 != -1 && crc1 != crc2) {\n      log.debug(\"Entry '\" + path + \"' CRC changed (\" + crc1 + \" vs \" + crc2 + \").\");\n      return false;\n    }\n\n    \n    if (log.isTraceEnabled()) {\n      long time1 = e1.getTime();\n      long time2 = e2.getTime();\n      if (time1 != -1 && time2 != -1 && time1 != time2) {\n        log.trace(\"Entry '\" + path + \"' time changed (\" + new Date(time1) + \" vs \" + new Date(time2) + \").\");\n      }\n    }\n\n    return true;\n  }\n\n  \n  public static boolean entryEquals(File f1, File f2, String path) {\n    return entryEquals(f1, f2, path, path);\n  }\n\n  \n  public static boolean entryEquals(File f1, File f2, String path1, String path2) {\n    ZipFile zf1 = null;\n    ZipFile zf2 = null;\n\n    try {\n      zf1 = new ZipFile(f1);\n      zf2 = new ZipFile(f2);\n\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      closeQuietly(zf1);\n      closeQuietly(zf2);\n    }\n  }\n\n  \n  public static boolean entryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) {\n    try {\n      return doEntryEquals(zf1, zf2, path1, path2);\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n  }\n\n  \n  private static boolean doEntryEquals(ZipFile zf1, ZipFile zf2, String path1, String path2) throws IOException {\n    InputStream is1 = null;\n    InputStream is2 = null;\n    try {\n      ZipEntry e1 = zf1.getEntry(path1);\n      ZipEntry e2 = zf2.getEntry(path2);\n\n      if (e1 == null && e2 == null) {\n        return true;\n      }\n\n      if (e1 == null || e2 == null) {\n        return false;\n      }\n\n      is1 = zf1.getInputStream(e1);\n      is2 = zf2.getInputStream(e2);\n      if (is1 == null && is2 == null) {\n        return true;\n      }\n      if (is1 == null || is2 == null) {\n        return false;\n      }\n\n      return IOUtils.contentEquals(is1, is2);\n    }\n    finally {\n      IOUtils.closeQuietly(is1);\n      IOUtils.closeQuietly(is2);\n    }\n  }\n\n  \n  public static void closeQuietly(ZipFile zf) {\n    try {\n      if (zf != null) {\n        zf.close();\n      }\n    }\n    catch (IOException e) {\n    }\n  }\n\n  \n  private abstract static class InPlaceAction {\n\n    \n    abstract boolean act(File tmpFile);\n  }\n\n  \n  private static boolean operateInPlace(File src, InPlaceAction action) {\n    File tmp = null;\n    try {\n      tmp = File.createTempFile(\"zt-zip-tmp\", \".zip\");\n      boolean result = action.act(tmp);\n      if (result) { \n        FileUtils.forceDelete(src);\n        FileUtils.moveFile(tmp, src);\n      }\n      return result;\n    }\n    catch (IOException e) {\n      throw ZipExceptionUtil.rethrow(e);\n    }\n    finally {\n      FileUtils.deleteQuietly(tmp);\n    }\n  }\n\n}\n",
    "is_vulnerable": 1
  }
]